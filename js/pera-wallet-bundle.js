var PeraWalletConnect = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x3) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x3, {
    get: (a2, b3) => (typeof require !== "undefined" ? require : a2)[b3]
  }) : x3)(function(x3) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x3 + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // polyfills.js
  var init_polyfills = __esm({
    "polyfills.js"() {
      global = window;
    }
  });

  // node_modules/@walletconnect/window-getters/dist/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
      function getFromWindow2(name) {
        let res = void 0;
        if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
          res = window[name];
        }
        return res;
      }
      exports.getFromWindow = getFromWindow2;
      function getFromWindowOrThrow2(name) {
        const res = getFromWindow2(name);
        if (!res) {
          throw new Error(`${name} is not defined in Window`);
        }
        return res;
      }
      exports.getFromWindowOrThrow = getFromWindowOrThrow2;
      function getDocumentOrThrow2() {
        return getFromWindowOrThrow2("document");
      }
      exports.getDocumentOrThrow = getDocumentOrThrow2;
      function getDocument2() {
        return getFromWindow2("document");
      }
      exports.getDocument = getDocument2;
      function getNavigatorOrThrow2() {
        return getFromWindowOrThrow2("navigator");
      }
      exports.getNavigatorOrThrow = getNavigatorOrThrow2;
      function getNavigator3() {
        return getFromWindow2("navigator");
      }
      exports.getNavigator = getNavigator3;
      function getLocationOrThrow2() {
        return getFromWindowOrThrow2("location");
      }
      exports.getLocationOrThrow = getLocationOrThrow2;
      function getLocation3() {
        return getFromWindow2("location");
      }
      exports.getLocation = getLocation3;
      function getCryptoOrThrow2() {
        return getFromWindowOrThrow2("crypto");
      }
      exports.getCryptoOrThrow = getCryptoOrThrow2;
      function getCrypto2() {
        return getFromWindow2("crypto");
      }
      exports.getCrypto = getCrypto2;
      function getLocalStorageOrThrow2() {
        return getFromWindowOrThrow2("localStorage");
      }
      exports.getLocalStorageOrThrow = getLocalStorageOrThrow2;
      function getLocalStorage3() {
        return getFromWindow2("localStorage");
      }
      exports.getLocalStorage = getLocalStorage3;
    }
  });

  // node_modules/@walletconnect/window-metadata/dist/cjs/index.js
  var require_cjs2 = __commonJS({
    "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getWindowMetadata = void 0;
      var window_getters_1 = require_cjs();
      function getWindowMetadata2() {
        let doc;
        let loc;
        try {
          doc = window_getters_1.getDocumentOrThrow();
          loc = window_getters_1.getLocationOrThrow();
        } catch (e2) {
          return null;
        }
        function getIcons() {
          const links = doc.getElementsByTagName("link");
          const icons2 = [];
          for (let i2 = 0; i2 < links.length; i2++) {
            const link = links[i2];
            const rel = link.getAttribute("rel");
            if (rel) {
              if (rel.toLowerCase().indexOf("icon") > -1) {
                const href = link.getAttribute("href");
                if (href) {
                  if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                    let absoluteHref = loc.protocol + "//" + loc.host;
                    if (href.indexOf("/") === 0) {
                      absoluteHref += href;
                    } else {
                      const path = loc.pathname.split("/");
                      path.pop();
                      const finalPath = path.join("/");
                      absoluteHref += finalPath + "/" + href;
                    }
                    icons2.push(absoluteHref);
                  } else if (href.indexOf("//") === 0) {
                    const absoluteUrl = loc.protocol + href;
                    icons2.push(absoluteUrl);
                  } else {
                    icons2.push(href);
                  }
                }
              }
            }
          }
          return icons2;
        }
        function getWindowMetadataOfAny(...args) {
          const metaTags = doc.getElementsByTagName("meta");
          for (let i2 = 0; i2 < metaTags.length; i2++) {
            const tag = metaTags[i2];
            const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
              if (attr) {
                return args.includes(attr);
              }
              return false;
            });
            if (attributes.length && attributes) {
              const content = tag.getAttribute("content");
              if (content) {
                return content;
              }
            }
          }
          return "";
        }
        function getName() {
          let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
          if (!name2) {
            name2 = doc.title;
          }
          return name2;
        }
        function getDescription() {
          const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
          return description2;
        }
        const name = getName();
        const description = getDescription();
        const url = loc.origin;
        const icons = getIcons();
        const meta = {
          description,
          url,
          icons,
          name
        };
        return meta;
      }
      exports.getWindowMetadata = getWindowMetadata2;
    }
  });

  // node_modules/detect-browser/es/index.js
  function detect(userAgent) {
    if (!!userAgent) {
      return parseUserAgent(userAgent);
    }
    if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
      return new ReactNativeInfo();
    }
    if (typeof navigator !== "undefined") {
      return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
  }
  function matchUserAgent(ua) {
    return ua !== "" && userAgentRules.reduce(function(matched, _a) {
      var browser = _a[0], regex = _a[1];
      if (matched) {
        return matched;
      }
      var uaMatch = regex.exec(ua);
      return !!uaMatch && [browser, uaMatch];
    }, false);
  }
  function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
      return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === "searchbot") {
      return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
    if (versionParts) {
      if (versionParts.length < REQUIRED_VERSION_PARTS) {
        versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
      }
    } else {
      versionParts = [];
    }
    var version = versionParts.join(".");
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
      return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name, version, os);
  }
  function detectOS(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
      var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
      var match = regex.exec(ua);
      if (match) {
        return os;
      }
    }
    return null;
  }
  function getNodeVersion() {
    var isNode4 = typeof process !== "undefined" && process.version;
    return isNode4 ? new NodeInfo(process.version.slice(1)) : null;
  }
  function createVersionParts(count) {
    var output = [];
    for (var ii = 0; ii < count; ii++) {
      output.push("0");
    }
    return output;
  }
  var __spreadArrays, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
  var init_es = __esm({
    "node_modules/detect-browser/es/index.js"() {
      init_polyfills();
      __spreadArrays = function() {
        for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
        for (var r3 = Array(s2), k3 = 0, i2 = 0; i2 < il; i2++)
          for (var a2 = arguments[i2], j3 = 0, jl = a2.length; j3 < jl; j3++, k3++)
            r3[k3] = a2[j3];
        return r3;
      };
      BrowserInfo = /** @class */
      /* @__PURE__ */ function() {
        function BrowserInfo2(name, version, os) {
          this.name = name;
          this.version = version;
          this.os = os;
          this.type = "browser";
        }
        return BrowserInfo2;
      }();
      NodeInfo = /** @class */
      /* @__PURE__ */ function() {
        function NodeInfo2(version) {
          this.version = version;
          this.type = "node";
          this.name = "node";
          this.os = process.platform;
        }
        return NodeInfo2;
      }();
      SearchBotDeviceInfo = /** @class */
      /* @__PURE__ */ function() {
        function SearchBotDeviceInfo2(name, version, os, bot) {
          this.name = name;
          this.version = version;
          this.os = os;
          this.bot = bot;
          this.type = "bot-device";
        }
        return SearchBotDeviceInfo2;
      }();
      BotInfo = /** @class */
      /* @__PURE__ */ function() {
        function BotInfo2() {
          this.type = "bot";
          this.bot = true;
          this.name = "bot";
          this.version = null;
          this.os = null;
        }
        return BotInfo2;
      }();
      ReactNativeInfo = /** @class */
      /* @__PURE__ */ function() {
        function ReactNativeInfo2() {
          this.type = "react-native";
          this.name = "react-native";
          this.version = null;
          this.os = null;
        }
        return ReactNativeInfo2;
      }();
      SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
      SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
      REQUIRED_VERSION_PARTS = 3;
      userAgentRules = [
        ["aol", /AOLShield\/([0-9\._]+)/],
        ["edge", /Edge\/([0-9\._]+)/],
        ["edge-ios", /EdgiOS\/([0-9\._]+)/],
        ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
        ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
        ["samsung", /SamsungBrowser\/([0-9\.]+)/],
        ["silk", /\bSilk\/([0-9._-]+)\b/],
        ["miui", /MiuiBrowser\/([0-9\.]+)$/],
        ["beaker", /BeakerBrowser\/([0-9\.]+)/],
        ["edge-chromium", /EdgA?\/([0-9\.]+)/],
        [
          "chromium-webview",
          /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
        ],
        ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
        ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
        ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
        ["fxios", /FxiOS\/([0-9\.]+)/],
        ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
        ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
        ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
        ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
        ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
        ["ie", /MSIE\s(7\.0)/],
        ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
        ["android", /Android\s([0-9\.]+)/],
        ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
        ["safari", /Version\/([0-9\._]+).*Safari/],
        ["facebook", /FBAV\/([0-9\.]+)/],
        ["instagram", /Instagram\s([0-9\.]+)/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
        ["searchbot", SEARCHBOX_UA_REGEX]
      ];
      operatingSystemRules = [
        ["iOS", /iP(hone|od|ad)/],
        ["Android OS", /Android/],
        ["BlackBerry OS", /BlackBerry|BB10/],
        ["Windows Mobile", /IEMobile/],
        ["Amazon OS", /Kindle/],
        ["Windows 3.11", /Win16/],
        ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
        ["Windows 98", /(Windows 98)|(Win98)/],
        ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
        ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
        ["Windows Server 2003", /(Windows NT 5.2)/],
        ["Windows Vista", /(Windows NT 6.0)/],
        ["Windows 7", /(Windows NT 6.1)/],
        ["Windows 8", /(Windows NT 6.2)/],
        ["Windows 8.1", /(Windows NT 6.3)/],
        ["Windows 10", /(Windows NT 10.0)/],
        ["Windows ME", /Windows ME/],
        ["Open BSD", /OpenBSD/],
        ["Sun OS", /SunOS/],
        ["Chrome OS", /CrOS/],
        ["Linux", /(Linux)|(X11)/],
        ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
        ["QNX", /QNX/],
        ["BeOS", /BeOS/],
        ["OS/2", /OS\/2/]
      ];
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/browser.js
  function detectEnv(userAgent) {
    return detect(userAgent);
  }
  function detectOS2() {
    const env3 = detectEnv();
    return env3 && env3.os ? env3.os : void 0;
  }
  function isAndroid() {
    const os = detectOS2();
    return os ? os.toLowerCase().includes("android") : false;
  }
  function isIOS() {
    const os = detectOS2();
    return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
  }
  function isMobile() {
    const os = detectOS2();
    return os ? isAndroid() || isIOS() : false;
  }
  function isNode() {
    const env3 = detectEnv();
    const result = env3 && env3.name ? env3.name.toLowerCase() === "node" : false;
    return result;
  }
  function isBrowser() {
    const result = !isNode() && !!getNavigator2();
    return result;
  }
  function getClientMeta() {
    return windowMetadata.getWindowMetadata();
  }
  var windowMetadata, windowGetters, getNavigator2, getLocation2, getLocalStorage2;
  var init_browser = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/browser.js"() {
      init_polyfills();
      windowMetadata = __toESM(require_cjs2());
      windowGetters = __toESM(require_cjs());
      init_es();
      getNavigator2 = windowGetters.getNavigator;
      getLocation2 = windowGetters.getLocation;
      getLocalStorage2 = windowGetters.getLocalStorage;
    }
  });

  // node_modules/@walletconnect/safe-json/dist/esm/index.js
  function safeJsonParse(value) {
    if (typeof value !== "string") {
      throw new Error(`Cannot safe json parse value of type ${typeof value}`);
    }
    try {
      return JSON.parse(value);
    } catch (_a) {
      return value;
    }
  }
  function safeJsonStringify(value) {
    return typeof value === "string" ? value : JSON.stringify(value);
  }
  var init_esm = __esm({
    "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
      init_polyfills();
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/json.js
  var safeJsonParse2, safeJsonStringify2;
  var init_json = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/json.js"() {
      init_polyfills();
      init_esm();
      safeJsonParse2 = safeJsonParse;
      safeJsonStringify2 = safeJsonStringify;
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/local.js
  function setLocal(key, data) {
    const raw = safeJsonStringify2(data);
    const local = getLocalStorage2();
    if (local) {
      local.setItem(key, raw);
    }
  }
  function getLocal(key) {
    let data = null;
    let raw = null;
    const local = getLocalStorage2();
    if (local) {
      raw = local.getItem(key);
    }
    data = raw ? safeJsonParse2(raw) : raw;
    return data;
  }
  function removeLocal(key) {
    const local = getLocalStorage2();
    if (local) {
      local.removeItem(key);
    }
  }
  var init_local = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/local.js"() {
      init_polyfills();
      init_json();
      init_browser();
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
  var mobileLinkChoiceKey;
  var init_mobile = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/mobile.js"() {
      init_polyfills();
      init_local();
      mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/registry.js
  var init_registry = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/registry.js"() {
      init_polyfills();
    }
  });

  // node_modules/@walletconnect/browser-utils/dist/esm/index.js
  var init_esm2 = __esm({
    "node_modules/@walletconnect/browser-utils/dist/esm/index.js"() {
      init_polyfills();
      init_browser();
      init_json();
      init_local();
      init_mobile();
      init_registry();
    }
  });

  // node_modules/@walletconnect/utils/dist/esm/constants.js
  var reservedEvents, signingMethods;
  var init_constants = __esm({
    "node_modules/@walletconnect/utils/dist/esm/constants.js"() {
      init_polyfills();
      reservedEvents = [
        "session_request",
        "session_update",
        "exchange_key",
        "connect",
        "disconnect",
        "display_uri",
        "modal_closed",
        "transport_open",
        "transport_close",
        "transport_error"
      ];
      signingMethods = [
        "eth_sendTransaction",
        "eth_signTransaction",
        "eth_sign",
        "eth_signTypedData",
        "eth_signTypedData_v1",
        "eth_signTypedData_v2",
        "eth_signTypedData_v3",
        "eth_signTypedData_v4",
        "personal_sign",
        "wallet_addEthereumChain",
        "wallet_switchEthereumChain",
        "wallet_getPermissions",
        "wallet_requestPermissions",
        "wallet_registerOnboarding",
        "wallet_watchAsset",
        "wallet_scanQRCode"
      ];
    }
  });

  // (disabled):node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "(disabled):node_modules/buffer/index.js"() {
      init_polyfills();
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports, module) {
      init_polyfills();
      (function(module2, exports2) {
        "use strict";
        function assert2(val, msg) {
          if (!val) throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number, base, endian) {
          if (BN2.isBN(number)) {
            return number;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number || 0, base || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          Buffer2 = require_buffer().Buffer;
        } catch (e2) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max(left, right) {
          if (left.cmp(right) > 0) return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0) return left;
          return right;
        };
        BN2.prototype._init = function init(number, base, endian) {
          if (typeof number === "number") {
            return this._initNumber(number, base, endian);
          }
          if (typeof number === "object") {
            return this._initArray(number, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert2(base === (base | 0) && base >= 2 && base <= 36);
          number = number.toString().replace(/\s+/g, "");
          var start = 0;
          if (number[0] === "-") {
            start++;
          }
          if (base === 16) {
            this._parseHex(number, start);
          } else {
            this._parseBase(number, base, start);
          }
          if (number[0] === "-") {
            this.negative = 1;
          }
          this.strip();
          if (endian !== "le") return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initNumber = function _initNumber(number, base, endian) {
          if (number < 0) {
            this.negative = 1;
            number = -number;
          }
          if (number < 67108864) {
            this.words = [number & 67108863];
            this.length = 1;
          } else if (number < 4503599627370496) {
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert2(number < 9007199254740992);
            this.words = [
              number & 67108863,
              number / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le") return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number, base, endian) {
          assert2(typeof number.length === "number");
          if (number.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number.length / 3);
          this.words = new Array(this.length);
          for (var i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = 0;
          }
          var j3, w3;
          var off = 0;
          if (endian === "be") {
            for (i2 = number.length - 1, j3 = 0; i2 >= 0; i2 -= 3) {
              w3 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
              this.words[j3] |= w3 << off & 67108863;
              this.words[j3 + 1] = w3 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j3++;
              }
            }
          } else if (endian === "le") {
            for (i2 = 0, j3 = 0; i2 < number.length; i2 += 3) {
              w3 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
              this.words[j3] |= w3 << off & 67108863;
              this.words[j3 + 1] = w3 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j3++;
              }
            }
          }
          return this.strip();
        };
        function parseHex(str, start, end) {
          var r3 = 0;
          var len = Math.min(str.length, end);
          for (var i2 = start; i2 < len; i2++) {
            var c2 = str.charCodeAt(i2) - 48;
            r3 <<= 4;
            if (c2 >= 49 && c2 <= 54) {
              r3 |= c2 - 49 + 10;
            } else if (c2 >= 17 && c2 <= 22) {
              r3 |= c2 - 17 + 10;
            } else {
              r3 |= c2 & 15;
            }
          }
          return r3;
        }
        BN2.prototype._parseHex = function _parseHex(number, start) {
          this.length = Math.ceil((number.length - start) / 6);
          this.words = new Array(this.length);
          for (var i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = 0;
          }
          var j3, w3;
          var off = 0;
          for (i2 = number.length - 6, j3 = 0; i2 >= start; i2 -= 6) {
            w3 = parseHex(number, i2, i2 + 6);
            this.words[j3] |= w3 << off & 67108863;
            this.words[j3 + 1] |= w3 >>> 26 - off & 4194303;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j3++;
            }
          }
          if (i2 + 6 !== start) {
            w3 = parseHex(number, start, i2 + 6);
            this.words[j3] |= w3 << off & 67108863;
            this.words[j3 + 1] |= w3 >>> 26 - off & 4194303;
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r3 = 0;
          var len = Math.min(str.length, end);
          for (var i2 = start; i2 < len; i2++) {
            var c2 = str.charCodeAt(i2) - 48;
            r3 *= mul;
            if (c2 >= 49) {
              r3 += c2 - 49 + 10;
            } else if (c2 >= 17) {
              r3 += c2 - 17 + 10;
            } else {
              r3 += c2;
            }
          }
          return r3;
        }
        BN2.prototype._parseBase = function _parseBase(number, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i2 = start; i2 < end; i2 += limbLen) {
            word = parseBase(number, i2, i2 + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i2, number.length, base);
            for (i2 = 0; i2 < mod; i2++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i2 = 0; i2 < this.length; i2++) {
            dest.words[i2] = this.words[i2];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN2.prototype.clone = function clone() {
          var r3 = new BN2(null);
          this.copy(r3);
          return r3;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN2.prototype.inspect = function inspect() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i2 = 0; i2 < this.length; i2++) {
              var w3 = this.words[i2];
              var word = ((w3 << off | carry) & 16777215).toString(16);
              carry = w3 >>> 24 - off & 16777215;
              if (carry !== 0 || i2 !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i2--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c2 = this.clone();
            c2.negative = 0;
            while (!c2.isZero()) {
              var r3 = c2.modn(groupBase).toString(base);
              c2 = c2.idivn(groupBase);
              if (!c2.isZero()) {
                out = zeros[groupSize - r3.length] + r3 + out;
              } else {
                out = r3 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert2(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert2(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN2.prototype.toBuffer = function toBuffer(endian, length) {
          assert2(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN2.prototype.toArray = function toArray(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert2(byteLength <= reqLength, "byte array longer than desired length");
          assert2(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType(reqLength);
          var b3, i2;
          var q3 = this.clone();
          if (!littleEndian) {
            for (i2 = 0; i2 < reqLength - byteLength; i2++) {
              res[i2] = 0;
            }
            for (i2 = 0; !q3.isZero(); i2++) {
              b3 = q3.andln(255);
              q3.iushrn(8);
              res[reqLength - i2 - 1] = b3;
            }
          } else {
            for (i2 = 0; !q3.isZero(); i2++) {
              b3 = q3.andln(255);
              q3.iushrn(8);
              res[i2] = b3;
            }
            for (; i2 < reqLength; i2++) {
              res[i2] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w3) {
            return 32 - Math.clz32(w3);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w3) {
            var t = w3;
            var r3 = 0;
            if (t >= 4096) {
              r3 += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r3 += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r3 += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r3 += 2;
              t >>>= 2;
            }
            return r3 + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w3) {
          if (w3 === 0) return 26;
          var t = w3;
          var r3 = 0;
          if ((t & 8191) === 0) {
            r3 += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r3 += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r3 += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r3 += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r3++;
          }
          return r3;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w3 = this.words[this.length - 1];
          var hi = this._countBits(w3);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w3 = new Array(num.bitLength());
          for (var bit = 0; bit < w3.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w3[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w3;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero()) return 0;
          var r3 = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var b3 = this._zeroBits(this.words[i2]);
            r3 += b3;
            if (b3 !== 26) break;
          }
          return r3;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i2 = 0; i2 < num.length; i2++) {
            this.words[i2] = this.words[i2] | num.words[i2];
          }
          return this.strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length) return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length) return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b3;
          if (this.length > num.length) {
            b3 = num;
          } else {
            b3 = this;
          }
          for (var i2 = 0; i2 < b3.length; i2++) {
            this.words[i2] = this.words[i2] & num.words[i2];
          }
          this.length = b3.length;
          return this.strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length) return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length) return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a2;
          var b3;
          if (this.length > num.length) {
            a2 = this;
            b3 = num;
          } else {
            a2 = num;
            b3 = this;
          }
          for (var i2 = 0; i2 < b3.length; i2++) {
            this.words[i2] = a2.words[i2] ^ b3.words[i2];
          }
          if (this !== a2) {
            for (; i2 < a2.length; i2++) {
              this.words[i2] = a2.words[i2];
            }
          }
          this.length = a2.length;
          return this.strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert2((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length) return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length) return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert2(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i2 = 0; i2 < bytesNeeded; i2++) {
            this.words[i2] = ~this.words[i2] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert2(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r3;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r3 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r3 = this.isub(num);
            num.negative = 1;
            return r3._normSign();
          }
          var a2, b3;
          if (this.length > num.length) {
            a2 = this;
            b3 = num;
          } else {
            a2 = num;
            b3 = this;
          }
          var carry = 0;
          for (var i2 = 0; i2 < b3.length; i2++) {
            r3 = (a2.words[i2] | 0) + (b3.words[i2] | 0) + carry;
            this.words[i2] = r3 & 67108863;
            carry = r3 >>> 26;
          }
          for (; carry !== 0 && i2 < a2.length; i2++) {
            r3 = (a2.words[i2] | 0) + carry;
            this.words[i2] = r3 & 67108863;
            carry = r3 >>> 26;
          }
          this.length = a2.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a2 !== this) {
            for (; i2 < a2.length; i2++) {
              this.words[i2] = a2.words[i2];
            }
          }
          return this;
        };
        BN2.prototype.add = function add(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length) return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r3 = this.iadd(num);
            num.negative = 1;
            return r3._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a2, b3;
          if (cmp > 0) {
            a2 = this;
            b3 = num;
          } else {
            a2 = num;
            b3 = this;
          }
          var carry = 0;
          for (var i2 = 0; i2 < b3.length; i2++) {
            r3 = (a2.words[i2] | 0) - (b3.words[i2] | 0) + carry;
            carry = r3 >> 26;
            this.words[i2] = r3 & 67108863;
          }
          for (; carry !== 0 && i2 < a2.length; i2++) {
            r3 = (a2.words[i2] | 0) + carry;
            carry = r3 >> 26;
            this.words[i2] = r3 & 67108863;
          }
          if (carry === 0 && i2 < a2.length && a2 !== this) {
            for (; i2 < a2.length; i2++) {
              this.words[i2] = a2.words[i2];
            }
          }
          this.length = Math.max(this.length, i2);
          if (a2 !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a2 = self2.words[0] | 0;
          var b3 = num.words[0] | 0;
          var r3 = a2 * b3;
          var lo = r3 & 67108863;
          var carry = r3 / 67108864 | 0;
          out.words[0] = lo;
          for (var k3 = 1; k3 < len; k3++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k3, num.length - 1);
            for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
              var i2 = k3 - j3 | 0;
              a2 = self2.words[i2] | 0;
              b3 = num.words[j3] | 0;
              r3 = a2 * b3 + rword;
              ncarry += r3 / 67108864 | 0;
              rword = r3 & 67108863;
            }
            out.words[k3] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k3] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a2 = self2.words;
          var b3 = num.words;
          var o3 = out.words;
          var c2 = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a2[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a2[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a22 = a2[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a3 = a2[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a2[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a2[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a2[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a2[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a2[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a2[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b3[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b3[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b22 = b3[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b32 = b3[3] | 0;
          var bl3 = b32 & 8191;
          var bh3 = b32 >>> 13;
          var b4 = b3[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b3[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b3[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b3[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b3[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b3[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w22 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
          c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o3[0] = w0;
          o3[1] = w1;
          o3[2] = w22;
          o3[3] = w3;
          o3[4] = w4;
          o3[5] = w5;
          o3[6] = w6;
          o3[7] = w7;
          o3[8] = w8;
          o3[9] = w9;
          o3[10] = w10;
          o3[11] = w11;
          o3[12] = w12;
          o3[13] = w13;
          o3[14] = w14;
          o3[15] = w15;
          o3[16] = w16;
          o3[17] = w17;
          o3[18] = w18;
          if (c2 !== 0) {
            o3[19] = c2;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k3 = 0; k3 < out.length - 1; k3++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k3, num.length - 1);
            for (var j3 = Math.max(0, k3 - self2.length + 1); j3 <= maxJ; j3++) {
              var i2 = k3 - j3;
              var a2 = self2.words[i2] | 0;
              var b3 = num.words[j3] | 0;
              var r3 = a2 * b3;
              var lo = r3 & 67108863;
              ncarry = ncarry + (r3 / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k3] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k3] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x3, y3) {
          this.x = x3;
          this.y = y3;
        }
        FFTM.prototype.makeRBT = function makeRBT(N3) {
          var t = new Array(N3);
          var l2 = BN2.prototype._countBits(N3) - 1;
          for (var i2 = 0; i2 < N3; i2++) {
            t[i2] = this.revBin(i2, l2, N3);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x3, l2, N3) {
          if (x3 === 0 || x3 === N3 - 1) return x3;
          var rb = 0;
          for (var i2 = 0; i2 < l2; i2++) {
            rb |= (x3 & 1) << l2 - i2 - 1;
            x3 >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N3) {
          for (var i2 = 0; i2 < N3; i2++) {
            rtws[i2] = rws[rbt[i2]];
            itws[i2] = iws[rbt[i2]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N3, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N3);
          for (var s2 = 1; s2 < N3; s2 <<= 1) {
            var l2 = s2 << 1;
            var rtwdf = Math.cos(2 * Math.PI / l2);
            var itwdf = Math.sin(2 * Math.PI / l2);
            for (var p2 = 0; p2 < N3; p2 += l2) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j3 = 0; j3 < s2; j3++) {
                var re = rtws[p2 + j3];
                var ie = itws[p2 + j3];
                var ro = rtws[p2 + j3 + s2];
                var io = itws[p2 + j3 + s2];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p2 + j3] = re + ro;
                itws[p2 + j3] = ie + io;
                rtws[p2 + j3 + s2] = re - ro;
                itws[p2 + j3 + s2] = ie - io;
                if (j3 !== l2) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n3, m3) {
          var N3 = Math.max(m3, n3) | 1;
          var odd = N3 & 1;
          var i2 = 0;
          for (N3 = N3 / 2 | 0; N3; N3 = N3 >>> 1) {
            i2++;
          }
          return 1 << i2 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N3) {
          if (N3 <= 1) return;
          for (var i2 = 0; i2 < N3 / 2; i2++) {
            var t = rws[i2];
            rws[i2] = rws[N3 - i2 - 1];
            rws[N3 - i2 - 1] = t;
            t = iws[i2];
            iws[i2] = -iws[N3 - i2 - 1];
            iws[N3 - i2 - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N3) {
          var carry = 0;
          for (var i2 = 0; i2 < N3 / 2; i2++) {
            var w3 = Math.round(ws[2 * i2 + 1] / N3) * 8192 + Math.round(ws[2 * i2] / N3) + carry;
            ws[i2] = w3 & 67108863;
            if (w3 < 67108864) {
              carry = 0;
            } else {
              carry = w3 / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N3) {
          var carry = 0;
          for (var i2 = 0; i2 < len; i2++) {
            carry = carry + (ws[i2] | 0);
            rws[2 * i2] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i2 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i2 = 2 * len; i2 < N3; ++i2) {
            rws[i2] = 0;
          }
          assert2(carry === 0);
          assert2((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N3) {
          var ph = new Array(N3);
          for (var i2 = 0; i2 < N3; i2++) {
            ph[i2] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x3, y3, out) {
          var N3 = 2 * this.guessLen13b(x3.length, y3.length);
          var rbt = this.makeRBT(N3);
          var _3 = this.stub(N3);
          var rws = new Array(N3);
          var rwst = new Array(N3);
          var iwst = new Array(N3);
          var nrws = new Array(N3);
          var nrwst = new Array(N3);
          var niwst = new Array(N3);
          var rmws = out.words;
          rmws.length = N3;
          this.convert13b(x3.words, x3.length, rws, N3);
          this.convert13b(y3.words, y3.length, nrws, N3);
          this.transform(rws, _3, rwst, iwst, N3, rbt);
          this.transform(nrws, _3, nrwst, niwst, N3, rbt);
          for (var i2 = 0; i2 < N3; i2++) {
            var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
            iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
            rwst[i2] = rx;
          }
          this.conjugate(rwst, iwst, N3);
          this.transform(rwst, iwst, rmws, _3, N3, rbt);
          this.conjugate(rmws, _3, N3);
          this.normalize13b(rmws, N3);
          out.negative = x3.negative ^ y3.negative;
          out.length = x3.length + y3.length;
          return out.strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w3 = (this.words[i2] | 0) * num;
            var lo = (w3 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w3 / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i2] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i2] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w3 = toBitArray(num);
          if (w3.length === 0) return new BN2(1);
          var res = this;
          for (var i2 = 0; i2 < w3.length; i2++, res = res.sqr()) {
            if (w3[i2] !== 0) break;
          }
          if (++i2 < w3.length) {
            for (var q3 = res.sqr(); i2 < w3.length; i2++, q3 = q3.sqr()) {
              if (w3[i2] === 0) continue;
              res = res.mul(q3);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r3 = bits % 26;
          var s2 = (bits - r3) / 26;
          var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
          var i2;
          if (r3 !== 0) {
            var carry = 0;
            for (i2 = 0; i2 < this.length; i2++) {
              var newCarry = this.words[i2] & carryMask;
              var c2 = (this.words[i2] | 0) - newCarry << r3;
              this.words[i2] = c2 | carry;
              carry = newCarry >>> 26 - r3;
            }
            if (carry) {
              this.words[i2] = carry;
              this.length++;
            }
          }
          if (s2 !== 0) {
            for (i2 = this.length - 1; i2 >= 0; i2--) {
              this.words[i2 + s2] = this.words[i2];
            }
            for (i2 = 0; i2 < s2; i2++) {
              this.words[i2] = 0;
            }
            this.length += s2;
          }
          return this.strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert2(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert2(typeof bits === "number" && bits >= 0);
          var h3;
          if (hint) {
            h3 = (hint - hint % 26) / 26;
          } else {
            h3 = 0;
          }
          var r3 = bits % 26;
          var s2 = Math.min((bits - r3) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          var maskedWords = extended;
          h3 -= s2;
          h3 = Math.max(0, h3);
          if (maskedWords) {
            for (var i2 = 0; i2 < s2; i2++) {
              maskedWords.words[i2] = this.words[i2];
            }
            maskedWords.length = s2;
          }
          if (s2 === 0) {
          } else if (this.length > s2) {
            this.length -= s2;
            for (i2 = 0; i2 < this.length; i2++) {
              this.words[i2] = this.words[i2 + s2];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h3); i2--) {
            var word = this.words[i2] | 0;
            this.words[i2] = carry << 26 - r3 | word >>> r3;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert2(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert2(typeof bit === "number" && bit >= 0);
          var r3 = bit % 26;
          var s2 = (bit - r3) / 26;
          var q3 = 1 << r3;
          if (this.length <= s2) return false;
          var w3 = this.words[s2];
          return !!(w3 & q3);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert2(typeof bits === "number" && bits >= 0);
          var r3 = bits % 26;
          var s2 = (bits - r3) / 26;
          assert2(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s2) {
            return this;
          }
          if (r3 !== 0) {
            s2++;
          }
          this.length = Math.min(s2, this.length);
          if (r3 !== 0) {
            var mask = 67108863 ^ 67108863 >>> r3 << r3;
            this.words[this.length - 1] &= mask;
          }
          return this.strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0) return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
            this.words[i2] -= 67108864;
            if (i2 === this.length - 1) {
              this.words[i2 + 1] = 1;
            } else {
              this.words[i2 + 1]++;
            }
          }
          this.length = Math.max(this.length, i2 + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert2(typeof num === "number");
          assert2(num < 67108864);
          if (num < 0) return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
              this.words[i2] += 67108864;
              this.words[i2 + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i2;
          this._expand(len);
          var w3;
          var carry = 0;
          for (i2 = 0; i2 < num.length; i2++) {
            w3 = (this.words[i2 + shift] | 0) + carry;
            var right = (num.words[i2] | 0) * mul;
            w3 -= right & 67108863;
            carry = (w3 >> 26) - (right / 67108864 | 0);
            this.words[i2 + shift] = w3 & 67108863;
          }
          for (; i2 < this.length - shift; i2++) {
            w3 = (this.words[i2 + shift] | 0) + carry;
            carry = w3 >> 26;
            this.words[i2 + shift] = w3 & 67108863;
          }
          if (carry === 0) return this.strip();
          assert2(carry === -1);
          carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            w3 = -(this.words[i2] | 0) + carry;
            carry = w3 >> 26;
            this.words[i2] = w3 & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a2 = this.clone();
          var b3 = num;
          var bhi = b3.words[b3.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b3 = b3.ushln(shift);
            a2.iushln(shift);
            bhi = b3.words[b3.length - 1] | 0;
          }
          var m3 = a2.length - b3.length;
          var q3;
          if (mode !== "mod") {
            q3 = new BN2(null);
            q3.length = m3 + 1;
            q3.words = new Array(q3.length);
            for (var i2 = 0; i2 < q3.length; i2++) {
              q3.words[i2] = 0;
            }
          }
          var diff = a2.clone()._ishlnsubmul(b3, 1, m3);
          if (diff.negative === 0) {
            a2 = diff;
            if (q3) {
              q3.words[m3] = 1;
            }
          }
          for (var j3 = m3 - 1; j3 >= 0; j3--) {
            var qj = (a2.words[b3.length + j3] | 0) * 67108864 + (a2.words[b3.length + j3 - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a2._ishlnsubmul(b3, qj, j3);
            while (a2.negative !== 0) {
              qj--;
              a2.negative = 0;
              a2._ishlnsubmul(b3, 1, j3);
              if (!a2.isZero()) {
                a2.negative ^= 1;
              }
            }
            if (q3) {
              q3.words[j3] = qj;
            }
          }
          if (q3) {
            q3.strip();
          }
          a2.strip();
          if (mode !== "div" && shift !== 0) {
            a2.iushrn(shift);
          }
          return {
            div: q3 || null,
            mod: a2
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert2(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero()) return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r22 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r22 === 1 && cmp === 0) return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modn = function modn(num) {
          assert2(num <= 67108863);
          var p2 = (1 << 26) % num;
          var acc = 0;
          for (var i2 = this.length - 1; i2 >= 0; i2--) {
            acc = (p2 * acc + (this.words[i2] | 0)) % num;
          }
          return acc;
        };
        BN2.prototype.idivn = function idivn(num) {
          assert2(num <= 67108863);
          var carry = 0;
          for (var i2 = this.length - 1; i2 >= 0; i2--) {
            var w3 = (this.words[i2] | 0) + carry * 67108864;
            this.words[i2] = w3 / num | 0;
            carry = w3 % num;
          }
          return this.strip();
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p2) {
          assert2(p2.negative === 0);
          assert2(!p2.isZero());
          var x3 = this;
          var y3 = p2.clone();
          if (x3.negative !== 0) {
            x3 = x3.umod(p2);
          } else {
            x3 = x3.clone();
          }
          var A3 = new BN2(1);
          var B3 = new BN2(0);
          var C3 = new BN2(0);
          var D3 = new BN2(1);
          var g3 = 0;
          while (x3.isEven() && y3.isEven()) {
            x3.iushrn(1);
            y3.iushrn(1);
            ++g3;
          }
          var yp = y3.clone();
          var xp = x3.clone();
          while (!x3.isZero()) {
            for (var i2 = 0, im = 1; (x3.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
            if (i2 > 0) {
              x3.iushrn(i2);
              while (i2-- > 0) {
                if (A3.isOdd() || B3.isOdd()) {
                  A3.iadd(yp);
                  B3.isub(xp);
                }
                A3.iushrn(1);
                B3.iushrn(1);
              }
            }
            for (var j3 = 0, jm = 1; (y3.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1) ;
            if (j3 > 0) {
              y3.iushrn(j3);
              while (j3-- > 0) {
                if (C3.isOdd() || D3.isOdd()) {
                  C3.iadd(yp);
                  D3.isub(xp);
                }
                C3.iushrn(1);
                D3.iushrn(1);
              }
            }
            if (x3.cmp(y3) >= 0) {
              x3.isub(y3);
              A3.isub(C3);
              B3.isub(D3);
            } else {
              y3.isub(x3);
              C3.isub(A3);
              D3.isub(B3);
            }
          }
          return {
            a: C3,
            b: D3,
            gcd: y3.iushln(g3)
          };
        };
        BN2.prototype._invmp = function _invmp(p2) {
          assert2(p2.negative === 0);
          assert2(!p2.isZero());
          var a2 = this;
          var b3 = p2.clone();
          if (a2.negative !== 0) {
            a2 = a2.umod(p2);
          } else {
            a2 = a2.clone();
          }
          var x1 = new BN2(1);
          var x22 = new BN2(0);
          var delta = b3.clone();
          while (a2.cmpn(1) > 0 && b3.cmpn(1) > 0) {
            for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
            if (i2 > 0) {
              a2.iushrn(i2);
              while (i2-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j3 = 0, jm = 1; (b3.words[0] & jm) === 0 && j3 < 26; ++j3, jm <<= 1) ;
            if (j3 > 0) {
              b3.iushrn(j3);
              while (j3-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a2.cmp(b3) >= 0) {
              a2.isub(b3);
              x1.isub(x22);
            } else {
              b3.isub(a2);
              x22.isub(x1);
            }
          }
          var res;
          if (a2.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p2);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero()) return num.abs();
          if (num.isZero()) return this.abs();
          var a2 = this.clone();
          var b3 = num.clone();
          a2.negative = 0;
          b3.negative = 0;
          for (var shift = 0; a2.isEven() && b3.isEven(); shift++) {
            a2.iushrn(1);
            b3.iushrn(1);
          }
          do {
            while (a2.isEven()) {
              a2.iushrn(1);
            }
            while (b3.isEven()) {
              b3.iushrn(1);
            }
            var r3 = a2.cmp(b3);
            if (r3 < 0) {
              var t = a2;
              a2 = b3;
              b3 = t;
            } else if (r3 === 0 || b3.cmpn(1) === 0) {
              break;
            }
            a2.isub(b3);
          } while (true);
          return b3.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert2(typeof bit === "number");
          var r3 = bit % 26;
          var s2 = (bit - r3) / 26;
          var q3 = 1 << r3;
          if (this.length <= s2) {
            this._expand(s2 + 1);
            this.words[s2] |= q3;
            return this;
          }
          var carry = q3;
          for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
            var w3 = this.words[i2] | 0;
            w3 += carry;
            carry = w3 >>> 26;
            w3 &= 67108863;
            this.words[i2] = w3;
          }
          if (carry !== 0) {
            this.words[i2] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative) return -1;
          if (this.negative === 0 && negative) return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert2(num <= 67108863, "Number is too big");
            var w3 = this.words[0] | 0;
            res = w3 === num ? 0 : w3 < num ? -1 : 1;
          }
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0) return -1;
          if (this.negative === 0 && num.negative !== 0) return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0) return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length) return 1;
          if (this.length < num.length) return -1;
          var res = 0;
          for (var i2 = this.length - 1; i2 >= 0; i2--) {
            var a2 = this.words[i2] | 0;
            var b3 = num.words[i2] | 0;
            if (a2 === b3) continue;
            if (a2 < b3) {
              res = -1;
            } else if (a2 > b3) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt2(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt2(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          assert2(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert2(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert2(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert2(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert2(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert2(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert2(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert2(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert2(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert2(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert2(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert2(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert2(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert2(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert2(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p2) {
          this.name = name;
          this.p = new BN2(p2, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r3 = num;
          var rlen;
          do {
            this.split(r3, this.tmp);
            r3 = this.imulK(r3);
            r3 = r3.iadd(this.tmp);
            rlen = r3.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
          if (cmp === 0) {
            r3.words[0] = 0;
            r3.length = 1;
          } else if (cmp > 0) {
            r3.isub(this.p);
          } else {
            r3.strip();
          }
          return r3;
        };
        MPrime.prototype.split = function split(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split(input, output) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i2 = 0; i2 < outLen; i2++) {
            output.words[i2] = input.words[i2];
          }
          output.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output.words[output.length++] = prev & mask;
          for (i2 = 10; i2 < input.length; i2++) {
            var next = input.words[i2] | 0;
            input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i2 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i2 = 0; i2 < num.length; i2++) {
            var w3 = num.words[i2] | 0;
            lo += w3 * 977;
            num.words[i2] = lo & 67108863;
            lo = w3 * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i2 = 0; i2 < num.length; i2++) {
            var hi = (num.words[i2] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i2] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name]) return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m3) {
          if (typeof m3 === "string") {
            var prime = BN2._prime(m3);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert2(m3.gtn(1), "modulus must be greater than 1");
            this.m = m3;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a2) {
          assert2(a2.negative === 0, "red works only with positives");
          assert2(a2.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a2, b3) {
          assert2((a2.negative | b3.negative) === 0, "red works only with positives");
          assert2(
            a2.red && a2.red === b3.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a2) {
          if (this.prime) return this.prime.ireduce(a2)._forceRed(this);
          return a2.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a2) {
          if (a2.isZero()) {
            return a2.clone();
          }
          return this.m.sub(a2)._forceRed(this);
        };
        Red.prototype.add = function add(a2, b3) {
          this._verify2(a2, b3);
          var res = a2.add(b3);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a2, b3) {
          this._verify2(a2, b3);
          var res = a2.iadd(b3);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a2, b3) {
          this._verify2(a2, b3);
          var res = a2.sub(b3);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a2, b3) {
          this._verify2(a2, b3);
          var res = a2.isub(b3);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a2, num) {
          this._verify1(a2);
          return this.imod(a2.ushln(num));
        };
        Red.prototype.imul = function imul(a2, b3) {
          this._verify2(a2, b3);
          return this.imod(a2.imul(b3));
        };
        Red.prototype.mul = function mul(a2, b3) {
          this._verify2(a2, b3);
          return this.imod(a2.mul(b3));
        };
        Red.prototype.isqr = function isqr(a2) {
          return this.imul(a2, a2.clone());
        };
        Red.prototype.sqr = function sqr(a2) {
          return this.mul(a2, a2);
        };
        Red.prototype.sqrt = function sqrt(a2) {
          if (a2.isZero()) return a2.clone();
          var mod3 = this.m.andln(3);
          assert2(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a2, pow);
          }
          var q3 = this.m.subn(1);
          var s2 = 0;
          while (!q3.isZero() && q3.andln(1) === 0) {
            s2++;
            q3.iushrn(1);
          }
          assert2(!q3.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z3 = this.m.bitLength();
          z3 = new BN2(2 * z3 * z3).toRed(this);
          while (this.pow(z3, lpow).cmp(nOne) !== 0) {
            z3.redIAdd(nOne);
          }
          var c2 = this.pow(z3, q3);
          var r3 = this.pow(a2, q3.addn(1).iushrn(1));
          var t = this.pow(a2, q3);
          var m3 = s2;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
              tmp = tmp.redSqr();
            }
            assert2(i2 < m3);
            var b3 = this.pow(c2, new BN2(1).iushln(m3 - i2 - 1));
            r3 = r3.redMul(b3);
            c2 = b3.redSqr();
            t = t.redMul(c2);
            m3 = i2;
          }
          return r3;
        };
        Red.prototype.invm = function invm(a2) {
          var inv = a2._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a2, num) {
          if (num.isZero()) return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0) return a2.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a2;
          for (var i2 = 2; i2 < wnd.length; i2++) {
            wnd[i2] = this.mul(wnd[i2 - 1], a2);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i2 = num.length - 1; i2 >= 0; i2--) {
            var word = num.words[i2];
            for (var j3 = start - 1; j3 >= 0; j3--) {
              var bit = word >> j3 & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i2 !== 0 || j3 !== 0)) continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r3 = num.umod(this.m);
          return r3 === num ? r3.clone() : r3;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m3) {
          Red.call(this, m3);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r3 = this.imod(num.mul(this.rinv));
          r3.red = null;
          return r3;
        };
        Mont.prototype.imul = function imul(a2, b3) {
          if (a2.isZero() || b3.isZero()) {
            a2.words[0] = 0;
            a2.length = 1;
            return a2;
          }
          var t = a2.imul(b3);
          var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u3 = t.isub(c2).iushrn(this.shift);
          var res = u3;
          if (u3.cmp(this.m) >= 0) {
            res = u3.isub(this.m);
          } else if (u3.cmpn(0) < 0) {
            res = u3.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a2, b3) {
          if (a2.isZero() || b3.isZero()) return new BN2(0)._forceRed(this);
          var t = a2.mul(b3);
          var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u3 = t.isub(c2).iushrn(this.shift);
          var res = u3;
          if (u3.cmp(this.m) >= 0) {
            res = u3.isub(this.m);
          } else if (u3.cmpn(0) < 0) {
            res = u3.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a2) {
          var res = this.imod(a2._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/is-typedarray/index.js
  var require_is_typedarray = __commonJS({
    "node_modules/is-typedarray/index.js"(exports, module) {
      init_polyfills();
      module.exports = isTypedArray2;
      isTypedArray2.strict = isStrictTypedArray;
      isTypedArray2.loose = isLooseTypedArray;
      var toString = Object.prototype.toString;
      var names = {
        "[object Int8Array]": true,
        "[object Int16Array]": true,
        "[object Int32Array]": true,
        "[object Uint8Array]": true,
        "[object Uint8ClampedArray]": true,
        "[object Uint16Array]": true,
        "[object Uint32Array]": true,
        "[object Float32Array]": true,
        "[object Float64Array]": true
      };
      function isTypedArray2(arr) {
        return isStrictTypedArray(arr) || isLooseTypedArray(arr);
      }
      function isStrictTypedArray(arr) {
        return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
      }
      function isLooseTypedArray(arr) {
        return names[toString.call(arr)];
      }
    }
  });

  // node_modules/typedarray-to-buffer/index.js
  var require_typedarray_to_buffer = __commonJS({
    "node_modules/typedarray-to-buffer/index.js"(exports, module) {
      init_polyfills();
      var isTypedArray2 = require_is_typedarray().strict;
      module.exports = function typedarrayToBuffer(arr) {
        if (isTypedArray2(arr)) {
          var buf = Buffer.from(arr.buffer);
          if (arr.byteLength !== arr.buffer.byteLength) {
            buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
          }
          return buf;
        } else {
          return Buffer.from(arr);
        }
      };
    }
  });

  // node_modules/@walletconnect/encoding/dist/esm/index.js
  function bufferToArray(buf) {
    return new Uint8Array(buf);
  }
  function bufferToHex(buf, prefixed = false) {
    const hex = buf.toString(ENC_HEX);
    return prefixed ? addHexPrefix(hex) : hex;
  }
  function bufferToUtf8(buf) {
    return buf.toString(ENC_UTF8);
  }
  function arrayToBuffer(arr) {
    return (0, import_typedarray_to_buffer.default)(arr);
  }
  function arrayToHex(arr, prefixed = false) {
    return bufferToHex(arrayToBuffer(arr), prefixed);
  }
  function arrayToUtf8(arr) {
    return bufferToUtf8(arrayToBuffer(arr));
  }
  function hexToBuffer(hex) {
    return Buffer.from(removeHexPrefix(hex), ENC_HEX);
  }
  function hexToArray(hex) {
    return bufferToArray(hexToBuffer(hex));
  }
  function utf8ToBuffer(utf8) {
    return Buffer.from(utf8, ENC_UTF8);
  }
  function utf8ToArray(utf8) {
    return bufferToArray(utf8ToBuffer(utf8));
  }
  function utf8ToHex(utf8, prefixed = false) {
    return bufferToHex(utf8ToBuffer(utf8), prefixed);
  }
  function isHexString(str, length) {
    if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (length && str.length !== 2 + 2 * length) {
      return false;
    }
    return true;
  }
  function concatArrays(...args) {
    let result = [];
    args.forEach((arg) => result = result.concat(Array.from(arg)));
    return new Uint8Array([...result]);
  }
  function calcByteLength(length, byteSize = 8) {
    const remainder = length % byteSize;
    return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
  }
  function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
    return padLeft(str, calcByteLength(str.length, byteSize), padding);
  }
  function padLeft(str, length, padding = STRING_ZERO) {
    return padString(str, length, true, padding);
  }
  function removeHexPrefix(hex) {
    return hex.replace(/^0x/, "");
  }
  function addHexPrefix(hex) {
    return hex.startsWith("0x") ? hex : `0x${hex}`;
  }
  function sanitizeHex(hex) {
    hex = removeHexPrefix(hex);
    hex = sanitizeBytes(hex, 2);
    if (hex) {
      hex = addHexPrefix(hex);
    }
    return hex;
  }
  function removeHexLeadingZeros(hex) {
    const prefixed = hex.startsWith("0x");
    hex = removeHexPrefix(hex);
    hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
    return prefixed ? addHexPrefix(hex) : hex;
  }
  function padString(str, length, left, padding = STRING_ZERO) {
    const diff = length - str.length;
    let result = str;
    if (diff > 0) {
      const pad = padding.repeat(diff);
      result = left ? pad + str : str + pad;
    }
    return result;
  }
  var import_is_typedarray, import_typedarray_to_buffer, ENC_HEX, ENC_UTF8, STRING_ZERO;
  var init_esm3 = __esm({
    "node_modules/@walletconnect/encoding/dist/esm/index.js"() {
      init_polyfills();
      import_is_typedarray = __toESM(require_is_typedarray());
      import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
      ENC_HEX = "hex";
      ENC_UTF8 = "utf8";
      STRING_ZERO = "0";
    }
  });

  // node_modules/@walletconnect/utils/dist/esm/encoding.js
  function convertArrayBufferToBuffer(arrBuf) {
    return arrayToBuffer(new Uint8Array(arrBuf));
  }
  function convertArrayBufferToHex(arrBuf, noPrefix) {
    return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
  }
  function convertBufferToArrayBuffer(buf) {
    return bufferToArray(buf).buffer;
  }
  function convertUtf8ToBuffer(utf8) {
    return utf8ToBuffer(utf8);
  }
  function convertUtf8ToHex(utf8, noPrefix) {
    return utf8ToHex(utf8, !noPrefix);
  }
  function convertHexToArrayBuffer(hex) {
    return hexToArray(hex).buffer;
  }
  function convertNumberToHex(num, noPrefix) {
    const hex = removeHexPrefix(sanitizeHex(new import_bn.default(num).toString(16)));
    return noPrefix ? hex : addHexPrefix(hex);
  }
  var import_bn;
  var init_encoding = __esm({
    "node_modules/@walletconnect/utils/dist/esm/encoding.js"() {
      init_polyfills();
      import_bn = __toESM(require_bn());
      init_esm3();
    }
  });

  // node_modules/js-sha3/src/sha3.js
  var require_sha3 = __commonJS({
    "node_modules/js-sha3/src/sha3.js"(exports, module) {
      init_polyfills();
      (function() {
        "use strict";
        var INPUT_ERROR = "input is invalid type";
        var FINALIZE_ERROR = "finalize already called";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA3_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
        var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
        var KECCAK_PADDING = [1, 256, 65536, 16777216];
        var PADDING2 = [6, 1536, 393216, 100663296];
        var SHIFT = [0, 8, 16, 24];
        var RC = [
          1,
          0,
          32898,
          0,
          32906,
          2147483648,
          2147516416,
          2147483648,
          32907,
          0,
          2147483649,
          0,
          2147516545,
          2147483648,
          32777,
          2147483648,
          138,
          0,
          136,
          0,
          2147516425,
          0,
          2147483658,
          0,
          2147516555,
          0,
          139,
          2147483648,
          32905,
          2147483648,
          32771,
          2147483648,
          32770,
          2147483648,
          128,
          2147483648,
          32778,
          0,
          2147483658,
          2147483648,
          2147516545,
          2147483648,
          32896,
          2147483648,
          2147483649,
          0,
          2147516424,
          2147483648
        ];
        var BITS = [224, 256, 384, 512];
        var SHAKE_BITS = [128, 256];
        var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
        var CSHAKE_BYTEPAD = {
          "128": 168,
          "256": 136
        };
        if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(bits2, padding, outputType) {
          return function(message) {
            return new Keccak(bits2, padding, bits2).update(message)[outputType]();
          };
        };
        var createShakeOutputMethod = function(bits2, padding, outputType) {
          return function(message, outputBits) {
            return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
          };
        };
        var createCshakeOutputMethod = function(bits2, padding, outputType) {
          return function(message, outputBits, n3, s2) {
            return methods["cshake" + bits2].update(message, outputBits, n3, s2)[outputType]();
          };
        };
        var createKmacOutputMethod = function(bits2, padding, outputType) {
          return function(key, message, outputBits, s2) {
            return methods["kmac" + bits2].update(key, message, outputBits, s2)[outputType]();
          };
        };
        var createOutputMethods = function(method, createMethod2, bits2, padding) {
          for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
            var type = OUTPUT_TYPES[i3];
            method[type] = createMethod2(bits2, padding, type);
          }
          return method;
        };
        var createMethod = function(bits2, padding) {
          var method = createOutputMethod(bits2, padding, "hex");
          method.create = function() {
            return new Keccak(bits2, padding, bits2);
          };
          method.update = function(message) {
            return method.create().update(message);
          };
          return createOutputMethods(method, createOutputMethod, bits2, padding);
        };
        var createShakeMethod = function(bits2, padding) {
          var method = createShakeOutputMethod(bits2, padding, "hex");
          method.create = function(outputBits) {
            return new Keccak(bits2, padding, outputBits);
          };
          method.update = function(message, outputBits) {
            return method.create(outputBits).update(message);
          };
          return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
        };
        var createCshakeMethod = function(bits2, padding) {
          var w3 = CSHAKE_BYTEPAD[bits2];
          var method = createCshakeOutputMethod(bits2, padding, "hex");
          method.create = function(outputBits, n3, s2) {
            if (!n3 && !s2) {
              return methods["shake" + bits2].create(outputBits);
            } else {
              return new Keccak(bits2, padding, outputBits).bytepad([n3, s2], w3);
            }
          };
          method.update = function(message, outputBits, n3, s2) {
            return method.create(outputBits, n3, s2).update(message);
          };
          return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
        };
        var createKmacMethod = function(bits2, padding) {
          var w3 = CSHAKE_BYTEPAD[bits2];
          var method = createKmacOutputMethod(bits2, padding, "hex");
          method.create = function(key, outputBits, s2) {
            return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s2], w3).bytepad([key], w3);
          };
          method.update = function(key, message, outputBits, s2) {
            return method.create(key, outputBits, s2).update(message);
          };
          return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
        };
        var algorithms = [
          { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
          { name: "sha3", padding: PADDING2, bits: BITS, createMethod },
          { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
          { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
          { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
        ];
        var methods = {}, methodNames = [];
        for (var i2 = 0; i2 < algorithms.length; ++i2) {
          var algorithm = algorithms[i2];
          var bits = algorithm.bits;
          for (var j3 = 0; j3 < bits.length; ++j3) {
            var methodName = algorithm.name + "_" + bits[j3];
            methodNames.push(methodName);
            methods[methodName] = algorithm.createMethod(bits[j3], algorithm.padding);
            if (algorithm.name !== "sha3") {
              var newMethodName = algorithm.name + bits[j3];
              methodNames.push(newMethodName);
              methods[newMethodName] = methods[methodName];
            }
          }
        }
        function Keccak(bits2, padding, outputBits) {
          this.blocks = [];
          this.s = [];
          this.padding = padding;
          this.outputBits = outputBits;
          this.reset = true;
          this.finalized = false;
          this.block = 0;
          this.start = 0;
          this.blockCount = 1600 - (bits2 << 1) >> 5;
          this.byteCount = this.blockCount << 2;
          this.outputBlocks = outputBits >> 5;
          this.extraBytes = (outputBits & 31) >> 3;
          for (var i3 = 0; i3 < 50; ++i3) {
            this.s[i3] = 0;
          }
        }
        Keccak.prototype.update = function(message) {
          if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s2 = this.s, i3, code;
          while (index < length) {
            if (this.reset) {
              this.reset = false;
              blocks[0] = this.block;
              for (i3 = 1; i3 < blockCount + 1; ++i3) {
                blocks[i3] = 0;
              }
            }
            if (notString) {
              for (i3 = this.start; index < length && i3 < byteCount; ++index) {
                blocks[i3 >> 2] |= message[index] << SHIFT[i3++ & 3];
              }
            } else {
              for (i3 = this.start; index < length && i3 < byteCount; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks[i3 >> 2] |= code << SHIFT[i3++ & 3];
                } else if (code < 2048) {
                  blocks[i3 >> 2] |= (192 | code >> 6) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks[i3 >> 2] |= (224 | code >> 12) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks[i3 >> 2] |= (240 | code >> 18) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i3++ & 3];
                  blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
                }
              }
            }
            this.lastByteIndex = i3;
            if (i3 >= byteCount) {
              this.start = i3 - byteCount;
              this.block = blocks[blockCount];
              for (i3 = 0; i3 < blockCount; ++i3) {
                s2[i3] ^= blocks[i3];
              }
              f3(s2);
              this.reset = true;
            } else {
              this.start = i3;
            }
          }
          return this;
        };
        Keccak.prototype.encode = function(x3, right) {
          var o3 = x3 & 255, n3 = 1;
          var bytes = [o3];
          x3 = x3 >> 8;
          o3 = x3 & 255;
          while (o3 > 0) {
            bytes.unshift(o3);
            x3 = x3 >> 8;
            o3 = x3 & 255;
            ++n3;
          }
          if (right) {
            bytes.push(n3);
          } else {
            bytes.unshift(n3);
          }
          this.update(bytes);
          return bytes.length;
        };
        Keccak.prototype.encodeString = function(str) {
          var notString, type = typeof str;
          if (type !== "string") {
            if (type === "object") {
              if (str === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
                str = new Uint8Array(str);
              } else if (!Array.isArray(str)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var bytes = 0, length = str.length;
          if (notString) {
            bytes = length;
          } else {
            for (var i3 = 0; i3 < str.length; ++i3) {
              var code = str.charCodeAt(i3);
              if (code < 128) {
                bytes += 1;
              } else if (code < 2048) {
                bytes += 2;
              } else if (code < 55296 || code >= 57344) {
                bytes += 3;
              } else {
                code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i3) & 1023);
                bytes += 4;
              }
            }
          }
          bytes += this.encode(bytes * 8);
          this.update(str);
          return bytes;
        };
        Keccak.prototype.bytepad = function(strs, w3) {
          var bytes = this.encode(w3);
          for (var i3 = 0; i3 < strs.length; ++i3) {
            bytes += this.encodeString(strs[i3]);
          }
          var paddingBytes = w3 - bytes % w3;
          var zeros = [];
          zeros.length = paddingBytes;
          this.update(zeros);
          return this;
        };
        Keccak.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks = this.blocks, i3 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
          blocks[i3 >> 2] |= this.padding[i3 & 3];
          if (this.lastByteIndex === this.byteCount) {
            blocks[0] = blocks[blockCount];
            for (i3 = 1; i3 < blockCount + 1; ++i3) {
              blocks[i3] = 0;
            }
          }
          blocks[blockCount - 1] |= 2147483648;
          for (i3 = 0; i3 < blockCount; ++i3) {
            s2[i3] ^= blocks[i3];
          }
          f3(s2);
        };
        Keccak.prototype.toString = Keccak.prototype.hex = function() {
          this.finalize();
          var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j4 = 0;
          var hex = "", block;
          while (j4 < outputBlocks) {
            for (i3 = 0; i3 < blockCount && j4 < outputBlocks; ++i3, ++j4) {
              block = s2[i3];
              hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
            }
            if (j4 % blockCount === 0) {
              f3(s2);
              i3 = 0;
            }
          }
          if (extraBytes) {
            block = s2[i3];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
            if (extraBytes > 1) {
              hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
            }
            if (extraBytes > 2) {
              hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
            }
          }
          return hex;
        };
        Keccak.prototype.arrayBuffer = function() {
          this.finalize();
          var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j4 = 0;
          var bytes = this.outputBits >> 3;
          var buffer;
          if (extraBytes) {
            buffer = new ArrayBuffer(outputBlocks + 1 << 2);
          } else {
            buffer = new ArrayBuffer(bytes);
          }
          var array = new Uint32Array(buffer);
          while (j4 < outputBlocks) {
            for (i3 = 0; i3 < blockCount && j4 < outputBlocks; ++i3, ++j4) {
              array[j4] = s2[i3];
            }
            if (j4 % blockCount === 0) {
              f3(s2);
            }
          }
          if (extraBytes) {
            array[i3] = s2[i3];
            buffer = buffer.slice(0, bytes);
          }
          return buffer;
        };
        Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
        Keccak.prototype.digest = Keccak.prototype.array = function() {
          this.finalize();
          var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j4 = 0;
          var array = [], offset, block;
          while (j4 < outputBlocks) {
            for (i3 = 0; i3 < blockCount && j4 < outputBlocks; ++i3, ++j4) {
              offset = j4 << 2;
              block = s2[i3];
              array[offset] = block & 255;
              array[offset + 1] = block >> 8 & 255;
              array[offset + 2] = block >> 16 & 255;
              array[offset + 3] = block >> 24 & 255;
            }
            if (j4 % blockCount === 0) {
              f3(s2);
            }
          }
          if (extraBytes) {
            offset = j4 << 2;
            block = s2[i3];
            array[offset] = block & 255;
            if (extraBytes > 1) {
              array[offset + 1] = block >> 8 & 255;
            }
            if (extraBytes > 2) {
              array[offset + 2] = block >> 16 & 255;
            }
          }
          return array;
        };
        function Kmac(bits2, padding, outputBits) {
          Keccak.call(this, bits2, padding, outputBits);
        }
        Kmac.prototype = new Keccak();
        Kmac.prototype.finalize = function() {
          this.encode(this.outputBits, true);
          return Keccak.prototype.finalize.call(this);
        };
        var f3 = function(s2) {
          var h3, l2, n3, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b22, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
          for (n3 = 0; n3 < 48; n3 += 2) {
            c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
            c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
            c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
            c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
            c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
            c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
            c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
            c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
            c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
            c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
            h3 = c8 ^ (c2 << 1 | c3 >>> 31);
            l2 = c9 ^ (c3 << 1 | c2 >>> 31);
            s2[0] ^= h3;
            s2[1] ^= l2;
            s2[10] ^= h3;
            s2[11] ^= l2;
            s2[20] ^= h3;
            s2[21] ^= l2;
            s2[30] ^= h3;
            s2[31] ^= l2;
            s2[40] ^= h3;
            s2[41] ^= l2;
            h3 = c0 ^ (c4 << 1 | c5 >>> 31);
            l2 = c1 ^ (c5 << 1 | c4 >>> 31);
            s2[2] ^= h3;
            s2[3] ^= l2;
            s2[12] ^= h3;
            s2[13] ^= l2;
            s2[22] ^= h3;
            s2[23] ^= l2;
            s2[32] ^= h3;
            s2[33] ^= l2;
            s2[42] ^= h3;
            s2[43] ^= l2;
            h3 = c2 ^ (c6 << 1 | c7 >>> 31);
            l2 = c3 ^ (c7 << 1 | c6 >>> 31);
            s2[4] ^= h3;
            s2[5] ^= l2;
            s2[14] ^= h3;
            s2[15] ^= l2;
            s2[24] ^= h3;
            s2[25] ^= l2;
            s2[34] ^= h3;
            s2[35] ^= l2;
            s2[44] ^= h3;
            s2[45] ^= l2;
            h3 = c4 ^ (c8 << 1 | c9 >>> 31);
            l2 = c5 ^ (c9 << 1 | c8 >>> 31);
            s2[6] ^= h3;
            s2[7] ^= l2;
            s2[16] ^= h3;
            s2[17] ^= l2;
            s2[26] ^= h3;
            s2[27] ^= l2;
            s2[36] ^= h3;
            s2[37] ^= l2;
            s2[46] ^= h3;
            s2[47] ^= l2;
            h3 = c6 ^ (c0 << 1 | c1 >>> 31);
            l2 = c7 ^ (c1 << 1 | c0 >>> 31);
            s2[8] ^= h3;
            s2[9] ^= l2;
            s2[18] ^= h3;
            s2[19] ^= l2;
            s2[28] ^= h3;
            s2[29] ^= l2;
            s2[38] ^= h3;
            s2[39] ^= l2;
            s2[48] ^= h3;
            s2[49] ^= l2;
            b0 = s2[0];
            b1 = s2[1];
            b32 = s2[11] << 4 | s2[10] >>> 28;
            b33 = s2[10] << 4 | s2[11] >>> 28;
            b14 = s2[20] << 3 | s2[21] >>> 29;
            b15 = s2[21] << 3 | s2[20] >>> 29;
            b46 = s2[31] << 9 | s2[30] >>> 23;
            b47 = s2[30] << 9 | s2[31] >>> 23;
            b28 = s2[40] << 18 | s2[41] >>> 14;
            b29 = s2[41] << 18 | s2[40] >>> 14;
            b20 = s2[2] << 1 | s2[3] >>> 31;
            b21 = s2[3] << 1 | s2[2] >>> 31;
            b22 = s2[13] << 12 | s2[12] >>> 20;
            b3 = s2[12] << 12 | s2[13] >>> 20;
            b34 = s2[22] << 10 | s2[23] >>> 22;
            b35 = s2[23] << 10 | s2[22] >>> 22;
            b16 = s2[33] << 13 | s2[32] >>> 19;
            b17 = s2[32] << 13 | s2[33] >>> 19;
            b48 = s2[42] << 2 | s2[43] >>> 30;
            b49 = s2[43] << 2 | s2[42] >>> 30;
            b40 = s2[5] << 30 | s2[4] >>> 2;
            b41 = s2[4] << 30 | s2[5] >>> 2;
            b222 = s2[14] << 6 | s2[15] >>> 26;
            b23 = s2[15] << 6 | s2[14] >>> 26;
            b4 = s2[25] << 11 | s2[24] >>> 21;
            b5 = s2[24] << 11 | s2[25] >>> 21;
            b36 = s2[34] << 15 | s2[35] >>> 17;
            b37 = s2[35] << 15 | s2[34] >>> 17;
            b18 = s2[45] << 29 | s2[44] >>> 3;
            b19 = s2[44] << 29 | s2[45] >>> 3;
            b10 = s2[6] << 28 | s2[7] >>> 4;
            b11 = s2[7] << 28 | s2[6] >>> 4;
            b42 = s2[17] << 23 | s2[16] >>> 9;
            b43 = s2[16] << 23 | s2[17] >>> 9;
            b24 = s2[26] << 25 | s2[27] >>> 7;
            b25 = s2[27] << 25 | s2[26] >>> 7;
            b6 = s2[36] << 21 | s2[37] >>> 11;
            b7 = s2[37] << 21 | s2[36] >>> 11;
            b38 = s2[47] << 24 | s2[46] >>> 8;
            b39 = s2[46] << 24 | s2[47] >>> 8;
            b30 = s2[8] << 27 | s2[9] >>> 5;
            b31 = s2[9] << 27 | s2[8] >>> 5;
            b12 = s2[18] << 20 | s2[19] >>> 12;
            b13 = s2[19] << 20 | s2[18] >>> 12;
            b44 = s2[29] << 7 | s2[28] >>> 25;
            b45 = s2[28] << 7 | s2[29] >>> 25;
            b26 = s2[38] << 8 | s2[39] >>> 24;
            b27 = s2[39] << 8 | s2[38] >>> 24;
            b8 = s2[48] << 14 | s2[49] >>> 18;
            b9 = s2[49] << 14 | s2[48] >>> 18;
            s2[0] = b0 ^ ~b22 & b4;
            s2[1] = b1 ^ ~b3 & b5;
            s2[10] = b10 ^ ~b12 & b14;
            s2[11] = b11 ^ ~b13 & b15;
            s2[20] = b20 ^ ~b222 & b24;
            s2[21] = b21 ^ ~b23 & b25;
            s2[30] = b30 ^ ~b32 & b34;
            s2[31] = b31 ^ ~b33 & b35;
            s2[40] = b40 ^ ~b42 & b44;
            s2[41] = b41 ^ ~b43 & b45;
            s2[2] = b22 ^ ~b4 & b6;
            s2[3] = b3 ^ ~b5 & b7;
            s2[12] = b12 ^ ~b14 & b16;
            s2[13] = b13 ^ ~b15 & b17;
            s2[22] = b222 ^ ~b24 & b26;
            s2[23] = b23 ^ ~b25 & b27;
            s2[32] = b32 ^ ~b34 & b36;
            s2[33] = b33 ^ ~b35 & b37;
            s2[42] = b42 ^ ~b44 & b46;
            s2[43] = b43 ^ ~b45 & b47;
            s2[4] = b4 ^ ~b6 & b8;
            s2[5] = b5 ^ ~b7 & b9;
            s2[14] = b14 ^ ~b16 & b18;
            s2[15] = b15 ^ ~b17 & b19;
            s2[24] = b24 ^ ~b26 & b28;
            s2[25] = b25 ^ ~b27 & b29;
            s2[34] = b34 ^ ~b36 & b38;
            s2[35] = b35 ^ ~b37 & b39;
            s2[44] = b44 ^ ~b46 & b48;
            s2[45] = b45 ^ ~b47 & b49;
            s2[6] = b6 ^ ~b8 & b0;
            s2[7] = b7 ^ ~b9 & b1;
            s2[16] = b16 ^ ~b18 & b10;
            s2[17] = b17 ^ ~b19 & b11;
            s2[26] = b26 ^ ~b28 & b20;
            s2[27] = b27 ^ ~b29 & b21;
            s2[36] = b36 ^ ~b38 & b30;
            s2[37] = b37 ^ ~b39 & b31;
            s2[46] = b46 ^ ~b48 & b40;
            s2[47] = b47 ^ ~b49 & b41;
            s2[8] = b8 ^ ~b0 & b22;
            s2[9] = b9 ^ ~b1 & b3;
            s2[18] = b18 ^ ~b10 & b12;
            s2[19] = b19 ^ ~b11 & b13;
            s2[28] = b28 ^ ~b20 & b222;
            s2[29] = b29 ^ ~b21 & b23;
            s2[38] = b38 ^ ~b30 & b32;
            s2[39] = b39 ^ ~b31 & b33;
            s2[48] = b48 ^ ~b40 & b42;
            s2[49] = b49 ^ ~b41 & b43;
            s2[0] ^= RC[n3];
            s2[1] ^= RC[n3 + 1];
          }
        };
        if (COMMON_JS) {
          module.exports = methods;
        } else {
          for (i2 = 0; i2 < methodNames.length; ++i2) {
            root[methodNames[i2]] = methods[methodNames[i2]];
          }
          if (AMD) {
            define(function() {
              return methods;
            });
          }
        }
      })();
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
  var PARSE_ERROR, INVALID_REQUEST, METHOD_NOT_FOUND, INVALID_PARAMS, INTERNAL_ERROR, SERVER_ERROR, RESERVED_ERROR_CODES, SERVER_ERROR_CODE_RANGE, STANDARD_ERROR_MAP, DEFAULT_ERROR;
  var init_constants2 = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js"() {
      init_polyfills();
      PARSE_ERROR = "PARSE_ERROR";
      INVALID_REQUEST = "INVALID_REQUEST";
      METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
      INVALID_PARAMS = "INVALID_PARAMS";
      INTERNAL_ERROR = "INTERNAL_ERROR";
      SERVER_ERROR = "SERVER_ERROR";
      RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
      SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
      STANDARD_ERROR_MAP = {
        [PARSE_ERROR]: { code: -32700, message: "Parse error" },
        [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
        [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
        [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
        [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
        [SERVER_ERROR]: { code: -32e3, message: "Server error" }
      };
      DEFAULT_ERROR = SERVER_ERROR;
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
  function isServerErrorCode(code) {
    return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
  }
  function isReservedErrorCode(code) {
    return RESERVED_ERROR_CODES.includes(code);
  }
  function isValidErrorCode(code) {
    return typeof code === "number";
  }
  function getError(type) {
    if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
      return STANDARD_ERROR_MAP[DEFAULT_ERROR];
    }
    return STANDARD_ERROR_MAP[type];
  }
  function getErrorByCode(code) {
    const match = Object.values(STANDARD_ERROR_MAP).find((e2) => e2.code === code);
    if (!match) {
      return STANDARD_ERROR_MAP[DEFAULT_ERROR];
    }
    return match;
  }
  function validateJsonRpcError(response) {
    if (typeof response.error.code === "undefined") {
      return { valid: false, error: "Missing code for JSON-RPC error" };
    }
    if (typeof response.error.message === "undefined") {
      return { valid: false, error: "Missing message for JSON-RPC error" };
    }
    if (!isValidErrorCode(response.error.code)) {
      return {
        valid: false,
        error: `Invalid error code type for JSON-RPC: ${response.error.code}`
      };
    }
    if (isReservedErrorCode(response.error.code)) {
      const error = getErrorByCode(response.error.code);
      if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
        return {
          valid: false,
          error: `Invalid error code message for JSON-RPC: ${response.error.code}`
        };
      }
    }
    return { valid: true };
  }
  function parseConnectionError(e2, url, type) {
    return e2.message.includes("getaddrinfo ENOTFOUND") || e2.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e2;
  }
  var init_error = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js"() {
      init_polyfills();
      init_constants2();
    }
  });

  // node_modules/tslib/tslib.es6.js
  var tslib_es6_exports = {};
  __export(tslib_es6_exports, {
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __read: () => __read,
    __rest: () => __rest,
    __spread: () => __spread,
    __spreadArrays: () => __spreadArrays2,
    __values: () => __values2
  });
  function __extends(d2, b3) {
    extendStatics(d2, b3);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
  }
  function __rest(s2, e2) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
        if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
          t[p2[i2]] = s2[p2[i2]];
      }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
    else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r3 = (c2 < 3 ? d2(r3) : c2 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
    return c2 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
  }
  function __param(paramIndex, decorator) {
    return function(target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P3, generator) {
    function adopt(value) {
      return value instanceof P3 ? value : new P3(function(resolve) {
        resolve(value);
      });
    }
    return new (P3 || (P3 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _3 = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f3, y3, t, g3;
    return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
      return this;
    }), g3;
    function verb(n3) {
      return function(v3) {
        return step([n3, v3]);
      };
    }
    function step(op) {
      if (f3) throw new TypeError("Generator is already executing.");
      while (_3) try {
        if (f3 = 1, y3 && (t = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t = y3["return"]) && t.call(y3), 0) : y3.next) && !(t = t.call(y3, op[1])).done) return t;
        if (y3 = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _3.label++;
            return { value: op[1], done: false };
          case 5:
            _3.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _3.ops.pop();
            _3.trys.pop();
            continue;
          default:
            if (!(t = _3.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _3 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _3.label = op[1];
              break;
            }
            if (op[0] === 6 && _3.label < t[1]) {
              _3.label = t[1];
              t = op;
              break;
            }
            if (t && _3.label < t[2]) {
              _3.label = t[2];
              _3.ops.push(op);
              break;
            }
            if (t[2]) _3.ops.pop();
            _3.trys.pop();
            continue;
        }
        op = body.call(thisArg, _3);
      } catch (e2) {
        op = [6, e2];
        y3 = 0;
      } finally {
        f3 = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __createBinding(o3, m3, k3, k22) {
    if (k22 === void 0) k22 = k3;
    o3[k22] = m3[k3];
  }
  function __exportStar(m3, exports) {
    for (var p2 in m3) if (p2 !== "default" && !exports.hasOwnProperty(p2)) exports[p2] = m3[p2];
  }
  function __values2(o3) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o3[s2], i2 = 0;
    if (m3) return m3.call(o3);
    if (o3 && typeof o3.length === "number") return {
      next: function() {
        if (o3 && i2 >= o3.length) o3 = void 0;
        return { value: o3 && o3[i2++], done: !o3 };
      }
    };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o3, n3) {
    var m3 = typeof Symbol === "function" && o3[Symbol.iterator];
    if (!m3) return o3;
    var i2 = m3.call(o3), r3, ar = [], e2;
    try {
      while ((n3 === void 0 || n3-- > 0) && !(r3 = i2.next()).done) ar.push(r3.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r3 && !r3.done && (m3 = i2["return"])) m3.call(i2);
      } finally {
        if (e2) throw e2.error;
      }
    }
    return ar;
  }
  function __spread() {
    for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
      ar = ar.concat(__read(arguments[i2]));
    return ar;
  }
  function __spreadArrays2() {
    for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
    for (var r3 = Array(s2), k3 = 0, i2 = 0; i2 < il; i2++)
      for (var a2 = arguments[i2], j3 = 0, jl = a2.length; j3 < jl; j3++, k3++)
        r3[k3] = a2[j3];
    return r3;
  }
  function __await(v3) {
    return this instanceof __await ? (this.v = v3, this) : new __await(v3);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g3 = generator.apply(thisArg, _arguments || []), i2, q3 = [];
    return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2;
    function verb(n3) {
      if (g3[n3]) i2[n3] = function(v3) {
        return new Promise(function(a2, b3) {
          q3.push([n3, v3, a2, b3]) > 1 || resume(n3, v3);
        });
      };
    }
    function resume(n3, v3) {
      try {
        step(g3[n3](v3));
      } catch (e2) {
        settle(q3[0][3], e2);
      }
    }
    function step(r3) {
      r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q3[0][2], r3);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f3, v3) {
      if (f3(v3), q3.shift(), q3.length) resume(q3[0][0], q3[0][1]);
    }
  }
  function __asyncDelegator(o3) {
    var i2, p2;
    return i2 = {}, verb("next"), verb("throw", function(e2) {
      throw e2;
    }), verb("return"), i2[Symbol.iterator] = function() {
      return this;
    }, i2;
    function verb(n3, f3) {
      i2[n3] = o3[n3] ? function(v3) {
        return (p2 = !p2) ? { value: __await(o3[n3](v3)), done: n3 === "return" } : f3 ? f3(v3) : v3;
      } : f3;
    }
  }
  function __asyncValues(o3) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m3 = o3[Symbol.asyncIterator], i2;
    return m3 ? m3.call(o3) : (o3 = typeof __values2 === "function" ? __values2(o3) : o3[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
      return this;
    }, i2);
    function verb(n3) {
      i2[n3] = o3[n3] && function(v3) {
        return new Promise(function(resolve, reject) {
          v3 = o3[n3](v3), settle(resolve, reject, v3.done, v3.value);
        });
      };
    }
    function settle(resolve, reject, d2, v3) {
      Promise.resolve(v3).then(function(v4) {
        resolve({ value: v4, done: d2 });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k3 in mod) if (Object.hasOwnProperty.call(mod, k3)) result[k3] = mod[k3];
    }
    result.default = mod;
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
  }
  function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
  }
  var extendStatics, __assign;
  var init_tslib_es6 = __esm({
    "node_modules/tslib/tslib.es6.js"() {
      init_polyfills();
      extendStatics = function(d2, b3) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
          d3.__proto__ = b4;
        } || function(d3, b4) {
          for (var p2 in b4) if (b4.hasOwnProperty(p2)) d3[p2] = b4[p2];
        };
        return extendStatics(d2, b3);
      };
      __assign = function() {
        __assign = Object.assign || function __assign2(t) {
          for (var s2, i2 = 1, n3 = arguments.length; i2 < n3; i2++) {
            s2 = arguments[i2];
            for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t[p2] = s2[p2];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
    }
  });

  // node_modules/@walletconnect/environment/dist/cjs/crypto.js
  var require_crypto = __commonJS({
    "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
      function getBrowerCrypto2() {
        return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
      }
      exports.getBrowerCrypto = getBrowerCrypto2;
      function getSubtleCrypto2() {
        const browserCrypto = getBrowerCrypto2();
        return browserCrypto.subtle || browserCrypto.webkitSubtle;
      }
      exports.getSubtleCrypto = getSubtleCrypto2;
      function isBrowserCryptoAvailable() {
        return !!getBrowerCrypto2() && !!getSubtleCrypto2();
      }
      exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
    }
  });

  // node_modules/@walletconnect/environment/dist/cjs/env.js
  var require_env = __commonJS({
    "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
      function isReactNative2() {
        return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
      }
      exports.isReactNative = isReactNative2;
      function isNode4() {
        return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
      }
      exports.isNode = isNode4;
      function isBrowser2() {
        return !isReactNative2() && !isNode4();
      }
      exports.isBrowser = isBrowser2;
    }
  });

  // node_modules/@walletconnect/environment/dist/cjs/index.js
  var require_cjs3 = __commonJS({
    "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
      "use strict";
      init_polyfills();
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_crypto(), exports);
      tslib_1.__exportStar(require_env(), exports);
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
  var env_exports = {};
  __export(env_exports, {
    isNodeJs: () => isNodeJs
  });
  var import_environment, isNodeJs;
  var init_env = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js"() {
      init_polyfills();
      import_environment = __toESM(require_cjs3());
      __reExport(env_exports, __toESM(require_cjs3()));
      isNodeJs = import_environment.isNode;
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
  function payloadId(entropy = 3) {
    const date = Date.now() * Math.pow(10, entropy);
    const extra = Math.floor(Math.random() * Math.pow(10, entropy));
    return date + extra;
  }
  function getBigIntRpcId(entropy = 6) {
    return BigInt(payloadId(entropy));
  }
  function formatJsonRpcRequest(method, params, id) {
    return {
      id: id || payloadId(),
      jsonrpc: "2.0",
      method,
      params
    };
  }
  function formatJsonRpcResult(id, result) {
    return {
      id,
      jsonrpc: "2.0",
      result
    };
  }
  function formatJsonRpcError(id, error, data) {
    return {
      id,
      jsonrpc: "2.0",
      error: formatErrorMessage(error, data)
    };
  }
  function formatErrorMessage(error, data) {
    if (typeof error === "undefined") {
      return getError(INTERNAL_ERROR);
    }
    if (typeof error === "string") {
      error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
    }
    if (typeof data !== "undefined") {
      error.data = data;
    }
    if (isReservedErrorCode(error.code)) {
      error = getErrorByCode(error.code);
    }
    return error;
  }
  var init_format = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js"() {
      init_polyfills();
      init_error();
      init_constants2();
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
  function isValidRoute(route) {
    if (route.includes("*")) {
      return isValidWildcardRoute(route);
    }
    if (/\W/g.test(route)) {
      return false;
    }
    return true;
  }
  function isValidDefaultRoute(route) {
    return route === "*";
  }
  function isValidWildcardRoute(route) {
    if (isValidDefaultRoute(route)) {
      return true;
    }
    if (!route.includes("*")) {
      return false;
    }
    if (route.split("*").length !== 2) {
      return false;
    }
    if (route.split("*").filter((x3) => x3.trim() === "").length !== 1) {
      return false;
    }
    return true;
  }
  function isValidLeadingWildcardRoute(route) {
    return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
  }
  function isValidTrailingWildcardRoute(route) {
    return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
  }
  var init_routing = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js"() {
      init_polyfills();
    }
  });

  // node_modules/@walletconnect/jsonrpc-types/dist/index.es.js
  var e, o, n, r;
  var init_index_es = __esm({
    "node_modules/@walletconnect/jsonrpc-types/dist/index.es.js"() {
      init_polyfills();
      e = class {
      };
      o = class extends e {
        constructor(c2) {
          super();
        }
      };
      n = class extends e {
        constructor() {
          super();
        }
      };
      r = class extends n {
        constructor(c2) {
          super();
        }
      };
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js
  var init_types = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js"() {
      init_polyfills();
      init_index_es();
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
  function getUrlProtocol(url) {
    const matches = url.match(new RegExp(/^\w+:/, "gi"));
    if (!matches || !matches.length)
      return;
    return matches[0];
  }
  function matchRegexProtocol(url, regex) {
    const protocol = getUrlProtocol(url);
    if (typeof protocol === "undefined")
      return false;
    return new RegExp(regex).test(protocol);
  }
  function isHttpUrl(url) {
    return matchRegexProtocol(url, HTTP_REGEX);
  }
  function isWsUrl(url) {
    return matchRegexProtocol(url, WS_REGEX);
  }
  function isLocalhostUrl(url) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(url);
  }
  var HTTP_REGEX, WS_REGEX;
  var init_url = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js"() {
      init_polyfills();
      HTTP_REGEX = "^https?:";
      WS_REGEX = "^wss?:";
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
  function isJsonRpcPayload(payload) {
    return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
  }
  function isJsonRpcRequest(payload) {
    return isJsonRpcPayload(payload) && "method" in payload;
  }
  function isJsonRpcResponse(payload) {
    return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
  }
  function isJsonRpcResult(payload) {
    return "result" in payload;
  }
  function isJsonRpcError(payload) {
    return "error" in payload;
  }
  function isJsonRpcValidationInvalid(validation) {
    return "error" in validation && validation.valid === false;
  }
  var init_validators = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js"() {
      init_polyfills();
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
  var esm_exports3 = {};
  __export(esm_exports3, {
    DEFAULT_ERROR: () => DEFAULT_ERROR,
    IBaseJsonRpcProvider: () => n,
    IEvents: () => e,
    IJsonRpcConnection: () => o,
    IJsonRpcProvider: () => r,
    INTERNAL_ERROR: () => INTERNAL_ERROR,
    INVALID_PARAMS: () => INVALID_PARAMS,
    INVALID_REQUEST: () => INVALID_REQUEST,
    METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
    PARSE_ERROR: () => PARSE_ERROR,
    RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
    SERVER_ERROR: () => SERVER_ERROR,
    SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
    STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
    formatErrorMessage: () => formatErrorMessage,
    formatJsonRpcError: () => formatJsonRpcError,
    formatJsonRpcRequest: () => formatJsonRpcRequest,
    formatJsonRpcResult: () => formatJsonRpcResult,
    getBigIntRpcId: () => getBigIntRpcId,
    getError: () => getError,
    getErrorByCode: () => getErrorByCode,
    isHttpUrl: () => isHttpUrl,
    isJsonRpcError: () => isJsonRpcError,
    isJsonRpcPayload: () => isJsonRpcPayload,
    isJsonRpcRequest: () => isJsonRpcRequest,
    isJsonRpcResponse: () => isJsonRpcResponse,
    isJsonRpcResult: () => isJsonRpcResult,
    isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
    isLocalhostUrl: () => isLocalhostUrl,
    isNodeJs: () => isNodeJs,
    isReservedErrorCode: () => isReservedErrorCode,
    isServerErrorCode: () => isServerErrorCode,
    isValidDefaultRoute: () => isValidDefaultRoute,
    isValidErrorCode: () => isValidErrorCode,
    isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
    isValidRoute: () => isValidRoute,
    isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
    isValidWildcardRoute: () => isValidWildcardRoute,
    isWsUrl: () => isWsUrl,
    parseConnectionError: () => parseConnectionError,
    payloadId: () => payloadId,
    validateJsonRpcError: () => validateJsonRpcError
  });
  var init_esm4 = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js"() {
      init_polyfills();
      init_constants2();
      init_error();
      init_env();
      __reExport(esm_exports3, env_exports);
      init_format();
      init_routing();
      init_types();
      init_url();
      init_validators();
    }
  });

  // node_modules/@walletconnect/utils/dist/esm/misc.js
  function sanitizeHex2(hex) {
    return sanitizeHex(hex);
  }
  function removeHexLeadingZeros2(hex) {
    return removeHexLeadingZeros(addHexPrefix(hex));
  }
  function uuid() {
    const result = ((a2, b3) => {
      for (b3 = a2 = ""; a2++ < 36; b3 += a2 * 51 & 52 ? (a2 ^ 15 ? 8 ^ Math.random() * (a2 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
      }
      return b3;
    })();
    return result;
  }
  var payloadId2;
  var init_misc = __esm({
    "node_modules/@walletconnect/utils/dist/esm/misc.js"() {
      init_polyfills();
      init_esm3();
      init_esm4();
      init_constants();
      payloadId2 = payloadId;
    }
  });

  // node_modules/@walletconnect/utils/dist/esm/validators.js
  function isEmptyString(value) {
    return value === "" || typeof value === "string" && value.trim() === "";
  }
  function isEmptyArray(array) {
    return !(array && array.length);
  }
  function isHexString2(value, length) {
    return isHexString(value, length);
  }
  function isJsonRpcRequest2(object) {
    return typeof object.method !== "undefined";
  }
  function isJsonRpcResponseSuccess(object) {
    return typeof object.result !== "undefined";
  }
  function isJsonRpcResponseError(object) {
    return typeof object.error !== "undefined";
  }
  function isInternalEvent(object) {
    return typeof object.event !== "undefined";
  }
  function isReservedEvent(event) {
    return reservedEvents.includes(event) || event.startsWith("wc_");
  }
  function isSilentPayload(request) {
    if (request.method.startsWith("wc_")) {
      return true;
    }
    if (signingMethods.includes(request.method)) {
      return false;
    }
    return true;
  }
  var init_validators2 = __esm({
    "node_modules/@walletconnect/utils/dist/esm/validators.js"() {
      init_polyfills();
      init_esm3();
      init_constants();
    }
  });

  // node_modules/@walletconnect/utils/dist/esm/ethereum.js
  function toChecksumAddress(address) {
    address = removeHexPrefix(address.toLowerCase());
    const hash = removeHexPrefix((0, import_js_sha3.keccak_256)(convertUtf8ToBuffer(address)));
    let checksum = "";
    for (let i2 = 0; i2 < address.length; i2++) {
      if (parseInt(hash[i2], 16) > 7) {
        checksum += address[i2].toUpperCase();
      } else {
        checksum += address[i2];
      }
    }
    return addHexPrefix(checksum);
  }
  function parsePersonalSign(params) {
    if (!isEmptyArray(params) && !isHexString2(params[0])) {
      params[0] = convertUtf8ToHex(params[0]);
    }
    return params;
  }
  function parseTransactionData(txData) {
    if (typeof txData.type !== "undefined" && txData.type !== "0")
      return txData;
    if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
      throw new Error(`Transaction object must include a valid 'from' value.`);
    }
    function parseHexValues(value) {
      let result = value;
      if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
        if (!isHexString2(value)) {
          result = convertNumberToHex(value);
        } else if (typeof value === "string") {
          result = sanitizeHex2(value);
        }
      }
      if (typeof result === "string") {
        result = removeHexLeadingZeros2(result);
      }
      return result;
    }
    const txDataRPC = {
      from: sanitizeHex2(txData.from),
      to: typeof txData.to === "undefined" ? void 0 : sanitizeHex2(txData.to),
      gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
      gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
      value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
      nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
      data: typeof txData.data === "undefined" ? "" : sanitizeHex2(txData.data) || "0x"
    };
    const prunable = ["gasPrice", "gas", "value", "nonce"];
    Object.keys(txDataRPC).forEach((key) => {
      if ((typeof txDataRPC[key] === "undefined" || typeof txDataRPC[key] === "string" && !txDataRPC[key].trim().length) && prunable.includes(key)) {
        delete txDataRPC[key];
      }
    });
    return txDataRPC;
  }
  var import_js_sha3, isValidAddress;
  var init_ethereum = __esm({
    "node_modules/@walletconnect/utils/dist/esm/ethereum.js"() {
      init_polyfills();
      import_js_sha3 = __toESM(require_sha3());
      init_esm3();
      init_encoding();
      init_misc();
      init_validators2();
      isValidAddress = (address) => {
        if (!address) {
          return false;
        } else if (address.toLowerCase().substring(0, 2) !== "0x") {
          return false;
        } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
          return false;
        } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
          return true;
        } else {
          return address === toChecksumAddress(address);
        }
      };
    }
  });

  // node_modules/@walletconnect/utils/dist/esm/payload.js
  function formatRpcError(error) {
    const message = error.message || "Failed or Rejected Request";
    let code = -32e3;
    if (error && !error.code) {
      switch (message) {
        case "Parse error":
          code = -32700;
          break;
        case "Invalid request":
          code = -32600;
          break;
        case "Method not found":
          code = -32601;
          break;
        case "Invalid params":
          code = -32602;
          break;
        case "Internal error":
          code = -32603;
          break;
        default:
          code = -32e3;
          break;
      }
    }
    const result = {
      code,
      message
    };
    if (error.data) {
      result.data = error.data;
    }
    return result;
  }
  var init_payload = __esm({
    "node_modules/@walletconnect/utils/dist/esm/payload.js"() {
      init_polyfills();
    }
  });

  // node_modules/strict-uri-encode/index.js
  var require_strict_uri_encode = __commonJS({
    "node_modules/strict-uri-encode/index.js"(exports, module) {
      "use strict";
      init_polyfills();
      module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x3) => `%${x3.charCodeAt(0).toString(16).toUpperCase()}`);
    }
  });

  // node_modules/decode-uri-component/index.js
  var require_decode_uri_component = __commonJS({
    "node_modules/decode-uri-component/index.js"(exports, module) {
      "use strict";
      init_polyfills();
      var token = "%[a-f0-9]{2}";
      var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
      var multiMatcher = new RegExp("(" + token + ")+", "gi");
      function decodeComponents(components, split) {
        try {
          return [decodeURIComponent(components.join(""))];
        } catch (err) {
        }
        if (components.length === 1) {
          return components;
        }
        split = split || 1;
        var left = components.slice(0, split);
        var right = components.slice(split);
        return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
      }
      function decode3(input) {
        try {
          return decodeURIComponent(input);
        } catch (err) {
          var tokens = input.match(singleMatcher) || [];
          for (var i2 = 1; i2 < tokens.length; i2++) {
            input = decodeComponents(tokens, i2).join("");
            tokens = input.match(singleMatcher) || [];
          }
          return input;
        }
      }
      function customDecodeURIComponent(input) {
        var replaceMap = {
          "%FE%FF": "\uFFFD\uFFFD",
          "%FF%FE": "\uFFFD\uFFFD"
        };
        var match = multiMatcher.exec(input);
        while (match) {
          try {
            replaceMap[match[0]] = decodeURIComponent(match[0]);
          } catch (err) {
            var result = decode3(match[0]);
            if (result !== match[0]) {
              replaceMap[match[0]] = result;
            }
          }
          match = multiMatcher.exec(input);
        }
        replaceMap["%C2"] = "\uFFFD";
        var entries = Object.keys(replaceMap);
        for (var i2 = 0; i2 < entries.length; i2++) {
          var key = entries[i2];
          input = input.replace(new RegExp(key, "g"), replaceMap[key]);
        }
        return input;
      }
      module.exports = function(encodedURI) {
        if (typeof encodedURI !== "string") {
          throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
        }
        try {
          encodedURI = encodedURI.replace(/\+/g, " ");
          return decodeURIComponent(encodedURI);
        } catch (err) {
          return customDecodeURIComponent(encodedURI);
        }
      };
    }
  });

  // node_modules/split-on-first/index.js
  var require_split_on_first = __commonJS({
    "node_modules/split-on-first/index.js"(exports, module) {
      "use strict";
      init_polyfills();
      module.exports = (string, separator) => {
        if (!(typeof string === "string" && typeof separator === "string")) {
          throw new TypeError("Expected the arguments to be of type `string`");
        }
        if (separator === "") {
          return [string];
        }
        const separatorIndex = string.indexOf(separator);
        if (separatorIndex === -1) {
          return [string];
        }
        return [
          string.slice(0, separatorIndex),
          string.slice(separatorIndex + separator.length)
        ];
      };
    }
  });

  // node_modules/query-string/index.js
  var require_query_string = __commonJS({
    "node_modules/query-string/index.js"(exports) {
      "use strict";
      init_polyfills();
      var strictUriEncode = require_strict_uri_encode();
      var decodeComponent = require_decode_uri_component();
      var splitOnFirst = require_split_on_first();
      var isNullOrUndefined = (value) => value === null || value === void 0;
      function encoderForArrayFormat(options) {
        switch (options.arrayFormat) {
          case "index":
            return (key) => (result, value) => {
              const index = result.length;
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode2(key, options), "[", index, "]"].join("")];
              }
              return [
                ...result,
                [encode2(key, options), "[", encode2(index, options), "]=", encode2(value, options)].join("")
              ];
            };
          case "bracket":
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode2(key, options), "[]"].join("")];
              }
              return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
            };
          case "comma":
          case "separator":
            return (key) => (result, value) => {
              if (value === null || value === void 0 || value.length === 0) {
                return result;
              }
              if (result.length === 0) {
                return [[encode2(key, options), "=", encode2(value, options)].join("")];
              }
              return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
            };
          default:
            return (key) => (result, value) => {
              if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, encode2(key, options)];
              }
              return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
            };
        }
      }
      function parserForArrayFormat(options) {
        let result;
        switch (options.arrayFormat) {
          case "index":
            return (key, value, accumulator) => {
              result = /\[(\d*)\]$/.exec(key);
              key = key.replace(/\[\d*\]$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = {};
              }
              accumulator[key][result[1]] = value;
            };
          case "bracket":
            return (key, value, accumulator) => {
              result = /(\[\])$/.exec(key);
              key = key.replace(/\[\]$/, "");
              if (!result) {
                accumulator[key] = value;
                return;
              }
              if (accumulator[key] === void 0) {
                accumulator[key] = [value];
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
          case "comma":
          case "separator":
            return (key, value, accumulator) => {
              const isArray = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
              const newValue = isArray ? value.split(options.arrayFormatSeparator).map((item) => decode3(item, options)) : value === null ? value : decode3(value, options);
              accumulator[key] = newValue;
            };
          default:
            return (key, value, accumulator) => {
              if (accumulator[key] === void 0) {
                accumulator[key] = value;
                return;
              }
              accumulator[key] = [].concat(accumulator[key], value);
            };
        }
      }
      function validateArrayFormatSeparator(value) {
        if (typeof value !== "string" || value.length !== 1) {
          throw new TypeError("arrayFormatSeparator must be single character string");
        }
      }
      function encode2(value, options) {
        if (options.encode) {
          return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
        }
        return value;
      }
      function decode3(value, options) {
        if (options.decode) {
          return decodeComponent(value);
        }
        return value;
      }
      function keysSorter(input) {
        if (Array.isArray(input)) {
          return input.sort();
        }
        if (typeof input === "object") {
          return keysSorter(Object.keys(input)).sort((a2, b3) => Number(a2) - Number(b3)).map((key) => input[key]);
        }
        return input;
      }
      function removeHash(input) {
        const hashStart = input.indexOf("#");
        if (hashStart !== -1) {
          input = input.slice(0, hashStart);
        }
        return input;
      }
      function getHash(url) {
        let hash = "";
        const hashStart = url.indexOf("#");
        if (hashStart !== -1) {
          hash = url.slice(hashStart);
        }
        return hash;
      }
      function extract(input) {
        input = removeHash(input);
        const queryStart = input.indexOf("?");
        if (queryStart === -1) {
          return "";
        }
        return input.slice(queryStart + 1);
      }
      function parseValue(value, options) {
        if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
          value = Number(value);
        } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
          value = value.toLowerCase() === "true";
        }
        return value;
      }
      function parse2(input, options) {
        options = Object.assign({
          decode: true,
          sort: true,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
          parseNumbers: false,
          parseBooleans: false
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const formatter = parserForArrayFormat(options);
        const ret = /* @__PURE__ */ Object.create(null);
        if (typeof input !== "string") {
          return ret;
        }
        input = input.trim().replace(/^[?#&]/, "");
        if (!input) {
          return ret;
        }
        for (const param of input.split("&")) {
          let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
          value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode3(value, options);
          formatter(decode3(key, options), value, ret);
        }
        for (const key of Object.keys(ret)) {
          const value = ret[key];
          if (typeof value === "object" && value !== null) {
            for (const k3 of Object.keys(value)) {
              value[k3] = parseValue(value[k3], options);
            }
          } else {
            ret[key] = parseValue(value, options);
          }
        }
        if (options.sort === false) {
          return ret;
        }
        return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
          const value = ret[key];
          if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
            result[key] = keysSorter(value);
          } else {
            result[key] = value;
          }
          return result;
        }, /* @__PURE__ */ Object.create(null));
      }
      exports.extract = extract;
      exports.parse = parse2;
      exports.stringify = (object, options) => {
        if (!object) {
          return "";
        }
        options = Object.assign({
          encode: true,
          strict: true,
          arrayFormat: "none",
          arrayFormatSeparator: ","
        }, options);
        validateArrayFormatSeparator(options.arrayFormatSeparator);
        const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
        const formatter = encoderForArrayFormat(options);
        const objectCopy = {};
        for (const key of Object.keys(object)) {
          if (!shouldFilter(key)) {
            objectCopy[key] = object[key];
          }
        }
        const keys = Object.keys(objectCopy);
        if (options.sort !== false) {
          keys.sort(options.sort);
        }
        return keys.map((key) => {
          const value = object[key];
          if (value === void 0) {
            return "";
          }
          if (value === null) {
            return encode2(key, options);
          }
          if (Array.isArray(value)) {
            return value.reduce(formatter(key), []).join("&");
          }
          return encode2(key, options) + "=" + encode2(value, options);
        }).filter((x3) => x3.length > 0).join("&");
      };
      exports.parseUrl = (input, options) => {
        options = Object.assign({
          decode: true
        }, options);
        const [url, hash] = splitOnFirst(input, "#");
        return Object.assign(
          {
            url: url.split("?")[0] || "",
            query: parse2(extract(input), options)
          },
          options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode3(hash, options) } : {}
        );
      };
      exports.stringifyUrl = (input, options) => {
        options = Object.assign({
          encode: true,
          strict: true
        }, options);
        const url = removeHash(input.url).split("?")[0] || "";
        const queryFromUrl = exports.extract(input.url);
        const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
        const query = Object.assign(parsedQueryFromUrl, input.query);
        let queryString = exports.stringify(query, options);
        if (queryString) {
          queryString = `?${queryString}`;
        }
        let hash = getHash(input.url);
        if (input.fragmentIdentifier) {
          hash = `#${encode2(input.fragmentIdentifier, options)}`;
        }
        return `${url}${queryString}${hash}`;
      };
    }
  });

  // node_modules/@walletconnect/utils/dist/esm/url.js
  function getQueryString(url) {
    const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
    const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
    return queryString;
  }
  function appendToQueryString(queryString, newQueryParams) {
    let queryParams = parseQueryString(queryString);
    queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
    queryString = formatQueryString(queryParams);
    return queryString;
  }
  function parseQueryString(queryString) {
    return queryStringUtils.parse(queryString);
  }
  function formatQueryString(queryParams) {
    return queryStringUtils.stringify(queryParams);
  }
  var queryStringUtils;
  var init_url2 = __esm({
    "node_modules/@walletconnect/utils/dist/esm/url.js"() {
      init_polyfills();
      queryStringUtils = __toESM(require_query_string());
    }
  });

  // node_modules/@walletconnect/utils/dist/esm/session.js
  function isWalletConnectSession(object) {
    return typeof object.bridge !== "undefined";
  }
  function parseWalletConnectUri(str) {
    const pathStart = str.indexOf(":");
    const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
    const protocol = str.substring(0, pathStart);
    const path = str.substring(pathStart + 1, pathEnd);
    function parseRequiredParams(path2) {
      const separator = "@";
      const values = path2.split(separator);
      const requiredParams2 = {
        handshakeTopic: values[0],
        version: parseInt(values[1], 10)
      };
      return requiredParams2;
    }
    const requiredParams = parseRequiredParams(path);
    const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
    function parseQueryParams(queryString2) {
      const result2 = parseQueryString(queryString2);
      const parameters = {
        key: result2.key || "",
        bridge: result2.bridge || ""
      };
      return parameters;
    }
    const queryParams = parseQueryParams(queryString);
    const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
    return result;
  }
  var init_session = __esm({
    "node_modules/@walletconnect/utils/dist/esm/session.js"() {
      init_polyfills();
      init_url2();
    }
  });

  // node_modules/@walletconnect/utils/dist/esm/index.js
  var init_esm5 = __esm({
    "node_modules/@walletconnect/utils/dist/esm/index.js"() {
      init_polyfills();
      init_esm2();
      init_constants();
      init_encoding();
      init_ethereum();
      init_misc();
      init_payload();
      init_session();
      init_url2();
      init_validators2();
    }
  });

  // node_modules/@walletconnect/socket-transport/dist/esm/network.js
  var NetworkMonitor, network_default;
  var init_network = __esm({
    "node_modules/@walletconnect/socket-transport/dist/esm/network.js"() {
      init_polyfills();
      NetworkMonitor = class {
        constructor() {
          this._eventEmitters = [];
          if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
            window.addEventListener("online", () => this.trigger("online"));
            window.addEventListener("offline", () => this.trigger("offline"));
          }
        }
        on(event, callback) {
          this._eventEmitters.push({
            event,
            callback
          });
        }
        trigger(event) {
          let eventEmitters = [];
          if (event) {
            eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
          }
          eventEmitters.forEach((eventEmitter) => {
            eventEmitter.callback();
          });
        }
      };
      network_default = NetworkMonitor;
    }
  });

  // node_modules/ws/browser.js
  var require_browser = __commonJS({
    "node_modules/ws/browser.js"(exports, module) {
      "use strict";
      init_polyfills();
      module.exports = function() {
        throw new Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      };
    }
  });

  // node_modules/@walletconnect/socket-transport/dist/esm/index.js
  function getWebSocketUrl(_url, protocol, version) {
    var _a, _b;
    const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
    const splitUrl = url.split("?");
    const params = isBrowser() ? {
      protocol,
      version,
      env: "browser",
      host: ((_a = getLocation2()) === null || _a === void 0 ? void 0 : _a.host) || ""
    } : {
      protocol,
      version,
      env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
    };
    const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
    return splitUrl[0] + "?" + queryString;
  }
  var WS, SocketTransport, esm_default;
  var init_esm6 = __esm({
    "node_modules/@walletconnect/socket-transport/dist/esm/index.js"() {
      init_polyfills();
      init_esm5();
      init_network();
      WS = typeof global.WebSocket !== "undefined" ? global.WebSocket : require_browser();
      SocketTransport = class {
        constructor(opts) {
          this.opts = opts;
          this._queue = [];
          this._events = [];
          this._subscriptions = [];
          this._protocol = opts.protocol;
          this._version = opts.version;
          this._url = "";
          this._netMonitor = null;
          this._socket = null;
          this._nextSocket = null;
          this._subscriptions = opts.subscriptions || [];
          this._netMonitor = opts.netMonitor || new network_default();
          if (!opts.url || typeof opts.url !== "string") {
            throw new Error("Missing or invalid WebSocket url");
          }
          this._url = opts.url;
          this._netMonitor.on("online", () => this._socketCreate());
        }
        set readyState(value) {
        }
        get readyState() {
          return this._socket ? this._socket.readyState : -1;
        }
        set connecting(value) {
        }
        get connecting() {
          return this.readyState === 0;
        }
        set connected(value) {
        }
        get connected() {
          return this.readyState === 1;
        }
        set closing(value) {
        }
        get closing() {
          return this.readyState === 2;
        }
        set closed(value) {
        }
        get closed() {
          return this.readyState === 3;
        }
        open() {
          this._socketCreate();
        }
        close() {
          this._socketClose();
        }
        send(message, topic, silent) {
          if (!topic || typeof topic !== "string") {
            throw new Error("Missing or invalid topic field");
          }
          this._socketSend({
            topic,
            type: "pub",
            payload: message,
            silent: !!silent
          });
        }
        subscribe(topic) {
          this._socketSend({
            topic,
            type: "sub",
            payload: "",
            silent: true
          });
        }
        on(event, callback) {
          this._events.push({ event, callback });
        }
        _socketCreate() {
          if (this._nextSocket) {
            return;
          }
          const url = getWebSocketUrl(this._url, this._protocol, this._version);
          this._nextSocket = new WS(url);
          if (!this._nextSocket) {
            throw new Error("Failed to create socket");
          }
          this._nextSocket.onmessage = (event) => this._socketReceive(event);
          this._nextSocket.onopen = () => this._socketOpen();
          this._nextSocket.onerror = (event) => this._socketError(event);
          this._nextSocket.onclose = () => {
            setTimeout(() => {
              this._nextSocket = null;
              this._socketCreate();
            }, 1e3);
          };
        }
        _socketOpen() {
          this._socketClose();
          this._socket = this._nextSocket;
          this._nextSocket = null;
          this._queueSubscriptions();
          this._pushQueue();
        }
        _socketClose() {
          if (this._socket) {
            this._socket.onclose = () => {
            };
            this._socket.close();
          }
        }
        _socketSend(socketMessage) {
          const message = JSON.stringify(socketMessage);
          if (this._socket && this._socket.readyState === 1) {
            this._socket.send(message);
          } else {
            this._setToQueue(socketMessage);
            this._socketCreate();
          }
        }
        async _socketReceive(event) {
          let socketMessage;
          try {
            socketMessage = JSON.parse(event.data);
          } catch (error) {
            return;
          }
          this._socketSend({
            topic: socketMessage.topic,
            type: "ack",
            payload: "",
            silent: true
          });
          if (this._socket && this._socket.readyState === 1) {
            const events = this._events.filter((event2) => event2.event === "message");
            if (events && events.length) {
              events.forEach((event2) => event2.callback(socketMessage));
            }
          }
        }
        _socketError(e2) {
          const events = this._events.filter((event) => event.event === "error");
          if (events && events.length) {
            events.forEach((event) => event.callback(e2));
          }
        }
        _queueSubscriptions() {
          const subscriptions = this._subscriptions;
          subscriptions.forEach((topic) => this._queue.push({
            topic,
            type: "sub",
            payload: "",
            silent: true
          }));
          this._subscriptions = this.opts.subscriptions || [];
        }
        _setToQueue(socketMessage) {
          this._queue.push(socketMessage);
        }
        _pushQueue() {
          const queue = this._queue;
          queue.forEach((socketMessage) => this._socketSend(socketMessage));
          this._queue = [];
        }
      };
      esm_default = SocketTransport;
    }
  });

  // node_modules/@walletconnect/core/dist/esm/errors.js
  var ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_MISSING_REQUIRED, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED;
  var init_errors = __esm({
    "node_modules/@walletconnect/core/dist/esm/errors.js"() {
      init_polyfills();
      ERROR_SESSION_CONNECTED = "Session currently connected";
      ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
      ERROR_SESSION_REJECTED = "Session Rejected";
      ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
      ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
      ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
      ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
      ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
      ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
      ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
      ERROR_INVALID_URI = "URI format is invalid";
      ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
      ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";
    }
  });

  // node_modules/@walletconnect/core/dist/esm/events.js
  var EventManager, events_default;
  var init_events = __esm({
    "node_modules/@walletconnect/core/dist/esm/events.js"() {
      init_polyfills();
      init_esm5();
      EventManager = class {
        constructor() {
          this._eventEmitters = [];
        }
        subscribe(eventEmitter) {
          this._eventEmitters.push(eventEmitter);
        }
        unsubscribe(event) {
          this._eventEmitters = this._eventEmitters.filter((x3) => x3.event !== event);
        }
        trigger(payload) {
          let eventEmitters = [];
          let event;
          if (isJsonRpcRequest2(payload)) {
            event = payload.method;
          } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
            event = `response:${payload.id}`;
          } else if (isInternalEvent(payload)) {
            event = payload.event;
          } else {
            event = "";
          }
          if (event) {
            eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
          }
          if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
            eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
          }
          eventEmitters.forEach((eventEmitter) => {
            if (isJsonRpcResponseError(payload)) {
              const error = new Error(payload.error.message);
              eventEmitter.callback(error, null);
            } else {
              eventEmitter.callback(null, payload);
            }
          });
        }
      };
      events_default = EventManager;
    }
  });

  // node_modules/@walletconnect/core/dist/esm/storage.js
  var SessionStorage, storage_default;
  var init_storage = __esm({
    "node_modules/@walletconnect/core/dist/esm/storage.js"() {
      init_polyfills();
      init_esm5();
      SessionStorage = class {
        constructor(storageId = "walletconnect") {
          this.storageId = storageId;
        }
        getSession() {
          let session = null;
          const json = getLocal(this.storageId);
          if (json && isWalletConnectSession(json)) {
            session = json;
          }
          return session;
        }
        setSession(session) {
          setLocal(this.storageId, session);
          return session;
        }
        removeSession() {
          removeLocal(this.storageId);
        }
      };
      storage_default = SessionStorage;
    }
  });

  // node_modules/@walletconnect/core/dist/esm/url.js
  function extractHostname(url) {
    let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
    hostname = hostname.split(":")[0];
    hostname = hostname.split("?")[0];
    return hostname;
  }
  function extractRootDomain(url) {
    return extractHostname(url).split(".").slice(-2).join(".");
  }
  function randomBridgeIndex() {
    return Math.floor(Math.random() * bridges.length);
  }
  function selectRandomBridgeUrl() {
    return bridges[randomBridgeIndex()];
  }
  function shouldSelectRandomly(url) {
    return extractRootDomain(url) === domain;
  }
  function getBridgeUrl(url) {
    if (shouldSelectRandomly(url)) {
      return selectRandomBridgeUrl();
    }
    return url;
  }
  var domain, alphanumerical, bridges;
  var init_url3 = __esm({
    "node_modules/@walletconnect/core/dist/esm/url.js"() {
      init_polyfills();
      domain = "walletconnect.org";
      alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
      bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
    }
  });

  // node_modules/@walletconnect/core/dist/esm/index.js
  var Connector, esm_default2;
  var init_esm7 = __esm({
    "node_modules/@walletconnect/core/dist/esm/index.js"() {
      init_polyfills();
      init_esm5();
      init_esm6();
      init_errors();
      init_events();
      init_storage();
      init_url3();
      Connector = class {
        constructor(opts) {
          this.protocol = "wc";
          this.version = 1;
          this._bridge = "";
          this._key = null;
          this._clientId = "";
          this._clientMeta = null;
          this._peerId = "";
          this._peerMeta = null;
          this._handshakeId = 0;
          this._handshakeTopic = "";
          this._connected = false;
          this._accounts = [];
          this._chainId = 0;
          this._networkId = 0;
          this._rpcUrl = "";
          this._eventManager = new events_default();
          this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
          this._cryptoLib = opts.cryptoLib;
          this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
          this._qrcodeModal = opts.connectorOpts.qrcodeModal;
          this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
          this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
          if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
            throw new Error(ERROR_MISSING_REQUIRED);
          }
          if (opts.connectorOpts.bridge) {
            this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
          }
          if (opts.connectorOpts.uri) {
            this.uri = opts.connectorOpts.uri;
          }
          const session = opts.connectorOpts.session || this._getStorageSession();
          if (session) {
            this.session = session;
          }
          if (this.handshakeId) {
            this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
          }
          this._transport = opts.transport || new esm_default({
            protocol: this.protocol,
            version: this.version,
            url: this.bridge,
            subscriptions: [this.clientId]
          });
          this._subscribeToInternalEvents();
          this._initTransport();
          if (opts.connectorOpts.uri) {
            this._subscribeToSessionRequest();
          }
          if (opts.pushServerOpts) {
            this._registerPushServer(opts.pushServerOpts);
          }
        }
        set bridge(value) {
          if (!value) {
            return;
          }
          this._bridge = value;
        }
        get bridge() {
          return this._bridge;
        }
        set key(value) {
          if (!value) {
            return;
          }
          const key = convertHexToArrayBuffer(value);
          this._key = key;
        }
        get key() {
          if (this._key) {
            const key = convertArrayBufferToHex(this._key, true);
            return key;
          }
          return "";
        }
        set clientId(value) {
          if (!value) {
            return;
          }
          this._clientId = value;
        }
        get clientId() {
          let clientId = this._clientId;
          if (!clientId) {
            clientId = this._clientId = uuid();
          }
          return this._clientId;
        }
        set peerId(value) {
          if (!value) {
            return;
          }
          this._peerId = value;
        }
        get peerId() {
          return this._peerId;
        }
        set clientMeta(value) {
        }
        get clientMeta() {
          let clientMeta = this._clientMeta;
          if (!clientMeta) {
            clientMeta = this._clientMeta = getClientMeta();
          }
          return clientMeta;
        }
        set peerMeta(value) {
          this._peerMeta = value;
        }
        get peerMeta() {
          const peerMeta = this._peerMeta;
          return peerMeta;
        }
        set handshakeTopic(value) {
          if (!value) {
            return;
          }
          this._handshakeTopic = value;
        }
        get handshakeTopic() {
          return this._handshakeTopic;
        }
        set handshakeId(value) {
          if (!value) {
            return;
          }
          this._handshakeId = value;
        }
        get handshakeId() {
          return this._handshakeId;
        }
        get uri() {
          const _uri = this._formatUri();
          return _uri;
        }
        set uri(value) {
          if (!value) {
            return;
          }
          const { handshakeTopic, bridge, key } = this._parseUri(value);
          this.handshakeTopic = handshakeTopic;
          this.bridge = bridge;
          this.key = key;
        }
        set chainId(value) {
          this._chainId = value;
        }
        get chainId() {
          const chainId = this._chainId;
          return chainId;
        }
        set networkId(value) {
          this._networkId = value;
        }
        get networkId() {
          const networkId = this._networkId;
          return networkId;
        }
        set accounts(value) {
          this._accounts = value;
        }
        get accounts() {
          const accounts = this._accounts;
          return accounts;
        }
        set rpcUrl(value) {
          this._rpcUrl = value;
        }
        get rpcUrl() {
          const rpcUrl = this._rpcUrl;
          return rpcUrl;
        }
        set connected(value) {
        }
        get connected() {
          return this._connected;
        }
        set pending(value) {
        }
        get pending() {
          return !!this._handshakeTopic;
        }
        get session() {
          return {
            connected: this.connected,
            accounts: this.accounts,
            chainId: this.chainId,
            bridge: this.bridge,
            key: this.key,
            clientId: this.clientId,
            clientMeta: this.clientMeta,
            peerId: this.peerId,
            peerMeta: this.peerMeta,
            handshakeId: this.handshakeId,
            handshakeTopic: this.handshakeTopic
          };
        }
        set session(value) {
          if (!value) {
            return;
          }
          this._connected = value.connected;
          this.accounts = value.accounts;
          this.chainId = value.chainId;
          this.bridge = value.bridge;
          this.key = value.key;
          this.clientId = value.clientId;
          this.clientMeta = value.clientMeta;
          this.peerId = value.peerId;
          this.peerMeta = value.peerMeta;
          this.handshakeId = value.handshakeId;
          this.handshakeTopic = value.handshakeTopic;
        }
        on(event, callback) {
          const eventEmitter = {
            event,
            callback
          };
          this._eventManager.subscribe(eventEmitter);
        }
        off(event) {
          this._eventManager.unsubscribe(event);
        }
        async createInstantRequest(instantRequest) {
          this._key = await this._generateKey();
          const request = this._formatRequest({
            method: "wc_instantRequest",
            params: [
              {
                peerId: this.clientId,
                peerMeta: this.clientMeta,
                request: this._formatRequest(instantRequest)
              }
            ]
          });
          this.handshakeId = request.id;
          this.handshakeTopic = uuid();
          this._eventManager.trigger({
            event: "display_uri",
            params: [this.uri]
          });
          this.on("modal_closed", () => {
            throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
          });
          const endInstantRequest = () => {
            this.killSession();
          };
          try {
            const result = await this._sendCallRequest(request);
            if (result) {
              endInstantRequest();
            }
            return result;
          } catch (error) {
            endInstantRequest();
            throw error;
          }
        }
        async connect(opts) {
          if (!this._qrcodeModal) {
            throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
          }
          if (this.connected) {
            return {
              chainId: this.chainId,
              accounts: this.accounts
            };
          }
          await this.createSession(opts);
          return new Promise(async (resolve, reject) => {
            this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
            this.on("connect", (error, payload) => {
              if (error) {
                return reject(error);
              }
              resolve(payload.params[0]);
            });
          });
        }
        async createSession(opts) {
          if (this._connected) {
            throw new Error(ERROR_SESSION_CONNECTED);
          }
          if (this.pending) {
            return;
          }
          this._key = await this._generateKey();
          const request = this._formatRequest({
            method: "wc_sessionRequest",
            params: [
              {
                peerId: this.clientId,
                peerMeta: this.clientMeta,
                chainId: opts && opts.chainId ? opts.chainId : null
              }
            ]
          });
          this.handshakeId = request.id;
          this.handshakeTopic = uuid();
          this._sendSessionRequest(request, "Session update rejected", {
            topic: this.handshakeTopic
          });
          this._eventManager.trigger({
            event: "display_uri",
            params: [this.uri]
          });
        }
        approveSession(sessionStatus) {
          if (this._connected) {
            throw new Error(ERROR_SESSION_CONNECTED);
          }
          this.chainId = sessionStatus.chainId;
          this.accounts = sessionStatus.accounts;
          this.networkId = sessionStatus.networkId || 0;
          this.rpcUrl = sessionStatus.rpcUrl || "";
          const sessionParams = {
            approved: true,
            chainId: this.chainId,
            networkId: this.networkId,
            accounts: this.accounts,
            rpcUrl: this.rpcUrl,
            peerId: this.clientId,
            peerMeta: this.clientMeta
          };
          const response = {
            id: this.handshakeId,
            jsonrpc: "2.0",
            result: sessionParams
          };
          this._sendResponse(response);
          this._connected = true;
          this._setStorageSession();
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        rejectSession(sessionError) {
          if (this._connected) {
            throw new Error(ERROR_SESSION_CONNECTED);
          }
          const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
          const response = this._formatResponse({
            id: this.handshakeId,
            error: { message }
          });
          this._sendResponse(response);
          this._connected = false;
          this._eventManager.trigger({
            event: "disconnect",
            params: [{ message }]
          });
          this._removeStorageSession();
        }
        updateSession(sessionStatus) {
          if (!this._connected) {
            throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          this.chainId = sessionStatus.chainId;
          this.accounts = sessionStatus.accounts;
          this.networkId = sessionStatus.networkId || 0;
          this.rpcUrl = sessionStatus.rpcUrl || "";
          const sessionParams = {
            approved: true,
            chainId: this.chainId,
            networkId: this.networkId,
            accounts: this.accounts,
            rpcUrl: this.rpcUrl
          };
          const request = this._formatRequest({
            method: "wc_sessionUpdate",
            params: [sessionParams]
          });
          this._sendSessionRequest(request, "Session update rejected");
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
          this._manageStorageSession();
        }
        async killSession(sessionError) {
          const message = sessionError ? sessionError.message : "Session Disconnected";
          const sessionParams = {
            approved: false,
            chainId: null,
            networkId: null,
            accounts: null
          };
          const request = this._formatRequest({
            method: "wc_sessionUpdate",
            params: [sessionParams]
          });
          await this._sendRequest(request);
          this._handleSessionDisconnect(message);
        }
        async sendTransaction(tx) {
          if (!this._connected) {
            throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          const parsedTx = parseTransactionData(tx);
          const request = this._formatRequest({
            method: "eth_sendTransaction",
            params: [parsedTx]
          });
          const result = await this._sendCallRequest(request);
          return result;
        }
        async signTransaction(tx) {
          if (!this._connected) {
            throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          const parsedTx = parseTransactionData(tx);
          const request = this._formatRequest({
            method: "eth_signTransaction",
            params: [parsedTx]
          });
          const result = await this._sendCallRequest(request);
          return result;
        }
        async signMessage(params) {
          if (!this._connected) {
            throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          const request = this._formatRequest({
            method: "eth_sign",
            params
          });
          const result = await this._sendCallRequest(request);
          return result;
        }
        async signPersonalMessage(params) {
          if (!this._connected) {
            throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          params = parsePersonalSign(params);
          const request = this._formatRequest({
            method: "personal_sign",
            params
          });
          const result = await this._sendCallRequest(request);
          return result;
        }
        async signTypedData(params) {
          if (!this._connected) {
            throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          const request = this._formatRequest({
            method: "eth_signTypedData",
            params
          });
          const result = await this._sendCallRequest(request);
          return result;
        }
        async updateChain(chainParams) {
          if (!this._connected) {
            throw new Error("Session currently disconnected");
          }
          const request = this._formatRequest({
            method: "wallet_updateChain",
            params: [chainParams]
          });
          const result = await this._sendCallRequest(request);
          return result;
        }
        unsafeSend(request, options) {
          this._sendRequest(request, options);
          this._eventManager.trigger({
            event: "call_request_sent",
            params: [{ request, options }]
          });
          return new Promise((resolve, reject) => {
            this._subscribeToResponse(request.id, (error, payload) => {
              if (error) {
                reject(error);
                return;
              }
              if (!payload) {
                throw new Error(ERROR_MISSING_JSON_RPC);
              }
              resolve(payload);
            });
          });
        }
        async sendCustomRequest(request, options) {
          if (!this._connected) {
            throw new Error(ERROR_SESSION_DISCONNECTED);
          }
          switch (request.method) {
            case "eth_accounts":
              return this.accounts;
            case "eth_chainId":
              return convertNumberToHex(this.chainId);
            case "eth_sendTransaction":
            case "eth_signTransaction":
              if (request.params) {
                request.params[0] = parseTransactionData(request.params[0]);
              }
              break;
            case "personal_sign":
              if (request.params) {
                request.params = parsePersonalSign(request.params);
              }
              break;
            default:
              break;
          }
          const formattedRequest = this._formatRequest(request);
          const result = await this._sendCallRequest(formattedRequest, options);
          return result;
        }
        approveRequest(response) {
          if (isJsonRpcResponseSuccess(response)) {
            const formattedResponse = this._formatResponse(response);
            this._sendResponse(formattedResponse);
          } else {
            throw new Error(ERROR_MISSING_RESULT);
          }
        }
        rejectRequest(response) {
          if (isJsonRpcResponseError(response)) {
            const formattedResponse = this._formatResponse(response);
            this._sendResponse(formattedResponse);
          } else {
            throw new Error(ERROR_MISSING_ERROR);
          }
        }
        transportClose() {
          this._transport.close();
        }
        async _sendRequest(request, options) {
          const callRequest = this._formatRequest(request);
          const encryptionPayload = await this._encrypt(callRequest);
          const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
          const payload = JSON.stringify(encryptionPayload);
          const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
          this._transport.send(payload, topic, silent);
        }
        async _sendResponse(response) {
          const encryptionPayload = await this._encrypt(response);
          const topic = this.peerId;
          const payload = JSON.stringify(encryptionPayload);
          const silent = true;
          this._transport.send(payload, topic, silent);
        }
        async _sendSessionRequest(request, errorMsg, options) {
          this._sendRequest(request, options);
          this._subscribeToSessionResponse(request.id, errorMsg);
        }
        _sendCallRequest(request, options) {
          this._sendRequest(request, options);
          this._eventManager.trigger({
            event: "call_request_sent",
            params: [{ request, options }]
          });
          return this._subscribeToCallResponse(request.id);
        }
        _formatRequest(request) {
          if (typeof request.method === "undefined") {
            throw new Error(ERROR_MISSING_METHOD);
          }
          const formattedRequest = {
            id: typeof request.id === "undefined" ? payloadId2() : request.id,
            jsonrpc: "2.0",
            method: request.method,
            params: typeof request.params === "undefined" ? [] : request.params
          };
          return formattedRequest;
        }
        _formatResponse(response) {
          if (typeof response.id === "undefined") {
            throw new Error(ERROR_MISSING_ID);
          }
          const baseResponse = { id: response.id, jsonrpc: "2.0" };
          if (isJsonRpcResponseError(response)) {
            const error = formatRpcError(response.error);
            const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
            return errorResponse;
          } else if (isJsonRpcResponseSuccess(response)) {
            const successResponse = Object.assign(Object.assign({}, baseResponse), response);
            return successResponse;
          }
          throw new Error(ERROR_INVALID_RESPONSE);
        }
        _handleSessionDisconnect(errorMsg) {
          const message = errorMsg || "Session Disconnected";
          if (!this._connected) {
            if (this._qrcodeModal) {
              this._qrcodeModal.close();
            }
            removeLocal(mobileLinkChoiceKey);
          }
          if (this._connected) {
            this._connected = false;
          }
          if (this._handshakeId) {
            this._handshakeId = 0;
          }
          if (this._handshakeTopic) {
            this._handshakeTopic = "";
          }
          if (this._peerId) {
            this._peerId = "";
          }
          this._eventManager.trigger({
            event: "disconnect",
            params: [{ message }]
          });
          this._removeStorageSession();
          this.transportClose();
        }
        _handleSessionResponse(errorMsg, sessionParams) {
          if (sessionParams) {
            if (sessionParams.approved) {
              if (!this._connected) {
                this._connected = true;
                if (sessionParams.chainId) {
                  this.chainId = sessionParams.chainId;
                }
                if (sessionParams.accounts) {
                  this.accounts = sessionParams.accounts;
                }
                if (sessionParams.peerId && !this.peerId) {
                  this.peerId = sessionParams.peerId;
                }
                if (sessionParams.peerMeta && !this.peerMeta) {
                  this.peerMeta = sessionParams.peerMeta;
                }
                this._eventManager.trigger({
                  event: "connect",
                  params: [
                    {
                      peerId: this.peerId,
                      peerMeta: this.peerMeta,
                      chainId: this.chainId,
                      accounts: this.accounts
                    }
                  ]
                });
              } else {
                if (sessionParams.chainId) {
                  this.chainId = sessionParams.chainId;
                }
                if (sessionParams.accounts) {
                  this.accounts = sessionParams.accounts;
                }
                this._eventManager.trigger({
                  event: "session_update",
                  params: [
                    {
                      chainId: this.chainId,
                      accounts: this.accounts
                    }
                  ]
                });
              }
              this._manageStorageSession();
            } else {
              this._handleSessionDisconnect(errorMsg);
            }
          } else {
            this._handleSessionDisconnect(errorMsg);
          }
        }
        async _handleIncomingMessages(socketMessage) {
          const activeTopics = [this.clientId, this.handshakeTopic];
          if (!activeTopics.includes(socketMessage.topic)) {
            return;
          }
          let encryptionPayload;
          try {
            encryptionPayload = JSON.parse(socketMessage.payload);
          } catch (error) {
            return;
          }
          const payload = await this._decrypt(encryptionPayload);
          if (payload) {
            this._eventManager.trigger(payload);
          }
        }
        _subscribeToSessionRequest() {
          this._transport.subscribe(this.handshakeTopic);
        }
        _subscribeToResponse(id, callback) {
          this.on(`response:${id}`, callback);
        }
        _subscribeToSessionResponse(id, errorMsg) {
          this._subscribeToResponse(id, (error, payload) => {
            if (error) {
              this._handleSessionResponse(error.message);
              return;
            }
            if (isJsonRpcResponseSuccess(payload)) {
              this._handleSessionResponse(errorMsg, payload.result);
            } else if (payload.error && payload.error.message) {
              this._handleSessionResponse(payload.error.message);
            } else {
              this._handleSessionResponse(errorMsg);
            }
          });
        }
        _subscribeToCallResponse(id) {
          return new Promise((resolve, reject) => {
            this._subscribeToResponse(id, (error, payload) => {
              if (error) {
                reject(error);
                return;
              }
              if (isJsonRpcResponseSuccess(payload)) {
                resolve(payload.result);
              } else if (payload.error && payload.error.message) {
                reject(payload.error);
              } else {
                reject(new Error(ERROR_INVALID_RESPONSE));
              }
            });
          });
        }
        _subscribeToInternalEvents() {
          this.on("display_uri", () => {
            if (this._qrcodeModal) {
              this._qrcodeModal.open(this.uri, () => {
                this._eventManager.trigger({
                  event: "modal_closed",
                  params: []
                });
              }, this._qrcodeModalOptions);
            }
          });
          this.on("connect", () => {
            if (this._qrcodeModal) {
              this._qrcodeModal.close();
            }
          });
          this.on("call_request_sent", (error, payload) => {
            const { request } = payload.params[0];
            if (isMobile() && this._signingMethods.includes(request.method)) {
              const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
              if (mobileLinkUrl) {
                window.location.href = mobileLinkUrl.href;
              }
            }
          });
          this.on("wc_sessionRequest", (error, payload) => {
            if (error) {
              this._eventManager.trigger({
                event: "error",
                params: [
                  {
                    code: "SESSION_REQUEST_ERROR",
                    message: error.toString()
                  }
                ]
              });
            }
            this.handshakeId = payload.id;
            this.peerId = payload.params[0].peerId;
            this.peerMeta = payload.params[0].peerMeta;
            const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
            this._eventManager.trigger(internalPayload);
          });
          this.on("wc_sessionUpdate", (error, payload) => {
            if (error) {
              this._handleSessionResponse(error.message);
            }
            this._handleSessionResponse("Session disconnected", payload.params[0]);
          });
        }
        _initTransport() {
          this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
          this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
          this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
          this._transport.on("error", () => this._eventManager.trigger({
            event: "transport_error",
            params: ["Websocket connection failed"]
          }));
          this._transport.open();
        }
        _formatUri() {
          const protocol = this.protocol;
          const handshakeTopic = this.handshakeTopic;
          const version = this.version;
          const bridge = encodeURIComponent(this.bridge);
          const key = this.key;
          const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;
          return uri;
        }
        _parseUri(uri) {
          const result = parseWalletConnectUri(uri);
          if (result.protocol === this.protocol) {
            if (!result.handshakeTopic) {
              throw Error("Invalid or missing handshakeTopic parameter value");
            }
            const handshakeTopic = result.handshakeTopic;
            if (!result.bridge) {
              throw Error("Invalid or missing bridge url parameter value");
            }
            const bridge = decodeURIComponent(result.bridge);
            if (!result.key) {
              throw Error("Invalid or missing key parameter value");
            }
            const key = result.key;
            return { handshakeTopic, bridge, key };
          } else {
            throw new Error(ERROR_INVALID_URI);
          }
        }
        async _generateKey() {
          if (this._cryptoLib) {
            const result = await this._cryptoLib.generateKey();
            return result;
          }
          return null;
        }
        async _encrypt(data) {
          const key = this._key;
          if (this._cryptoLib && key) {
            const result = await this._cryptoLib.encrypt(data, key);
            return result;
          }
          return null;
        }
        async _decrypt(payload) {
          const key = this._key;
          if (this._cryptoLib && key) {
            const result = await this._cryptoLib.decrypt(payload, key);
            return result;
          }
          return null;
        }
        _getStorageSession() {
          let result = null;
          if (this._sessionStorage) {
            result = this._sessionStorage.getSession();
          }
          return result;
        }
        _setStorageSession() {
          if (this._sessionStorage) {
            this._sessionStorage.setSession(this.session);
          }
        }
        _removeStorageSession() {
          if (this._sessionStorage) {
            this._sessionStorage.removeSession();
          }
        }
        _manageStorageSession() {
          if (this._connected) {
            this._setStorageSession();
          } else {
            this._removeStorageSession();
          }
        }
        _registerPushServer(pushServerOpts) {
          if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
            throw Error("Invalid or missing pushServerOpts.url parameter value");
          }
          if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
            throw Error("Invalid or missing pushServerOpts.type parameter value");
          }
          if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
            throw Error("Invalid or missing pushServerOpts.token parameter value");
          }
          const pushSubscription = {
            bridge: this.bridge,
            topic: this.clientId,
            type: pushServerOpts.type,
            token: pushServerOpts.token,
            peerName: "",
            language: pushServerOpts.language || ""
          };
          this.on("connect", async (error, payload) => {
            if (error) {
              throw error;
            }
            if (pushServerOpts.peerMeta) {
              const peerName = payload.params[0].peerMeta.name;
              pushSubscription.peerName = peerName;
            }
            try {
              const response = await fetch(`${pushServerOpts.url}/new`, {
                method: "POST",
                headers: {
                  Accept: "application/json",
                  "Content-Type": "application/json"
                },
                body: JSON.stringify(pushSubscription)
              });
              const json = await response.json();
              if (!json.success) {
                throw Error("Failed to register in Push Server");
              }
            } catch (error2) {
              throw Error("Failed to register in Push Server");
            }
          });
        }
      };
      esm_default2 = Connector;
    }
  });

  // node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
  function randomBytes(length) {
    const browserCrypto = env.getBrowerCrypto();
    return browserCrypto.getRandomValues(new Uint8Array(length));
  }
  var env;
  var init_browser2 = __esm({
    "node_modules/@walletconnect/randombytes/dist/esm/browser/index.js"() {
      init_polyfills();
      env = __toESM(require_cjs3());
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/constants/length.js
  var LENGTH_0, LENGTH_1, LENGTH_16, LENGTH_32, LENGTH_64, LENGTH_128, LENGTH_256, LENGTH_512, LENGTH_1024;
  var init_length = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/constants/length.js"() {
      init_polyfills();
      LENGTH_0 = 0;
      LENGTH_1 = 1;
      LENGTH_16 = 16;
      LENGTH_32 = 32;
      LENGTH_64 = 64;
      LENGTH_128 = 128;
      LENGTH_256 = 256;
      LENGTH_512 = 512;
      LENGTH_1024 = 1024;
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/constants/default.js
  var AES_LENGTH, HMAC_LENGTH, AES_BROWSER_ALGO, HMAC_BROWSER_ALGO, HMAC_BROWSER, SHA256_BROWSER_ALGO, SHA512_BROWSER_ALGO, AES_NODE_ALGO, HMAC_NODE_ALGO, SHA256_NODE_ALGO, SHA512_NODE_ALGO, RIPEMD160_NODE_ALGO, PREFIX_LENGTH, KEY_LENGTH, IV_LENGTH, MAC_LENGTH;
  var init_default = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/constants/default.js"() {
      init_polyfills();
      init_length();
      AES_LENGTH = LENGTH_256;
      HMAC_LENGTH = LENGTH_256;
      AES_BROWSER_ALGO = "AES-CBC";
      HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
      HMAC_BROWSER = "HMAC";
      SHA256_BROWSER_ALGO = "SHA-256";
      SHA512_BROWSER_ALGO = "SHA-512";
      AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
      HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
      SHA256_NODE_ALGO = "sha256";
      SHA512_NODE_ALGO = "sha512";
      RIPEMD160_NODE_ALGO = "ripemd160";
      PREFIX_LENGTH = LENGTH_1;
      KEY_LENGTH = LENGTH_32;
      IV_LENGTH = LENGTH_16;
      MAC_LENGTH = LENGTH_32;
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
  var HEX_ENC, UTF8_ENC;
  var init_encoding2 = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js"() {
      init_polyfills();
      HEX_ENC = "hex";
      UTF8_ENC = "utf8";
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/constants/error.js
  var ERROR_BAD_MAC;
  var init_error2 = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/constants/error.js"() {
      init_polyfills();
      ERROR_BAD_MAC = "Bad MAC";
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
  var ENCRYPT_OP, DECRYPT_OP, SIGN_OP, VERIFY_OP;
  var init_operations = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/constants/operations.js"() {
      init_polyfills();
      ENCRYPT_OP = "encrypt";
      DECRYPT_OP = "decrypt";
      SIGN_OP = "sign";
      VERIFY_OP = "verify";
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/constants/index.js
  var init_constants3 = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/constants/index.js"() {
      init_polyfills();
      init_default();
      init_encoding2();
      init_error2();
      init_length();
      init_operations();
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
  function getAlgo(type) {
    return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
      hash: { name: HMAC_BROWSER_ALGO },
      name: HMAC_BROWSER
    };
  }
  function getOps(type) {
    return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
  }
  async function browserImportKey(buffer, type = AES_BROWSER_ALGO) {
    return env2.getSubtleCrypto().importKey("raw", buffer, getAlgo(type), true, getOps(type));
  }
  async function browserAesEncrypt(iv, key, data) {
    const subtle = env2.getSubtleCrypto();
    const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
    const result = await subtle.encrypt({
      iv,
      name: AES_BROWSER_ALGO
    }, cryptoKey, data);
    return new Uint8Array(result);
  }
  async function browserAesDecrypt(iv, key, data) {
    const subtle = env2.getSubtleCrypto();
    const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
    const result = await subtle.decrypt({
      iv,
      name: AES_BROWSER_ALGO
    }, cryptoKey, data);
    return new Uint8Array(result);
  }
  async function browserHmacSha256Sign(key, data) {
    const subtle = env2.getSubtleCrypto();
    const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
    const signature = await subtle.sign({
      length: HMAC_LENGTH,
      name: HMAC_BROWSER
    }, cryptoKey, data);
    return new Uint8Array(signature);
  }
  async function browserHmacSha512Sign(key, data) {
    const subtle = env2.getSubtleCrypto();
    const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
    const signature = await subtle.sign({
      length: LENGTH_512,
      name: HMAC_BROWSER
    }, cryptoKey, data);
    return new Uint8Array(signature);
  }
  async function browserSha256(data) {
    const subtle = env2.getSubtleCrypto();
    const result = await subtle.digest({
      name: SHA256_BROWSER_ALGO
    }, data);
    return new Uint8Array(result);
  }
  async function browserSha512(data) {
    const subtle = env2.getSubtleCrypto();
    const result = await subtle.digest({
      name: SHA512_BROWSER_ALGO
    }, data);
    return new Uint8Array(result);
  }
  var env2;
  var init_browser3 = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/lib/browser.js"() {
      init_polyfills();
      env2 = __toESM(require_cjs3());
      init_constants3();
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
  function aesCbcEncrypt(iv, key, data) {
    return browserAesEncrypt(iv, key, data);
  }
  function aesCbcDecrypt(iv, key, data) {
    return browserAesDecrypt(iv, key, data);
  }
  var init_aes = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/browser/aes.js"() {
      init_polyfills();
      init_browser3();
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
  var env_exports2 = {};
  var init_env2 = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/helpers/env.js"() {
      init_polyfills();
      __reExport(env_exports2, __toESM(require_cjs3()));
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
  var PADDING, pkcs7;
  var init_pkcs7 = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js"() {
      init_polyfills();
      PADDING = [
        [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
        [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
        [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
        [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
        [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
        [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
        [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
        [9, 9, 9, 9, 9, 9, 9, 9, 9],
        [8, 8, 8, 8, 8, 8, 8, 8],
        [7, 7, 7, 7, 7, 7, 7],
        [6, 6, 6, 6, 6, 6],
        [5, 5, 5, 5, 5],
        [4, 4, 4, 4],
        [3, 3, 3],
        [2, 2],
        [1]
      ];
      pkcs7 = {
        pad(plaintext) {
          const padding = PADDING[plaintext.byteLength % 16 || 0];
          const result = new Uint8Array(plaintext.byteLength + padding.length);
          result.set(plaintext);
          result.set(padding, plaintext.byteLength);
          return result;
        },
        unpad(padded) {
          return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
        }
      };
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/helpers/types.js
  var init_types2 = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/helpers/types.js"() {
      init_polyfills();
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || "Assertion failed");
    }
  }
  function isConstantTime(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      return false;
    }
    let res = 0;
    for (let i2 = 0; i2 < arr1.length; i2++) {
      res |= arr1[i2] ^ arr2[i2];
    }
    return res === 0;
  }
  var init_validators3 = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js"() {
      init_polyfills();
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
  var helpers_exports = {};
  __export(helpers_exports, {
    assert: () => assert,
    isConstantTime: () => isConstantTime,
    pkcs7: () => pkcs7
  });
  var init_helpers = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/helpers/index.js"() {
      init_polyfills();
      init_env2();
      __reExport(helpers_exports, env_exports2);
      init_pkcs7();
      init_types2();
      init_validators3();
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
  async function hmacSha256Sign(key, msg) {
    const result = await browserHmacSha256Sign(key, msg);
    return result;
  }
  async function hmacSha256Verify(key, msg, sig) {
    const expectedSig = await browserHmacSha256Sign(key, msg);
    const result = isConstantTime(expectedSig, sig);
    return result;
  }
  async function hmacSha512Sign(key, msg) {
    const result = await browserHmacSha512Sign(key, msg);
    return result;
  }
  async function hmacSha512Verify(key, msg, sig) {
    const expectedSig = await browserHmacSha512Sign(key, msg);
    const result = isConstantTime(expectedSig, sig);
    return result;
  }
  var init_hmac = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js"() {
      init_polyfills();
      init_browser3();
      init_helpers();
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
  async function sha256(msg) {
    const result = await browserSha256(msg);
    return result;
  }
  async function sha512(msg) {
    const result = await browserSha512(msg);
    return result;
  }
  async function ripemd160(_msg) {
    throw new Error("Not supported for Browser async methods, use sync instead!");
  }
  var init_sha2 = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js"() {
      init_polyfills();
      init_browser3();
    }
  });

  // node_modules/@walletconnect/crypto/dist/esm/browser/index.js
  var browser_exports = {};
  __export(browser_exports, {
    AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
    AES_LENGTH: () => AES_LENGTH,
    AES_NODE_ALGO: () => AES_NODE_ALGO,
    DECRYPT_OP: () => DECRYPT_OP,
    ENCRYPT_OP: () => ENCRYPT_OP,
    ERROR_BAD_MAC: () => ERROR_BAD_MAC,
    HEX_ENC: () => HEX_ENC,
    HMAC_BROWSER: () => HMAC_BROWSER,
    HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
    HMAC_LENGTH: () => HMAC_LENGTH,
    HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
    IV_LENGTH: () => IV_LENGTH,
    KEY_LENGTH: () => KEY_LENGTH,
    LENGTH_0: () => LENGTH_0,
    LENGTH_1: () => LENGTH_1,
    LENGTH_1024: () => LENGTH_1024,
    LENGTH_128: () => LENGTH_128,
    LENGTH_16: () => LENGTH_16,
    LENGTH_256: () => LENGTH_256,
    LENGTH_32: () => LENGTH_32,
    LENGTH_512: () => LENGTH_512,
    LENGTH_64: () => LENGTH_64,
    MAC_LENGTH: () => MAC_LENGTH,
    PREFIX_LENGTH: () => PREFIX_LENGTH,
    RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
    SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
    SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
    SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
    SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
    SIGN_OP: () => SIGN_OP,
    UTF8_ENC: () => UTF8_ENC,
    VERIFY_OP: () => VERIFY_OP,
    aesCbcDecrypt: () => aesCbcDecrypt,
    aesCbcEncrypt: () => aesCbcEncrypt,
    assert: () => assert,
    hmacSha256Sign: () => hmacSha256Sign,
    hmacSha256Verify: () => hmacSha256Verify,
    hmacSha512Sign: () => hmacSha512Sign,
    hmacSha512Verify: () => hmacSha512Verify,
    isConstantTime: () => isConstantTime,
    pkcs7: () => pkcs7,
    randomBytes: () => randomBytes,
    ripemd160: () => ripemd160,
    sha256: () => sha256,
    sha512: () => sha512
  });
  var init_browser4 = __esm({
    "node_modules/@walletconnect/crypto/dist/esm/browser/index.js"() {
      init_polyfills();
      init_browser2();
      init_aes();
      init_hmac();
      init_sha2();
      init_helpers();
      __reExport(browser_exports, helpers_exports);
      init_constants3();
    }
  });

  // node_modules/@walletconnect/iso-crypto/dist/esm/index.js
  var esm_exports4 = {};
  __export(esm_exports4, {
    decrypt: () => decrypt,
    encrypt: () => encrypt,
    generateKey: () => generateKey,
    verifyHmac: () => verifyHmac
  });
  async function generateKey(length) {
    const _length = (length || 256) / 8;
    const bytes = randomBytes(_length);
    const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
    return result;
  }
  async function verifyHmac(payload, key) {
    const cipherText = hexToArray(payload.data);
    const iv = hexToArray(payload.iv);
    const hmac = hexToArray(payload.hmac);
    const hmacHex = arrayToHex(hmac, false);
    const unsigned = concatArrays(cipherText, iv);
    const chmac = await hmacSha256Sign(key, unsigned);
    const chmacHex = arrayToHex(chmac, false);
    if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
      return true;
    }
    return false;
  }
  async function encrypt(data, key, providedIv) {
    const _key = bufferToArray(convertArrayBufferToBuffer(key));
    const ivArrayBuffer = providedIv || await generateKey(128);
    const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
    const ivHex = arrayToHex(iv, false);
    const contentString = JSON.stringify(data);
    const content = utf8ToArray(contentString);
    const cipherText = await aesCbcEncrypt(iv, _key, content);
    const cipherTextHex = arrayToHex(cipherText, false);
    const unsigned = concatArrays(cipherText, iv);
    const hmac = await hmacSha256Sign(_key, unsigned);
    const hmacHex = arrayToHex(hmac, false);
    return {
      data: cipherTextHex,
      hmac: hmacHex,
      iv: ivHex
    };
  }
  async function decrypt(payload, key) {
    const _key = bufferToArray(convertArrayBufferToBuffer(key));
    if (!_key) {
      throw new Error("Missing key: required for decryption");
    }
    const verified = await verifyHmac(payload, _key);
    if (!verified) {
      return null;
    }
    const cipherText = hexToArray(payload.data);
    const iv = hexToArray(payload.iv);
    const buffer = await aesCbcDecrypt(iv, _key, cipherText);
    const utf8 = arrayToUtf8(buffer);
    let data;
    try {
      data = JSON.parse(utf8);
    } catch (error) {
      return null;
    }
    return data;
  }
  var init_esm8 = __esm({
    "node_modules/@walletconnect/iso-crypto/dist/esm/index.js"() {
      init_polyfills();
      init_browser4();
      init_esm3();
      init_esm5();
    }
  });

  // node_modules/@walletconnect/client/dist/esm/index.js
  var WalletConnect, esm_default3;
  var init_esm9 = __esm({
    "node_modules/@walletconnect/client/dist/esm/index.js"() {
      init_polyfills();
      init_esm7();
      init_esm8();
      WalletConnect = class extends esm_default2 {
        constructor(connectorOpts, pushServerOpts) {
          super({
            cryptoLib: esm_exports4,
            connectorOpts,
            pushServerOpts
          });
        }
      };
      esm_default3 = WalletConnect;
    }
  });

  // (disabled):crypto
  var require_crypto2 = __commonJS({
    "(disabled):crypto"() {
      init_polyfills();
    }
  });

  // node_modules/tweetnacl/nacl-fast.js
  var require_nacl_fast = __commonJS({
    "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
      init_polyfills();
      (function(nacl2) {
        "use strict";
        var gf = function(init) {
          var i2, r3 = new Float64Array(16);
          if (init) for (i2 = 0; i2 < init.length; i2++) r3[i2] = init[i2];
          return r3;
        };
        var randombytes = function() {
          throw new Error("no PRNG");
        };
        var _0 = new Uint8Array(16);
        var _9 = new Uint8Array(32);
        _9[0] = 9;
        var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D3 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X3 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y3 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I3 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
        function ts64(x3, i2, h3, l2) {
          x3[i2] = h3 >> 24 & 255;
          x3[i2 + 1] = h3 >> 16 & 255;
          x3[i2 + 2] = h3 >> 8 & 255;
          x3[i2 + 3] = h3 & 255;
          x3[i2 + 4] = l2 >> 24 & 255;
          x3[i2 + 5] = l2 >> 16 & 255;
          x3[i2 + 6] = l2 >> 8 & 255;
          x3[i2 + 7] = l2 & 255;
        }
        function vn(x3, xi, y3, yi, n3) {
          var i2, d2 = 0;
          for (i2 = 0; i2 < n3; i2++) d2 |= x3[xi + i2] ^ y3[yi + i2];
          return (1 & d2 - 1 >>> 8) - 1;
        }
        function crypto_verify_16(x3, xi, y3, yi) {
          return vn(x3, xi, y3, yi, 16);
        }
        function crypto_verify_32(x3, xi, y3, yi) {
          return vn(x3, xi, y3, yi, 32);
        }
        function core_salsa20(o3, p2, k3, c2) {
          var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j22 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j3 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
          var x0 = j0, x1 = j1, x22 = j22, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u3;
          for (var i2 = 0; i2 < 20; i2 += 2) {
            u3 = x0 + x12 | 0;
            x4 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x4 + x0 | 0;
            x8 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x8 + x4 | 0;
            x12 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x12 + x8 | 0;
            x0 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x5 + x1 | 0;
            x9 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x9 + x5 | 0;
            x13 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x13 + x9 | 0;
            x1 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x1 + x13 | 0;
            x5 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x10 + x6 | 0;
            x14 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x14 + x10 | 0;
            x22 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x22 + x14 | 0;
            x6 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x6 + x22 | 0;
            x10 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x15 + x11 | 0;
            x3 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x3 + x15 | 0;
            x7 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x7 + x3 | 0;
            x11 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x11 + x7 | 0;
            x15 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x0 + x3 | 0;
            x1 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x1 + x0 | 0;
            x22 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x22 + x1 | 0;
            x3 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x3 + x22 | 0;
            x0 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x5 + x4 | 0;
            x6 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x6 + x5 | 0;
            x7 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x7 + x6 | 0;
            x4 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x4 + x7 | 0;
            x5 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x10 + x9 | 0;
            x11 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x11 + x10 | 0;
            x8 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x8 + x11 | 0;
            x9 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x9 + x8 | 0;
            x10 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x15 + x14 | 0;
            x12 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x12 + x15 | 0;
            x13 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x13 + x12 | 0;
            x14 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x14 + x13 | 0;
            x15 ^= u3 << 18 | u3 >>> 32 - 18;
          }
          x0 = x0 + j0 | 0;
          x1 = x1 + j1 | 0;
          x22 = x22 + j22 | 0;
          x3 = x3 + j3 | 0;
          x4 = x4 + j4 | 0;
          x5 = x5 + j5 | 0;
          x6 = x6 + j6 | 0;
          x7 = x7 + j7 | 0;
          x8 = x8 + j8 | 0;
          x9 = x9 + j9 | 0;
          x10 = x10 + j10 | 0;
          x11 = x11 + j11 | 0;
          x12 = x12 + j12 | 0;
          x13 = x13 + j13 | 0;
          x14 = x14 + j14 | 0;
          x15 = x15 + j15 | 0;
          o3[0] = x0 >>> 0 & 255;
          o3[1] = x0 >>> 8 & 255;
          o3[2] = x0 >>> 16 & 255;
          o3[3] = x0 >>> 24 & 255;
          o3[4] = x1 >>> 0 & 255;
          o3[5] = x1 >>> 8 & 255;
          o3[6] = x1 >>> 16 & 255;
          o3[7] = x1 >>> 24 & 255;
          o3[8] = x22 >>> 0 & 255;
          o3[9] = x22 >>> 8 & 255;
          o3[10] = x22 >>> 16 & 255;
          o3[11] = x22 >>> 24 & 255;
          o3[12] = x3 >>> 0 & 255;
          o3[13] = x3 >>> 8 & 255;
          o3[14] = x3 >>> 16 & 255;
          o3[15] = x3 >>> 24 & 255;
          o3[16] = x4 >>> 0 & 255;
          o3[17] = x4 >>> 8 & 255;
          o3[18] = x4 >>> 16 & 255;
          o3[19] = x4 >>> 24 & 255;
          o3[20] = x5 >>> 0 & 255;
          o3[21] = x5 >>> 8 & 255;
          o3[22] = x5 >>> 16 & 255;
          o3[23] = x5 >>> 24 & 255;
          o3[24] = x6 >>> 0 & 255;
          o3[25] = x6 >>> 8 & 255;
          o3[26] = x6 >>> 16 & 255;
          o3[27] = x6 >>> 24 & 255;
          o3[28] = x7 >>> 0 & 255;
          o3[29] = x7 >>> 8 & 255;
          o3[30] = x7 >>> 16 & 255;
          o3[31] = x7 >>> 24 & 255;
          o3[32] = x8 >>> 0 & 255;
          o3[33] = x8 >>> 8 & 255;
          o3[34] = x8 >>> 16 & 255;
          o3[35] = x8 >>> 24 & 255;
          o3[36] = x9 >>> 0 & 255;
          o3[37] = x9 >>> 8 & 255;
          o3[38] = x9 >>> 16 & 255;
          o3[39] = x9 >>> 24 & 255;
          o3[40] = x10 >>> 0 & 255;
          o3[41] = x10 >>> 8 & 255;
          o3[42] = x10 >>> 16 & 255;
          o3[43] = x10 >>> 24 & 255;
          o3[44] = x11 >>> 0 & 255;
          o3[45] = x11 >>> 8 & 255;
          o3[46] = x11 >>> 16 & 255;
          o3[47] = x11 >>> 24 & 255;
          o3[48] = x12 >>> 0 & 255;
          o3[49] = x12 >>> 8 & 255;
          o3[50] = x12 >>> 16 & 255;
          o3[51] = x12 >>> 24 & 255;
          o3[52] = x13 >>> 0 & 255;
          o3[53] = x13 >>> 8 & 255;
          o3[54] = x13 >>> 16 & 255;
          o3[55] = x13 >>> 24 & 255;
          o3[56] = x14 >>> 0 & 255;
          o3[57] = x14 >>> 8 & 255;
          o3[58] = x14 >>> 16 & 255;
          o3[59] = x14 >>> 24 & 255;
          o3[60] = x15 >>> 0 & 255;
          o3[61] = x15 >>> 8 & 255;
          o3[62] = x15 >>> 16 & 255;
          o3[63] = x15 >>> 24 & 255;
        }
        function core_hsalsa20(o3, p2, k3, c2) {
          var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j22 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j3 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
          var x0 = j0, x1 = j1, x22 = j22, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u3;
          for (var i2 = 0; i2 < 20; i2 += 2) {
            u3 = x0 + x12 | 0;
            x4 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x4 + x0 | 0;
            x8 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x8 + x4 | 0;
            x12 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x12 + x8 | 0;
            x0 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x5 + x1 | 0;
            x9 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x9 + x5 | 0;
            x13 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x13 + x9 | 0;
            x1 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x1 + x13 | 0;
            x5 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x10 + x6 | 0;
            x14 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x14 + x10 | 0;
            x22 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x22 + x14 | 0;
            x6 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x6 + x22 | 0;
            x10 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x15 + x11 | 0;
            x3 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x3 + x15 | 0;
            x7 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x7 + x3 | 0;
            x11 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x11 + x7 | 0;
            x15 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x0 + x3 | 0;
            x1 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x1 + x0 | 0;
            x22 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x22 + x1 | 0;
            x3 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x3 + x22 | 0;
            x0 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x5 + x4 | 0;
            x6 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x6 + x5 | 0;
            x7 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x7 + x6 | 0;
            x4 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x4 + x7 | 0;
            x5 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x10 + x9 | 0;
            x11 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x11 + x10 | 0;
            x8 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x8 + x11 | 0;
            x9 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x9 + x8 | 0;
            x10 ^= u3 << 18 | u3 >>> 32 - 18;
            u3 = x15 + x14 | 0;
            x12 ^= u3 << 7 | u3 >>> 32 - 7;
            u3 = x12 + x15 | 0;
            x13 ^= u3 << 9 | u3 >>> 32 - 9;
            u3 = x13 + x12 | 0;
            x14 ^= u3 << 13 | u3 >>> 32 - 13;
            u3 = x14 + x13 | 0;
            x15 ^= u3 << 18 | u3 >>> 32 - 18;
          }
          o3[0] = x0 >>> 0 & 255;
          o3[1] = x0 >>> 8 & 255;
          o3[2] = x0 >>> 16 & 255;
          o3[3] = x0 >>> 24 & 255;
          o3[4] = x5 >>> 0 & 255;
          o3[5] = x5 >>> 8 & 255;
          o3[6] = x5 >>> 16 & 255;
          o3[7] = x5 >>> 24 & 255;
          o3[8] = x10 >>> 0 & 255;
          o3[9] = x10 >>> 8 & 255;
          o3[10] = x10 >>> 16 & 255;
          o3[11] = x10 >>> 24 & 255;
          o3[12] = x15 >>> 0 & 255;
          o3[13] = x15 >>> 8 & 255;
          o3[14] = x15 >>> 16 & 255;
          o3[15] = x15 >>> 24 & 255;
          o3[16] = x6 >>> 0 & 255;
          o3[17] = x6 >>> 8 & 255;
          o3[18] = x6 >>> 16 & 255;
          o3[19] = x6 >>> 24 & 255;
          o3[20] = x7 >>> 0 & 255;
          o3[21] = x7 >>> 8 & 255;
          o3[22] = x7 >>> 16 & 255;
          o3[23] = x7 >>> 24 & 255;
          o3[24] = x8 >>> 0 & 255;
          o3[25] = x8 >>> 8 & 255;
          o3[26] = x8 >>> 16 & 255;
          o3[27] = x8 >>> 24 & 255;
          o3[28] = x9 >>> 0 & 255;
          o3[29] = x9 >>> 8 & 255;
          o3[30] = x9 >>> 16 & 255;
          o3[31] = x9 >>> 24 & 255;
        }
        function crypto_core_salsa20(out, inp, k3, c2) {
          core_salsa20(out, inp, k3, c2);
        }
        function crypto_core_hsalsa20(out, inp, k3, c2) {
          core_hsalsa20(out, inp, k3, c2);
        }
        var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
        function crypto_stream_salsa20_xor(c2, cpos, m3, mpos, b3, n3, k3) {
          var z3 = new Uint8Array(16), x3 = new Uint8Array(64);
          var u3, i2;
          for (i2 = 0; i2 < 16; i2++) z3[i2] = 0;
          for (i2 = 0; i2 < 8; i2++) z3[i2] = n3[i2];
          while (b3 >= 64) {
            crypto_core_salsa20(x3, z3, k3, sigma);
            for (i2 = 0; i2 < 64; i2++) c2[cpos + i2] = m3[mpos + i2] ^ x3[i2];
            u3 = 1;
            for (i2 = 8; i2 < 16; i2++) {
              u3 = u3 + (z3[i2] & 255) | 0;
              z3[i2] = u3 & 255;
              u3 >>>= 8;
            }
            b3 -= 64;
            cpos += 64;
            mpos += 64;
          }
          if (b3 > 0) {
            crypto_core_salsa20(x3, z3, k3, sigma);
            for (i2 = 0; i2 < b3; i2++) c2[cpos + i2] = m3[mpos + i2] ^ x3[i2];
          }
          return 0;
        }
        function crypto_stream_salsa20(c2, cpos, b3, n3, k3) {
          var z3 = new Uint8Array(16), x3 = new Uint8Array(64);
          var u3, i2;
          for (i2 = 0; i2 < 16; i2++) z3[i2] = 0;
          for (i2 = 0; i2 < 8; i2++) z3[i2] = n3[i2];
          while (b3 >= 64) {
            crypto_core_salsa20(x3, z3, k3, sigma);
            for (i2 = 0; i2 < 64; i2++) c2[cpos + i2] = x3[i2];
            u3 = 1;
            for (i2 = 8; i2 < 16; i2++) {
              u3 = u3 + (z3[i2] & 255) | 0;
              z3[i2] = u3 & 255;
              u3 >>>= 8;
            }
            b3 -= 64;
            cpos += 64;
          }
          if (b3 > 0) {
            crypto_core_salsa20(x3, z3, k3, sigma);
            for (i2 = 0; i2 < b3; i2++) c2[cpos + i2] = x3[i2];
          }
          return 0;
        }
        function crypto_stream(c2, cpos, d2, n3, k3) {
          var s2 = new Uint8Array(32);
          crypto_core_hsalsa20(s2, n3, k3, sigma);
          var sn = new Uint8Array(8);
          for (var i2 = 0; i2 < 8; i2++) sn[i2] = n3[i2 + 16];
          return crypto_stream_salsa20(c2, cpos, d2, sn, s2);
        }
        function crypto_stream_xor(c2, cpos, m3, mpos, d2, n3, k3) {
          var s2 = new Uint8Array(32);
          crypto_core_hsalsa20(s2, n3, k3, sigma);
          var sn = new Uint8Array(8);
          for (var i2 = 0; i2 < 8; i2++) sn[i2] = n3[i2 + 16];
          return crypto_stream_salsa20_xor(c2, cpos, m3, mpos, d2, sn, s2);
        }
        var poly1305 = function(key) {
          this.buffer = new Uint8Array(16);
          this.r = new Uint16Array(10);
          this.h = new Uint16Array(10);
          this.pad = new Uint16Array(8);
          this.leftover = 0;
          this.fin = 0;
          var t0, t1, t2, t3, t4, t5, t6, t7;
          t0 = key[0] & 255 | (key[1] & 255) << 8;
          this.r[0] = t0 & 8191;
          t1 = key[2] & 255 | (key[3] & 255) << 8;
          this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          t2 = key[4] & 255 | (key[5] & 255) << 8;
          this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          t3 = key[6] & 255 | (key[7] & 255) << 8;
          this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          t4 = key[8] & 255 | (key[9] & 255) << 8;
          this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this.r[5] = t4 >>> 1 & 8190;
          t5 = key[10] & 255 | (key[11] & 255) << 8;
          this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          t6 = key[12] & 255 | (key[13] & 255) << 8;
          this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          t7 = key[14] & 255 | (key[15] & 255) << 8;
          this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this.r[9] = t7 >>> 5 & 127;
          this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
          this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
          this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
          this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
          this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
          this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
          this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
          this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
        };
        poly1305.prototype.blocks = function(m3, mpos, bytes) {
          var hibit = this.fin ? 0 : 1 << 11;
          var t0, t1, t2, t3, t4, t5, t6, t7, c2;
          var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
          var h0 = this.h[0], h1 = this.h[1], h22 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
          var r0 = this.r[0], r1 = this.r[1], r22 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
          while (bytes >= 16) {
            t0 = m3[mpos + 0] & 255 | (m3[mpos + 1] & 255) << 8;
            h0 += t0 & 8191;
            t1 = m3[mpos + 2] & 255 | (m3[mpos + 3] & 255) << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            t2 = m3[mpos + 4] & 255 | (m3[mpos + 5] & 255) << 8;
            h22 += (t1 >>> 10 | t2 << 6) & 8191;
            t3 = m3[mpos + 6] & 255 | (m3[mpos + 7] & 255) << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 8191;
            t4 = m3[mpos + 8] & 255 | (m3[mpos + 9] & 255) << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            t5 = m3[mpos + 10] & 255 | (m3[mpos + 11] & 255) << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            t6 = m3[mpos + 12] & 255 | (m3[mpos + 13] & 255) << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            t7 = m3[mpos + 14] & 255 | (m3[mpos + 15] & 255) << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            c2 = 0;
            d0 = c2;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h22 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c2 = d0 >>> 13;
            d0 &= 8191;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r22);
            d0 += h9 * (5 * r1);
            c2 += d0 >>> 13;
            d0 &= 8191;
            d1 = c2;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h22 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c2 = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r22);
            c2 += d1 >>> 13;
            d1 &= 8191;
            d2 = c2;
            d2 += h0 * r22;
            d2 += h1 * r1;
            d2 += h22 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c2 = d2 >>> 13;
            d2 &= 8191;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c2 += d2 >>> 13;
            d2 &= 8191;
            d3 = c2;
            d3 += h0 * r3;
            d3 += h1 * r22;
            d3 += h22 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c2 = d3 >>> 13;
            d3 &= 8191;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c2 += d3 >>> 13;
            d3 &= 8191;
            d4 = c2;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h22 * r22;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c2 = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c2 += d4 >>> 13;
            d4 &= 8191;
            d5 = c2;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h22 * r3;
            d5 += h3 * r22;
            d5 += h4 * r1;
            c2 = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c2 += d5 >>> 13;
            d5 &= 8191;
            d6 = c2;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h22 * r4;
            d6 += h3 * r3;
            d6 += h4 * r22;
            c2 = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c2 += d6 >>> 13;
            d6 &= 8191;
            d7 = c2;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h22 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c2 = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r22;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c2 += d7 >>> 13;
            d7 &= 8191;
            d8 = c2;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h22 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c2 = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r22;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c2 += d8 >>> 13;
            d8 &= 8191;
            d9 = c2;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h22 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c2 = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r22;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c2 += d9 >>> 13;
            d9 &= 8191;
            c2 = (c2 << 2) + c2 | 0;
            c2 = c2 + d0 | 0;
            d0 = c2 & 8191;
            c2 = c2 >>> 13;
            d1 += c2;
            h0 = d0;
            h1 = d1;
            h22 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this.h[0] = h0;
          this.h[1] = h1;
          this.h[2] = h22;
          this.h[3] = h3;
          this.h[4] = h4;
          this.h[5] = h5;
          this.h[6] = h6;
          this.h[7] = h7;
          this.h[8] = h8;
          this.h[9] = h9;
        };
        poly1305.prototype.finish = function(mac, macpos) {
          var g3 = new Uint16Array(10);
          var c2, mask, f3, i2;
          if (this.leftover) {
            i2 = this.leftover;
            this.buffer[i2++] = 1;
            for (; i2 < 16; i2++) this.buffer[i2] = 0;
            this.fin = 1;
            this.blocks(this.buffer, 0, 16);
          }
          c2 = this.h[1] >>> 13;
          this.h[1] &= 8191;
          for (i2 = 2; i2 < 10; i2++) {
            this.h[i2] += c2;
            c2 = this.h[i2] >>> 13;
            this.h[i2] &= 8191;
          }
          this.h[0] += c2 * 5;
          c2 = this.h[0] >>> 13;
          this.h[0] &= 8191;
          this.h[1] += c2;
          c2 = this.h[1] >>> 13;
          this.h[1] &= 8191;
          this.h[2] += c2;
          g3[0] = this.h[0] + 5;
          c2 = g3[0] >>> 13;
          g3[0] &= 8191;
          for (i2 = 1; i2 < 10; i2++) {
            g3[i2] = this.h[i2] + c2;
            c2 = g3[i2] >>> 13;
            g3[i2] &= 8191;
          }
          g3[9] -= 1 << 13;
          mask = (c2 ^ 1) - 1;
          for (i2 = 0; i2 < 10; i2++) g3[i2] &= mask;
          mask = ~mask;
          for (i2 = 0; i2 < 10; i2++) this.h[i2] = this.h[i2] & mask | g3[i2];
          this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
          this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
          this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
          this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
          this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
          this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
          this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
          this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
          f3 = this.h[0] + this.pad[0];
          this.h[0] = f3 & 65535;
          for (i2 = 1; i2 < 8; i2++) {
            f3 = (this.h[i2] + this.pad[i2] | 0) + (f3 >>> 16) | 0;
            this.h[i2] = f3 & 65535;
          }
          mac[macpos + 0] = this.h[0] >>> 0 & 255;
          mac[macpos + 1] = this.h[0] >>> 8 & 255;
          mac[macpos + 2] = this.h[1] >>> 0 & 255;
          mac[macpos + 3] = this.h[1] >>> 8 & 255;
          mac[macpos + 4] = this.h[2] >>> 0 & 255;
          mac[macpos + 5] = this.h[2] >>> 8 & 255;
          mac[macpos + 6] = this.h[3] >>> 0 & 255;
          mac[macpos + 7] = this.h[3] >>> 8 & 255;
          mac[macpos + 8] = this.h[4] >>> 0 & 255;
          mac[macpos + 9] = this.h[4] >>> 8 & 255;
          mac[macpos + 10] = this.h[5] >>> 0 & 255;
          mac[macpos + 11] = this.h[5] >>> 8 & 255;
          mac[macpos + 12] = this.h[6] >>> 0 & 255;
          mac[macpos + 13] = this.h[6] >>> 8 & 255;
          mac[macpos + 14] = this.h[7] >>> 0 & 255;
          mac[macpos + 15] = this.h[7] >>> 8 & 255;
        };
        poly1305.prototype.update = function(m3, mpos, bytes) {
          var i2, want;
          if (this.leftover) {
            want = 16 - this.leftover;
            if (want > bytes)
              want = bytes;
            for (i2 = 0; i2 < want; i2++)
              this.buffer[this.leftover + i2] = m3[mpos + i2];
            bytes -= want;
            mpos += want;
            this.leftover += want;
            if (this.leftover < 16)
              return;
            this.blocks(this.buffer, 0, 16);
            this.leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this.blocks(m3, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (i2 = 0; i2 < bytes; i2++)
              this.buffer[this.leftover + i2] = m3[mpos + i2];
            this.leftover += bytes;
          }
        };
        function crypto_onetimeauth(out, outpos, m3, mpos, n3, k3) {
          var s2 = new poly1305(k3);
          s2.update(m3, mpos, n3);
          s2.finish(out, outpos);
          return 0;
        }
        function crypto_onetimeauth_verify(h3, hpos, m3, mpos, n3, k3) {
          var x3 = new Uint8Array(16);
          crypto_onetimeauth(x3, 0, m3, mpos, n3, k3);
          return crypto_verify_16(h3, hpos, x3, 0);
        }
        function crypto_secretbox(c2, m3, d2, n3, k3) {
          var i2;
          if (d2 < 32) return -1;
          crypto_stream_xor(c2, 0, m3, 0, d2, n3, k3);
          crypto_onetimeauth(c2, 16, c2, 32, d2 - 32, c2);
          for (i2 = 0; i2 < 16; i2++) c2[i2] = 0;
          return 0;
        }
        function crypto_secretbox_open(m3, c2, d2, n3, k3) {
          var i2;
          var x3 = new Uint8Array(32);
          if (d2 < 32) return -1;
          crypto_stream(x3, 0, 32, n3, k3);
          if (crypto_onetimeauth_verify(c2, 16, c2, 32, d2 - 32, x3) !== 0) return -1;
          crypto_stream_xor(m3, 0, c2, 0, d2, n3, k3);
          for (i2 = 0; i2 < 32; i2++) m3[i2] = 0;
          return 0;
        }
        function set25519(r3, a2) {
          var i2;
          for (i2 = 0; i2 < 16; i2++) r3[i2] = a2[i2] | 0;
        }
        function car25519(o3) {
          var i2, v3, c2 = 1;
          for (i2 = 0; i2 < 16; i2++) {
            v3 = o3[i2] + c2 + 65535;
            c2 = Math.floor(v3 / 65536);
            o3[i2] = v3 - c2 * 65536;
          }
          o3[0] += c2 - 1 + 37 * (c2 - 1);
        }
        function sel25519(p2, q3, b3) {
          var t, c2 = ~(b3 - 1);
          for (var i2 = 0; i2 < 16; i2++) {
            t = c2 & (p2[i2] ^ q3[i2]);
            p2[i2] ^= t;
            q3[i2] ^= t;
          }
        }
        function pack25519(o3, n3) {
          var i2, j3, b3;
          var m3 = gf(), t = gf();
          for (i2 = 0; i2 < 16; i2++) t[i2] = n3[i2];
          car25519(t);
          car25519(t);
          car25519(t);
          for (j3 = 0; j3 < 2; j3++) {
            m3[0] = t[0] - 65517;
            for (i2 = 1; i2 < 15; i2++) {
              m3[i2] = t[i2] - 65535 - (m3[i2 - 1] >> 16 & 1);
              m3[i2 - 1] &= 65535;
            }
            m3[15] = t[15] - 32767 - (m3[14] >> 16 & 1);
            b3 = m3[15] >> 16 & 1;
            m3[14] &= 65535;
            sel25519(t, m3, 1 - b3);
          }
          for (i2 = 0; i2 < 16; i2++) {
            o3[2 * i2] = t[i2] & 255;
            o3[2 * i2 + 1] = t[i2] >> 8;
          }
        }
        function neq25519(a2, b3) {
          var c2 = new Uint8Array(32), d2 = new Uint8Array(32);
          pack25519(c2, a2);
          pack25519(d2, b3);
          return crypto_verify_32(c2, 0, d2, 0);
        }
        function par25519(a2) {
          var d2 = new Uint8Array(32);
          pack25519(d2, a2);
          return d2[0] & 1;
        }
        function unpack25519(o3, n3) {
          var i2;
          for (i2 = 0; i2 < 16; i2++) o3[i2] = n3[2 * i2] + (n3[2 * i2 + 1] << 8);
          o3[15] &= 32767;
        }
        function A3(o3, a2, b3) {
          for (var i2 = 0; i2 < 16; i2++) o3[i2] = a2[i2] + b3[i2];
        }
        function Z3(o3, a2, b3) {
          for (var i2 = 0; i2 < 16; i2++) o3[i2] = a2[i2] - b3[i2];
        }
        function M3(o3, a2, b3) {
          var v3, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b3[0], b1 = b3[1], b22 = b3[2], b32 = b3[3], b4 = b3[4], b5 = b3[5], b6 = b3[6], b7 = b3[7], b8 = b3[8], b9 = b3[9], b10 = b3[10], b11 = b3[11], b12 = b3[12], b13 = b3[13], b14 = b3[14], b15 = b3[15];
          v3 = a2[0];
          t0 += v3 * b0;
          t1 += v3 * b1;
          t2 += v3 * b22;
          t3 += v3 * b32;
          t4 += v3 * b4;
          t5 += v3 * b5;
          t6 += v3 * b6;
          t7 += v3 * b7;
          t8 += v3 * b8;
          t9 += v3 * b9;
          t10 += v3 * b10;
          t11 += v3 * b11;
          t12 += v3 * b12;
          t13 += v3 * b13;
          t14 += v3 * b14;
          t15 += v3 * b15;
          v3 = a2[1];
          t1 += v3 * b0;
          t2 += v3 * b1;
          t3 += v3 * b22;
          t4 += v3 * b32;
          t5 += v3 * b4;
          t6 += v3 * b5;
          t7 += v3 * b6;
          t8 += v3 * b7;
          t9 += v3 * b8;
          t10 += v3 * b9;
          t11 += v3 * b10;
          t12 += v3 * b11;
          t13 += v3 * b12;
          t14 += v3 * b13;
          t15 += v3 * b14;
          t16 += v3 * b15;
          v3 = a2[2];
          t2 += v3 * b0;
          t3 += v3 * b1;
          t4 += v3 * b22;
          t5 += v3 * b32;
          t6 += v3 * b4;
          t7 += v3 * b5;
          t8 += v3 * b6;
          t9 += v3 * b7;
          t10 += v3 * b8;
          t11 += v3 * b9;
          t12 += v3 * b10;
          t13 += v3 * b11;
          t14 += v3 * b12;
          t15 += v3 * b13;
          t16 += v3 * b14;
          t17 += v3 * b15;
          v3 = a2[3];
          t3 += v3 * b0;
          t4 += v3 * b1;
          t5 += v3 * b22;
          t6 += v3 * b32;
          t7 += v3 * b4;
          t8 += v3 * b5;
          t9 += v3 * b6;
          t10 += v3 * b7;
          t11 += v3 * b8;
          t12 += v3 * b9;
          t13 += v3 * b10;
          t14 += v3 * b11;
          t15 += v3 * b12;
          t16 += v3 * b13;
          t17 += v3 * b14;
          t18 += v3 * b15;
          v3 = a2[4];
          t4 += v3 * b0;
          t5 += v3 * b1;
          t6 += v3 * b22;
          t7 += v3 * b32;
          t8 += v3 * b4;
          t9 += v3 * b5;
          t10 += v3 * b6;
          t11 += v3 * b7;
          t12 += v3 * b8;
          t13 += v3 * b9;
          t14 += v3 * b10;
          t15 += v3 * b11;
          t16 += v3 * b12;
          t17 += v3 * b13;
          t18 += v3 * b14;
          t19 += v3 * b15;
          v3 = a2[5];
          t5 += v3 * b0;
          t6 += v3 * b1;
          t7 += v3 * b22;
          t8 += v3 * b32;
          t9 += v3 * b4;
          t10 += v3 * b5;
          t11 += v3 * b6;
          t12 += v3 * b7;
          t13 += v3 * b8;
          t14 += v3 * b9;
          t15 += v3 * b10;
          t16 += v3 * b11;
          t17 += v3 * b12;
          t18 += v3 * b13;
          t19 += v3 * b14;
          t20 += v3 * b15;
          v3 = a2[6];
          t6 += v3 * b0;
          t7 += v3 * b1;
          t8 += v3 * b22;
          t9 += v3 * b32;
          t10 += v3 * b4;
          t11 += v3 * b5;
          t12 += v3 * b6;
          t13 += v3 * b7;
          t14 += v3 * b8;
          t15 += v3 * b9;
          t16 += v3 * b10;
          t17 += v3 * b11;
          t18 += v3 * b12;
          t19 += v3 * b13;
          t20 += v3 * b14;
          t21 += v3 * b15;
          v3 = a2[7];
          t7 += v3 * b0;
          t8 += v3 * b1;
          t9 += v3 * b22;
          t10 += v3 * b32;
          t11 += v3 * b4;
          t12 += v3 * b5;
          t13 += v3 * b6;
          t14 += v3 * b7;
          t15 += v3 * b8;
          t16 += v3 * b9;
          t17 += v3 * b10;
          t18 += v3 * b11;
          t19 += v3 * b12;
          t20 += v3 * b13;
          t21 += v3 * b14;
          t22 += v3 * b15;
          v3 = a2[8];
          t8 += v3 * b0;
          t9 += v3 * b1;
          t10 += v3 * b22;
          t11 += v3 * b32;
          t12 += v3 * b4;
          t13 += v3 * b5;
          t14 += v3 * b6;
          t15 += v3 * b7;
          t16 += v3 * b8;
          t17 += v3 * b9;
          t18 += v3 * b10;
          t19 += v3 * b11;
          t20 += v3 * b12;
          t21 += v3 * b13;
          t22 += v3 * b14;
          t23 += v3 * b15;
          v3 = a2[9];
          t9 += v3 * b0;
          t10 += v3 * b1;
          t11 += v3 * b22;
          t12 += v3 * b32;
          t13 += v3 * b4;
          t14 += v3 * b5;
          t15 += v3 * b6;
          t16 += v3 * b7;
          t17 += v3 * b8;
          t18 += v3 * b9;
          t19 += v3 * b10;
          t20 += v3 * b11;
          t21 += v3 * b12;
          t22 += v3 * b13;
          t23 += v3 * b14;
          t24 += v3 * b15;
          v3 = a2[10];
          t10 += v3 * b0;
          t11 += v3 * b1;
          t12 += v3 * b22;
          t13 += v3 * b32;
          t14 += v3 * b4;
          t15 += v3 * b5;
          t16 += v3 * b6;
          t17 += v3 * b7;
          t18 += v3 * b8;
          t19 += v3 * b9;
          t20 += v3 * b10;
          t21 += v3 * b11;
          t22 += v3 * b12;
          t23 += v3 * b13;
          t24 += v3 * b14;
          t25 += v3 * b15;
          v3 = a2[11];
          t11 += v3 * b0;
          t12 += v3 * b1;
          t13 += v3 * b22;
          t14 += v3 * b32;
          t15 += v3 * b4;
          t16 += v3 * b5;
          t17 += v3 * b6;
          t18 += v3 * b7;
          t19 += v3 * b8;
          t20 += v3 * b9;
          t21 += v3 * b10;
          t22 += v3 * b11;
          t23 += v3 * b12;
          t24 += v3 * b13;
          t25 += v3 * b14;
          t26 += v3 * b15;
          v3 = a2[12];
          t12 += v3 * b0;
          t13 += v3 * b1;
          t14 += v3 * b22;
          t15 += v3 * b32;
          t16 += v3 * b4;
          t17 += v3 * b5;
          t18 += v3 * b6;
          t19 += v3 * b7;
          t20 += v3 * b8;
          t21 += v3 * b9;
          t22 += v3 * b10;
          t23 += v3 * b11;
          t24 += v3 * b12;
          t25 += v3 * b13;
          t26 += v3 * b14;
          t27 += v3 * b15;
          v3 = a2[13];
          t13 += v3 * b0;
          t14 += v3 * b1;
          t15 += v3 * b22;
          t16 += v3 * b32;
          t17 += v3 * b4;
          t18 += v3 * b5;
          t19 += v3 * b6;
          t20 += v3 * b7;
          t21 += v3 * b8;
          t22 += v3 * b9;
          t23 += v3 * b10;
          t24 += v3 * b11;
          t25 += v3 * b12;
          t26 += v3 * b13;
          t27 += v3 * b14;
          t28 += v3 * b15;
          v3 = a2[14];
          t14 += v3 * b0;
          t15 += v3 * b1;
          t16 += v3 * b22;
          t17 += v3 * b32;
          t18 += v3 * b4;
          t19 += v3 * b5;
          t20 += v3 * b6;
          t21 += v3 * b7;
          t22 += v3 * b8;
          t23 += v3 * b9;
          t24 += v3 * b10;
          t25 += v3 * b11;
          t26 += v3 * b12;
          t27 += v3 * b13;
          t28 += v3 * b14;
          t29 += v3 * b15;
          v3 = a2[15];
          t15 += v3 * b0;
          t16 += v3 * b1;
          t17 += v3 * b22;
          t18 += v3 * b32;
          t19 += v3 * b4;
          t20 += v3 * b5;
          t21 += v3 * b6;
          t22 += v3 * b7;
          t23 += v3 * b8;
          t24 += v3 * b9;
          t25 += v3 * b10;
          t26 += v3 * b11;
          t27 += v3 * b12;
          t28 += v3 * b13;
          t29 += v3 * b14;
          t30 += v3 * b15;
          t0 += 38 * t16;
          t1 += 38 * t17;
          t2 += 38 * t18;
          t3 += 38 * t19;
          t4 += 38 * t20;
          t5 += 38 * t21;
          t6 += 38 * t22;
          t7 += 38 * t23;
          t8 += 38 * t24;
          t9 += 38 * t25;
          t10 += 38 * t26;
          t11 += 38 * t27;
          t12 += 38 * t28;
          t13 += 38 * t29;
          t14 += 38 * t30;
          c2 = 1;
          v3 = t0 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t0 = v3 - c2 * 65536;
          v3 = t1 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t1 = v3 - c2 * 65536;
          v3 = t2 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t2 = v3 - c2 * 65536;
          v3 = t3 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t3 = v3 - c2 * 65536;
          v3 = t4 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t4 = v3 - c2 * 65536;
          v3 = t5 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t5 = v3 - c2 * 65536;
          v3 = t6 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t6 = v3 - c2 * 65536;
          v3 = t7 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t7 = v3 - c2 * 65536;
          v3 = t8 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t8 = v3 - c2 * 65536;
          v3 = t9 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t9 = v3 - c2 * 65536;
          v3 = t10 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t10 = v3 - c2 * 65536;
          v3 = t11 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t11 = v3 - c2 * 65536;
          v3 = t12 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t12 = v3 - c2 * 65536;
          v3 = t13 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t13 = v3 - c2 * 65536;
          v3 = t14 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t14 = v3 - c2 * 65536;
          v3 = t15 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t15 = v3 - c2 * 65536;
          t0 += c2 - 1 + 37 * (c2 - 1);
          c2 = 1;
          v3 = t0 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t0 = v3 - c2 * 65536;
          v3 = t1 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t1 = v3 - c2 * 65536;
          v3 = t2 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t2 = v3 - c2 * 65536;
          v3 = t3 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t3 = v3 - c2 * 65536;
          v3 = t4 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t4 = v3 - c2 * 65536;
          v3 = t5 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t5 = v3 - c2 * 65536;
          v3 = t6 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t6 = v3 - c2 * 65536;
          v3 = t7 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t7 = v3 - c2 * 65536;
          v3 = t8 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t8 = v3 - c2 * 65536;
          v3 = t9 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t9 = v3 - c2 * 65536;
          v3 = t10 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t10 = v3 - c2 * 65536;
          v3 = t11 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t11 = v3 - c2 * 65536;
          v3 = t12 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t12 = v3 - c2 * 65536;
          v3 = t13 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t13 = v3 - c2 * 65536;
          v3 = t14 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t14 = v3 - c2 * 65536;
          v3 = t15 + c2 + 65535;
          c2 = Math.floor(v3 / 65536);
          t15 = v3 - c2 * 65536;
          t0 += c2 - 1 + 37 * (c2 - 1);
          o3[0] = t0;
          o3[1] = t1;
          o3[2] = t2;
          o3[3] = t3;
          o3[4] = t4;
          o3[5] = t5;
          o3[6] = t6;
          o3[7] = t7;
          o3[8] = t8;
          o3[9] = t9;
          o3[10] = t10;
          o3[11] = t11;
          o3[12] = t12;
          o3[13] = t13;
          o3[14] = t14;
          o3[15] = t15;
        }
        function S3(o3, a2) {
          M3(o3, a2, a2);
        }
        function inv25519(o3, i2) {
          var c2 = gf();
          var a2;
          for (a2 = 0; a2 < 16; a2++) c2[a2] = i2[a2];
          for (a2 = 253; a2 >= 0; a2--) {
            S3(c2, c2);
            if (a2 !== 2 && a2 !== 4) M3(c2, c2, i2);
          }
          for (a2 = 0; a2 < 16; a2++) o3[a2] = c2[a2];
        }
        function pow2523(o3, i2) {
          var c2 = gf();
          var a2;
          for (a2 = 0; a2 < 16; a2++) c2[a2] = i2[a2];
          for (a2 = 250; a2 >= 0; a2--) {
            S3(c2, c2);
            if (a2 !== 1) M3(c2, c2, i2);
          }
          for (a2 = 0; a2 < 16; a2++) o3[a2] = c2[a2];
        }
        function crypto_scalarmult(q3, n3, p2) {
          var z3 = new Uint8Array(32);
          var x3 = new Float64Array(80), r3, i2;
          var a2 = gf(), b3 = gf(), c2 = gf(), d2 = gf(), e2 = gf(), f3 = gf();
          for (i2 = 0; i2 < 31; i2++) z3[i2] = n3[i2];
          z3[31] = n3[31] & 127 | 64;
          z3[0] &= 248;
          unpack25519(x3, p2);
          for (i2 = 0; i2 < 16; i2++) {
            b3[i2] = x3[i2];
            d2[i2] = a2[i2] = c2[i2] = 0;
          }
          a2[0] = d2[0] = 1;
          for (i2 = 254; i2 >= 0; --i2) {
            r3 = z3[i2 >>> 3] >>> (i2 & 7) & 1;
            sel25519(a2, b3, r3);
            sel25519(c2, d2, r3);
            A3(e2, a2, c2);
            Z3(a2, a2, c2);
            A3(c2, b3, d2);
            Z3(b3, b3, d2);
            S3(d2, e2);
            S3(f3, a2);
            M3(a2, c2, a2);
            M3(c2, b3, e2);
            A3(e2, a2, c2);
            Z3(a2, a2, c2);
            S3(b3, a2);
            Z3(c2, d2, f3);
            M3(a2, c2, _121665);
            A3(a2, a2, d2);
            M3(c2, c2, a2);
            M3(a2, d2, f3);
            M3(d2, b3, x3);
            S3(b3, e2);
            sel25519(a2, b3, r3);
            sel25519(c2, d2, r3);
          }
          for (i2 = 0; i2 < 16; i2++) {
            x3[i2 + 16] = a2[i2];
            x3[i2 + 32] = c2[i2];
            x3[i2 + 48] = b3[i2];
            x3[i2 + 64] = d2[i2];
          }
          var x32 = x3.subarray(32);
          var x16 = x3.subarray(16);
          inv25519(x32, x32);
          M3(x16, x16, x32);
          pack25519(q3, x16);
          return 0;
        }
        function crypto_scalarmult_base(q3, n3) {
          return crypto_scalarmult(q3, n3, _9);
        }
        function crypto_box_keypair(y3, x3) {
          randombytes(x3, 32);
          return crypto_scalarmult_base(y3, x3);
        }
        function crypto_box_beforenm(k3, y3, x3) {
          var s2 = new Uint8Array(32);
          crypto_scalarmult(s2, x3, y3);
          return crypto_core_hsalsa20(k3, _0, s2, sigma);
        }
        var crypto_box_afternm = crypto_secretbox;
        var crypto_box_open_afternm = crypto_secretbox_open;
        function crypto_box(c2, m3, d2, n3, y3, x3) {
          var k3 = new Uint8Array(32);
          crypto_box_beforenm(k3, y3, x3);
          return crypto_box_afternm(c2, m3, d2, n3, k3);
        }
        function crypto_box_open(m3, c2, d2, n3, y3, x3) {
          var k3 = new Uint8Array(32);
          crypto_box_beforenm(k3, y3, x3);
          return crypto_box_open_afternm(m3, c2, d2, n3, k3);
        }
        var K3 = [
          1116352408,
          3609767458,
          1899447441,
          602891725,
          3049323471,
          3964484399,
          3921009573,
          2173295548,
          961987163,
          4081628472,
          1508970993,
          3053834265,
          2453635748,
          2937671579,
          2870763221,
          3664609560,
          3624381080,
          2734883394,
          310598401,
          1164996542,
          607225278,
          1323610764,
          1426881987,
          3590304994,
          1925078388,
          4068182383,
          2162078206,
          991336113,
          2614888103,
          633803317,
          3248222580,
          3479774868,
          3835390401,
          2666613458,
          4022224774,
          944711139,
          264347078,
          2341262773,
          604807628,
          2007800933,
          770255983,
          1495990901,
          1249150122,
          1856431235,
          1555081692,
          3175218132,
          1996064986,
          2198950837,
          2554220882,
          3999719339,
          2821834349,
          766784016,
          2952996808,
          2566594879,
          3210313671,
          3203337956,
          3336571891,
          1034457026,
          3584528711,
          2466948901,
          113926993,
          3758326383,
          338241895,
          168717936,
          666307205,
          1188179964,
          773529912,
          1546045734,
          1294757372,
          1522805485,
          1396182291,
          2643833823,
          1695183700,
          2343527390,
          1986661051,
          1014477480,
          2177026350,
          1206759142,
          2456956037,
          344077627,
          2730485921,
          1290863460,
          2820302411,
          3158454273,
          3259730800,
          3505952657,
          3345764771,
          106217008,
          3516065817,
          3606008344,
          3600352804,
          1432725776,
          4094571909,
          1467031594,
          275423344,
          851169720,
          430227734,
          3100823752,
          506948616,
          1363258195,
          659060556,
          3750685593,
          883997877,
          3785050280,
          958139571,
          3318307427,
          1322822218,
          3812723403,
          1537002063,
          2003034995,
          1747873779,
          3602036899,
          1955562222,
          1575990012,
          2024104815,
          1125592928,
          2227730452,
          2716904306,
          2361852424,
          442776044,
          2428436474,
          593698344,
          2756734187,
          3733110249,
          3204031479,
          2999351573,
          3329325298,
          3815920427,
          3391569614,
          3928383900,
          3515267271,
          566280711,
          3940187606,
          3454069534,
          4118630271,
          4000239992,
          116418474,
          1914138554,
          174292421,
          2731055270,
          289380356,
          3203993006,
          460393269,
          320620315,
          685471733,
          587496836,
          852142971,
          1086792851,
          1017036298,
          365543100,
          1126000580,
          2618297676,
          1288033470,
          3409855158,
          1501505948,
          4234509866,
          1607167915,
          987167468,
          1816402316,
          1246189591
        ];
        function crypto_hashblocks_hl(hh, hl, m3, n3) {
          var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i2, j3, h3, l2, a2, b3, c2, d2;
          var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
          var pos = 0;
          while (n3 >= 128) {
            for (i2 = 0; i2 < 16; i2++) {
              j3 = 8 * i2 + pos;
              wh[i2] = m3[j3 + 0] << 24 | m3[j3 + 1] << 16 | m3[j3 + 2] << 8 | m3[j3 + 3];
              wl[i2] = m3[j3 + 4] << 24 | m3[j3 + 5] << 16 | m3[j3 + 6] << 8 | m3[j3 + 7];
            }
            for (i2 = 0; i2 < 80; i2++) {
              bh0 = ah0;
              bh1 = ah1;
              bh2 = ah2;
              bh3 = ah3;
              bh4 = ah4;
              bh5 = ah5;
              bh6 = ah6;
              bh7 = ah7;
              bl0 = al0;
              bl1 = al1;
              bl2 = al2;
              bl3 = al3;
              bl4 = al4;
              bl5 = al5;
              bl6 = al6;
              bl7 = al7;
              h3 = ah7;
              l2 = al7;
              a2 = l2 & 65535;
              b3 = l2 >>> 16;
              c2 = h3 & 65535;
              d2 = h3 >>> 16;
              h3 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
              l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
              a2 += l2 & 65535;
              b3 += l2 >>> 16;
              c2 += h3 & 65535;
              d2 += h3 >>> 16;
              h3 = ah4 & ah5 ^ ~ah4 & ah6;
              l2 = al4 & al5 ^ ~al4 & al6;
              a2 += l2 & 65535;
              b3 += l2 >>> 16;
              c2 += h3 & 65535;
              d2 += h3 >>> 16;
              h3 = K3[i2 * 2];
              l2 = K3[i2 * 2 + 1];
              a2 += l2 & 65535;
              b3 += l2 >>> 16;
              c2 += h3 & 65535;
              d2 += h3 >>> 16;
              h3 = wh[i2 % 16];
              l2 = wl[i2 % 16];
              a2 += l2 & 65535;
              b3 += l2 >>> 16;
              c2 += h3 & 65535;
              d2 += h3 >>> 16;
              b3 += a2 >>> 16;
              c2 += b3 >>> 16;
              d2 += c2 >>> 16;
              th = c2 & 65535 | d2 << 16;
              tl = a2 & 65535 | b3 << 16;
              h3 = th;
              l2 = tl;
              a2 = l2 & 65535;
              b3 = l2 >>> 16;
              c2 = h3 & 65535;
              d2 = h3 >>> 16;
              h3 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
              l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
              a2 += l2 & 65535;
              b3 += l2 >>> 16;
              c2 += h3 & 65535;
              d2 += h3 >>> 16;
              h3 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
              l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
              a2 += l2 & 65535;
              b3 += l2 >>> 16;
              c2 += h3 & 65535;
              d2 += h3 >>> 16;
              b3 += a2 >>> 16;
              c2 += b3 >>> 16;
              d2 += c2 >>> 16;
              bh7 = c2 & 65535 | d2 << 16;
              bl7 = a2 & 65535 | b3 << 16;
              h3 = bh3;
              l2 = bl3;
              a2 = l2 & 65535;
              b3 = l2 >>> 16;
              c2 = h3 & 65535;
              d2 = h3 >>> 16;
              h3 = th;
              l2 = tl;
              a2 += l2 & 65535;
              b3 += l2 >>> 16;
              c2 += h3 & 65535;
              d2 += h3 >>> 16;
              b3 += a2 >>> 16;
              c2 += b3 >>> 16;
              d2 += c2 >>> 16;
              bh3 = c2 & 65535 | d2 << 16;
              bl3 = a2 & 65535 | b3 << 16;
              ah1 = bh0;
              ah2 = bh1;
              ah3 = bh2;
              ah4 = bh3;
              ah5 = bh4;
              ah6 = bh5;
              ah7 = bh6;
              ah0 = bh7;
              al1 = bl0;
              al2 = bl1;
              al3 = bl2;
              al4 = bl3;
              al5 = bl4;
              al6 = bl5;
              al7 = bl6;
              al0 = bl7;
              if (i2 % 16 === 15) {
                for (j3 = 0; j3 < 16; j3++) {
                  h3 = wh[j3];
                  l2 = wl[j3];
                  a2 = l2 & 65535;
                  b3 = l2 >>> 16;
                  c2 = h3 & 65535;
                  d2 = h3 >>> 16;
                  h3 = wh[(j3 + 9) % 16];
                  l2 = wl[(j3 + 9) % 16];
                  a2 += l2 & 65535;
                  b3 += l2 >>> 16;
                  c2 += h3 & 65535;
                  d2 += h3 >>> 16;
                  th = wh[(j3 + 1) % 16];
                  tl = wl[(j3 + 1) % 16];
                  h3 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                  l2 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                  a2 += l2 & 65535;
                  b3 += l2 >>> 16;
                  c2 += h3 & 65535;
                  d2 += h3 >>> 16;
                  th = wh[(j3 + 14) % 16];
                  tl = wl[(j3 + 14) % 16];
                  h3 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                  l2 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                  a2 += l2 & 65535;
                  b3 += l2 >>> 16;
                  c2 += h3 & 65535;
                  d2 += h3 >>> 16;
                  b3 += a2 >>> 16;
                  c2 += b3 >>> 16;
                  d2 += c2 >>> 16;
                  wh[j3] = c2 & 65535 | d2 << 16;
                  wl[j3] = a2 & 65535 | b3 << 16;
                }
              }
            }
            h3 = ah0;
            l2 = al0;
            a2 = l2 & 65535;
            b3 = l2 >>> 16;
            c2 = h3 & 65535;
            d2 = h3 >>> 16;
            h3 = hh[0];
            l2 = hl[0];
            a2 += l2 & 65535;
            b3 += l2 >>> 16;
            c2 += h3 & 65535;
            d2 += h3 >>> 16;
            b3 += a2 >>> 16;
            c2 += b3 >>> 16;
            d2 += c2 >>> 16;
            hh[0] = ah0 = c2 & 65535 | d2 << 16;
            hl[0] = al0 = a2 & 65535 | b3 << 16;
            h3 = ah1;
            l2 = al1;
            a2 = l2 & 65535;
            b3 = l2 >>> 16;
            c2 = h3 & 65535;
            d2 = h3 >>> 16;
            h3 = hh[1];
            l2 = hl[1];
            a2 += l2 & 65535;
            b3 += l2 >>> 16;
            c2 += h3 & 65535;
            d2 += h3 >>> 16;
            b3 += a2 >>> 16;
            c2 += b3 >>> 16;
            d2 += c2 >>> 16;
            hh[1] = ah1 = c2 & 65535 | d2 << 16;
            hl[1] = al1 = a2 & 65535 | b3 << 16;
            h3 = ah2;
            l2 = al2;
            a2 = l2 & 65535;
            b3 = l2 >>> 16;
            c2 = h3 & 65535;
            d2 = h3 >>> 16;
            h3 = hh[2];
            l2 = hl[2];
            a2 += l2 & 65535;
            b3 += l2 >>> 16;
            c2 += h3 & 65535;
            d2 += h3 >>> 16;
            b3 += a2 >>> 16;
            c2 += b3 >>> 16;
            d2 += c2 >>> 16;
            hh[2] = ah2 = c2 & 65535 | d2 << 16;
            hl[2] = al2 = a2 & 65535 | b3 << 16;
            h3 = ah3;
            l2 = al3;
            a2 = l2 & 65535;
            b3 = l2 >>> 16;
            c2 = h3 & 65535;
            d2 = h3 >>> 16;
            h3 = hh[3];
            l2 = hl[3];
            a2 += l2 & 65535;
            b3 += l2 >>> 16;
            c2 += h3 & 65535;
            d2 += h3 >>> 16;
            b3 += a2 >>> 16;
            c2 += b3 >>> 16;
            d2 += c2 >>> 16;
            hh[3] = ah3 = c2 & 65535 | d2 << 16;
            hl[3] = al3 = a2 & 65535 | b3 << 16;
            h3 = ah4;
            l2 = al4;
            a2 = l2 & 65535;
            b3 = l2 >>> 16;
            c2 = h3 & 65535;
            d2 = h3 >>> 16;
            h3 = hh[4];
            l2 = hl[4];
            a2 += l2 & 65535;
            b3 += l2 >>> 16;
            c2 += h3 & 65535;
            d2 += h3 >>> 16;
            b3 += a2 >>> 16;
            c2 += b3 >>> 16;
            d2 += c2 >>> 16;
            hh[4] = ah4 = c2 & 65535 | d2 << 16;
            hl[4] = al4 = a2 & 65535 | b3 << 16;
            h3 = ah5;
            l2 = al5;
            a2 = l2 & 65535;
            b3 = l2 >>> 16;
            c2 = h3 & 65535;
            d2 = h3 >>> 16;
            h3 = hh[5];
            l2 = hl[5];
            a2 += l2 & 65535;
            b3 += l2 >>> 16;
            c2 += h3 & 65535;
            d2 += h3 >>> 16;
            b3 += a2 >>> 16;
            c2 += b3 >>> 16;
            d2 += c2 >>> 16;
            hh[5] = ah5 = c2 & 65535 | d2 << 16;
            hl[5] = al5 = a2 & 65535 | b3 << 16;
            h3 = ah6;
            l2 = al6;
            a2 = l2 & 65535;
            b3 = l2 >>> 16;
            c2 = h3 & 65535;
            d2 = h3 >>> 16;
            h3 = hh[6];
            l2 = hl[6];
            a2 += l2 & 65535;
            b3 += l2 >>> 16;
            c2 += h3 & 65535;
            d2 += h3 >>> 16;
            b3 += a2 >>> 16;
            c2 += b3 >>> 16;
            d2 += c2 >>> 16;
            hh[6] = ah6 = c2 & 65535 | d2 << 16;
            hl[6] = al6 = a2 & 65535 | b3 << 16;
            h3 = ah7;
            l2 = al7;
            a2 = l2 & 65535;
            b3 = l2 >>> 16;
            c2 = h3 & 65535;
            d2 = h3 >>> 16;
            h3 = hh[7];
            l2 = hl[7];
            a2 += l2 & 65535;
            b3 += l2 >>> 16;
            c2 += h3 & 65535;
            d2 += h3 >>> 16;
            b3 += a2 >>> 16;
            c2 += b3 >>> 16;
            d2 += c2 >>> 16;
            hh[7] = ah7 = c2 & 65535 | d2 << 16;
            hl[7] = al7 = a2 & 65535 | b3 << 16;
            pos += 128;
            n3 -= 128;
          }
          return n3;
        }
        function crypto_hash(out, m3, n3) {
          var hh = new Int32Array(8), hl = new Int32Array(8), x3 = new Uint8Array(256), i2, b3 = n3;
          hh[0] = 1779033703;
          hh[1] = 3144134277;
          hh[2] = 1013904242;
          hh[3] = 2773480762;
          hh[4] = 1359893119;
          hh[5] = 2600822924;
          hh[6] = 528734635;
          hh[7] = 1541459225;
          hl[0] = 4089235720;
          hl[1] = 2227873595;
          hl[2] = 4271175723;
          hl[3] = 1595750129;
          hl[4] = 2917565137;
          hl[5] = 725511199;
          hl[6] = 4215389547;
          hl[7] = 327033209;
          crypto_hashblocks_hl(hh, hl, m3, n3);
          n3 %= 128;
          for (i2 = 0; i2 < n3; i2++) x3[i2] = m3[b3 - n3 + i2];
          x3[n3] = 128;
          n3 = 256 - 128 * (n3 < 112 ? 1 : 0);
          x3[n3 - 9] = 0;
          ts64(x3, n3 - 8, b3 / 536870912 | 0, b3 << 3);
          crypto_hashblocks_hl(hh, hl, x3, n3);
          for (i2 = 0; i2 < 8; i2++) ts64(out, 8 * i2, hh[i2], hl[i2]);
          return 0;
        }
        function add(p2, q3) {
          var a2 = gf(), b3 = gf(), c2 = gf(), d2 = gf(), e2 = gf(), f3 = gf(), g3 = gf(), h3 = gf(), t = gf();
          Z3(a2, p2[1], p2[0]);
          Z3(t, q3[1], q3[0]);
          M3(a2, a2, t);
          A3(b3, p2[0], p2[1]);
          A3(t, q3[0], q3[1]);
          M3(b3, b3, t);
          M3(c2, p2[3], q3[3]);
          M3(c2, c2, D22);
          M3(d2, p2[2], q3[2]);
          A3(d2, d2, d2);
          Z3(e2, b3, a2);
          Z3(f3, d2, c2);
          A3(g3, d2, c2);
          A3(h3, b3, a2);
          M3(p2[0], e2, f3);
          M3(p2[1], h3, g3);
          M3(p2[2], g3, f3);
          M3(p2[3], e2, h3);
        }
        function cswap(p2, q3, b3) {
          var i2;
          for (i2 = 0; i2 < 4; i2++) {
            sel25519(p2[i2], q3[i2], b3);
          }
        }
        function pack(r3, p2) {
          var tx = gf(), ty = gf(), zi = gf();
          inv25519(zi, p2[2]);
          M3(tx, p2[0], zi);
          M3(ty, p2[1], zi);
          pack25519(r3, ty);
          r3[31] ^= par25519(tx) << 7;
        }
        function scalarmult(p2, q3, s2) {
          var b3, i2;
          set25519(p2[0], gf0);
          set25519(p2[1], gf1);
          set25519(p2[2], gf1);
          set25519(p2[3], gf0);
          for (i2 = 255; i2 >= 0; --i2) {
            b3 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
            cswap(p2, q3, b3);
            add(q3, p2);
            add(p2, p2);
            cswap(p2, q3, b3);
          }
        }
        function scalarbase(p2, s2) {
          var q3 = [gf(), gf(), gf(), gf()];
          set25519(q3[0], X3);
          set25519(q3[1], Y3);
          set25519(q3[2], gf1);
          M3(q3[3], X3, Y3);
          scalarmult(p2, q3, s2);
        }
        function crypto_sign_keypair(pk, sk, seeded) {
          var d2 = new Uint8Array(64);
          var p2 = [gf(), gf(), gf(), gf()];
          var i2;
          if (!seeded) randombytes(sk, 32);
          crypto_hash(d2, sk, 32);
          d2[0] &= 248;
          d2[31] &= 127;
          d2[31] |= 64;
          scalarbase(p2, d2);
          pack(pk, p2);
          for (i2 = 0; i2 < 32; i2++) sk[i2 + 32] = pk[i2];
          return 0;
        }
        var L3 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
        function modL(r3, x3) {
          var carry, i2, j3, k3;
          for (i2 = 63; i2 >= 32; --i2) {
            carry = 0;
            for (j3 = i2 - 32, k3 = i2 - 12; j3 < k3; ++j3) {
              x3[j3] += carry - 16 * x3[i2] * L3[j3 - (i2 - 32)];
              carry = Math.floor((x3[j3] + 128) / 256);
              x3[j3] -= carry * 256;
            }
            x3[j3] += carry;
            x3[i2] = 0;
          }
          carry = 0;
          for (j3 = 0; j3 < 32; j3++) {
            x3[j3] += carry - (x3[31] >> 4) * L3[j3];
            carry = x3[j3] >> 8;
            x3[j3] &= 255;
          }
          for (j3 = 0; j3 < 32; j3++) x3[j3] -= carry * L3[j3];
          for (i2 = 0; i2 < 32; i2++) {
            x3[i2 + 1] += x3[i2] >> 8;
            r3[i2] = x3[i2] & 255;
          }
        }
        function reduce(r3) {
          var x3 = new Float64Array(64), i2;
          for (i2 = 0; i2 < 64; i2++) x3[i2] = r3[i2];
          for (i2 = 0; i2 < 64; i2++) r3[i2] = 0;
          modL(r3, x3);
        }
        function crypto_sign(sm, m3, n3, sk) {
          var d2 = new Uint8Array(64), h3 = new Uint8Array(64), r3 = new Uint8Array(64);
          var i2, j3, x3 = new Float64Array(64);
          var p2 = [gf(), gf(), gf(), gf()];
          crypto_hash(d2, sk, 32);
          d2[0] &= 248;
          d2[31] &= 127;
          d2[31] |= 64;
          var smlen = n3 + 64;
          for (i2 = 0; i2 < n3; i2++) sm[64 + i2] = m3[i2];
          for (i2 = 0; i2 < 32; i2++) sm[32 + i2] = d2[32 + i2];
          crypto_hash(r3, sm.subarray(32), n3 + 32);
          reduce(r3);
          scalarbase(p2, r3);
          pack(sm, p2);
          for (i2 = 32; i2 < 64; i2++) sm[i2] = sk[i2];
          crypto_hash(h3, sm, n3 + 64);
          reduce(h3);
          for (i2 = 0; i2 < 64; i2++) x3[i2] = 0;
          for (i2 = 0; i2 < 32; i2++) x3[i2] = r3[i2];
          for (i2 = 0; i2 < 32; i2++) {
            for (j3 = 0; j3 < 32; j3++) {
              x3[i2 + j3] += h3[i2] * d2[j3];
            }
          }
          modL(sm.subarray(32), x3);
          return smlen;
        }
        function unpackneg(r3, p2) {
          var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
          set25519(r3[2], gf1);
          unpack25519(r3[1], p2);
          S3(num, r3[1]);
          M3(den, num, D3);
          Z3(num, num, r3[2]);
          A3(den, r3[2], den);
          S3(den2, den);
          S3(den4, den2);
          M3(den6, den4, den2);
          M3(t, den6, num);
          M3(t, t, den);
          pow2523(t, t);
          M3(t, t, num);
          M3(t, t, den);
          M3(t, t, den);
          M3(r3[0], t, den);
          S3(chk, r3[0]);
          M3(chk, chk, den);
          if (neq25519(chk, num)) M3(r3[0], r3[0], I3);
          S3(chk, r3[0]);
          M3(chk, chk, den);
          if (neq25519(chk, num)) return -1;
          if (par25519(r3[0]) === p2[31] >> 7) Z3(r3[0], gf0, r3[0]);
          M3(r3[3], r3[0], r3[1]);
          return 0;
        }
        function crypto_sign_open(m3, sm, n3, pk) {
          var i2;
          var t = new Uint8Array(32), h3 = new Uint8Array(64);
          var p2 = [gf(), gf(), gf(), gf()], q3 = [gf(), gf(), gf(), gf()];
          if (n3 < 64) return -1;
          if (unpackneg(q3, pk)) return -1;
          for (i2 = 0; i2 < n3; i2++) m3[i2] = sm[i2];
          for (i2 = 0; i2 < 32; i2++) m3[i2 + 32] = pk[i2];
          crypto_hash(h3, m3, n3);
          reduce(h3);
          scalarmult(p2, q3, h3);
          scalarbase(q3, sm.subarray(32));
          add(p2, q3);
          pack(t, p2);
          n3 -= 64;
          if (crypto_verify_32(sm, 0, t, 0)) {
            for (i2 = 0; i2 < n3; i2++) m3[i2] = 0;
            return -1;
          }
          for (i2 = 0; i2 < n3; i2++) m3[i2] = sm[i2 + 64];
          return n3;
        }
        var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
        nacl2.lowlevel = {
          crypto_core_hsalsa20,
          crypto_stream_xor,
          crypto_stream,
          crypto_stream_salsa20_xor,
          crypto_stream_salsa20,
          crypto_onetimeauth,
          crypto_onetimeauth_verify,
          crypto_verify_16,
          crypto_verify_32,
          crypto_secretbox,
          crypto_secretbox_open,
          crypto_scalarmult,
          crypto_scalarmult_base,
          crypto_box_beforenm,
          crypto_box_afternm,
          crypto_box,
          crypto_box_open,
          crypto_box_keypair,
          crypto_hash,
          crypto_sign,
          crypto_sign_keypair,
          crypto_sign_open,
          crypto_secretbox_KEYBYTES,
          crypto_secretbox_NONCEBYTES,
          crypto_secretbox_ZEROBYTES,
          crypto_secretbox_BOXZEROBYTES,
          crypto_scalarmult_BYTES,
          crypto_scalarmult_SCALARBYTES,
          crypto_box_PUBLICKEYBYTES,
          crypto_box_SECRETKEYBYTES,
          crypto_box_BEFORENMBYTES,
          crypto_box_NONCEBYTES,
          crypto_box_ZEROBYTES,
          crypto_box_BOXZEROBYTES,
          crypto_sign_BYTES,
          crypto_sign_PUBLICKEYBYTES,
          crypto_sign_SECRETKEYBYTES,
          crypto_sign_SEEDBYTES,
          crypto_hash_BYTES,
          gf,
          D: D3,
          L: L3,
          pack25519,
          unpack25519,
          M: M3,
          A: A3,
          S: S3,
          Z: Z3,
          pow2523,
          add,
          set25519,
          modL,
          scalarmult,
          scalarbase
        };
        function checkLengths(k3, n3) {
          if (k3.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
          if (n3.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
        }
        function checkBoxLengths(pk, sk) {
          if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
          if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
        }
        function checkArrayTypes() {
          for (var i2 = 0; i2 < arguments.length; i2++) {
            if (!(arguments[i2] instanceof Uint8Array))
              throw new TypeError("unexpected type, use Uint8Array");
          }
        }
        function cleanup(arr) {
          for (var i2 = 0; i2 < arr.length; i2++) arr[i2] = 0;
        }
        nacl2.randomBytes = function(n3) {
          var b3 = new Uint8Array(n3);
          randombytes(b3, n3);
          return b3;
        };
        nacl2.secretbox = function(msg, nonce, key) {
          checkArrayTypes(msg, nonce, key);
          checkLengths(key, nonce);
          var m3 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
          var c2 = new Uint8Array(m3.length);
          for (var i2 = 0; i2 < msg.length; i2++) m3[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
          crypto_secretbox(c2, m3, m3.length, nonce, key);
          return c2.subarray(crypto_secretbox_BOXZEROBYTES);
        };
        nacl2.secretbox.open = function(box, nonce, key) {
          checkArrayTypes(box, nonce, key);
          checkLengths(key, nonce);
          var c2 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
          var m3 = new Uint8Array(c2.length);
          for (var i2 = 0; i2 < box.length; i2++) c2[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
          if (c2.length < 32) return null;
          if (crypto_secretbox_open(m3, c2, c2.length, nonce, key) !== 0) return null;
          return m3.subarray(crypto_secretbox_ZEROBYTES);
        };
        nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
        nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
        nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
        nacl2.scalarMult = function(n3, p2) {
          checkArrayTypes(n3, p2);
          if (n3.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
          if (p2.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
          var q3 = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult(q3, n3, p2);
          return q3;
        };
        nacl2.scalarMult.base = function(n3) {
          checkArrayTypes(n3);
          if (n3.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
          var q3 = new Uint8Array(crypto_scalarmult_BYTES);
          crypto_scalarmult_base(q3, n3);
          return q3;
        };
        nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
        nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
        nacl2.box = function(msg, nonce, publicKey, secretKey) {
          var k3 = nacl2.box.before(publicKey, secretKey);
          return nacl2.secretbox(msg, nonce, k3);
        };
        nacl2.box.before = function(publicKey, secretKey) {
          checkArrayTypes(publicKey, secretKey);
          checkBoxLengths(publicKey, secretKey);
          var k3 = new Uint8Array(crypto_box_BEFORENMBYTES);
          crypto_box_beforenm(k3, publicKey, secretKey);
          return k3;
        };
        nacl2.box.after = nacl2.secretbox;
        nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
          var k3 = nacl2.box.before(publicKey, secretKey);
          return nacl2.secretbox.open(msg, nonce, k3);
        };
        nacl2.box.open.after = nacl2.secretbox.open;
        nacl2.box.keyPair = function() {
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
          crypto_box_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl2.box.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_box_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
          crypto_scalarmult_base(pk, secretKey);
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
        nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
        nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
        nacl2.box.nonceLength = crypto_box_NONCEBYTES;
        nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
        nacl2.sign = function(msg, secretKey) {
          checkArrayTypes(msg, secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
          crypto_sign(signedMsg, msg, msg.length, secretKey);
          return signedMsg;
        };
        nacl2.sign.open = function(signedMsg, publicKey) {
          checkArrayTypes(signedMsg, publicKey);
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var tmp = new Uint8Array(signedMsg.length);
          var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
          if (mlen < 0) return null;
          var m3 = new Uint8Array(mlen);
          for (var i2 = 0; i2 < m3.length; i2++) m3[i2] = tmp[i2];
          return m3;
        };
        nacl2.sign.detached = function(msg, secretKey) {
          var signedMsg = nacl2.sign(msg, secretKey);
          var sig = new Uint8Array(crypto_sign_BYTES);
          for (var i2 = 0; i2 < sig.length; i2++) sig[i2] = signedMsg[i2];
          return sig;
        };
        nacl2.sign.detached.verify = function(msg, sig, publicKey) {
          checkArrayTypes(msg, sig, publicKey);
          if (sig.length !== crypto_sign_BYTES)
            throw new Error("bad signature size");
          if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
            throw new Error("bad public key size");
          var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
          var m3 = new Uint8Array(crypto_sign_BYTES + msg.length);
          var i2;
          for (i2 = 0; i2 < crypto_sign_BYTES; i2++) sm[i2] = sig[i2];
          for (i2 = 0; i2 < msg.length; i2++) sm[i2 + crypto_sign_BYTES] = msg[i2];
          return crypto_sign_open(m3, sm, sm.length, publicKey) >= 0;
        };
        nacl2.sign.keyPair = function() {
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          crypto_sign_keypair(pk, sk);
          return { publicKey: pk, secretKey: sk };
        };
        nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
          checkArrayTypes(secretKey);
          if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
            throw new Error("bad secret key size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          for (var i2 = 0; i2 < pk.length; i2++) pk[i2] = secretKey[32 + i2];
          return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
        };
        nacl2.sign.keyPair.fromSeed = function(seed) {
          checkArrayTypes(seed);
          if (seed.length !== crypto_sign_SEEDBYTES)
            throw new Error("bad seed size");
          var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
          var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
          for (var i2 = 0; i2 < 32; i2++) sk[i2] = seed[i2];
          crypto_sign_keypair(pk, sk, true);
          return { publicKey: pk, secretKey: sk };
        };
        nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
        nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
        nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
        nacl2.sign.signatureLength = crypto_sign_BYTES;
        nacl2.hash = function(msg) {
          checkArrayTypes(msg);
          var h3 = new Uint8Array(crypto_hash_BYTES);
          crypto_hash(h3, msg, msg.length);
          return h3;
        };
        nacl2.hash.hashLength = crypto_hash_BYTES;
        nacl2.verify = function(x3, y3) {
          checkArrayTypes(x3, y3);
          if (x3.length === 0 || y3.length === 0) return false;
          if (x3.length !== y3.length) return false;
          return vn(x3, 0, y3, 0, x3.length) === 0 ? true : false;
        };
        nacl2.setPRNG = function(fn) {
          randombytes = fn;
        };
        (function() {
          var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
          if (crypto2 && crypto2.getRandomValues) {
            var QUOTA = 65536;
            nacl2.setPRNG(function(x3, n3) {
              var i2, v3 = new Uint8Array(n3);
              for (i2 = 0; i2 < n3; i2 += QUOTA) {
                crypto2.getRandomValues(v3.subarray(i2, i2 + Math.min(n3 - i2, QUOTA)));
              }
              for (i2 = 0; i2 < n3; i2++) x3[i2] = v3[i2];
              cleanup(v3);
            });
          } else if (typeof __require !== "undefined") {
            crypto2 = require_crypto2();
            if (crypto2 && crypto2.randomBytes) {
              nacl2.setPRNG(function(x3, n3) {
                var i2, v3 = crypto2.randomBytes(n3);
                for (i2 = 0; i2 < n3; i2++) x3[i2] = v3[i2];
                cleanup(v3);
              });
            }
          }
        })();
      })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
    }
  });

  // node_modules/js-sha512/src/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/js-sha512/src/sha512.js"(exports, module) {
      init_polyfills();
      (function() {
        "use strict";
        var INPUT_ERROR = "input is invalid type";
        var FINALIZE_ERROR = "finalize already called";
        var WINDOW = typeof window === "object";
        var root = WINDOW ? window : {};
        if (root.JS_SHA512_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        } else if (WEB_WORKER) {
          root = self;
        }
        var COMMON_JS = !root.JS_SHA512_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var EXTRA = [-2147483648, 8388608, 32768, 128];
        var SHIFT = [24, 16, 8, 0];
        var K3 = [
          1116352408,
          3609767458,
          1899447441,
          602891725,
          3049323471,
          3964484399,
          3921009573,
          2173295548,
          961987163,
          4081628472,
          1508970993,
          3053834265,
          2453635748,
          2937671579,
          2870763221,
          3664609560,
          3624381080,
          2734883394,
          310598401,
          1164996542,
          607225278,
          1323610764,
          1426881987,
          3590304994,
          1925078388,
          4068182383,
          2162078206,
          991336113,
          2614888103,
          633803317,
          3248222580,
          3479774868,
          3835390401,
          2666613458,
          4022224774,
          944711139,
          264347078,
          2341262773,
          604807628,
          2007800933,
          770255983,
          1495990901,
          1249150122,
          1856431235,
          1555081692,
          3175218132,
          1996064986,
          2198950837,
          2554220882,
          3999719339,
          2821834349,
          766784016,
          2952996808,
          2566594879,
          3210313671,
          3203337956,
          3336571891,
          1034457026,
          3584528711,
          2466948901,
          113926993,
          3758326383,
          338241895,
          168717936,
          666307205,
          1188179964,
          773529912,
          1546045734,
          1294757372,
          1522805485,
          1396182291,
          2643833823,
          1695183700,
          2343527390,
          1986661051,
          1014477480,
          2177026350,
          1206759142,
          2456956037,
          344077627,
          2730485921,
          1290863460,
          2820302411,
          3158454273,
          3259730800,
          3505952657,
          3345764771,
          106217008,
          3516065817,
          3606008344,
          3600352804,
          1432725776,
          4094571909,
          1467031594,
          275423344,
          851169720,
          430227734,
          3100823752,
          506948616,
          1363258195,
          659060556,
          3750685593,
          883997877,
          3785050280,
          958139571,
          3318307427,
          1322822218,
          3812723403,
          1537002063,
          2003034995,
          1747873779,
          3602036899,
          1955562222,
          1575990012,
          2024104815,
          1125592928,
          2227730452,
          2716904306,
          2361852424,
          442776044,
          2428436474,
          593698344,
          2756734187,
          3733110249,
          3204031479,
          2999351573,
          3329325298,
          3815920427,
          3391569614,
          3928383900,
          3515267271,
          566280711,
          3940187606,
          3454069534,
          4118630271,
          4000239992,
          116418474,
          1914138554,
          174292421,
          2731055270,
          289380356,
          3203993006,
          460393269,
          320620315,
          685471733,
          587496836,
          852142971,
          1086792851,
          1017036298,
          365543100,
          1126000580,
          2618297676,
          1288033470,
          3409855158,
          1501505948,
          4234509866,
          1607167915,
          987167468,
          1816402316,
          1246189591
        ];
        var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
        var blocks = [];
        if (root.JS_SHA512_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(outputType, bits) {
          return function(message) {
            return new Sha512(bits, true).update(message)[outputType]();
          };
        };
        var createMethod = function(bits) {
          var method = createOutputMethod("hex", bits);
          method.create = function() {
            return new Sha512(bits);
          };
          method.update = function(message) {
            return method.create().update(message);
          };
          for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
            var type = OUTPUT_TYPES[i2];
            method[type] = createOutputMethod(type, bits);
          }
          return method;
        };
        var createHmacOutputMethod = function(outputType, bits) {
          return function(key, message) {
            return new HmacSha512(key, bits, true).update(message)[outputType]();
          };
        };
        var createHmacMethod = function(bits) {
          var method = createHmacOutputMethod("hex", bits);
          method.create = function(key) {
            return new HmacSha512(key, bits);
          };
          method.update = function(key, message) {
            return method.create(key).update(message);
          };
          for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
            var type = OUTPUT_TYPES[i2];
            method[type] = createHmacOutputMethod(type, bits);
          }
          return method;
        };
        function Sha512(bits, sharedMemory) {
          if (sharedMemory) {
            blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
            this.blocks = blocks;
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
          if (bits == 384) {
            this.h0h = 3418070365;
            this.h0l = 3238371032;
            this.h1h = 1654270250;
            this.h1l = 914150663;
            this.h2h = 2438529370;
            this.h2l = 812702999;
            this.h3h = 355462360;
            this.h3l = 4144912697;
            this.h4h = 1731405415;
            this.h4l = 4290775857;
            this.h5h = 2394180231;
            this.h5l = 1750603025;
            this.h6h = 3675008525;
            this.h6l = 1694076839;
            this.h7h = 1203062813;
            this.h7l = 3204075428;
          } else if (bits == 256) {
            this.h0h = 573645204;
            this.h0l = 4230739756;
            this.h1h = 2673172387;
            this.h1l = 3360449730;
            this.h2h = 596883563;
            this.h2l = 1867755857;
            this.h3h = 2520282905;
            this.h3l = 1497426621;
            this.h4h = 2519219938;
            this.h4l = 2827943907;
            this.h5h = 3193839141;
            this.h5l = 1401305490;
            this.h6h = 721525244;
            this.h6l = 746961066;
            this.h7h = 246885852;
            this.h7l = 2177182882;
          } else if (bits == 224) {
            this.h0h = 2352822216;
            this.h0l = 424955298;
            this.h1h = 1944164710;
            this.h1l = 2312950998;
            this.h2h = 502970286;
            this.h2l = 855612546;
            this.h3h = 1738396948;
            this.h3l = 1479516111;
            this.h4h = 258812777;
            this.h4l = 2077511080;
            this.h5h = 2011393907;
            this.h5l = 79989058;
            this.h6h = 1067287976;
            this.h6l = 1780299464;
            this.h7h = 286451373;
            this.h7l = 2446758561;
          } else {
            this.h0h = 1779033703;
            this.h0l = 4089235720;
            this.h1h = 3144134277;
            this.h1l = 2227873595;
            this.h2h = 1013904242;
            this.h2l = 4271175723;
            this.h3h = 2773480762;
            this.h3l = 1595750129;
            this.h4h = 1359893119;
            this.h4l = 2917565137;
            this.h5h = 2600822924;
            this.h5l = 725511199;
            this.h6h = 528734635;
            this.h6l = 4215389547;
            this.h7h = 1541459225;
            this.h7l = 327033209;
          }
          this.bits = bits;
          this.block = this.start = this.bytes = this.hBytes = 0;
          this.finalized = this.hashed = false;
        }
        Sha512.prototype.update = function(message) {
          if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var code, index = 0, i2, length = message.length, blocks2 = this.blocks;
          while (index < length) {
            if (this.hashed) {
              this.hashed = false;
              blocks2[0] = this.block;
              blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
            }
            if (notString) {
              for (i2 = this.start; index < length && i2 < 128; ++index) {
                blocks2[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
              }
            } else {
              for (i2 = this.start; index < length && i2 < 128; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i2 >> 2] |= code << SHIFT[i2++ & 3];
                } else if (code < 2048) {
                  blocks2[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                  blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
                }
              }
            }
            this.lastByteIndex = i2;
            this.bytes += i2 - this.start;
            if (i2 >= 128) {
              this.block = blocks2[32];
              this.start = i2 - 128;
              this.hash();
              this.hashed = true;
            } else {
              this.start = i2;
            }
          }
          if (this.bytes > 4294967295) {
            this.hBytes += this.bytes / 4294967296 << 0;
            this.bytes = this.bytes % 4294967296;
          }
          return this;
        };
        Sha512.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks2 = this.blocks, i2 = this.lastByteIndex;
          blocks2[32] = this.block;
          blocks2[i2 >> 2] |= EXTRA[i2 & 3];
          this.block = blocks2[32];
          if (i2 >= 112) {
            if (!this.hashed) {
              this.hash();
            }
            blocks2[0] = this.block;
            blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
          }
          blocks2[30] = this.hBytes << 3 | this.bytes >>> 29;
          blocks2[31] = this.bytes << 3;
          this.hash();
        };
        Sha512.prototype.hash = function() {
          var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks2 = this.blocks, j3, s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
          for (j3 = 32; j3 < 160; j3 += 2) {
            t1h = blocks2[j3 - 30];
            t1l = blocks2[j3 - 29];
            s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
            s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
            t1h = blocks2[j3 - 4];
            t1l = blocks2[j3 - 3];
            s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
            s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
            t1h = blocks2[j3 - 32];
            t1l = blocks2[j3 - 31];
            t2h = blocks2[j3 - 14];
            t2l = blocks2[j3 - 13];
            c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
            blocks2[j3] = c4 << 16 | c3 & 65535;
            blocks2[j3 + 1] = c2 << 16 | c1 & 65535;
          }
          var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
          bch = bh & ch;
          bcl = bl & cl;
          for (j3 = 0; j3 < 160; j3 += 8) {
            s0h = (ah >>> 28 | al << 4) ^ (al >>> 2 | ah << 30) ^ (al >>> 7 | ah << 25);
            s0l = (al >>> 28 | ah << 4) ^ (ah >>> 2 | al << 30) ^ (ah >>> 7 | al << 25);
            s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23);
            s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23);
            abh = ah & bh;
            abl = al & bl;
            majh = abh ^ ah & ch ^ bch;
            majl = abl ^ al & cl ^ bcl;
            chh = eh & fh ^ ~eh & gh;
            chl = el & fl ^ ~el & gl;
            t1h = blocks2[j3];
            t1l = blocks2[j3 + 1];
            t2h = K3[j3];
            t2l = K3[j3 + 1];
            c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
            t1h = c4 << 16 | c3 & 65535;
            t1l = c2 << 16 | c1 & 65535;
            c1 = (majl & 65535) + (s0l & 65535);
            c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
            c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
            c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
            t2h = c4 << 16 | c3 & 65535;
            t2l = c2 << 16 | c1 & 65535;
            c1 = (dl & 65535) + (t1l & 65535);
            c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (dh & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            hh = c4 << 16 | c3 & 65535;
            hl = c2 << 16 | c1 & 65535;
            c1 = (t2l & 65535) + (t1l & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            dh = c4 << 16 | c3 & 65535;
            dl = c2 << 16 | c1 & 65535;
            s0h = (dh >>> 28 | dl << 4) ^ (dl >>> 2 | dh << 30) ^ (dl >>> 7 | dh << 25);
            s0l = (dl >>> 28 | dh << 4) ^ (dh >>> 2 | dl << 30) ^ (dh >>> 7 | dl << 25);
            s1h = (hh >>> 14 | hl << 18) ^ (hh >>> 18 | hl << 14) ^ (hl >>> 9 | hh << 23);
            s1l = (hl >>> 14 | hh << 18) ^ (hl >>> 18 | hh << 14) ^ (hh >>> 9 | hl << 23);
            dah = dh & ah;
            dal = dl & al;
            majh = dah ^ dh & bh ^ abh;
            majl = dal ^ dl & bl ^ abl;
            chh = hh & eh ^ ~hh & fh;
            chl = hl & el ^ ~hl & fl;
            t1h = blocks2[j3 + 2];
            t1l = blocks2[j3 + 3];
            t2h = K3[j3 + 2];
            t2l = K3[j3 + 3];
            c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
            t1h = c4 << 16 | c3 & 65535;
            t1l = c2 << 16 | c1 & 65535;
            c1 = (majl & 65535) + (s0l & 65535);
            c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
            c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
            c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
            t2h = c4 << 16 | c3 & 65535;
            t2l = c2 << 16 | c1 & 65535;
            c1 = (cl & 65535) + (t1l & 65535);
            c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (ch & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            gh = c4 << 16 | c3 & 65535;
            gl = c2 << 16 | c1 & 65535;
            c1 = (t2l & 65535) + (t1l & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            ch = c4 << 16 | c3 & 65535;
            cl = c2 << 16 | c1 & 65535;
            s0h = (ch >>> 28 | cl << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25);
            s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25);
            s1h = (gh >>> 14 | gl << 18) ^ (gh >>> 18 | gl << 14) ^ (gl >>> 9 | gh << 23);
            s1l = (gl >>> 14 | gh << 18) ^ (gl >>> 18 | gh << 14) ^ (gh >>> 9 | gl << 23);
            cdh = ch & dh;
            cdl = cl & dl;
            majh = cdh ^ ch & ah ^ dah;
            majl = cdl ^ cl & al ^ dal;
            chh = gh & hh ^ ~gh & eh;
            chl = gl & hl ^ ~gl & el;
            t1h = blocks2[j3 + 4];
            t1l = blocks2[j3 + 5];
            t2h = K3[j3 + 4];
            t2l = K3[j3 + 5];
            c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
            t1h = c4 << 16 | c3 & 65535;
            t1l = c2 << 16 | c1 & 65535;
            c1 = (majl & 65535) + (s0l & 65535);
            c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
            c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
            c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
            t2h = c4 << 16 | c3 & 65535;
            t2l = c2 << 16 | c1 & 65535;
            c1 = (bl & 65535) + (t1l & 65535);
            c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (bh & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            fh = c4 << 16 | c3 & 65535;
            fl = c2 << 16 | c1 & 65535;
            c1 = (t2l & 65535) + (t1l & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            bh = c4 << 16 | c3 & 65535;
            bl = c2 << 16 | c1 & 65535;
            s0h = (bh >>> 28 | bl << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25);
            s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25);
            s1h = (fh >>> 14 | fl << 18) ^ (fh >>> 18 | fl << 14) ^ (fl >>> 9 | fh << 23);
            s1l = (fl >>> 14 | fh << 18) ^ (fl >>> 18 | fh << 14) ^ (fh >>> 9 | fl << 23);
            bch = bh & ch;
            bcl = bl & cl;
            majh = bch ^ bh & dh ^ cdh;
            majl = bcl ^ bl & dl ^ cdl;
            chh = fh & gh ^ ~fh & hh;
            chl = fl & gl ^ ~fl & hl;
            t1h = blocks2[j3 + 6];
            t1l = blocks2[j3 + 7];
            t2h = K3[j3 + 6];
            t2l = K3[j3 + 7];
            c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
            t1h = c4 << 16 | c3 & 65535;
            t1l = c2 << 16 | c1 & 65535;
            c1 = (majl & 65535) + (s0l & 65535);
            c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
            c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
            c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
            t2h = c4 << 16 | c3 & 65535;
            t2l = c2 << 16 | c1 & 65535;
            c1 = (al & 65535) + (t1l & 65535);
            c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (ah & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            eh = c4 << 16 | c3 & 65535;
            el = c2 << 16 | c1 & 65535;
            c1 = (t2l & 65535) + (t1l & 65535);
            c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
            c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
            c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
            ah = c4 << 16 | c3 & 65535;
            al = c2 << 16 | c1 & 65535;
          }
          c1 = (h0l & 65535) + (al & 65535);
          c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
          c3 = (h0h & 65535) + (ah & 65535) + (c2 >>> 16);
          c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
          this.h0h = c4 << 16 | c3 & 65535;
          this.h0l = c2 << 16 | c1 & 65535;
          c1 = (h1l & 65535) + (bl & 65535);
          c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
          c3 = (h1h & 65535) + (bh & 65535) + (c2 >>> 16);
          c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
          this.h1h = c4 << 16 | c3 & 65535;
          this.h1l = c2 << 16 | c1 & 65535;
          c1 = (h2l & 65535) + (cl & 65535);
          c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
          c3 = (h2h & 65535) + (ch & 65535) + (c2 >>> 16);
          c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
          this.h2h = c4 << 16 | c3 & 65535;
          this.h2l = c2 << 16 | c1 & 65535;
          c1 = (h3l & 65535) + (dl & 65535);
          c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
          c3 = (h3h & 65535) + (dh & 65535) + (c2 >>> 16);
          c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
          this.h3h = c4 << 16 | c3 & 65535;
          this.h3l = c2 << 16 | c1 & 65535;
          c1 = (h4l & 65535) + (el & 65535);
          c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
          c3 = (h4h & 65535) + (eh & 65535) + (c2 >>> 16);
          c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
          this.h4h = c4 << 16 | c3 & 65535;
          this.h4l = c2 << 16 | c1 & 65535;
          c1 = (h5l & 65535) + (fl & 65535);
          c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
          c3 = (h5h & 65535) + (fh & 65535) + (c2 >>> 16);
          c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
          this.h5h = c4 << 16 | c3 & 65535;
          this.h5l = c2 << 16 | c1 & 65535;
          c1 = (h6l & 65535) + (gl & 65535);
          c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
          c3 = (h6h & 65535) + (gh & 65535) + (c2 >>> 16);
          c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
          this.h6h = c4 << 16 | c3 & 65535;
          this.h6l = c2 << 16 | c1 & 65535;
          c1 = (h7l & 65535) + (hl & 65535);
          c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
          c3 = (h7h & 65535) + (hh & 65535) + (c2 >>> 16);
          c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
          this.h7h = c4 << 16 | c3 & 65535;
          this.h7l = c2 << 16 | c1 & 65535;
        };
        Sha512.prototype.hex = function() {
          this.finalize();
          var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
          var hex = HEX_CHARS[h0h >> 28 & 15] + HEX_CHARS[h0h >> 24 & 15] + HEX_CHARS[h0h >> 20 & 15] + HEX_CHARS[h0h >> 16 & 15] + HEX_CHARS[h0h >> 12 & 15] + HEX_CHARS[h0h >> 8 & 15] + HEX_CHARS[h0h >> 4 & 15] + HEX_CHARS[h0h & 15] + HEX_CHARS[h0l >> 28 & 15] + HEX_CHARS[h0l >> 24 & 15] + HEX_CHARS[h0l >> 20 & 15] + HEX_CHARS[h0l >> 16 & 15] + HEX_CHARS[h0l >> 12 & 15] + HEX_CHARS[h0l >> 8 & 15] + HEX_CHARS[h0l >> 4 & 15] + HEX_CHARS[h0l & 15] + HEX_CHARS[h1h >> 28 & 15] + HEX_CHARS[h1h >> 24 & 15] + HEX_CHARS[h1h >> 20 & 15] + HEX_CHARS[h1h >> 16 & 15] + HEX_CHARS[h1h >> 12 & 15] + HEX_CHARS[h1h >> 8 & 15] + HEX_CHARS[h1h >> 4 & 15] + HEX_CHARS[h1h & 15] + HEX_CHARS[h1l >> 28 & 15] + HEX_CHARS[h1l >> 24 & 15] + HEX_CHARS[h1l >> 20 & 15] + HEX_CHARS[h1l >> 16 & 15] + HEX_CHARS[h1l >> 12 & 15] + HEX_CHARS[h1l >> 8 & 15] + HEX_CHARS[h1l >> 4 & 15] + HEX_CHARS[h1l & 15] + HEX_CHARS[h2h >> 28 & 15] + HEX_CHARS[h2h >> 24 & 15] + HEX_CHARS[h2h >> 20 & 15] + HEX_CHARS[h2h >> 16 & 15] + HEX_CHARS[h2h >> 12 & 15] + HEX_CHARS[h2h >> 8 & 15] + HEX_CHARS[h2h >> 4 & 15] + HEX_CHARS[h2h & 15] + HEX_CHARS[h2l >> 28 & 15] + HEX_CHARS[h2l >> 24 & 15] + HEX_CHARS[h2l >> 20 & 15] + HEX_CHARS[h2l >> 16 & 15] + HEX_CHARS[h2l >> 12 & 15] + HEX_CHARS[h2l >> 8 & 15] + HEX_CHARS[h2l >> 4 & 15] + HEX_CHARS[h2l & 15] + HEX_CHARS[h3h >> 28 & 15] + HEX_CHARS[h3h >> 24 & 15] + HEX_CHARS[h3h >> 20 & 15] + HEX_CHARS[h3h >> 16 & 15] + HEX_CHARS[h3h >> 12 & 15] + HEX_CHARS[h3h >> 8 & 15] + HEX_CHARS[h3h >> 4 & 15] + HEX_CHARS[h3h & 15];
          if (bits >= 256) {
            hex += HEX_CHARS[h3l >> 28 & 15] + HEX_CHARS[h3l >> 24 & 15] + HEX_CHARS[h3l >> 20 & 15] + HEX_CHARS[h3l >> 16 & 15] + HEX_CHARS[h3l >> 12 & 15] + HEX_CHARS[h3l >> 8 & 15] + HEX_CHARS[h3l >> 4 & 15] + HEX_CHARS[h3l & 15];
          }
          if (bits >= 384) {
            hex += HEX_CHARS[h4h >> 28 & 15] + HEX_CHARS[h4h >> 24 & 15] + HEX_CHARS[h4h >> 20 & 15] + HEX_CHARS[h4h >> 16 & 15] + HEX_CHARS[h4h >> 12 & 15] + HEX_CHARS[h4h >> 8 & 15] + HEX_CHARS[h4h >> 4 & 15] + HEX_CHARS[h4h & 15] + HEX_CHARS[h4l >> 28 & 15] + HEX_CHARS[h4l >> 24 & 15] + HEX_CHARS[h4l >> 20 & 15] + HEX_CHARS[h4l >> 16 & 15] + HEX_CHARS[h4l >> 12 & 15] + HEX_CHARS[h4l >> 8 & 15] + HEX_CHARS[h4l >> 4 & 15] + HEX_CHARS[h4l & 15] + HEX_CHARS[h5h >> 28 & 15] + HEX_CHARS[h5h >> 24 & 15] + HEX_CHARS[h5h >> 20 & 15] + HEX_CHARS[h5h >> 16 & 15] + HEX_CHARS[h5h >> 12 & 15] + HEX_CHARS[h5h >> 8 & 15] + HEX_CHARS[h5h >> 4 & 15] + HEX_CHARS[h5h & 15] + HEX_CHARS[h5l >> 28 & 15] + HEX_CHARS[h5l >> 24 & 15] + HEX_CHARS[h5l >> 20 & 15] + HEX_CHARS[h5l >> 16 & 15] + HEX_CHARS[h5l >> 12 & 15] + HEX_CHARS[h5l >> 8 & 15] + HEX_CHARS[h5l >> 4 & 15] + HEX_CHARS[h5l & 15];
          }
          if (bits == 512) {
            hex += HEX_CHARS[h6h >> 28 & 15] + HEX_CHARS[h6h >> 24 & 15] + HEX_CHARS[h6h >> 20 & 15] + HEX_CHARS[h6h >> 16 & 15] + HEX_CHARS[h6h >> 12 & 15] + HEX_CHARS[h6h >> 8 & 15] + HEX_CHARS[h6h >> 4 & 15] + HEX_CHARS[h6h & 15] + HEX_CHARS[h6l >> 28 & 15] + HEX_CHARS[h6l >> 24 & 15] + HEX_CHARS[h6l >> 20 & 15] + HEX_CHARS[h6l >> 16 & 15] + HEX_CHARS[h6l >> 12 & 15] + HEX_CHARS[h6l >> 8 & 15] + HEX_CHARS[h6l >> 4 & 15] + HEX_CHARS[h6l & 15] + HEX_CHARS[h7h >> 28 & 15] + HEX_CHARS[h7h >> 24 & 15] + HEX_CHARS[h7h >> 20 & 15] + HEX_CHARS[h7h >> 16 & 15] + HEX_CHARS[h7h >> 12 & 15] + HEX_CHARS[h7h >> 8 & 15] + HEX_CHARS[h7h >> 4 & 15] + HEX_CHARS[h7h & 15] + HEX_CHARS[h7l >> 28 & 15] + HEX_CHARS[h7l >> 24 & 15] + HEX_CHARS[h7l >> 20 & 15] + HEX_CHARS[h7l >> 16 & 15] + HEX_CHARS[h7l >> 12 & 15] + HEX_CHARS[h7l >> 8 & 15] + HEX_CHARS[h7l >> 4 & 15] + HEX_CHARS[h7l & 15];
          }
          return hex;
        };
        Sha512.prototype.toString = Sha512.prototype.hex;
        Sha512.prototype.digest = function() {
          this.finalize();
          var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
          var arr = [
            h0h >> 24 & 255,
            h0h >> 16 & 255,
            h0h >> 8 & 255,
            h0h & 255,
            h0l >> 24 & 255,
            h0l >> 16 & 255,
            h0l >> 8 & 255,
            h0l & 255,
            h1h >> 24 & 255,
            h1h >> 16 & 255,
            h1h >> 8 & 255,
            h1h & 255,
            h1l >> 24 & 255,
            h1l >> 16 & 255,
            h1l >> 8 & 255,
            h1l & 255,
            h2h >> 24 & 255,
            h2h >> 16 & 255,
            h2h >> 8 & 255,
            h2h & 255,
            h2l >> 24 & 255,
            h2l >> 16 & 255,
            h2l >> 8 & 255,
            h2l & 255,
            h3h >> 24 & 255,
            h3h >> 16 & 255,
            h3h >> 8 & 255,
            h3h & 255
          ];
          if (bits >= 256) {
            arr.push(h3l >> 24 & 255, h3l >> 16 & 255, h3l >> 8 & 255, h3l & 255);
          }
          if (bits >= 384) {
            arr.push(
              h4h >> 24 & 255,
              h4h >> 16 & 255,
              h4h >> 8 & 255,
              h4h & 255,
              h4l >> 24 & 255,
              h4l >> 16 & 255,
              h4l >> 8 & 255,
              h4l & 255,
              h5h >> 24 & 255,
              h5h >> 16 & 255,
              h5h >> 8 & 255,
              h5h & 255,
              h5l >> 24 & 255,
              h5l >> 16 & 255,
              h5l >> 8 & 255,
              h5l & 255
            );
          }
          if (bits == 512) {
            arr.push(
              h6h >> 24 & 255,
              h6h >> 16 & 255,
              h6h >> 8 & 255,
              h6h & 255,
              h6l >> 24 & 255,
              h6l >> 16 & 255,
              h6l >> 8 & 255,
              h6l & 255,
              h7h >> 24 & 255,
              h7h >> 16 & 255,
              h7h >> 8 & 255,
              h7h & 255,
              h7l >> 24 & 255,
              h7l >> 16 & 255,
              h7l >> 8 & 255,
              h7l & 255
            );
          }
          return arr;
        };
        Sha512.prototype.array = Sha512.prototype.digest;
        Sha512.prototype.arrayBuffer = function() {
          this.finalize();
          var bits = this.bits;
          var buffer = new ArrayBuffer(bits / 8);
          var dataView = new DataView(buffer);
          dataView.setUint32(0, this.h0h);
          dataView.setUint32(4, this.h0l);
          dataView.setUint32(8, this.h1h);
          dataView.setUint32(12, this.h1l);
          dataView.setUint32(16, this.h2h);
          dataView.setUint32(20, this.h2l);
          dataView.setUint32(24, this.h3h);
          if (bits >= 256) {
            dataView.setUint32(28, this.h3l);
          }
          if (bits >= 384) {
            dataView.setUint32(32, this.h4h);
            dataView.setUint32(36, this.h4l);
            dataView.setUint32(40, this.h5h);
            dataView.setUint32(44, this.h5l);
          }
          if (bits == 512) {
            dataView.setUint32(48, this.h6h);
            dataView.setUint32(52, this.h6l);
            dataView.setUint32(56, this.h7h);
            dataView.setUint32(60, this.h7l);
          }
          return buffer;
        };
        Sha512.prototype.clone = function() {
          var hash = new Sha512(this.bits, false);
          this.copyTo(hash);
          return hash;
        };
        Sha512.prototype.copyTo = function(hash) {
          var i2 = 0, attrs = [
            "h0h",
            "h0l",
            "h1h",
            "h1l",
            "h2h",
            "h2l",
            "h3h",
            "h3l",
            "h4h",
            "h4l",
            "h5h",
            "h5l",
            "h6h",
            "h6l",
            "h7h",
            "h7l",
            "start",
            "bytes",
            "hBytes",
            "finalized",
            "hashed",
            "lastByteIndex"
          ];
          for (i2 = 0; i2 < attrs.length; ++i2) {
            hash[attrs[i2]] = this[attrs[i2]];
          }
          for (i2 = 0; i2 < this.blocks.length; ++i2) {
            hash.blocks[i2] = this.blocks[i2];
          }
        };
        function HmacSha512(key, bits, sharedMemory) {
          var notString, type = typeof key;
          if (type !== "string") {
            if (type === "object") {
              if (key === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
                key = new Uint8Array(key);
              } else if (!Array.isArray(key)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var length = key.length;
          if (!notString) {
            var bytes = [], length = key.length, index = 0, code;
            for (var i2 = 0; i2 < length; ++i2) {
              code = key.charCodeAt(i2);
              if (code < 128) {
                bytes[index++] = code;
              } else if (code < 2048) {
                bytes[index++] = 192 | code >> 6;
                bytes[index++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                bytes[index++] = 224 | code >> 12;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i2) & 1023);
                bytes[index++] = 240 | code >> 18;
                bytes[index++] = 128 | code >> 12 & 63;
                bytes[index++] = 128 | code >> 6 & 63;
                bytes[index++] = 128 | code & 63;
              }
            }
            key = bytes;
          }
          if (key.length > 128) {
            key = new Sha512(bits, true).update(key).array();
          }
          var oKeyPad = [], iKeyPad = [];
          for (var i2 = 0; i2 < 128; ++i2) {
            var b3 = key[i2] || 0;
            oKeyPad[i2] = 92 ^ b3;
            iKeyPad[i2] = 54 ^ b3;
          }
          Sha512.call(this, bits, sharedMemory);
          this.update(iKeyPad);
          this.oKeyPad = oKeyPad;
          this.inner = true;
          this.sharedMemory = sharedMemory;
        }
        HmacSha512.prototype = new Sha512();
        HmacSha512.prototype.finalize = function() {
          Sha512.prototype.finalize.call(this);
          if (this.inner) {
            this.inner = false;
            var innerHash = this.array();
            Sha512.call(this, this.bits, this.sharedMemory);
            this.update(this.oKeyPad);
            this.update(innerHash);
            Sha512.prototype.finalize.call(this);
          }
        };
        HmacSha512.prototype.clone = function() {
          var hash = new HmacSha512([], this.bits, false);
          this.copyTo(hash);
          hash.inner = this.inner;
          for (var i2 = 0; i2 < this.oKeyPad.length; ++i2) {
            hash.oKeyPad[i2] = this.oKeyPad[i2];
          }
          return hash;
        };
        var exports2 = createMethod(512);
        exports2.sha512 = exports2;
        exports2.sha384 = createMethod(384);
        exports2.sha512_256 = createMethod(256);
        exports2.sha512_224 = createMethod(224);
        exports2.sha512.hmac = createHmacMethod(512);
        exports2.sha384.hmac = createHmacMethod(384);
        exports2.sha512_256.hmac = createHmacMethod(256);
        exports2.sha512_224.hmac = createHmacMethod(224);
        if (COMMON_JS) {
          module.exports = exports2;
        } else {
          root.sha512 = exports2.sha512;
          root.sha384 = exports2.sha384;
          root.sha512_256 = exports2.sha512_256;
          root.sha512_224 = exports2.sha512_224;
          if (AMD) {
            define(function() {
              return exports2;
            });
          }
        }
      })();
    }
  });

  // node_modules/bignumber.js/bignumber.js
  var require_bignumber = __commonJS({
    "node_modules/bignumber.js/bignumber.js"(exports, module) {
      init_polyfills();
      (function(globalObject) {
        "use strict";
        var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
        function clone(configObject) {
          var div, convertBase, parseNumeric, P3 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: "\xA0",
            // non-breaking space
            suffix: ""
          }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
          function BigNumber2(v3, b3) {
            var alphabet, c2, caseChanged, e2, i2, isNum, len, str, x3 = this;
            if (!(x3 instanceof BigNumber2)) return new BigNumber2(v3, b3);
            if (b3 == null) {
              if (v3 && v3._isBigNumber === true) {
                x3.s = v3.s;
                if (!v3.c || v3.e > MAX_EXP) {
                  x3.c = x3.e = null;
                } else if (v3.e < MIN_EXP) {
                  x3.c = [x3.e = 0];
                } else {
                  x3.e = v3.e;
                  x3.c = v3.c.slice();
                }
                return;
              }
              if ((isNum = typeof v3 == "number") && v3 * 0 == 0) {
                x3.s = 1 / v3 < 0 ? (v3 = -v3, -1) : 1;
                if (v3 === ~~v3) {
                  for (e2 = 0, i2 = v3; i2 >= 10; i2 /= 10, e2++) ;
                  if (e2 > MAX_EXP) {
                    x3.c = x3.e = null;
                  } else {
                    x3.e = e2;
                    x3.c = [v3];
                  }
                  return;
                }
                str = String(v3);
              } else {
                if (!isNumeric.test(str = String(v3))) return parseNumeric(x3, str, isNum);
                x3.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
              }
              if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
              if ((i2 = str.search(/e/i)) > 0) {
                if (e2 < 0) e2 = i2;
                e2 += +str.slice(i2 + 1);
                str = str.substring(0, i2);
              } else if (e2 < 0) {
                e2 = str.length;
              }
            } else {
              intCheck(b3, 2, ALPHABET.length, "Base");
              if (b3 == 10 && alphabetHasNormalDecimalDigits) {
                x3 = new BigNumber2(v3);
                return round(x3, DECIMAL_PLACES + x3.e + 1, ROUNDING_MODE);
              }
              str = String(v3);
              if (isNum = typeof v3 == "number") {
                if (v3 * 0 != 0) return parseNumeric(x3, str, isNum, b3);
                x3.s = 1 / v3 < 0 ? (str = str.slice(1), -1) : 1;
                if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                  throw Error(tooManyDigits + v3);
                }
              } else {
                x3.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
              }
              alphabet = ALPHABET.slice(0, b3);
              e2 = i2 = 0;
              for (len = str.length; i2 < len; i2++) {
                if (alphabet.indexOf(c2 = str.charAt(i2)) < 0) {
                  if (c2 == ".") {
                    if (i2 > e2) {
                      e2 = len;
                      continue;
                    }
                  } else if (!caseChanged) {
                    if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                      caseChanged = true;
                      i2 = -1;
                      e2 = 0;
                      continue;
                    }
                  }
                  return parseNumeric(x3, String(v3), isNum, b3);
                }
              }
              isNum = false;
              str = convertBase(str, b3, 10, x3.s);
              if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
              else e2 = str.length;
            }
            for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
            for (len = str.length; str.charCodeAt(--len) === 48; ) ;
            if (str = str.slice(i2, ++len)) {
              len -= i2;
              if (isNum && BigNumber2.DEBUG && len > 15 && (v3 > MAX_SAFE_INTEGER || v3 !== mathfloor(v3))) {
                throw Error(tooManyDigits + x3.s * v3);
              }
              if ((e2 = e2 - i2 - 1) > MAX_EXP) {
                x3.c = x3.e = null;
              } else if (e2 < MIN_EXP) {
                x3.c = [x3.e = 0];
              } else {
                x3.e = e2;
                x3.c = [];
                i2 = (e2 + 1) % LOG_BASE;
                if (e2 < 0) i2 += LOG_BASE;
                if (i2 < len) {
                  if (i2) x3.c.push(+str.slice(0, i2));
                  for (len -= LOG_BASE; i2 < len; ) {
                    x3.c.push(+str.slice(i2, i2 += LOG_BASE));
                  }
                  i2 = LOG_BASE - (str = str.slice(i2)).length;
                } else {
                  i2 -= len;
                }
                for (; i2--; str += "0") ;
                x3.c.push(+str);
              }
            } else {
              x3.c = [x3.e = 0];
            }
          }
          BigNumber2.clone = clone;
          BigNumber2.ROUND_UP = 0;
          BigNumber2.ROUND_DOWN = 1;
          BigNumber2.ROUND_CEIL = 2;
          BigNumber2.ROUND_FLOOR = 3;
          BigNumber2.ROUND_HALF_UP = 4;
          BigNumber2.ROUND_HALF_DOWN = 5;
          BigNumber2.ROUND_HALF_EVEN = 6;
          BigNumber2.ROUND_HALF_CEIL = 7;
          BigNumber2.ROUND_HALF_FLOOR = 8;
          BigNumber2.EUCLID = 9;
          BigNumber2.config = BigNumber2.set = function(obj) {
            var p2, v3;
            if (obj != null) {
              if (typeof obj == "object") {
                if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
                  v3 = obj[p2];
                  intCheck(v3, 0, MAX, p2);
                  DECIMAL_PLACES = v3;
                }
                if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
                  v3 = obj[p2];
                  intCheck(v3, 0, 8, p2);
                  ROUNDING_MODE = v3;
                }
                if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
                  v3 = obj[p2];
                  if (v3 && v3.pop) {
                    intCheck(v3[0], -MAX, 0, p2);
                    intCheck(v3[1], 0, MAX, p2);
                    TO_EXP_NEG = v3[0];
                    TO_EXP_POS = v3[1];
                  } else {
                    intCheck(v3, -MAX, MAX, p2);
                    TO_EXP_NEG = -(TO_EXP_POS = v3 < 0 ? -v3 : v3);
                  }
                }
                if (obj.hasOwnProperty(p2 = "RANGE")) {
                  v3 = obj[p2];
                  if (v3 && v3.pop) {
                    intCheck(v3[0], -MAX, -1, p2);
                    intCheck(v3[1], 1, MAX, p2);
                    MIN_EXP = v3[0];
                    MAX_EXP = v3[1];
                  } else {
                    intCheck(v3, -MAX, MAX, p2);
                    if (v3) {
                      MIN_EXP = -(MAX_EXP = v3 < 0 ? -v3 : v3);
                    } else {
                      throw Error(bignumberError + p2 + " cannot be zero: " + v3);
                    }
                  }
                }
                if (obj.hasOwnProperty(p2 = "CRYPTO")) {
                  v3 = obj[p2];
                  if (v3 === !!v3) {
                    if (v3) {
                      if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                        CRYPTO = v3;
                      } else {
                        CRYPTO = !v3;
                        throw Error(bignumberError + "crypto unavailable");
                      }
                    } else {
                      CRYPTO = v3;
                    }
                  } else {
                    throw Error(bignumberError + p2 + " not true or false: " + v3);
                  }
                }
                if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
                  v3 = obj[p2];
                  intCheck(v3, 0, 9, p2);
                  MODULO_MODE = v3;
                }
                if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
                  v3 = obj[p2];
                  intCheck(v3, 0, MAX, p2);
                  POW_PRECISION = v3;
                }
                if (obj.hasOwnProperty(p2 = "FORMAT")) {
                  v3 = obj[p2];
                  if (typeof v3 == "object") FORMAT = v3;
                  else throw Error(bignumberError + p2 + " not an object: " + v3);
                }
                if (obj.hasOwnProperty(p2 = "ALPHABET")) {
                  v3 = obj[p2];
                  if (typeof v3 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v3)) {
                    alphabetHasNormalDecimalDigits = v3.slice(0, 10) == "0123456789";
                    ALPHABET = v3;
                  } else {
                    throw Error(bignumberError + p2 + " invalid: " + v3);
                  }
                }
              } else {
                throw Error(bignumberError + "Object expected: " + obj);
              }
            }
            return {
              DECIMAL_PLACES,
              ROUNDING_MODE,
              EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
              RANGE: [MIN_EXP, MAX_EXP],
              CRYPTO,
              MODULO_MODE,
              POW_PRECISION,
              FORMAT,
              ALPHABET
            };
          };
          BigNumber2.isBigNumber = function(v3) {
            if (!v3 || v3._isBigNumber !== true) return false;
            if (!BigNumber2.DEBUG) return true;
            var i2, n3, c2 = v3.c, e2 = v3.e, s2 = v3.s;
            out: if ({}.toString.call(c2) == "[object Array]") {
              if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
                if (c2[0] === 0) {
                  if (e2 === 0 && c2.length === 1) return true;
                  break out;
                }
                i2 = (e2 + 1) % LOG_BASE;
                if (i2 < 1) i2 += LOG_BASE;
                if (String(c2[0]).length == i2) {
                  for (i2 = 0; i2 < c2.length; i2++) {
                    n3 = c2[i2];
                    if (n3 < 0 || n3 >= BASE || n3 !== mathfloor(n3)) break out;
                  }
                  if (n3 !== 0) return true;
                }
              }
            } else if (c2 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
              return true;
            }
            throw Error(bignumberError + "Invalid BigNumber: " + v3);
          };
          BigNumber2.maximum = BigNumber2.max = function() {
            return maxOrMin(arguments, -1);
          };
          BigNumber2.minimum = BigNumber2.min = function() {
            return maxOrMin(arguments, 1);
          };
          BigNumber2.random = function() {
            var pow2_53 = 9007199254740992;
            var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
              return mathfloor(Math.random() * pow2_53);
            } : function() {
              return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
            };
            return function(dp) {
              var a2, b3, e2, k3, v3, i2 = 0, c2 = [], rand = new BigNumber2(ONE);
              if (dp == null) dp = DECIMAL_PLACES;
              else intCheck(dp, 0, MAX);
              k3 = mathceil(dp / LOG_BASE);
              if (CRYPTO) {
                if (crypto.getRandomValues) {
                  a2 = crypto.getRandomValues(new Uint32Array(k3 *= 2));
                  for (; i2 < k3; ) {
                    v3 = a2[i2] * 131072 + (a2[i2 + 1] >>> 11);
                    if (v3 >= 9e15) {
                      b3 = crypto.getRandomValues(new Uint32Array(2));
                      a2[i2] = b3[0];
                      a2[i2 + 1] = b3[1];
                    } else {
                      c2.push(v3 % 1e14);
                      i2 += 2;
                    }
                  }
                  i2 = k3 / 2;
                } else if (crypto.randomBytes) {
                  a2 = crypto.randomBytes(k3 *= 7);
                  for (; i2 < k3; ) {
                    v3 = (a2[i2] & 31) * 281474976710656 + a2[i2 + 1] * 1099511627776 + a2[i2 + 2] * 4294967296 + a2[i2 + 3] * 16777216 + (a2[i2 + 4] << 16) + (a2[i2 + 5] << 8) + a2[i2 + 6];
                    if (v3 >= 9e15) {
                      crypto.randomBytes(7).copy(a2, i2);
                    } else {
                      c2.push(v3 % 1e14);
                      i2 += 7;
                    }
                  }
                  i2 = k3 / 7;
                } else {
                  CRYPTO = false;
                  throw Error(bignumberError + "crypto unavailable");
                }
              }
              if (!CRYPTO) {
                for (; i2 < k3; ) {
                  v3 = random53bitInt();
                  if (v3 < 9e15) c2[i2++] = v3 % 1e14;
                }
              }
              k3 = c2[--i2];
              dp %= LOG_BASE;
              if (k3 && dp) {
                v3 = POWS_TEN[LOG_BASE - dp];
                c2[i2] = mathfloor(k3 / v3) * v3;
              }
              for (; c2[i2] === 0; c2.pop(), i2--) ;
              if (i2 < 0) {
                c2 = [e2 = 0];
              } else {
                for (e2 = -1; c2[0] === 0; c2.splice(0, 1), e2 -= LOG_BASE) ;
                for (i2 = 1, v3 = c2[0]; v3 >= 10; v3 /= 10, i2++) ;
                if (i2 < LOG_BASE) e2 -= LOG_BASE - i2;
              }
              rand.e = e2;
              rand.c = c2;
              return rand;
            };
          }();
          BigNumber2.sum = function() {
            var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
            for (; i2 < args.length; ) sum = sum.plus(args[i2++]);
            return sum;
          };
          convertBase = /* @__PURE__ */ function() {
            var decimal = "0123456789";
            function toBaseOut(str, baseIn, baseOut, alphabet) {
              var j3, arr = [0], arrL, i2 = 0, len = str.length;
              for (; i2 < len; ) {
                for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
                arr[0] += alphabet.indexOf(str.charAt(i2++));
                for (j3 = 0; j3 < arr.length; j3++) {
                  if (arr[j3] > baseOut - 1) {
                    if (arr[j3 + 1] == null) arr[j3 + 1] = 0;
                    arr[j3 + 1] += arr[j3] / baseOut | 0;
                    arr[j3] %= baseOut;
                  }
                }
              }
              return arr.reverse();
            }
            return function(str, baseIn, baseOut, sign2, callerIsToString) {
              var alphabet, d2, e2, k3, r3, x3, xc, y3, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
              if (i2 >= 0) {
                k3 = POW_PRECISION;
                POW_PRECISION = 0;
                str = str.replace(".", "");
                y3 = new BigNumber2(baseIn);
                x3 = y3.pow(str.length - i2);
                POW_PRECISION = k3;
                y3.c = toBaseOut(
                  toFixedPoint(coeffToString(x3.c), x3.e, "0"),
                  10,
                  baseOut,
                  decimal
                );
                y3.e = y3.c.length;
              }
              xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
              e2 = k3 = xc.length;
              for (; xc[--k3] == 0; xc.pop()) ;
              if (!xc[0]) return alphabet.charAt(0);
              if (i2 < 0) {
                --e2;
              } else {
                x3.c = xc;
                x3.e = e2;
                x3.s = sign2;
                x3 = div(x3, y3, dp, rm, baseOut);
                xc = x3.c;
                r3 = x3.r;
                e2 = x3.e;
              }
              d2 = e2 + dp + 1;
              i2 = xc[d2];
              k3 = baseOut / 2;
              r3 = r3 || d2 < 0 || xc[d2 + 1] != null;
              r3 = rm < 4 ? (i2 != null || r3) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : i2 > k3 || i2 == k3 && (rm == 4 || r3 || rm == 6 && xc[d2 - 1] & 1 || rm == (x3.s < 0 ? 8 : 7));
              if (d2 < 1 || !xc[0]) {
                str = r3 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
              } else {
                xc.length = d2;
                if (r3) {
                  for (--baseOut; ++xc[--d2] > baseOut; ) {
                    xc[d2] = 0;
                    if (!d2) {
                      ++e2;
                      xc = [1].concat(xc);
                    }
                  }
                }
                for (k3 = xc.length; !xc[--k3]; ) ;
                for (i2 = 0, str = ""; i2 <= k3; str += alphabet.charAt(xc[i2++])) ;
                str = toFixedPoint(str, e2, alphabet.charAt(0));
              }
              return str;
            };
          }();
          div = /* @__PURE__ */ function() {
            function multiply(x3, k3, base) {
              var m3, temp, xlo, xhi, carry = 0, i2 = x3.length, klo = k3 % SQRT_BASE, khi = k3 / SQRT_BASE | 0;
              for (x3 = x3.slice(); i2--; ) {
                xlo = x3[i2] % SQRT_BASE;
                xhi = x3[i2] / SQRT_BASE | 0;
                m3 = khi * xlo + xhi * klo;
                temp = klo * xlo + m3 % SQRT_BASE * SQRT_BASE + carry;
                carry = (temp / base | 0) + (m3 / SQRT_BASE | 0) + khi * xhi;
                x3[i2] = temp % base;
              }
              if (carry) x3 = [carry].concat(x3);
              return x3;
            }
            function compare2(a2, b3, aL, bL) {
              var i2, cmp;
              if (aL != bL) {
                cmp = aL > bL ? 1 : -1;
              } else {
                for (i2 = cmp = 0; i2 < aL; i2++) {
                  if (a2[i2] != b3[i2]) {
                    cmp = a2[i2] > b3[i2] ? 1 : -1;
                    break;
                  }
                }
              }
              return cmp;
            }
            function subtract(a2, b3, aL, base) {
              var i2 = 0;
              for (; aL--; ) {
                a2[aL] -= i2;
                i2 = a2[aL] < b3[aL] ? 1 : 0;
                a2[aL] = i2 * base + a2[aL] - b3[aL];
              }
              for (; !a2[0] && a2.length > 1; a2.splice(0, 1)) ;
            }
            return function(x3, y3, dp, rm, base) {
              var cmp, e2, i2, more, n3, prod, prodL, q3, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x3.s == y3.s ? 1 : -1, xc = x3.c, yc = y3.c;
              if (!xc || !xc[0] || !yc || !yc[0]) {
                return new BigNumber2(
                  // Return NaN if either NaN, or both Infinity or 0.
                  !x3.s || !y3.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                    // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                    xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
                  )
                );
              }
              q3 = new BigNumber2(s2);
              qc = q3.c = [];
              e2 = x3.e - y3.e;
              s2 = dp + e2 + 1;
              if (!base) {
                base = BASE;
                e2 = bitFloor(x3.e / LOG_BASE) - bitFloor(y3.e / LOG_BASE);
                s2 = s2 / LOG_BASE | 0;
              }
              for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++) ;
              if (yc[i2] > (xc[i2] || 0)) e2--;
              if (s2 < 0) {
                qc.push(1);
                more = true;
              } else {
                xL = xc.length;
                yL = yc.length;
                i2 = 0;
                s2 += 2;
                n3 = mathfloor(base / (yc[0] + 1));
                if (n3 > 1) {
                  yc = multiply(yc, n3, base);
                  xc = multiply(xc, n3, base);
                  yL = yc.length;
                  xL = xc.length;
                }
                xi = yL;
                rem = xc.slice(0, yL);
                remL = rem.length;
                for (; remL < yL; rem[remL++] = 0) ;
                yz = yc.slice();
                yz = [0].concat(yz);
                yc0 = yc[0];
                if (yc[1] >= base / 2) yc0++;
                do {
                  n3 = 0;
                  cmp = compare2(yc, rem, yL, remL);
                  if (cmp < 0) {
                    rem0 = rem[0];
                    if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                    n3 = mathfloor(rem0 / yc0);
                    if (n3 > 1) {
                      if (n3 >= base) n3 = base - 1;
                      prod = multiply(yc, n3, base);
                      prodL = prod.length;
                      remL = rem.length;
                      while (compare2(prod, rem, prodL, remL) == 1) {
                        n3--;
                        subtract(prod, yL < prodL ? yz : yc, prodL, base);
                        prodL = prod.length;
                        cmp = 1;
                      }
                    } else {
                      if (n3 == 0) {
                        cmp = n3 = 1;
                      }
                      prod = yc.slice();
                      prodL = prod.length;
                    }
                    if (prodL < remL) prod = [0].concat(prod);
                    subtract(rem, prod, remL, base);
                    remL = rem.length;
                    if (cmp == -1) {
                      while (compare2(yc, rem, yL, remL) < 1) {
                        n3++;
                        subtract(rem, yL < remL ? yz : yc, remL, base);
                        remL = rem.length;
                      }
                    }
                  } else if (cmp === 0) {
                    n3++;
                    rem = [0];
                  }
                  qc[i2++] = n3;
                  if (rem[0]) {
                    rem[remL++] = xc[xi] || 0;
                  } else {
                    rem = [xc[xi]];
                    remL = 1;
                  }
                } while ((xi++ < xL || rem[0] != null) && s2--);
                more = rem[0] != null;
                if (!qc[0]) qc.splice(0, 1);
              }
              if (base == BASE) {
                for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++) ;
                round(q3, dp + (q3.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
              } else {
                q3.e = e2;
                q3.r = +more;
              }
              return q3;
            };
          }();
          function format(n3, i2, rm, id) {
            var c0, e2, ne2, len, str;
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            if (!n3.c) return n3.toString();
            c0 = n3.c[0];
            ne2 = n3.e;
            if (i2 == null) {
              str = coeffToString(n3.c);
              str = id == 1 || id == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
            } else {
              n3 = round(new BigNumber2(n3), i2, rm);
              e2 = n3.e;
              str = coeffToString(n3.c);
              len = str.length;
              if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
                for (; len < i2; str += "0", len++) ;
                str = toExponential(str, e2);
              } else {
                i2 -= ne2;
                str = toFixedPoint(str, e2, "0");
                if (e2 + 1 > len) {
                  if (--i2 > 0) for (str += "."; i2--; str += "0") ;
                } else {
                  i2 += e2 - len;
                  if (i2 > 0) {
                    if (e2 + 1 == len) str += ".";
                    for (; i2--; str += "0") ;
                  }
                }
              }
            }
            return n3.s < 0 && c0 ? "-" + str : str;
          }
          function maxOrMin(args, n3) {
            var k3, y3, i2 = 1, x3 = new BigNumber2(args[0]);
            for (; i2 < args.length; i2++) {
              y3 = new BigNumber2(args[i2]);
              if (!y3.s || (k3 = compare(x3, y3)) === n3 || k3 === 0 && x3.s === n3) {
                x3 = y3;
              }
            }
            return x3;
          }
          function normalise(n3, c2, e2) {
            var i2 = 1, j3 = c2.length;
            for (; !c2[--j3]; c2.pop()) ;
            for (j3 = c2[0]; j3 >= 10; j3 /= 10, i2++) ;
            if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
              n3.c = n3.e = null;
            } else if (e2 < MIN_EXP) {
              n3.c = [n3.e = 0];
            } else {
              n3.e = e2;
              n3.c = c2;
            }
            return n3;
          }
          parseNumeric = /* @__PURE__ */ function() {
            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
            return function(x3, str, isNum, b3) {
              var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
              if (isInfinityOrNaN.test(s2)) {
                x3.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
              } else {
                if (!isNum) {
                  s2 = s2.replace(basePrefix, function(m3, p1, p2) {
                    base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                    return !b3 || b3 == base ? p1 : m3;
                  });
                  if (b3) {
                    base = b3;
                    s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                  }
                  if (str != s2) return new BigNumber2(s2, base);
                }
                if (BigNumber2.DEBUG) {
                  throw Error(bignumberError + "Not a" + (b3 ? " base " + b3 : "") + " number: " + str);
                }
                x3.s = null;
              }
              x3.c = x3.e = null;
            };
          }();
          function round(x3, sd, rm, r3) {
            var d2, i2, j3, k3, n3, ni, rd, xc = x3.c, pows10 = POWS_TEN;
            if (xc) {
              out: {
                for (d2 = 1, k3 = xc[0]; k3 >= 10; k3 /= 10, d2++) ;
                i2 = sd - d2;
                if (i2 < 0) {
                  i2 += LOG_BASE;
                  j3 = sd;
                  n3 = xc[ni = 0];
                  rd = mathfloor(n3 / pows10[d2 - j3 - 1] % 10);
                } else {
                  ni = mathceil((i2 + 1) / LOG_BASE);
                  if (ni >= xc.length) {
                    if (r3) {
                      for (; xc.length <= ni; xc.push(0)) ;
                      n3 = rd = 0;
                      d2 = 1;
                      i2 %= LOG_BASE;
                      j3 = i2 - LOG_BASE + 1;
                    } else {
                      break out;
                    }
                  } else {
                    n3 = k3 = xc[ni];
                    for (d2 = 1; k3 >= 10; k3 /= 10, d2++) ;
                    i2 %= LOG_BASE;
                    j3 = i2 - LOG_BASE + d2;
                    rd = j3 < 0 ? 0 : mathfloor(n3 / pows10[d2 - j3 - 1] % 10);
                  }
                }
                r3 = r3 || sd < 0 || // Are there any non-zero digits after the rounding digit?
                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                xc[ni + 1] != null || (j3 < 0 ? n3 : n3 % pows10[d2 - j3 - 1]);
                r3 = rm < 4 ? (rd || r3) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r3 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
                (i2 > 0 ? j3 > 0 ? n3 / pows10[d2 - j3] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x3.s < 0 ? 8 : 7));
                if (sd < 1 || !xc[0]) {
                  xc.length = 0;
                  if (r3) {
                    sd -= x3.e + 1;
                    xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                    x3.e = -sd || 0;
                  } else {
                    xc[0] = x3.e = 0;
                  }
                  return x3;
                }
                if (i2 == 0) {
                  xc.length = ni;
                  k3 = 1;
                  ni--;
                } else {
                  xc.length = ni + 1;
                  k3 = pows10[LOG_BASE - i2];
                  xc[ni] = j3 > 0 ? mathfloor(n3 / pows10[d2 - j3] % pows10[j3]) * k3 : 0;
                }
                if (r3) {
                  for (; ; ) {
                    if (ni == 0) {
                      for (i2 = 1, j3 = xc[0]; j3 >= 10; j3 /= 10, i2++) ;
                      j3 = xc[0] += k3;
                      for (k3 = 1; j3 >= 10; j3 /= 10, k3++) ;
                      if (i2 != k3) {
                        x3.e++;
                        if (xc[0] == BASE) xc[0] = 1;
                      }
                      break;
                    } else {
                      xc[ni] += k3;
                      if (xc[ni] != BASE) break;
                      xc[ni--] = 0;
                      k3 = 1;
                    }
                  }
                }
                for (i2 = xc.length; xc[--i2] === 0; xc.pop()) ;
              }
              if (x3.e > MAX_EXP) {
                x3.c = x3.e = null;
              } else if (x3.e < MIN_EXP) {
                x3.c = [x3.e = 0];
              }
            }
            return x3;
          }
          function valueOf(n3) {
            var str, e2 = n3.e;
            if (e2 === null) return n3.toString();
            str = coeffToString(n3.c);
            str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
            return n3.s < 0 ? "-" + str : str;
          }
          P3.absoluteValue = P3.abs = function() {
            var x3 = new BigNumber2(this);
            if (x3.s < 0) x3.s = 1;
            return x3;
          };
          P3.comparedTo = function(y3, b3) {
            return compare(this, new BigNumber2(y3, b3));
          };
          P3.decimalPlaces = P3.dp = function(dp, rm) {
            var c2, n3, v3, x3 = this;
            if (dp != null) {
              intCheck(dp, 0, MAX);
              if (rm == null) rm = ROUNDING_MODE;
              else intCheck(rm, 0, 8);
              return round(new BigNumber2(x3), dp + x3.e + 1, rm);
            }
            if (!(c2 = x3.c)) return null;
            n3 = ((v3 = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
            if (v3 = c2[v3]) for (; v3 % 10 == 0; v3 /= 10, n3--) ;
            if (n3 < 0) n3 = 0;
            return n3;
          };
          P3.dividedBy = P3.div = function(y3, b3) {
            return div(this, new BigNumber2(y3, b3), DECIMAL_PLACES, ROUNDING_MODE);
          };
          P3.dividedToIntegerBy = P3.idiv = function(y3, b3) {
            return div(this, new BigNumber2(y3, b3), 0, 1);
          };
          P3.exponentiatedBy = P3.pow = function(n3, m3) {
            var half, isModExp, i2, k3, more, nIsBig, nIsNeg, nIsOdd, y3, x3 = this;
            n3 = new BigNumber2(n3);
            if (n3.c && !n3.isInteger()) {
              throw Error(bignumberError + "Exponent not an integer: " + valueOf(n3));
            }
            if (m3 != null) m3 = new BigNumber2(m3);
            nIsBig = n3.e > 14;
            if (!x3.c || !x3.c[0] || x3.c[0] == 1 && !x3.e && x3.c.length == 1 || !n3.c || !n3.c[0]) {
              y3 = new BigNumber2(Math.pow(+valueOf(x3), nIsBig ? n3.s * (2 - isOdd(n3)) : +valueOf(n3)));
              return m3 ? y3.mod(m3) : y3;
            }
            nIsNeg = n3.s < 0;
            if (m3) {
              if (m3.c ? !m3.c[0] : !m3.s) return new BigNumber2(NaN);
              isModExp = !nIsNeg && x3.isInteger() && m3.isInteger();
              if (isModExp) x3 = x3.mod(m3);
            } else if (n3.e > 9 && (x3.e > 0 || x3.e < -1 || (x3.e == 0 ? x3.c[0] > 1 || nIsBig && x3.c[1] >= 24e7 : x3.c[0] < 8e13 || nIsBig && x3.c[0] <= 9999975e7))) {
              k3 = x3.s < 0 && isOdd(n3) ? -0 : 0;
              if (x3.e > -1) k3 = 1 / k3;
              return new BigNumber2(nIsNeg ? 1 / k3 : k3);
            } else if (POW_PRECISION) {
              k3 = mathceil(POW_PRECISION / LOG_BASE + 2);
            }
            if (nIsBig) {
              half = new BigNumber2(0.5);
              if (nIsNeg) n3.s = 1;
              nIsOdd = isOdd(n3);
            } else {
              i2 = Math.abs(+valueOf(n3));
              nIsOdd = i2 % 2;
            }
            y3 = new BigNumber2(ONE);
            for (; ; ) {
              if (nIsOdd) {
                y3 = y3.times(x3);
                if (!y3.c) break;
                if (k3) {
                  if (y3.c.length > k3) y3.c.length = k3;
                } else if (isModExp) {
                  y3 = y3.mod(m3);
                }
              }
              if (i2) {
                i2 = mathfloor(i2 / 2);
                if (i2 === 0) break;
                nIsOdd = i2 % 2;
              } else {
                n3 = n3.times(half);
                round(n3, n3.e + 1, 1);
                if (n3.e > 14) {
                  nIsOdd = isOdd(n3);
                } else {
                  i2 = +valueOf(n3);
                  if (i2 === 0) break;
                  nIsOdd = i2 % 2;
                }
              }
              x3 = x3.times(x3);
              if (k3) {
                if (x3.c && x3.c.length > k3) x3.c.length = k3;
              } else if (isModExp) {
                x3 = x3.mod(m3);
              }
            }
            if (isModExp) return y3;
            if (nIsNeg) y3 = ONE.div(y3);
            return m3 ? y3.mod(m3) : k3 ? round(y3, POW_PRECISION, ROUNDING_MODE, more) : y3;
          };
          P3.integerValue = function(rm) {
            var n3 = new BigNumber2(this);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(n3, n3.e + 1, rm);
          };
          P3.isEqualTo = P3.eq = function(y3, b3) {
            return compare(this, new BigNumber2(y3, b3)) === 0;
          };
          P3.isFinite = function() {
            return !!this.c;
          };
          P3.isGreaterThan = P3.gt = function(y3, b3) {
            return compare(this, new BigNumber2(y3, b3)) > 0;
          };
          P3.isGreaterThanOrEqualTo = P3.gte = function(y3, b3) {
            return (b3 = compare(this, new BigNumber2(y3, b3))) === 1 || b3 === 0;
          };
          P3.isInteger = function() {
            return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
          };
          P3.isLessThan = P3.lt = function(y3, b3) {
            return compare(this, new BigNumber2(y3, b3)) < 0;
          };
          P3.isLessThanOrEqualTo = P3.lte = function(y3, b3) {
            return (b3 = compare(this, new BigNumber2(y3, b3))) === -1 || b3 === 0;
          };
          P3.isNaN = function() {
            return !this.s;
          };
          P3.isNegative = function() {
            return this.s < 0;
          };
          P3.isPositive = function() {
            return this.s > 0;
          };
          P3.isZero = function() {
            return !!this.c && this.c[0] == 0;
          };
          P3.minus = function(y3, b3) {
            var i2, j3, t, xLTy, x3 = this, a2 = x3.s;
            y3 = new BigNumber2(y3, b3);
            b3 = y3.s;
            if (!a2 || !b3) return new BigNumber2(NaN);
            if (a2 != b3) {
              y3.s = -b3;
              return x3.plus(y3);
            }
            var xe = x3.e / LOG_BASE, ye = y3.e / LOG_BASE, xc = x3.c, yc = y3.c;
            if (!xe || !ye) {
              if (!xc || !yc) return xc ? (y3.s = -b3, y3) : new BigNumber2(yc ? x3 : NaN);
              if (!xc[0] || !yc[0]) {
                return yc[0] ? (y3.s = -b3, y3) : new BigNumber2(xc[0] ? x3 : (
                  // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                  ROUNDING_MODE == 3 ? -0 : 0
                ));
              }
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            if (a2 = xe - ye) {
              if (xLTy = a2 < 0) {
                a2 = -a2;
                t = xc;
              } else {
                ye = xe;
                t = yc;
              }
              t.reverse();
              for (b3 = a2; b3--; t.push(0)) ;
              t.reverse();
            } else {
              j3 = (xLTy = (a2 = xc.length) < (b3 = yc.length)) ? a2 : b3;
              for (a2 = b3 = 0; b3 < j3; b3++) {
                if (xc[b3] != yc[b3]) {
                  xLTy = xc[b3] < yc[b3];
                  break;
                }
              }
            }
            if (xLTy) {
              t = xc;
              xc = yc;
              yc = t;
              y3.s = -y3.s;
            }
            b3 = (j3 = yc.length) - (i2 = xc.length);
            if (b3 > 0) for (; b3--; xc[i2++] = 0) ;
            b3 = BASE - 1;
            for (; j3 > a2; ) {
              if (xc[--j3] < yc[j3]) {
                for (i2 = j3; i2 && !xc[--i2]; xc[i2] = b3) ;
                --xc[i2];
                xc[j3] += BASE;
              }
              xc[j3] -= yc[j3];
            }
            for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
            if (!xc[0]) {
              y3.s = ROUNDING_MODE == 3 ? -1 : 1;
              y3.c = [y3.e = 0];
              return y3;
            }
            return normalise(y3, xc, ye);
          };
          P3.modulo = P3.mod = function(y3, b3) {
            var q3, s2, x3 = this;
            y3 = new BigNumber2(y3, b3);
            if (!x3.c || !y3.s || y3.c && !y3.c[0]) {
              return new BigNumber2(NaN);
            } else if (!y3.c || x3.c && !x3.c[0]) {
              return new BigNumber2(x3);
            }
            if (MODULO_MODE == 9) {
              s2 = y3.s;
              y3.s = 1;
              q3 = div(x3, y3, 0, 3);
              y3.s = s2;
              q3.s *= s2;
            } else {
              q3 = div(x3, y3, 0, MODULO_MODE);
            }
            y3 = x3.minus(q3.times(y3));
            if (!y3.c[0] && MODULO_MODE == 1) y3.s = x3.s;
            return y3;
          };
          P3.multipliedBy = P3.times = function(y3, b3) {
            var c2, e2, i2, j3, k3, m3, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x3 = this, xc = x3.c, yc = (y3 = new BigNumber2(y3, b3)).c;
            if (!xc || !yc || !xc[0] || !yc[0]) {
              if (!x3.s || !y3.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                y3.c = y3.e = y3.s = null;
              } else {
                y3.s *= x3.s;
                if (!xc || !yc) {
                  y3.c = y3.e = null;
                } else {
                  y3.c = [0];
                  y3.e = 0;
                }
              }
              return y3;
            }
            e2 = bitFloor(x3.e / LOG_BASE) + bitFloor(y3.e / LOG_BASE);
            y3.s *= x3.s;
            xcL = xc.length;
            ycL = yc.length;
            if (xcL < ycL) {
              zc = xc;
              xc = yc;
              yc = zc;
              i2 = xcL;
              xcL = ycL;
              ycL = i2;
            }
            for (i2 = xcL + ycL, zc = []; i2--; zc.push(0)) ;
            base = BASE;
            sqrtBase = SQRT_BASE;
            for (i2 = ycL; --i2 >= 0; ) {
              c2 = 0;
              ylo = yc[i2] % sqrtBase;
              yhi = yc[i2] / sqrtBase | 0;
              for (k3 = xcL, j3 = i2 + k3; j3 > i2; ) {
                xlo = xc[--k3] % sqrtBase;
                xhi = xc[k3] / sqrtBase | 0;
                m3 = yhi * xlo + xhi * ylo;
                xlo = ylo * xlo + m3 % sqrtBase * sqrtBase + zc[j3] + c2;
                c2 = (xlo / base | 0) + (m3 / sqrtBase | 0) + yhi * xhi;
                zc[j3--] = xlo % base;
              }
              zc[j3] = c2;
            }
            if (c2) {
              ++e2;
            } else {
              zc.splice(0, 1);
            }
            return normalise(y3, zc, e2);
          };
          P3.negated = function() {
            var x3 = new BigNumber2(this);
            x3.s = -x3.s || null;
            return x3;
          };
          P3.plus = function(y3, b3) {
            var t, x3 = this, a2 = x3.s;
            y3 = new BigNumber2(y3, b3);
            b3 = y3.s;
            if (!a2 || !b3) return new BigNumber2(NaN);
            if (a2 != b3) {
              y3.s = -b3;
              return x3.minus(y3);
            }
            var xe = x3.e / LOG_BASE, ye = y3.e / LOG_BASE, xc = x3.c, yc = y3.c;
            if (!xe || !ye) {
              if (!xc || !yc) return new BigNumber2(a2 / 0);
              if (!xc[0] || !yc[0]) return yc[0] ? y3 : new BigNumber2(xc[0] ? x3 : a2 * 0);
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            if (a2 = xe - ye) {
              if (a2 > 0) {
                ye = xe;
                t = yc;
              } else {
                a2 = -a2;
                t = xc;
              }
              t.reverse();
              for (; a2--; t.push(0)) ;
              t.reverse();
            }
            a2 = xc.length;
            b3 = yc.length;
            if (a2 - b3 < 0) {
              t = yc;
              yc = xc;
              xc = t;
              b3 = a2;
            }
            for (a2 = 0; b3; ) {
              a2 = (xc[--b3] = xc[b3] + yc[b3] + a2) / BASE | 0;
              xc[b3] = BASE === xc[b3] ? 0 : xc[b3] % BASE;
            }
            if (a2) {
              xc = [a2].concat(xc);
              ++ye;
            }
            return normalise(y3, xc, ye);
          };
          P3.precision = P3.sd = function(sd, rm) {
            var c2, n3, v3, x3 = this;
            if (sd != null && sd !== !!sd) {
              intCheck(sd, 1, MAX);
              if (rm == null) rm = ROUNDING_MODE;
              else intCheck(rm, 0, 8);
              return round(new BigNumber2(x3), sd, rm);
            }
            if (!(c2 = x3.c)) return null;
            v3 = c2.length - 1;
            n3 = v3 * LOG_BASE + 1;
            if (v3 = c2[v3]) {
              for (; v3 % 10 == 0; v3 /= 10, n3--) ;
              for (v3 = c2[0]; v3 >= 10; v3 /= 10, n3++) ;
            }
            if (sd && x3.e + 1 > n3) n3 = x3.e + 1;
            return n3;
          };
          P3.shiftedBy = function(k3) {
            intCheck(k3, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
            return this.times("1e" + k3);
          };
          P3.squareRoot = P3.sqrt = function() {
            var m3, n3, r3, rep, t, x3 = this, c2 = x3.c, s2 = x3.s, e2 = x3.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
            if (s2 !== 1 || !c2 || !c2[0]) {
              return new BigNumber2(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x3 : 1 / 0);
            }
            s2 = Math.sqrt(+valueOf(x3));
            if (s2 == 0 || s2 == 1 / 0) {
              n3 = coeffToString(c2);
              if ((n3.length + e2) % 2 == 0) n3 += "0";
              s2 = Math.sqrt(+n3);
              e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
              if (s2 == 1 / 0) {
                n3 = "5e" + e2;
              } else {
                n3 = s2.toExponential();
                n3 = n3.slice(0, n3.indexOf("e") + 1) + e2;
              }
              r3 = new BigNumber2(n3);
            } else {
              r3 = new BigNumber2(s2 + "");
            }
            if (r3.c[0]) {
              e2 = r3.e;
              s2 = e2 + dp;
              if (s2 < 3) s2 = 0;
              for (; ; ) {
                t = r3;
                r3 = half.times(t.plus(div(x3, t, dp, 1)));
                if (coeffToString(t.c).slice(0, s2) === (n3 = coeffToString(r3.c)).slice(0, s2)) {
                  if (r3.e < e2) --s2;
                  n3 = n3.slice(s2 - 3, s2 + 1);
                  if (n3 == "9999" || !rep && n3 == "4999") {
                    if (!rep) {
                      round(t, t.e + DECIMAL_PLACES + 2, 0);
                      if (t.times(t).eq(x3)) {
                        r3 = t;
                        break;
                      }
                    }
                    dp += 4;
                    s2 += 4;
                    rep = 1;
                  } else {
                    if (!+n3 || !+n3.slice(1) && n3.charAt(0) == "5") {
                      round(r3, r3.e + DECIMAL_PLACES + 2, 1);
                      m3 = !r3.times(r3).eq(x3);
                    }
                    break;
                  }
                }
              }
            }
            return round(r3, r3.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m3);
          };
          P3.toExponential = function(dp, rm) {
            if (dp != null) {
              intCheck(dp, 0, MAX);
              dp++;
            }
            return format(this, dp, rm, 1);
          };
          P3.toFixed = function(dp, rm) {
            if (dp != null) {
              intCheck(dp, 0, MAX);
              dp = dp + this.e + 1;
            }
            return format(this, dp, rm);
          };
          P3.toFormat = function(dp, rm, format2) {
            var str, x3 = this;
            if (format2 == null) {
              if (dp != null && rm && typeof rm == "object") {
                format2 = rm;
                rm = null;
              } else if (dp && typeof dp == "object") {
                format2 = dp;
                dp = rm = null;
              } else {
                format2 = FORMAT;
              }
            } else if (typeof format2 != "object") {
              throw Error(bignumberError + "Argument not an object: " + format2);
            }
            str = x3.toFixed(dp, rm);
            if (x3.c) {
              var i2, arr = str.split("."), g1 = +format2.groupSize, g22 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x3.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
              if (g22) {
                i2 = g1;
                g1 = g22;
                g22 = i2;
                len -= i2;
              }
              if (g1 > 0 && len > 0) {
                i2 = len % g1 || g1;
                intPart = intDigits.substr(0, i2);
                for (; i2 < len; i2 += g1) intPart += groupSeparator + intDigits.substr(i2, g1);
                if (g22 > 0) intPart += groupSeparator + intDigits.slice(i2);
                if (isNeg) intPart = "-" + intPart;
              }
              str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g22 = +format2.fractionGroupSize) ? fractionPart.replace(
                new RegExp("\\d{" + g22 + "}\\B", "g"),
                "$&" + (format2.fractionGroupSeparator || "")
              ) : fractionPart) : intPart;
            }
            return (format2.prefix || "") + str + (format2.suffix || "");
          };
          P3.toFraction = function(md) {
            var d2, d0, d1, d22, e2, exp, n3, n0, n1, q3, r3, s2, x3 = this, xc = x3.c;
            if (md != null) {
              n3 = new BigNumber2(md);
              if (!n3.isInteger() && (n3.c || n3.s !== 1) || n3.lt(ONE)) {
                throw Error(bignumberError + "Argument " + (n3.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n3));
              }
            }
            if (!xc) return new BigNumber2(x3);
            d2 = new BigNumber2(ONE);
            n1 = d0 = new BigNumber2(ONE);
            d1 = n0 = new BigNumber2(ONE);
            s2 = coeffToString(xc);
            e2 = d2.e = s2.length - x3.e - 1;
            d2.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
            md = !md || n3.comparedTo(d2) > 0 ? e2 > 0 ? d2 : n1 : n3;
            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n3 = new BigNumber2(s2);
            n0.c[0] = 0;
            for (; ; ) {
              q3 = div(n3, d2, 0, 1);
              d22 = d0.plus(q3.times(d1));
              if (d22.comparedTo(md) == 1) break;
              d0 = d1;
              d1 = d22;
              n1 = n0.plus(q3.times(d22 = n1));
              n0 = d22;
              d2 = n3.minus(q3.times(d22 = d2));
              n3 = d22;
            }
            d22 = div(md.minus(d0), d1, 0, 1);
            n0 = n0.plus(d22.times(n1));
            d0 = d0.plus(d22.times(d1));
            n0.s = n1.s = x3.s;
            e2 = e2 * 2;
            r3 = div(n1, d1, e2, ROUNDING_MODE).minus(x3).abs().comparedTo(
              div(n0, d0, e2, ROUNDING_MODE).minus(x3).abs()
            ) < 1 ? [n1, d1] : [n0, d0];
            MAX_EXP = exp;
            return r3;
          };
          P3.toNumber = function() {
            return +valueOf(this);
          };
          P3.toPrecision = function(sd, rm) {
            if (sd != null) intCheck(sd, 1, MAX);
            return format(this, sd, rm, 2);
          };
          P3.toString = function(b3) {
            var str, n3 = this, s2 = n3.s, e2 = n3.e;
            if (e2 === null) {
              if (s2) {
                str = "Infinity";
                if (s2 < 0) str = "-" + str;
              } else {
                str = "NaN";
              }
            } else {
              if (b3 == null) {
                str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n3.c), e2) : toFixedPoint(coeffToString(n3.c), e2, "0");
              } else if (b3 === 10 && alphabetHasNormalDecimalDigits) {
                n3 = round(new BigNumber2(n3), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
                str = toFixedPoint(coeffToString(n3.c), n3.e, "0");
              } else {
                intCheck(b3, 2, ALPHABET.length, "Base");
                str = convertBase(toFixedPoint(coeffToString(n3.c), e2, "0"), 10, b3, s2, true);
              }
              if (s2 < 0 && n3.c[0]) str = "-" + str;
            }
            return str;
          };
          P3.valueOf = P3.toJSON = function() {
            return valueOf(this);
          };
          P3._isBigNumber = true;
          if (configObject != null) BigNumber2.set(configObject);
          return BigNumber2;
        }
        function bitFloor(n3) {
          var i2 = n3 | 0;
          return n3 > 0 || n3 === i2 ? i2 : i2 - 1;
        }
        function coeffToString(a2) {
          var s2, z3, i2 = 1, j3 = a2.length, r3 = a2[0] + "";
          for (; i2 < j3; ) {
            s2 = a2[i2++] + "";
            z3 = LOG_BASE - s2.length;
            for (; z3--; s2 = "0" + s2) ;
            r3 += s2;
          }
          for (j3 = r3.length; r3.charCodeAt(--j3) === 48; ) ;
          return r3.slice(0, j3 + 1 || 1);
        }
        function compare(x3, y3) {
          var a2, b3, xc = x3.c, yc = y3.c, i2 = x3.s, j3 = y3.s, k3 = x3.e, l2 = y3.e;
          if (!i2 || !j3) return null;
          a2 = xc && !xc[0];
          b3 = yc && !yc[0];
          if (a2 || b3) return a2 ? b3 ? 0 : -j3 : i2;
          if (i2 != j3) return i2;
          a2 = i2 < 0;
          b3 = k3 == l2;
          if (!xc || !yc) return b3 ? 0 : !xc ^ a2 ? 1 : -1;
          if (!b3) return k3 > l2 ^ a2 ? 1 : -1;
          j3 = (k3 = xc.length) < (l2 = yc.length) ? k3 : l2;
          for (i2 = 0; i2 < j3; i2++) if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ a2 ? 1 : -1;
          return k3 == l2 ? 0 : k3 > l2 ^ a2 ? 1 : -1;
        }
        function intCheck(n3, min, max, name) {
          if (n3 < min || n3 > max || n3 !== mathfloor(n3)) {
            throw Error(bignumberError + (name || "Argument") + (typeof n3 == "number" ? n3 < min || n3 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n3));
          }
        }
        function isOdd(n3) {
          var k3 = n3.c.length - 1;
          return bitFloor(n3.e / LOG_BASE) == k3 && n3.c[k3] % 2 != 0;
        }
        function toExponential(str, e2) {
          return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
        }
        function toFixedPoint(str, e2, z3) {
          var len, zs;
          if (e2 < 0) {
            for (zs = z3 + "."; ++e2; zs += z3) ;
            str = zs + str;
          } else {
            len = str.length;
            if (++e2 > len) {
              for (zs = z3, e2 -= len; --e2; zs += z3) ;
              str += zs;
            } else if (e2 < len) {
              str = str.slice(0, e2) + "." + str.slice(e2);
            }
          }
          return str;
        }
        BigNumber = clone();
        BigNumber["default"] = BigNumber.BigNumber = BigNumber;
        if (typeof define == "function" && define.amd) {
          define(function() {
            return BigNumber;
          });
        } else if (typeof module != "undefined" && module.exports) {
          module.exports = BigNumber;
        } else {
          if (!globalObject) {
            globalObject = typeof self != "undefined" && self ? self : window;
          }
          globalObject.BigNumber = BigNumber;
        }
      })(exports);
    }
  });

  // node_modules/json-bigint/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/json-bigint/lib/stringify.js"(exports, module) {
      init_polyfills();
      var BigNumber = require_bignumber();
      var JSON2 = module.exports;
      (function() {
        "use strict";
        function f3(n3) {
          return n3 < 10 ? "0" + n3 : n3;
        }
        var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
          // table of character substitutions
          "\b": "\\b",
          "	": "\\t",
          "\n": "\\n",
          "\f": "\\f",
          "\r": "\\r",
          '"': '\\"',
          "\\": "\\\\"
        }, rep;
        function quote(string) {
          escapable.lastIndex = 0;
          return escapable.test(string) ? '"' + string.replace(escapable, function(a2) {
            var c2 = meta[a2];
            return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a2.charCodeAt(0).toString(16)).slice(-4);
          }) + '"' : '"' + string + '"';
        }
        function str(key, holder) {
          var i2, k3, v3, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
          if (value && typeof value === "object" && typeof value.toJSON === "function") {
            value = value.toJSON(key);
          }
          if (typeof rep === "function") {
            value = rep.call(holder, key, value);
          }
          switch (typeof value) {
            case "string":
              if (isBigNumber) {
                return value;
              } else {
                return quote(value);
              }
            case "number":
              return isFinite(value) ? String(value) : "null";
            case "boolean":
            case "null":
            case "bigint":
              return String(value);
            // If the type is 'object', we might be dealing with an object or an array or
            // null.
            case "object":
              if (!value) {
                return "null";
              }
              gap += indent;
              partial = [];
              if (Object.prototype.toString.apply(value) === "[object Array]") {
                length = value.length;
                for (i2 = 0; i2 < length; i2 += 1) {
                  partial[i2] = str(i2, value) || "null";
                }
                v3 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
                gap = mind;
                return v3;
              }
              if (rep && typeof rep === "object") {
                length = rep.length;
                for (i2 = 0; i2 < length; i2 += 1) {
                  if (typeof rep[i2] === "string") {
                    k3 = rep[i2];
                    v3 = str(k3, value);
                    if (v3) {
                      partial.push(quote(k3) + (gap ? ": " : ":") + v3);
                    }
                  }
                }
              } else {
                Object.keys(value).forEach(function(k4) {
                  var v4 = str(k4, value);
                  if (v4) {
                    partial.push(quote(k4) + (gap ? ": " : ":") + v4);
                  }
                });
              }
              v3 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
              gap = mind;
              return v3;
          }
        }
        if (typeof JSON2.stringify !== "function") {
          JSON2.stringify = function(value, replacer, space) {
            var i2;
            gap = "";
            indent = "";
            if (typeof space === "number") {
              for (i2 = 0; i2 < space; i2 += 1) {
                indent += " ";
              }
            } else if (typeof space === "string") {
              indent = space;
            }
            rep = replacer;
            if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
              throw new Error("JSON.stringify");
            }
            return str("", { "": value });
          };
        }
      })();
    }
  });

  // node_modules/json-bigint/lib/parse.js
  var require_parse = __commonJS({
    "node_modules/json-bigint/lib/parse.js"(exports, module) {
      init_polyfills();
      var BigNumber = null;
      var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
      var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
      var json_parse = function(options) {
        "use strict";
        var _options = {
          strict: false,
          // not being strict means do not generate syntax errors for "duplicate key"
          storeAsString: false,
          // toggles whether the values should be stored as BigNumber (default) or a string
          alwaysParseAsBig: false,
          // toggles whether all numbers should be Big
          useNativeBigInt: false,
          // toggles whether to use native BigInt instead of bignumber.js
          protoAction: "error",
          constructorAction: "error"
        };
        if (options !== void 0 && options !== null) {
          if (options.strict === true) {
            _options.strict = true;
          }
          if (options.storeAsString === true) {
            _options.storeAsString = true;
          }
          _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
          _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
          if (typeof options.constructorAction !== "undefined") {
            if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
              _options.constructorAction = options.constructorAction;
            } else {
              throw new Error(
                `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
              );
            }
          }
          if (typeof options.protoAction !== "undefined") {
            if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
              _options.protoAction = options.protoAction;
            } else {
              throw new Error(
                `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
              );
            }
          }
        }
        var at2, ch, escapee = {
          '"': '"',
          "\\": "\\",
          "/": "/",
          b: "\b",
          f: "\f",
          n: "\n",
          r: "\r",
          t: "	"
        }, text, error = function(m3) {
          throw {
            name: "SyntaxError",
            message: m3,
            at: at2,
            text
          };
        }, next = function(c2) {
          if (c2 && c2 !== ch) {
            error("Expected '" + c2 + "' instead of '" + ch + "'");
          }
          ch = text.charAt(at2);
          at2 += 1;
          return ch;
        }, number = function() {
          var number2, string2 = "";
          if (ch === "-") {
            string2 = "-";
            next("-");
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
          if (ch === ".") {
            string2 += ".";
            while (next() && ch >= "0" && ch <= "9") {
              string2 += ch;
            }
          }
          if (ch === "e" || ch === "E") {
            string2 += ch;
            next();
            if (ch === "-" || ch === "+") {
              string2 += ch;
              next();
            }
            while (ch >= "0" && ch <= "9") {
              string2 += ch;
              next();
            }
          }
          number2 = +string2;
          if (!isFinite(number2)) {
            error("Bad number");
          } else {
            if (BigNumber == null) BigNumber = require_bignumber();
            if (string2.length > 15)
              return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
            else
              return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
          }
        }, string = function() {
          var hex, i2, string2 = "", uffff;
          if (ch === '"') {
            var startAt = at2;
            while (next()) {
              if (ch === '"') {
                if (at2 - 1 > startAt) string2 += text.substring(startAt, at2 - 1);
                next();
                return string2;
              }
              if (ch === "\\") {
                if (at2 - 1 > startAt) string2 += text.substring(startAt, at2 - 1);
                next();
                if (ch === "u") {
                  uffff = 0;
                  for (i2 = 0; i2 < 4; i2 += 1) {
                    hex = parseInt(next(), 16);
                    if (!isFinite(hex)) {
                      break;
                    }
                    uffff = uffff * 16 + hex;
                  }
                  string2 += String.fromCharCode(uffff);
                } else if (typeof escapee[ch] === "string") {
                  string2 += escapee[ch];
                } else {
                  break;
                }
                startAt = at2;
              }
            }
          }
          error("Bad string");
        }, white = function() {
          while (ch && ch <= " ") {
            next();
          }
        }, word = function() {
          switch (ch) {
            case "t":
              next("t");
              next("r");
              next("u");
              next("e");
              return true;
            case "f":
              next("f");
              next("a");
              next("l");
              next("s");
              next("e");
              return false;
            case "n":
              next("n");
              next("u");
              next("l");
              next("l");
              return null;
          }
          error("Unexpected '" + ch + "'");
        }, value, array = function() {
          var array2 = [];
          if (ch === "[") {
            next("[");
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            while (ch) {
              array2.push(value());
              white();
              if (ch === "]") {
                next("]");
                return array2;
              }
              next(",");
              white();
            }
          }
          error("Bad array");
        }, object = function() {
          var key, object2 = /* @__PURE__ */ Object.create(null);
          if (ch === "{") {
            next("{");
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            while (ch) {
              key = string();
              white();
              next(":");
              if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
                error('Duplicate key "' + key + '"');
              }
              if (suspectProtoRx.test(key) === true) {
                if (_options.protoAction === "error") {
                  error("Object contains forbidden prototype property");
                } else if (_options.protoAction === "ignore") {
                  value();
                } else {
                  object2[key] = value();
                }
              } else if (suspectConstructorRx.test(key) === true) {
                if (_options.constructorAction === "error") {
                  error("Object contains forbidden constructor property");
                } else if (_options.constructorAction === "ignore") {
                  value();
                } else {
                  object2[key] = value();
                }
              } else {
                object2[key] = value();
              }
              white();
              if (ch === "}") {
                next("}");
                return object2;
              }
              next(",");
              white();
            }
          }
          error("Bad object");
        };
        value = function() {
          white();
          switch (ch) {
            case "{":
              return object();
            case "[":
              return array();
            case '"':
              return string();
            case "-":
              return number();
            default:
              return ch >= "0" && ch <= "9" ? number() : word();
          }
        };
        return function(source, reviver) {
          var result;
          text = source + "";
          at2 = 0;
          ch = " ";
          result = value();
          white();
          if (ch) {
            error("Syntax error");
          }
          return typeof reviver === "function" ? function walk(holder, key) {
            var k3, v3, value2 = holder[key];
            if (value2 && typeof value2 === "object") {
              Object.keys(value2).forEach(function(k4) {
                v3 = walk(value2, k4);
                if (v3 !== void 0) {
                  value2[k4] = v3;
                } else {
                  delete value2[k4];
                }
              });
            }
            return reviver.call(holder, key, value2);
          }({ "": result }, "") : result;
        };
      };
      module.exports = json_parse;
    }
  });

  // node_modules/json-bigint/index.js
  var require_json_bigint = __commonJS({
    "node_modules/json-bigint/index.js"(exports, module) {
      init_polyfills();
      var json_stringify = require_stringify().stringify;
      var json_parse = require_parse();
      module.exports = function(options) {
        return {
          parse: json_parse(options),
          stringify: json_stringify
        };
      };
      module.exports.parse = json_parse();
      module.exports.stringify = json_stringify;
    }
  });

  // node_modules/algosdk/dist/esm/types/intDecoding.js
  var IntDecoding, intDecoding_default;
  var init_intDecoding = __esm({
    "node_modules/algosdk/dist/esm/types/intDecoding.js"() {
      init_polyfills();
      (function(IntDecoding2) {
        IntDecoding2["UNSAFE"] = "unsafe";
        IntDecoding2["SAFE"] = "safe";
        IntDecoding2["MIXED"] = "mixed";
        IntDecoding2["BIGINT"] = "bigint";
      })(IntDecoding || (IntDecoding = {}));
      intDecoding_default = IntDecoding;
    }
  });

  // node_modules/algosdk/dist/esm/utils/utils.js
  function parseJSON(str, { intDecoding }) {
    if (intDecoding !== intDecoding_default.SAFE && intDecoding !== intDecoding_default.UNSAFE && intDecoding !== intDecoding_default.BIGINT && intDecoding !== intDecoding_default.MIXED) {
      throw new Error(`Invalid intDecoding option: ${intDecoding}`);
    }
    return JSONbig.parse(str, (_3, value) => {
      if (value != null && typeof value === "object" && Object.getPrototypeOf(value) == null) {
        Object.setPrototypeOf(value, Object.prototype);
      }
      if (typeof value === "bigint") {
        if (intDecoding === intDecoding_default.SAFE && value > Number.MAX_SAFE_INTEGER) {
          throw new Error(`Integer exceeds maximum safe integer: ${value.toString()}. Try parsing with a different intDecoding option.`);
        }
        if (intDecoding === intDecoding_default.BIGINT || intDecoding === intDecoding_default.MIXED && value > Number.MAX_SAFE_INTEGER) {
          return value;
        }
        return Number(value);
      }
      if (typeof value === "number") {
        if (intDecoding === intDecoding_default.BIGINT && Number.isInteger(value)) {
          return BigInt(value);
        }
      }
      return value;
    });
  }
  function stringifyJSON(value, replacer, space) {
    return JSONbig.stringify(value, replacer, space);
  }
  function arrayEqual(a2, b3) {
    if (a2.length !== b3.length) {
      return false;
    }
    return Array.from(a2).every((val, i2) => val === b3[i2]);
  }
  function concatArrays2(...arrs) {
    const size = arrs.reduce((sum, arr) => sum + arr.length, 0);
    const c2 = new Uint8Array(size);
    let offset = 0;
    for (let i2 = 0; i2 < arrs.length; i2++) {
      c2.set(arrs[i2], offset);
      offset += arrs[i2].length;
    }
    return c2;
  }
  function isNode3() {
    return (
      // @ts-ignore
      typeof process === "object" && // @ts-ignore
      typeof process.versions === "object" && // @ts-ignore
      typeof process.versions.node !== "undefined"
    );
  }
  function isReactNative() {
    const { navigator: navigator2 } = globalThis;
    if (typeof navigator2 === "object" && navigator2.product === "ReactNative") {
      return true;
    }
    return false;
  }
  function ensureSafeInteger(value) {
    if (typeof value === "undefined") {
      throw new Error("Value is undefined");
    }
    if (typeof value === "bigint") {
      if (value > BigInt(Number.MAX_SAFE_INTEGER) || value < BigInt(Number.MIN_SAFE_INTEGER)) {
        throw new Error(`BigInt value ${value} is not a safe integer`);
      }
      return Number(value);
    }
    if (typeof value === "number") {
      if (Number.isSafeInteger(value)) {
        return value;
      }
      throw new Error(`Value ${value} is not a safe integer`);
    }
    throw new Error(`Unexpected type ${typeof value}, ${value}`);
  }
  function ensureSafeUnsignedInteger(value) {
    const intValue = ensureSafeInteger(value);
    if (intValue < 0) {
      throw new Error(`Value ${intValue} is negative`);
    }
    return intValue;
  }
  function ensureBigInt(value) {
    if (typeof value === "undefined") {
      throw new Error("Value is undefined");
    }
    if (typeof value === "bigint") {
      return value;
    }
    if (typeof value === "number") {
      if (!Number.isSafeInteger(value)) {
        throw new Error(`Value ${value} is not a safe integer`);
      }
      return BigInt(value);
    }
    throw new Error(`Unexpected type ${typeof value}, ${value}`);
  }
  function ensureUint64(value) {
    const bigIntValue = ensureBigInt(value);
    if (bigIntValue < 0 || bigIntValue > BigInt("0xffffffffffffffff")) {
      throw new Error(`Value ${bigIntValue} is not a uint64`);
    }
    return bigIntValue;
  }
  var import_json_bigint, JSONbig;
  var init_utils = __esm({
    "node_modules/algosdk/dist/esm/utils/utils.js"() {
      init_polyfills();
      import_json_bigint = __toESM(require_json_bigint(), 1);
      init_intDecoding();
      JSONbig = (0, import_json_bigint.default)({
        useNativeBigInt: true,
        strict: true
      });
    }
  });

  // node_modules/algosdk/dist/esm/nacl/naclWrappers.js
  function genericHash(arr) {
    return import_js_sha512.default.sha512_256.array(arr);
  }
  function randomBytes2(length) {
    if (isReactNative()) {
      console.warn(`It looks like you're running in react-native. In order to perform common crypto operations you will need to polyfill common operations such as crypto.getRandomValues`);
    }
    return import_tweetnacl.default.randomBytes(length);
  }
  function keyPairFromSeed(seed) {
    return import_tweetnacl.default.sign.keyPair.fromSeed(seed);
  }
  function keyPair() {
    const seed = randomBytes2(import_tweetnacl.default.box.secretKeyLength);
    return keyPairFromSeed(seed);
  }
  function isValidSignatureLength(len) {
    return len === import_tweetnacl.default.sign.signatureLength;
  }
  function keyPairFromSecretKey(sk) {
    return import_tweetnacl.default.sign.keyPair.fromSecretKey(sk);
  }
  function sign(msg, secretKey) {
    return import_tweetnacl.default.sign.detached(msg, secretKey);
  }
  function bytesEqual(a2, b3) {
    return import_tweetnacl.default.verify(a2, b3);
  }
  function verify(message, signature, verifyKey) {
    return import_tweetnacl.default.sign.detached.verify(message, signature, verifyKey);
  }
  var import_tweetnacl, import_js_sha512, PUBLIC_KEY_LENGTH, SECRET_KEY_LENGTH, HASH_BYTES_LENGTH, SEED_BTYES_LENGTH;
  var init_naclWrappers = __esm({
    "node_modules/algosdk/dist/esm/nacl/naclWrappers.js"() {
      init_polyfills();
      import_tweetnacl = __toESM(require_nacl_fast(), 1);
      import_js_sha512 = __toESM(require_sha512(), 1);
      init_utils();
      PUBLIC_KEY_LENGTH = import_tweetnacl.default.sign.publicKeyLength;
      SECRET_KEY_LENGTH = import_tweetnacl.default.sign.secretKeyLength;
      HASH_BYTES_LENGTH = 32;
      SEED_BTYES_LENGTH = 32;
    }
  });

  // node_modules/hi-base32/src/base32.js
  var require_base32 = __commonJS({
    "node_modules/hi-base32/src/base32.js"(exports, module) {
      init_polyfills();
      (function() {
        "use strict";
        var root = typeof window === "object" ? window : {};
        var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root = global;
        }
        var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
        var BASE32_DECODE_CHAR = {
          "A": 0,
          "B": 1,
          "C": 2,
          "D": 3,
          "E": 4,
          "F": 5,
          "G": 6,
          "H": 7,
          "I": 8,
          "J": 9,
          "K": 10,
          "L": 11,
          "M": 12,
          "N": 13,
          "O": 14,
          "P": 15,
          "Q": 16,
          "R": 17,
          "S": 18,
          "T": 19,
          "U": 20,
          "V": 21,
          "W": 22,
          "X": 23,
          "Y": 24,
          "Z": 25,
          "2": 26,
          "3": 27,
          "4": 28,
          "5": 29,
          "6": 30,
          "7": 31
        };
        var blocks = [0, 0, 0, 0, 0, 0, 0, 0];
        var throwInvalidUtf8 = function(position, partial) {
          if (partial.length > 10) {
            partial = "..." + partial.substr(-10);
          }
          var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
          err.position = position;
          throw err;
        };
        var toUtf8String = function(bytes) {
          var str = "", length = bytes.length, i2 = 0, followingChars = 0, b3, c2;
          while (i2 < length) {
            b3 = bytes[i2++];
            if (b3 <= 127) {
              str += String.fromCharCode(b3);
              continue;
            } else if (b3 > 191 && b3 <= 223) {
              c2 = b3 & 31;
              followingChars = 1;
            } else if (b3 <= 239) {
              c2 = b3 & 15;
              followingChars = 2;
            } else if (b3 <= 247) {
              c2 = b3 & 7;
              followingChars = 3;
            } else {
              throwInvalidUtf8(i2, str);
            }
            for (var j3 = 0; j3 < followingChars; ++j3) {
              b3 = bytes[i2++];
              if (b3 < 128 || b3 > 191) {
                throwInvalidUtf8(i2, str);
              }
              c2 <<= 6;
              c2 += b3 & 63;
            }
            if (c2 >= 55296 && c2 <= 57343) {
              throwInvalidUtf8(i2, str);
            }
            if (c2 > 1114111) {
              throwInvalidUtf8(i2, str);
            }
            if (c2 <= 65535) {
              str += String.fromCharCode(c2);
            } else {
              c2 -= 65536;
              str += String.fromCharCode((c2 >> 10) + 55296);
              str += String.fromCharCode((c2 & 1023) + 56320);
            }
          }
          return str;
        };
        var decodeAsBytes = function(base32Str) {
          if (base32Str === "") {
            return [];
          } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
            throw new Error("Invalid base32 characters");
          }
          base32Str = base32Str.replace(/=/g, "");
          var v1, v22, v3, v4, v5, v6, v7, v8, bytes = [], index = 0, length = base32Str.length;
          for (var i2 = 0, count = length >> 3 << 3; i2 < count; ) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v22 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v8 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            bytes[index++] = (v1 << 3 | v22 >>> 2) & 255;
            bytes[index++] = (v22 << 6 | v3 << 1 | v4 >>> 4) & 255;
            bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
            bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
            bytes[index++] = (v7 << 5 | v8) & 255;
          }
          var remain = length - count;
          if (remain === 2) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v22 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            bytes[index++] = (v1 << 3 | v22 >>> 2) & 255;
          } else if (remain === 4) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v22 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            bytes[index++] = (v1 << 3 | v22 >>> 2) & 255;
            bytes[index++] = (v22 << 6 | v3 << 1 | v4 >>> 4) & 255;
          } else if (remain === 5) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v22 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            bytes[index++] = (v1 << 3 | v22 >>> 2) & 255;
            bytes[index++] = (v22 << 6 | v3 << 1 | v4 >>> 4) & 255;
            bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          } else if (remain === 7) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v22 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            bytes[index++] = (v1 << 3 | v22 >>> 2) & 255;
            bytes[index++] = (v22 << 6 | v3 << 1 | v4 >>> 4) & 255;
            bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
            bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
          }
          return bytes;
        };
        var encodeAscii = function(str) {
          var v1, v22, v3, v4, v5, base32Str = "", length = str.length;
          for (var i2 = 0, count = parseInt(length / 5) * 5; i2 < count; ) {
            v1 = str.charCodeAt(i2++);
            v22 = str.charCodeAt(i2++);
            v3 = str.charCodeAt(i2++);
            v4 = str.charCodeAt(i2++);
            v5 = str.charCodeAt(i2++);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v22 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          }
          var remain = length - count;
          if (remain === 1) {
            v1 = str.charCodeAt(i2);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (remain === 2) {
            v1 = str.charCodeAt(i2++);
            v22 = str.charCodeAt(i2);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[v22 << 4 & 31] + "====";
          } else if (remain === 3) {
            v1 = str.charCodeAt(i2++);
            v22 = str.charCodeAt(i2++);
            v3 = str.charCodeAt(i2);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v22 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else if (remain === 4) {
            v1 = str.charCodeAt(i2++);
            v22 = str.charCodeAt(i2++);
            v3 = str.charCodeAt(i2++);
            v4 = str.charCodeAt(i2);
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v22 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
          }
          return base32Str;
        };
        var encodeUtf8 = function(str) {
          var v1, v22, v3, v4, v5, code, end = false, base32Str = "", index = 0, i2, start = 0, bytes = 0, length = str.length;
          if (str === "") {
            return base32Str;
          }
          do {
            blocks[0] = blocks[5];
            blocks[1] = blocks[6];
            blocks[2] = blocks[7];
            for (i2 = start; index < length && i2 < 5; ++index) {
              code = str.charCodeAt(index);
              if (code < 128) {
                blocks[i2++] = code;
              } else if (code < 2048) {
                blocks[i2++] = 192 | code >> 6;
                blocks[i2++] = 128 | code & 63;
              } else if (code < 55296 || code >= 57344) {
                blocks[i2++] = 224 | code >> 12;
                blocks[i2++] = 128 | code >> 6 & 63;
                blocks[i2++] = 128 | code & 63;
              } else {
                code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++index) & 1023);
                blocks[i2++] = 240 | code >> 18;
                blocks[i2++] = 128 | code >> 12 & 63;
                blocks[i2++] = 128 | code >> 6 & 63;
                blocks[i2++] = 128 | code & 63;
              }
            }
            bytes += i2 - start;
            start = i2 - 5;
            if (index === length) {
              ++index;
            }
            if (index > length && i2 < 6) {
              end = true;
            }
            v1 = blocks[0];
            if (i2 > 4) {
              v22 = blocks[1];
              v3 = blocks[2];
              v4 = blocks[3];
              v5 = blocks[4];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v22 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
            } else if (i2 === 1) {
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
            } else if (i2 === 2) {
              v22 = blocks[1];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[v22 << 4 & 31] + "====";
            } else if (i2 === 3) {
              v22 = blocks[1];
              v3 = blocks[2];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v22 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
            } else {
              v22 = blocks[1];
              v3 = blocks[2];
              v4 = blocks[3];
              base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v22 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
            }
          } while (!end);
          return base32Str;
        };
        var encodeBytes = function(bytes) {
          var v1, v22, v3, v4, v5, base32Str = "", length = bytes.length;
          for (var i2 = 0, count = parseInt(length / 5) * 5; i2 < count; ) {
            v1 = bytes[i2++];
            v22 = bytes[i2++];
            v3 = bytes[i2++];
            v4 = bytes[i2++];
            v5 = bytes[i2++];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v22 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          }
          var remain = length - count;
          if (remain === 1) {
            v1 = bytes[i2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (remain === 2) {
            v1 = bytes[i2++];
            v22 = bytes[i2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[v22 << 4 & 31] + "====";
          } else if (remain === 3) {
            v1 = bytes[i2++];
            v22 = bytes[i2++];
            v3 = bytes[i2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v22 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else if (remain === 4) {
            v1 = bytes[i2++];
            v22 = bytes[i2++];
            v3 = bytes[i2++];
            v4 = bytes[i2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v22 >>> 6) & 31] + BASE32_ENCODE_CHAR[v22 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v22 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
          }
          return base32Str;
        };
        var encode2 = function(input, asciiOnly) {
          var notString = typeof input !== "string";
          if (notString && input.constructor === ArrayBuffer) {
            input = new Uint8Array(input);
          }
          if (notString) {
            return encodeBytes(input);
          } else if (asciiOnly) {
            return encodeAscii(input);
          } else {
            return encodeUtf8(input);
          }
        };
        var decode3 = function(base32Str, asciiOnly) {
          if (!asciiOnly) {
            return toUtf8String(decodeAsBytes(base32Str));
          }
          if (base32Str === "") {
            return "";
          } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
            throw new Error("Invalid base32 characters");
          }
          var v1, v22, v3, v4, v5, v6, v7, v8, str = "", length = base32Str.indexOf("=");
          if (length === -1) {
            length = base32Str.length;
          }
          for (var i2 = 0, count = length >> 3 << 3; i2 < count; ) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v22 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v8 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            str += String.fromCharCode((v1 << 3 | v22 >>> 2) & 255) + String.fromCharCode((v22 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
          }
          var remain = length - count;
          if (remain === 2) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v22 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            str += String.fromCharCode((v1 << 3 | v22 >>> 2) & 255);
          } else if (remain === 4) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v22 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            str += String.fromCharCode((v1 << 3 | v22 >>> 2) & 255) + String.fromCharCode((v22 << 6 | v3 << 1 | v4 >>> 4) & 255);
          } else if (remain === 5) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v22 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            str += String.fromCharCode((v1 << 3 | v22 >>> 2) & 255) + String.fromCharCode((v22 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255);
          } else if (remain === 7) {
            v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v22 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
            str += String.fromCharCode((v1 << 3 | v22 >>> 2) & 255) + String.fromCharCode((v22 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
          }
          return str;
        };
        var exports2 = {
          encode: encode2,
          decode: decode3
        };
        decode3.asBytes = decodeAsBytes;
        if (COMMON_JS) {
          module.exports = exports2;
        } else {
          root.base32 = exports2;
          if (AMD) {
            define(function() {
              return exports2;
            });
          }
        }
      })();
    }
  });

  // node_modules/algosdk/dist/esm/encoding/uint64.js
  function encodeUint64(num) {
    const isInteger = typeof num === "bigint" || Number.isInteger(num);
    if (!isInteger || num < 0 || num > BigInt("0xffffffffffffffff")) {
      throw new Error("Input is not a 64-bit unsigned integer");
    }
    const encoding = new Uint8Array(8);
    const view = new DataView(encoding.buffer);
    view.setBigUint64(0, BigInt(num));
    return encoding;
  }
  function decodeUint64(data, decodingMode = "safe") {
    if (decodingMode !== "safe" && decodingMode !== "mixed" && decodingMode !== "bigint") {
      throw new Error(`Unknown decodingMode option: ${decodingMode}`);
    }
    if (data.byteLength === 0 || data.byteLength > 8) {
      throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);
    }
    const padding = new Uint8Array(8 - data.byteLength);
    const encoding = concatArrays2(padding, data);
    const view = new DataView(encoding.buffer);
    const num = view.getBigUint64(0);
    const isBig = num > BigInt(Number.MAX_SAFE_INTEGER);
    if (decodingMode === "safe") {
      if (isBig) {
        throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
      }
      return Number(num);
    }
    if (decodingMode === "mixed" && !isBig) {
      return Number(num);
    }
    return num;
  }
  var init_uint64 = __esm({
    "node_modules/algosdk/dist/esm/encoding/uint64.js"() {
      init_polyfills();
      init_utils();
    }
  });

  // node_modules/algosdk/dist/esm/encoding/binarydata.js
  function base64ToBytes(base64String) {
    if (isNode3()) {
      return new Uint8Array(Buffer.from(base64String, "base64"));
    }
    const binString = atob(base64String);
    return Uint8Array.from(binString, (m3) => m3.codePointAt(0));
  }
  function bytesToBase64(byteArray) {
    if (isNode3()) {
      return Buffer.from(byteArray).toString("base64");
    }
    const binString = Array.from(byteArray, (x3) => String.fromCodePoint(x3)).join("");
    return btoa(binString);
  }
  function bytesToString(byteArray) {
    return new TextDecoder().decode(byteArray);
  }
  function coerceToBytes(input) {
    if (typeof input === "string") {
      return new TextEncoder().encode(input);
    }
    return input;
  }
  function bytesToHex(byteArray) {
    if (isNode3()) {
      return Buffer.from(byteArray).toString("hex");
    }
    return Array.from(byteArray).map((i2) => i2.toString(16).padStart(2, "0")).join("");
  }
  function hexToBytes(hexString) {
    if (isNode3()) {
      return Buffer.from(hexString, "hex");
    }
    let hex = hexString;
    if (hexString.length % 2 !== 0) {
      hex = hexString.padStart(1, "0");
    }
    const byteArray = new Uint8Array(hex.length / 2);
    for (let i2 = 0; i2 < hex.length / 2; i2++) {
      byteArray[i2] = parseInt(hex.slice(2 * i2, 2 * i2 + 2), 16);
    }
    return byteArray;
  }
  var init_binarydata = __esm({
    "node_modules/algosdk/dist/esm/encoding/binarydata.js"() {
      init_polyfills();
      init_utils();
    }
  });

  // node_modules/algosdk/dist/esm/encoding/address.js
  function checksumFromPublicKey(pk) {
    return Uint8Array.from(genericHash(pk).slice(HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, HASH_BYTES_LENGTH));
  }
  function decodeAddress(address) {
    return Address.fromString(address);
  }
  function isValidAddress2(address) {
    try {
      Address.fromString(address);
    } catch (e2) {
      return false;
    }
    return true;
  }
  function encodeAddress(address) {
    return new Address(address).toString();
  }
  function getApplicationAddress(appID) {
    const toBeSigned = concatArrays2(APP_ID_PREFIX, encodeUint64(appID));
    const hash = genericHash(toBeSigned);
    return new Address(Uint8Array.from(hash));
  }
  var import_hi_base32, ALGORAND_ADDRESS_BYTE_LENGTH, ALGORAND_CHECKSUM_BYTE_LENGTH, ALGORAND_ADDRESS_LENGTH, ALGORAND_ZERO_ADDRESS_STRING, MALFORMED_ADDRESS_ERROR_MSG, CHECKSUM_ADDRESS_ERROR_MSG, Address, APP_ID_PREFIX;
  var init_address = __esm({
    "node_modules/algosdk/dist/esm/encoding/address.js"() {
      init_polyfills();
      import_hi_base32 = __toESM(require_base32(), 1);
      init_naclWrappers();
      init_utils();
      init_uint64();
      init_binarydata();
      ALGORAND_ADDRESS_BYTE_LENGTH = 36;
      ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
      ALGORAND_ADDRESS_LENGTH = 58;
      ALGORAND_ZERO_ADDRESS_STRING = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
      MALFORMED_ADDRESS_ERROR_MSG = "address seems to be malformed";
      CHECKSUM_ADDRESS_ERROR_MSG = "wrong checksum for address";
      Address = class _Address {
        /**
         * Create a new Address object from its binary form.
         * @param publicKey - The binary form of the address. Must be 32 bytes.
         */
        constructor(publicKey) {
          if (!(publicKey instanceof Uint8Array)) {
            throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: ${publicKey} is not Uint8Array, type ${typeof publicKey}`);
          }
          if (publicKey.length !== ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH)
            throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: 0x${bytesToHex(publicKey)}, length ${publicKey.length}`);
          this.publicKey = publicKey;
        }
        /**
         * Check if the address is equal to another address.
         */
        equals(other) {
          return other instanceof _Address && arrayEqual(this.publicKey, other.publicKey);
        }
        /**
         * Compute the 4 byte checksum of the address.
         */
        checksum() {
          return checksumFromPublicKey(this.publicKey);
        }
        /**
         * Encode the address into a string form.
         */
        toString() {
          const addr = import_hi_base32.default.encode(concatArrays2(this.publicKey, this.checksum()));
          return addr.slice(0, ALGORAND_ADDRESS_LENGTH);
        }
        /**
         * Decode an address from a string.
         * @param address - The address to decode. Must be 58 bytes long.
         * @returns An Address object corresponding to the input string.
         */
        static fromString(address) {
          if (typeof address !== "string")
            throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected string, got ${typeof address}, ${address}`);
          if (address.length !== ALGORAND_ADDRESS_LENGTH)
            throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected length ${ALGORAND_ADDRESS_LENGTH}, got ${address.length}: ${address}`);
          const decoded = import_hi_base32.default.decode.asBytes(address);
          if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)
            throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected byte length ${ALGORAND_ADDRESS_BYTE_LENGTH}, got ${decoded.length}`);
          const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
          const cs = new Uint8Array(decoded.slice(PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));
          const checksum = checksumFromPublicKey(pk);
          if (!arrayEqual(checksum, cs))
            throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);
          return new _Address(pk);
        }
        /**
         * Get the zero address.
         */
        static zeroAddress() {
          return new _Address(new Uint8Array(ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
        }
      };
      APP_ID_PREFIX = new TextEncoder().encode("appID");
    }
  });

  // node_modules/algosdk/dist/esm/convert.js
  function microalgosToAlgos(microalgos) {
    if (microalgos < 0 || !Number.isSafeInteger(microalgos)) {
      throw new Error(INVALID_MICROALGOS_ERROR_MSG);
    }
    return microalgos / MICROALGOS_TO_ALGOS_RATIO;
  }
  function algosToMicroalgos(algos) {
    const microalgos = algos * MICROALGOS_TO_ALGOS_RATIO;
    return Math.round(microalgos);
  }
  var MICROALGOS_TO_ALGOS_RATIO, INVALID_MICROALGOS_ERROR_MSG;
  var init_convert = __esm({
    "node_modules/algosdk/dist/esm/convert.js"() {
      init_polyfills();
      MICROALGOS_TO_ALGOS_RATIO = 1e6;
      INVALID_MICROALGOS_ERROR_MSG = "Microalgos should be positive and less than 2^53 - 1.";
    }
  });

  // node_modules/algosdk/dist/esm/client/urlTokenBaseHTTPClient.js
  var URLTokenBaseHTTPError, URLTokenBaseHTTPClient;
  var init_urlTokenBaseHTTPClient = __esm({
    "node_modules/algosdk/dist/esm/client/urlTokenBaseHTTPClient.js"() {
      init_polyfills();
      URLTokenBaseHTTPError = class extends Error {
        constructor(message, response) {
          super(message);
          this.response = response;
          this.name = "URLTokenBaseHTTPError";
          this.response = response;
        }
      };
      URLTokenBaseHTTPClient = class _URLTokenBaseHTTPClient {
        constructor(tokenHeader, baseServer, port, defaultHeaders = {}) {
          this.defaultHeaders = defaultHeaders;
          const fixedBaseServer = baseServer.endsWith("/") ? baseServer : `${baseServer}/`;
          const baseServerURL = new URL(fixedBaseServer);
          if (typeof port !== "undefined") {
            baseServerURL.port = port.toString();
          }
          if (baseServerURL.protocol.length === 0) {
            throw new Error("Invalid base server URL, protocol must be defined.");
          }
          this.baseURL = baseServerURL;
          this.tokenHeader = tokenHeader;
        }
        /**
         * Compute the URL for a path relative to the instance's address
         * @param relativePath - A path string
         * @param query - An optional key-value object of query parameters to add to the URL. If the
         *   relativePath already has query parameters on it, the additional parameters defined here will
         *   be added to the URL without modifying those (unless a key collision occurs).
         * @returns A URL string
         */
        getURL(relativePath, query) {
          let fixedRelativePath;
          if (relativePath.startsWith("./")) {
            fixedRelativePath = relativePath;
          } else if (relativePath.startsWith("/")) {
            fixedRelativePath = `.${relativePath}`;
          } else {
            fixedRelativePath = `./${relativePath}`;
          }
          const address = new URL(fixedRelativePath, this.baseURL);
          if (query) {
            for (const [key, value] of Object.entries(query)) {
              address.searchParams.set(key, value.toString());
            }
          }
          return address.toString();
        }
        static formatFetchResponseHeaders(headers) {
          const headersObj = {};
          headers.forEach((key, value) => {
            headersObj[key] = value;
          });
          return headersObj;
        }
        static async checkHttpError(res) {
          if (res.ok) {
            return;
          }
          let body;
          let bodyErrorMessage;
          try {
            body = new Uint8Array(await res.arrayBuffer());
            const decoded = JSON.parse(new TextDecoder().decode(body));
            if (decoded.message) {
              bodyErrorMessage = decoded.message;
            }
          } catch (_3) {
          }
          let message = `Network request error. Received status ${res.status} (${res.statusText})`;
          if (bodyErrorMessage) {
            message += `: ${bodyErrorMessage}`;
          }
          throw new URLTokenBaseHTTPError(message, {
            body: body ?? new Uint8Array(),
            status: res.status,
            headers: _URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
          });
        }
        static async formatFetchResponse(res) {
          await this.checkHttpError(res);
          return {
            body: new Uint8Array(await res.arrayBuffer()),
            status: res.status,
            headers: _URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
          };
        }
        async get(relativePath, query, requestHeaders, customOptions) {
          const headers = {
            ...this.tokenHeader,
            ...this.defaultHeaders,
            ...requestHeaders ?? {}
          };
          const res = await fetch(this.getURL(relativePath, query), {
            headers,
            ...customOptions ?? {}
          });
          return _URLTokenBaseHTTPClient.formatFetchResponse(res);
        }
        async post(relativePath, data, query, requestHeaders, customOptions) {
          const headers = {
            ...this.tokenHeader,
            ...this.defaultHeaders,
            ...requestHeaders ?? {}
          };
          const res = await fetch(this.getURL(relativePath, query), {
            method: "POST",
            body: data,
            headers,
            ...customOptions ?? {}
          });
          return _URLTokenBaseHTTPClient.formatFetchResponse(res);
        }
        async delete(relativePath, data, query, requestHeaders, customOptions) {
          const headers = {
            ...this.tokenHeader,
            ...this.defaultHeaders,
            ...requestHeaders ?? {}
          };
          const res = await fetch(this.getURL(relativePath, query), {
            method: "DELETE",
            body: data,
            headers,
            ...customOptions ?? {}
          });
          return _URLTokenBaseHTTPClient.formatFetchResponse(res);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/client.js
  function removeFalsyOrEmpty(obj) {
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        if (!obj[key] || obj[key].length === 0)
          delete obj[key];
      }
    }
    return obj;
  }
  function tolowerCaseKeys(o3) {
    return Object.keys(o3).reduce((c2, k3) => (c2[k3.toLowerCase()] = o3[k3], c2), {});
  }
  function getAcceptFormat(query) {
    if (query !== void 0 && Object.prototype.hasOwnProperty.call(query, "format")) {
      switch (query.format) {
        case "msgpack":
          return "application/msgpack";
        case "json":
        default:
          return "application/json";
      }
    } else
      return "application/json";
  }
  var HTTPClientResponse, HTTPClient;
  var init_client = __esm({
    "node_modules/algosdk/dist/esm/client/client.js"() {
      init_polyfills();
      init_utils();
      init_urlTokenBaseHTTPClient();
      HTTPClientResponse = class {
        constructor(options) {
          this.body = options.body;
          this.text = options.text;
          this.format = options.format;
          this.headers = options.headers;
          this.status = options.status;
          this.ok = options.ok;
        }
        /**
         * Returns the response body as a string, ready to be parsed as JSON.
         */
        getJSONText() {
          if (this.text === void 0) {
            throw new Error(`Response body does not contain JSON data. Format is ${this.format}`);
          }
          return this.text;
        }
        /**
         * Parses the response body as JSON with the given options.
         */
        parseBodyAsJSON(jsonOptions) {
          if (this.text === void 0) {
            throw new Error(`Response body does not contain JSON data. Format is ${this.format}`);
          }
          return HTTPClient.parseJSON(this.text, this.status, jsonOptions);
        }
      };
      HTTPClient = class _HTTPClient {
        constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {
          if (baseServer !== void 0) {
            this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);
          } else {
            this.bc = bcOrTokenHeader;
          }
        }
        /**
         * Parse JSON using utils.parseJSON
         *
         * @param text - JSON data
         * @param status - Status of the response (used in case parseJSON fails)
         * @param jsonOptions - Options object to use to decode JSON responses. See
         *   utils.parseJSON for the options available.
         */
        static parseJSON(text, status, jsonOptions) {
          try {
            if (!text) {
              return null;
            }
            return parseJSON(text, jsonOptions);
          } catch (err_) {
            const err = err_;
            err.rawResponse = text || null;
            err.statusCode = status;
            throw err;
          }
        }
        /**
         * Serialize the data according to the requestHeaders
         * Assumes that requestHeaders contain a key "content-type"
         * If the content-type is "application/json", data is JSON serialized
         * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array
         * or an Uint8Array
         * @private
         */
        static serializeData(data, requestHeaders) {
          if (!data) {
            return new Uint8Array(0);
          }
          if (requestHeaders["content-type"] === "application/json") {
            return new TextEncoder().encode(stringifyJSON(data));
          }
          if (typeof data === "string") {
            return new TextEncoder().encode(data);
          }
          if (data instanceof Uint8Array) {
            return data;
          }
          throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
        }
        /**
         * Convert a BaseHTTPClientResponse into a full HTTPClientResponse
         * Parse the body in
         * Modifies in place res and return the result
         */
        static prepareResponse(res, format) {
          const { body } = res;
          let text;
          if (format !== "application/msgpack") {
            text = body && new TextDecoder().decode(body) || "";
          }
          return new HTTPClientResponse({
            ...res,
            format,
            text,
            ok: Math.trunc(res.status / 100) === 2
          });
        }
        /**
         * Prepare an error with a response
         * (the type of errors BaseHTTPClient are supposed to throw)
         * by adding the status and preparing the internal response
         * @private
         */
        static prepareResponseError(err) {
          if (err.response) {
            err.response = _HTTPClient.prepareResponse(err.response, "application/json");
            err.status = err.response.status;
          }
          return err;
        }
        /**
         * Send a GET request.
         *
         * @param options - The options to use for the request.
         * @param options.relativePath - The path of the request.
         * @param options.query - An object containing the query parameters of the request.
         * @param options.requestHeaders - An object containing additional request headers to use.
         *   or not.
         * @param options.customOptions - An object containing additional options to pass to the
         *   underlying BaseHTTPClient instance.
         * @returns Response object.
         */
        async get({ relativePath, query, requestHeaders, customOptions }) {
          const format = getAcceptFormat(query);
          const fullHeaders = { ...requestHeaders ?? {}, accept: format };
          try {
            const res = await this.bc.get(relativePath, query ? removeFalsyOrEmpty(query) : void 0, fullHeaders, customOptions);
            return _HTTPClient.prepareResponse(res, format);
          } catch (err) {
            throw _HTTPClient.prepareResponseError(err);
          }
        }
        /**
         * Send a POST request.
         * If no content-type present, adds the header "content-type: application/json"
         * and data is serialized in JSON (if not empty)
         * @param options - The options to use for the request.
         */
        async post({ relativePath, data, query, requestHeaders, customOptions }) {
          const fullHeaders = {
            "content-type": "application/json",
            ...tolowerCaseKeys(requestHeaders ?? {})
          };
          try {
            const res = await this.bc.post(relativePath, _HTTPClient.serializeData(data, fullHeaders), query, fullHeaders, customOptions);
            return _HTTPClient.prepareResponse(res, "application/json");
          } catch (err) {
            throw _HTTPClient.prepareResponseError(err);
          }
        }
        /**
         * Send a DELETE request.
         * If no content-type present, adds the header "content-type: application/json"
         * and data is serialized in JSON (if not empty)
         * @param options - The options to use for the request.
         */
        async delete({ relativePath, data, requestHeaders, customOptions }) {
          const fullHeaders = {
            "content-type": "application/json",
            ...tolowerCaseKeys(requestHeaders ?? {})
          };
          try {
            const res = await this.bc.delete(relativePath, typeof data !== "undefined" ? _HTTPClient.serializeData(data, fullHeaders) : void 0, void 0, fullHeaders, customOptions);
            return _HTTPClient.prepareResponse(res, "application/json");
          } catch (err) {
            throw _HTTPClient.prepareResponseError(err);
          }
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/serviceClient.js
  function convertTokenStringToTokenHeader(headerIdentifier, token = "") {
    const tokenHeader = {};
    if (token === "") {
      return tokenHeader;
    }
    tokenHeader[headerIdentifier] = token;
    return tokenHeader;
  }
  function isBaseHTTPClient(tbc) {
    return typeof tbc.get === "function";
  }
  var ServiceClient;
  var init_serviceClient = __esm({
    "node_modules/algosdk/dist/esm/client/v2/serviceClient.js"() {
      init_polyfills();
      init_client();
      ServiceClient = class {
        constructor(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient, baseServer, port, defaultHeaders = {}) {
          if (isBaseHTTPClient(tokenHeaderOrStrOrBaseClient)) {
            this.c = new HTTPClient(tokenHeaderOrStrOrBaseClient);
          } else {
            let tokenHeader;
            if (typeof tokenHeaderOrStrOrBaseClient === "string") {
              tokenHeader = convertTokenStringToTokenHeader(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient);
            } else {
              tokenHeader = tokenHeaderOrStrOrBaseClient;
            }
            this.c = new HTTPClient(tokenHeader, baseServer, port, defaultHeaders);
          }
        }
      };
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/utils/utf8.mjs
  function utf8Count(str) {
    var strLength = str.length;
    var byteLength = 0;
    var pos = 0;
    while (pos < strLength) {
      var value = str.charCodeAt(pos++);
      if ((value & 4294967168) === 0) {
        byteLength++;
        continue;
      } else if ((value & 4294965248) === 0) {
        byteLength += 2;
      } else {
        if (value >= 55296 && value <= 56319) {
          if (pos < strLength) {
            var extra = str.charCodeAt(pos);
            if ((extra & 64512) === 56320) {
              ++pos;
              value = ((value & 1023) << 10) + (extra & 1023) + 65536;
            }
          }
        }
        if ((value & 4294901760) === 0) {
          byteLength += 3;
        } else {
          byteLength += 4;
        }
      }
    }
    return byteLength;
  }
  function utf8EncodeJs(str, output, outputOffset) {
    var strLength = str.length;
    var offset = outputOffset;
    var pos = 0;
    while (pos < strLength) {
      var value = str.charCodeAt(pos++);
      if ((value & 4294967168) === 0) {
        output[offset++] = value;
        continue;
      } else if ((value & 4294965248) === 0) {
        output[offset++] = value >> 6 & 31 | 192;
      } else {
        if (value >= 55296 && value <= 56319) {
          if (pos < strLength) {
            var extra = str.charCodeAt(pos);
            if ((extra & 64512) === 56320) {
              ++pos;
              value = ((value & 1023) << 10) + (extra & 1023) + 65536;
            }
          }
        }
        if ((value & 4294901760) === 0) {
          output[offset++] = value >> 12 & 15 | 224;
          output[offset++] = value >> 6 & 63 | 128;
        } else {
          output[offset++] = value >> 18 & 7 | 240;
          output[offset++] = value >> 12 & 63 | 128;
          output[offset++] = value >> 6 & 63 | 128;
        }
      }
      output[offset++] = value & 63 | 128;
    }
  }
  function utf8EncodeTE(str, output, outputOffset) {
    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
  }
  function utf8Encode(str, output, outputOffset) {
    if (str.length > TEXT_ENCODER_THRESHOLD) {
      utf8EncodeTE(str, output, outputOffset);
    } else {
      utf8EncodeJs(str, output, outputOffset);
    }
  }
  function utf8DecodeJs(bytes, inputOffset, byteLength) {
    var offset = inputOffset;
    var end = offset + byteLength;
    var units = [];
    var result = "";
    while (offset < end) {
      var byte1 = bytes[offset++];
      if ((byte1 & 128) === 0) {
        units.push(byte1);
      } else if ((byte1 & 224) === 192) {
        var byte2 = bytes[offset++] & 63;
        units.push((byte1 & 31) << 6 | byte2);
      } else if ((byte1 & 240) === 224) {
        var byte2 = bytes[offset++] & 63;
        var byte3 = bytes[offset++] & 63;
        units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
      } else if ((byte1 & 248) === 240) {
        var byte2 = bytes[offset++] & 63;
        var byte3 = bytes[offset++] & 63;
        var byte4 = bytes[offset++] & 63;
        var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
        if (unit > 65535) {
          unit -= 65536;
          units.push(unit >>> 10 & 1023 | 55296);
          unit = 56320 | unit & 1023;
        }
        units.push(unit);
      } else {
        units.push(byte1);
      }
      if (units.length >= CHUNK_SIZE) {
        result += String.fromCharCode.apply(String, units);
        units.length = 0;
      }
    }
    if (units.length > 0) {
      result += String.fromCharCode.apply(String, units);
    }
    return result;
  }
  function utf8DecodeTD(bytes, inputOffset, byteLength) {
    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
    return sharedTextDecoder.decode(stringBytes);
  }
  function utf8Decode(bytes, inputOffset, byteLength) {
    if (byteLength > TEXT_DECODER_THRESHOLD) {
      return utf8DecodeTD(bytes, inputOffset, byteLength);
    } else {
      return utf8DecodeJs(bytes, inputOffset, byteLength);
    }
  }
  var sharedTextEncoder, TEXT_ENCODER_THRESHOLD, CHUNK_SIZE, sharedTextDecoder, TEXT_DECODER_THRESHOLD;
  var init_utf8 = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/utils/utf8.mjs"() {
      init_polyfills();
      sharedTextEncoder = new TextEncoder();
      TEXT_ENCODER_THRESHOLD = 50;
      CHUNK_SIZE = 4096;
      sharedTextDecoder = new TextDecoder();
      TEXT_DECODER_THRESHOLD = 200;
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/ExtData.mjs
  var ExtData;
  var init_ExtData = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/ExtData.mjs"() {
      init_polyfills();
      ExtData = /** @class */
      /* @__PURE__ */ function() {
        function ExtData2(type, data) {
          this.type = type;
          this.data = data;
        }
        return ExtData2;
      }();
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/DecodeError.mjs
  var __extends2, DecodeError;
  var init_DecodeError = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/DecodeError.mjs"() {
      init_polyfills();
      __extends2 = /* @__PURE__ */ function() {
        var extendStatics2 = function(d2, b3) {
          extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b4) {
            d3.__proto__ = b4;
          } || function(d3, b4) {
            for (var p2 in b4) if (Object.prototype.hasOwnProperty.call(b4, p2)) d3[p2] = b4[p2];
          };
          return extendStatics2(d2, b3);
        };
        return function(d2, b3) {
          if (typeof b3 !== "function" && b3 !== null)
            throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
          extendStatics2(d2, b3);
          function __() {
            this.constructor = d2;
          }
          d2.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
        };
      }();
      DecodeError = /** @class */
      function(_super) {
        __extends2(DecodeError2, _super);
        function DecodeError2(message) {
          var _this = _super.call(this, message) || this;
          var proto = Object.create(DecodeError2.prototype);
          Object.setPrototypeOf(_this, proto);
          Object.defineProperty(_this, "name", {
            configurable: true,
            enumerable: false,
            value: DecodeError2.name
          });
          return _this;
        }
        return DecodeError2;
      }(Error);
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/utils/int.mjs
  function setUint64(view, offset, value) {
    var high = value / 4294967296;
    var low = value;
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
  }
  function setInt64(view, offset, value) {
    var high = Math.floor(value / 4294967296);
    var low = value;
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
  }
  function getInt64(view, offset, mode) {
    if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {
      var high = view.getInt32(offset);
      var low = view.getUint32(offset + 4);
      if (mode === IntMode.SAFE_NUMBER && (high < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || high === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && low === 0 || high > (Number.MAX_SAFE_INTEGER - low) / 4294967296)) {
        var hexValue = "".concat(high < 0 ? "-" : "", "0x").concat(Math.abs(high).toString(16)).concat(low.toString(16).padStart(8, "0"));
        throw new Error("Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ".concat(hexValue));
      }
      return high * 4294967296 + low;
    }
    var value = view.getBigInt64(offset);
    if (mode === IntMode.MIXED && value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER) {
      return Number(value);
    }
    return value;
  }
  function getUint64(view, offset, mode) {
    if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {
      var high = view.getUint32(offset);
      var low = view.getUint32(offset + 4);
      if (mode === IntMode.SAFE_NUMBER && high > (Number.MAX_SAFE_INTEGER - low) / 4294967296) {
        var hexValue = "0x".concat(high.toString(16)).concat(low.toString(16).padStart(8, "0"));
        throw new Error("Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ".concat(hexValue));
      }
      return high * 4294967296 + low;
    }
    var value = view.getBigUint64(offset);
    if (mode === IntMode.MIXED && value <= Number.MAX_SAFE_INTEGER) {
      return Number(value);
    }
    return value;
  }
  function convertSafeIntegerToMode(value, mode) {
    if (mode === IntMode.BIGINT) {
      return BigInt(value);
    }
    return Number(value);
  }
  var IntMode, UINT32_MAX;
  var init_int = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/utils/int.mjs"() {
      init_polyfills();
      (function(IntMode2) {
        IntMode2[IntMode2["UNSAFE_NUMBER"] = 0] = "UNSAFE_NUMBER";
        IntMode2[IntMode2["SAFE_NUMBER"] = 1] = "SAFE_NUMBER";
        IntMode2[IntMode2["AS_ENCODED"] = 2] = "AS_ENCODED";
        IntMode2[IntMode2["MIXED"] = 3] = "MIXED";
        IntMode2[IntMode2["BIGINT"] = 4] = "BIGINT";
      })(IntMode || (IntMode = {}));
      UINT32_MAX = 4294967295;
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/timestamp.mjs
  function encodeTimeSpecToTimestamp(_a) {
    var sec = _a.sec, nsec = _a.nsec;
    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
      if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
        var rv = new Uint8Array(4);
        var view = new DataView(rv.buffer);
        view.setUint32(0, sec);
        return rv;
      } else {
        var secHigh = sec / 4294967296;
        var secLow = sec & 4294967295;
        var rv = new Uint8Array(8);
        var view = new DataView(rv.buffer);
        view.setUint32(0, nsec << 2 | secHigh & 3);
        view.setUint32(4, secLow);
        return rv;
      }
    } else {
      var rv = new Uint8Array(12);
      var view = new DataView(rv.buffer);
      view.setUint32(0, nsec);
      setInt64(view, 4, sec);
      return rv;
    }
  }
  function encodeDateToTimeSpec(date) {
    var msec = date.getTime();
    var sec = Math.floor(msec / 1e3);
    var nsec = (msec - sec * 1e3) * 1e6;
    var nsecInSec = Math.floor(nsec / 1e9);
    return {
      sec: sec + nsecInSec,
      nsec: nsec - nsecInSec * 1e9
    };
  }
  function encodeTimestampExtension(object) {
    if (object instanceof Date) {
      var timeSpec = encodeDateToTimeSpec(object);
      return encodeTimeSpecToTimestamp(timeSpec);
    } else {
      return null;
    }
  }
  function decodeTimestampToTimeSpec(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    switch (data.byteLength) {
      case 4: {
        var sec = view.getUint32(0);
        var nsec = 0;
        return { sec, nsec };
      }
      case 8: {
        var nsec30AndSecHigh2 = view.getUint32(0);
        var secLow32 = view.getUint32(4);
        var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
        var nsec = nsec30AndSecHigh2 >>> 2;
        return { sec, nsec };
      }
      case 12: {
        var sec = getInt64(view, 4, IntMode.UNSAFE_NUMBER);
        var nsec = view.getUint32(0);
        return { sec, nsec };
      }
      default:
        throw new DecodeError("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(data.length));
    }
  }
  function decodeTimestampExtension(data) {
    var timeSpec = decodeTimestampToTimeSpec(data);
    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
  }
  var EXT_TIMESTAMP, TIMESTAMP32_MAX_SEC, TIMESTAMP64_MAX_SEC, timestampExtension;
  var init_timestamp = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/timestamp.mjs"() {
      init_polyfills();
      init_DecodeError();
      init_int();
      EXT_TIMESTAMP = -1;
      TIMESTAMP32_MAX_SEC = 4294967296 - 1;
      TIMESTAMP64_MAX_SEC = 17179869184 - 1;
      timestampExtension = {
        type: EXT_TIMESTAMP,
        encode: encodeTimestampExtension,
        decode: decodeTimestampExtension
      };
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/ExtensionCodec.mjs
  var ExtensionCodec;
  var init_ExtensionCodec = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/ExtensionCodec.mjs"() {
      init_polyfills();
      init_ExtData();
      init_timestamp();
      ExtensionCodec = /** @class */
      function() {
        function ExtensionCodec2() {
          this.builtInEncoders = [];
          this.builtInDecoders = [];
          this.encoders = [];
          this.decoders = [];
          this.register(timestampExtension);
        }
        ExtensionCodec2.prototype.register = function(_a) {
          var type = _a.type, encode2 = _a.encode, decode3 = _a.decode;
          if (type >= 0) {
            this.encoders[type] = encode2;
            this.decoders[type] = decode3;
          } else {
            var index = 1 + type;
            this.builtInEncoders[index] = encode2;
            this.builtInDecoders[index] = decode3;
          }
        };
        ExtensionCodec2.prototype.tryToEncode = function(object, context) {
          for (var i2 = 0; i2 < this.builtInEncoders.length; i2++) {
            var encodeExt = this.builtInEncoders[i2];
            if (encodeExt != null) {
              var data = encodeExt(object, context);
              if (data != null) {
                var type = -1 - i2;
                return new ExtData(type, data);
              }
            }
          }
          for (var i2 = 0; i2 < this.encoders.length; i2++) {
            var encodeExt = this.encoders[i2];
            if (encodeExt != null) {
              var data = encodeExt(object, context);
              if (data != null) {
                var type = i2;
                return new ExtData(type, data);
              }
            }
          }
          if (object instanceof ExtData) {
            return object;
          }
          return null;
        };
        ExtensionCodec2.prototype.decode = function(data, type, context) {
          var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
          if (decodeExt) {
            return decodeExt(data, type, context);
          } else {
            return new ExtData(type, data);
          }
        };
        ExtensionCodec2.defaultCodec = new ExtensionCodec2();
        return ExtensionCodec2;
      }();
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/utils/typedArrays.mjs
  function ensureUint8Array(buffer) {
    if (buffer instanceof Uint8Array) {
      return buffer;
    } else if (ArrayBuffer.isView(buffer)) {
      return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    } else if (buffer instanceof ArrayBuffer) {
      return new Uint8Array(buffer);
    } else {
      return Uint8Array.from(buffer);
    }
  }
  function createDataView(buffer) {
    if (buffer instanceof ArrayBuffer) {
      return new DataView(buffer);
    }
    var bufferView = ensureUint8Array(buffer);
    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
  }
  function compareUint8Arrays(a2, b3) {
    var length = Math.min(a2.length, b3.length);
    for (var i2 = 0; i2 < length; i2++) {
      var diff = a2[i2] - b3[i2];
      if (diff !== 0) {
        return diff;
      }
    }
    return a2.length - b3.length;
  }
  var RawBinaryString;
  var init_typedArrays = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/utils/typedArrays.mjs"() {
      init_polyfills();
      RawBinaryString = /** @class */
      /* @__PURE__ */ function() {
        function RawBinaryString2(rawBinaryValue) {
          this.rawBinaryValue = rawBinaryValue;
          if (!ArrayBuffer.isView(rawBinaryValue)) {
            throw new TypeError("RawBinaryString: rawBinaryValue must be an ArrayBufferView");
          }
        }
        return RawBinaryString2;
      }();
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/Encoder.mjs
  var DEFAULT_MAX_DEPTH, DEFAULT_INITIAL_BUFFER_SIZE, Encoder;
  var init_Encoder = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/Encoder.mjs"() {
      init_polyfills();
      init_utf8();
      init_ExtensionCodec();
      init_int();
      init_typedArrays();
      DEFAULT_MAX_DEPTH = 100;
      DEFAULT_INITIAL_BUFFER_SIZE = 2048;
      Encoder = /** @class */
      function() {
        function Encoder2(options) {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : ExtensionCodec.defaultCodec;
          this.context = options === null || options === void 0 ? void 0 : options.context;
          this.forceBigIntToInt64 = (_b = options === null || options === void 0 ? void 0 : options.forceBigIntToInt64) !== null && _b !== void 0 ? _b : false;
          this.maxDepth = (_c = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _c !== void 0 ? _c : DEFAULT_MAX_DEPTH;
          this.initialBufferSize = (_d = options === null || options === void 0 ? void 0 : options.initialBufferSize) !== null && _d !== void 0 ? _d : DEFAULT_INITIAL_BUFFER_SIZE;
          this.sortKeys = (_e = options === null || options === void 0 ? void 0 : options.sortKeys) !== null && _e !== void 0 ? _e : false;
          this.forceFloat32 = (_f = options === null || options === void 0 ? void 0 : options.forceFloat32) !== null && _f !== void 0 ? _f : false;
          this.ignoreUndefined = (_g = options === null || options === void 0 ? void 0 : options.ignoreUndefined) !== null && _g !== void 0 ? _g : false;
          this.forceIntegerToFloat = (_h = options === null || options === void 0 ? void 0 : options.forceIntegerToFloat) !== null && _h !== void 0 ? _h : false;
          this.pos = 0;
          this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
          this.bytes = new Uint8Array(this.view.buffer);
        }
        Encoder2.prototype.reinitializeState = function() {
          this.pos = 0;
        };
        Encoder2.prototype.encodeSharedRef = function(object) {
          this.reinitializeState();
          this.doEncode(object, 1);
          return this.bytes.subarray(0, this.pos);
        };
        Encoder2.prototype.encode = function(object) {
          this.reinitializeState();
          this.doEncode(object, 1);
          return this.bytes.slice(0, this.pos);
        };
        Encoder2.prototype.doEncode = function(object, depth) {
          if (depth > this.maxDepth) {
            throw new Error("Too deep objects in depth ".concat(depth));
          }
          if (object == null) {
            this.encodeNil();
          } else if (typeof object === "boolean") {
            this.encodeBoolean(object);
          } else if (typeof object === "number") {
            this.encodeNumber(object);
          } else if (typeof object === "string") {
            this.encodeString(object);
          } else {
            this.encodeObject(object, depth);
          }
        };
        Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {
          var requiredSize = this.pos + sizeToWrite;
          if (this.view.byteLength < requiredSize) {
            this.resizeBuffer(requiredSize * 2);
          }
        };
        Encoder2.prototype.resizeBuffer = function(newSize) {
          var newBuffer = new ArrayBuffer(newSize);
          var newBytes = new Uint8Array(newBuffer);
          var newView = new DataView(newBuffer);
          newBytes.set(this.bytes);
          this.view = newView;
          this.bytes = newBytes;
        };
        Encoder2.prototype.encodeNil = function() {
          this.writeU8(192);
        };
        Encoder2.prototype.encodeBoolean = function(object) {
          if (object === false) {
            this.writeU8(194);
          } else {
            this.writeU8(195);
          }
        };
        Encoder2.prototype.encodeNumber = function(object) {
          if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {
            if (object >= 0) {
              if (object < 128) {
                this.writeU8(object);
              } else if (object < 256) {
                this.writeU8(204);
                this.writeU8(object);
              } else if (object < 65536) {
                this.writeU8(205);
                this.writeU16(object);
              } else if (object < 4294967296) {
                this.writeU8(206);
                this.writeU32(object);
              } else {
                this.writeU8(207);
                this.writeU64(object);
              }
            } else {
              if (object >= -32) {
                this.writeU8(224 | object + 32);
              } else if (object >= -128) {
                this.writeU8(208);
                this.writeI8(object);
              } else if (object >= -32768) {
                this.writeU8(209);
                this.writeI16(object);
              } else if (object >= -2147483648) {
                this.writeU8(210);
                this.writeI32(object);
              } else {
                this.writeU8(211);
                this.writeI64(object);
              }
            }
          } else {
            this.encodeNumberAsFloat(object);
          }
        };
        Encoder2.prototype.encodeNumberAsFloat = function(object) {
          if (this.forceFloat32) {
            this.writeU8(202);
            this.writeF32(object);
          } else {
            this.writeU8(203);
            this.writeF64(object);
          }
        };
        Encoder2.prototype.encodeBigInt = function(object) {
          if (this.forceBigIntToInt64) {
            this.encodeBigIntAsInt64(object);
          } else if (object >= 0) {
            if (object < 4294967296 || this.forceIntegerToFloat) {
              this.encodeNumber(Number(object));
            } else if (object < BigInt("0x10000000000000000")) {
              this.encodeBigIntAsInt64(object);
            } else {
              throw new Error("Bigint is too large for uint64: ".concat(object));
            }
          } else {
            if (object >= -2147483648 || this.forceIntegerToFloat) {
              this.encodeNumber(Number(object));
            } else if (object >= BigInt(-1) * BigInt("0x8000000000000000")) {
              this.encodeBigIntAsInt64(object);
            } else {
              throw new Error("Bigint is too small for int64: ".concat(object));
            }
          }
        };
        Encoder2.prototype.encodeBigIntAsInt64 = function(object) {
          if (object >= BigInt(0)) {
            this.writeU8(207);
            this.writeBigUint64(object);
          } else {
            this.writeU8(211);
            this.writeBigInt64(object);
          }
        };
        Encoder2.prototype.writeStringHeader = function(byteLength) {
          if (byteLength < 32) {
            this.writeU8(160 + byteLength);
          } else if (byteLength < 256) {
            this.writeU8(217);
            this.writeU8(byteLength);
          } else if (byteLength < 65536) {
            this.writeU8(218);
            this.writeU16(byteLength);
          } else if (byteLength < 4294967296) {
            this.writeU8(219);
            this.writeU32(byteLength);
          } else {
            throw new Error("Too long string: ".concat(byteLength, " bytes in UTF-8"));
          }
        };
        Encoder2.prototype.encodeString = function(object) {
          var maxHeaderSize = 1 + 4;
          var byteLength = utf8Count(object);
          this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
          this.writeStringHeader(byteLength);
          utf8Encode(object, this.bytes, this.pos);
          this.pos += byteLength;
        };
        Encoder2.prototype.encodeObject = function(object, depth) {
          var ext = this.extensionCodec.tryToEncode(object, this.context);
          if (ext != null) {
            this.encodeExtension(ext);
          } else if (Array.isArray(object)) {
            this.encodeArray(object, depth);
          } else if (ArrayBuffer.isView(object)) {
            this.encodeBinary(object);
          } else if (object instanceof RawBinaryString) {
            this.encodeBinaryAsString(object);
          } else if (typeof object === "bigint") {
            this.encodeBigInt(object);
          } else if (object instanceof Map) {
            this.encodeMap(object, depth);
          } else if (typeof object === "object") {
            this.encodeMapObject(object, depth);
          } else {
            throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(object)));
          }
        };
        Encoder2.prototype.encodeBinary = function(object) {
          var size = object.byteLength;
          if (size < 256) {
            this.writeU8(196);
            this.writeU8(size);
          } else if (size < 65536) {
            this.writeU8(197);
            this.writeU16(size);
          } else if (size < 4294967296) {
            this.writeU8(198);
            this.writeU32(size);
          } else {
            throw new Error("Too large binary: ".concat(size));
          }
          var bytes = ensureUint8Array(object);
          this.writeU8a(bytes);
        };
        Encoder2.prototype.encodeBinaryAsString = function(binaryString) {
          var object = binaryString.rawBinaryValue;
          this.writeStringHeader(object.byteLength);
          var bytes = ensureUint8Array(object);
          this.writeU8a(bytes);
        };
        Encoder2.prototype.encodeArray = function(object, depth) {
          var size = object.length;
          if (size < 16) {
            this.writeU8(144 + size);
          } else if (size < 65536) {
            this.writeU8(220);
            this.writeU16(size);
          } else if (size < 4294967296) {
            this.writeU8(221);
            this.writeU32(size);
          } else {
            throw new Error("Too large array: ".concat(size));
          }
          for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {
            var item = object_1[_i];
            this.doEncode(item, depth + 1);
          }
        };
        Encoder2.prototype.countWithoutUndefined = function(map, keys) {
          var count = 0;
          for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
            var key = keys_1[_i];
            if (map.get(key) !== void 0) {
              count++;
            }
          }
          return count;
        };
        Encoder2.prototype.sortMapKeys = function(keys) {
          var numericKeys = [];
          var stringKeys = [];
          var rawStringKeys = [];
          var binaryKeys = [];
          for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
            var key = keys_2[_i];
            if (typeof key === "number") {
              if (isNaN(key)) {
                throw new Error("Cannot sort map keys with NaN value");
              }
              numericKeys.push(key);
            } else if (typeof key === "bigint") {
              numericKeys.push(key);
            } else if (typeof key === "string") {
              stringKeys.push(key);
            } else if (ArrayBuffer.isView(key)) {
              binaryKeys.push(ensureUint8Array(key));
            } else if (key instanceof RawBinaryString) {
              rawStringKeys.push(key);
            } else {
              throw new Error("Unsupported map key type: ".concat(Object.prototype.toString.apply(key)));
            }
          }
          numericKeys.sort(function(a2, b3) {
            return a2 < b3 ? -1 : a2 > b3 ? 1 : 0;
          });
          stringKeys.sort();
          rawStringKeys.sort(function(a2, b3) {
            return compareUint8Arrays(ensureUint8Array(a2.rawBinaryValue), ensureUint8Array(b3.rawBinaryValue));
          });
          binaryKeys.sort(compareUint8Arrays);
          return [].concat(numericKeys, stringKeys, rawStringKeys, binaryKeys);
        };
        Encoder2.prototype.encodeMapObject = function(object, depth) {
          this.encodeMap(new Map(Object.entries(object)), depth);
        };
        Encoder2.prototype.encodeMap = function(map, depth) {
          var keys = Array.from(map.keys());
          if (this.sortKeys) {
            keys = this.sortMapKeys(keys);
          }
          var size = this.ignoreUndefined ? this.countWithoutUndefined(map, keys) : keys.length;
          if (size < 16) {
            this.writeU8(128 + size);
          } else if (size < 65536) {
            this.writeU8(222);
            this.writeU16(size);
          } else if (size < 4294967296) {
            this.writeU8(223);
            this.writeU32(size);
          } else {
            throw new Error("Too large map object: ".concat(size));
          }
          for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
            var key = keys_3[_i];
            var value = map.get(key);
            if (!(this.ignoreUndefined && value === void 0)) {
              if (typeof key === "string") {
                this.encodeString(key);
              } else if (typeof key === "number") {
                this.encodeNumber(key);
              } else if (typeof key === "bigint") {
                this.encodeBigInt(key);
              } else if (ArrayBuffer.isView(key)) {
                this.encodeBinary(key);
              } else if (key instanceof RawBinaryString) {
                this.encodeBinaryAsString(key);
              } else {
                throw new Error("Unsupported map key type: ".concat(Object.prototype.toString.apply(key)));
              }
              this.doEncode(value, depth + 1);
            }
          }
        };
        Encoder2.prototype.encodeExtension = function(ext) {
          var size = ext.data.length;
          if (size === 1) {
            this.writeU8(212);
          } else if (size === 2) {
            this.writeU8(213);
          } else if (size === 4) {
            this.writeU8(214);
          } else if (size === 8) {
            this.writeU8(215);
          } else if (size === 16) {
            this.writeU8(216);
          } else if (size < 256) {
            this.writeU8(199);
            this.writeU8(size);
          } else if (size < 65536) {
            this.writeU8(200);
            this.writeU16(size);
          } else if (size < 4294967296) {
            this.writeU8(201);
            this.writeU32(size);
          } else {
            throw new Error("Too large extension object: ".concat(size));
          }
          this.writeI8(ext.type);
          this.writeU8a(ext.data);
        };
        Encoder2.prototype.writeU8 = function(value) {
          this.ensureBufferSizeToWrite(1);
          this.view.setUint8(this.pos, value);
          this.pos++;
        };
        Encoder2.prototype.writeU8a = function(values) {
          var size = values.length;
          this.ensureBufferSizeToWrite(size);
          this.bytes.set(values, this.pos);
          this.pos += size;
        };
        Encoder2.prototype.writeI8 = function(value) {
          this.ensureBufferSizeToWrite(1);
          this.view.setInt8(this.pos, value);
          this.pos++;
        };
        Encoder2.prototype.writeU16 = function(value) {
          this.ensureBufferSizeToWrite(2);
          this.view.setUint16(this.pos, value);
          this.pos += 2;
        };
        Encoder2.prototype.writeI16 = function(value) {
          this.ensureBufferSizeToWrite(2);
          this.view.setInt16(this.pos, value);
          this.pos += 2;
        };
        Encoder2.prototype.writeU32 = function(value) {
          this.ensureBufferSizeToWrite(4);
          this.view.setUint32(this.pos, value);
          this.pos += 4;
        };
        Encoder2.prototype.writeI32 = function(value) {
          this.ensureBufferSizeToWrite(4);
          this.view.setInt32(this.pos, value);
          this.pos += 4;
        };
        Encoder2.prototype.writeF32 = function(value) {
          this.ensureBufferSizeToWrite(4);
          this.view.setFloat32(this.pos, value);
          this.pos += 4;
        };
        Encoder2.prototype.writeF64 = function(value) {
          this.ensureBufferSizeToWrite(8);
          this.view.setFloat64(this.pos, value);
          this.pos += 8;
        };
        Encoder2.prototype.writeU64 = function(value) {
          this.ensureBufferSizeToWrite(8);
          setUint64(this.view, this.pos, value);
          this.pos += 8;
        };
        Encoder2.prototype.writeI64 = function(value) {
          this.ensureBufferSizeToWrite(8);
          setInt64(this.view, this.pos, value);
          this.pos += 8;
        };
        Encoder2.prototype.writeBigUint64 = function(value) {
          this.ensureBufferSizeToWrite(8);
          this.view.setBigUint64(this.pos, value);
          this.pos += 8;
        };
        Encoder2.prototype.writeBigInt64 = function(value) {
          this.ensureBufferSizeToWrite(8);
          this.view.setBigInt64(this.pos, value);
          this.pos += 8;
        };
        return Encoder2;
      }();
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/encode.mjs
  function encode(value, options) {
    var encoder = new Encoder(options);
    return encoder.encodeSharedRef(value);
  }
  var init_encode = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/encode.mjs"() {
      init_polyfills();
      init_Encoder();
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/utils/prettyByte.mjs
  function prettyByte(byte) {
    return "".concat(byte < 0 ? "-" : "", "0x").concat(Math.abs(byte).toString(16).padStart(2, "0"));
  }
  var init_prettyByte = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/utils/prettyByte.mjs"() {
      init_polyfills();
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/CachedKeyDecoder.mjs
  var DEFAULT_MAX_KEY_LENGTH, DEFAULT_MAX_LENGTH_PER_KEY, CachedKeyDecoder;
  var init_CachedKeyDecoder = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/CachedKeyDecoder.mjs"() {
      init_polyfills();
      init_utf8();
      DEFAULT_MAX_KEY_LENGTH = 16;
      DEFAULT_MAX_LENGTH_PER_KEY = 16;
      CachedKeyDecoder = /** @class */
      function() {
        function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {
          if (maxKeyLength === void 0) {
            maxKeyLength = DEFAULT_MAX_KEY_LENGTH;
          }
          if (maxLengthPerKey === void 0) {
            maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;
          }
          this.maxKeyLength = maxKeyLength;
          this.maxLengthPerKey = maxLengthPerKey;
          this.hit = 0;
          this.miss = 0;
          this.caches = [];
          for (var i2 = 0; i2 < this.maxKeyLength; i2++) {
            this.caches.push([]);
          }
        }
        CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {
          return byteLength > 0 && byteLength <= this.maxKeyLength;
        };
        CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {
          var records = this.caches[byteLength - 1];
          FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {
            var record = records_1[_i];
            var recordBytes = record.bytes;
            for (var j3 = 0; j3 < byteLength; j3++) {
              if (recordBytes[j3] !== bytes[inputOffset + j3]) {
                continue FIND_CHUNK;
              }
            }
            return record.str;
          }
          return null;
        };
        CachedKeyDecoder2.prototype.store = function(bytes, value) {
          var records = this.caches[bytes.length - 1];
          var record = { bytes, str: value };
          if (records.length >= this.maxLengthPerKey) {
            records[Math.random() * records.length | 0] = record;
          } else {
            records.push(record);
          }
        };
        CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {
          var cachedValue = this.find(bytes, inputOffset, byteLength);
          if (cachedValue != null) {
            this.hit++;
            return cachedValue;
          }
          this.miss++;
          var str = utf8DecodeJs(bytes, inputOffset, byteLength);
          var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
          this.store(slicedCopyOfBytes, str);
          return str;
        };
        return CachedKeyDecoder2;
      }();
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/Decoder.mjs
  function isValidMapKeyType(key, useMap, supportObjectNumberKeys) {
    if (useMap) {
      return typeof key === "string" || typeof key === "number" || typeof key === "bigint" || key instanceof Uint8Array || key instanceof RawBinaryString;
    }
    return typeof key === "string" || supportObjectNumberKeys && typeof key === "number";
  }
  var __awaiter2, __generator2, __asyncValues2, __await2, __asyncGenerator2, STATE_ARRAY, STATE_MAP_KEY, STATE_MAP_VALUE, StackPool, HEAD_BYTE_REQUIRED, EMPTY_VIEW, EMPTY_BYTES, DataViewIndexOutOfBoundsError, MORE_DATA, sharedCachedKeyDecoder, Decoder;
  var init_Decoder = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/Decoder.mjs"() {
      init_polyfills();
      init_prettyByte();
      init_ExtensionCodec();
      init_int();
      init_utf8();
      init_typedArrays();
      init_CachedKeyDecoder();
      init_DecodeError();
      __awaiter2 = function(thisArg, _arguments, P3, generator) {
        function adopt(value) {
          return value instanceof P3 ? value : new P3(function(resolve) {
            resolve(value);
          });
        }
        return new (P3 || (P3 = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e2) {
              reject(e2);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e2) {
              reject(e2);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _3 = { label: 0, sent: function() {
          if (t[0] & 1) throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f3, y3, t, g3;
        return g3 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
          return this;
        }), g3;
        function verb(n3) {
          return function(v3) {
            return step([n3, v3]);
          };
        }
        function step(op) {
          if (f3) throw new TypeError("Generator is already executing.");
          while (g3 && (g3 = 0, op[0] && (_3 = 0)), _3) try {
            if (f3 = 1, y3 && (t = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t = y3["return"]) && t.call(y3), 0) : y3.next) && !(t = t.call(y3, op[1])).done) return t;
            if (y3 = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _3.label++;
                return { value: op[1], done: false };
              case 5:
                _3.label++;
                y3 = op[1];
                op = [0];
                continue;
              case 7:
                op = _3.ops.pop();
                _3.trys.pop();
                continue;
              default:
                if (!(t = _3.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _3 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _3.label = op[1];
                  break;
                }
                if (op[0] === 6 && _3.label < t[1]) {
                  _3.label = t[1];
                  t = op;
                  break;
                }
                if (t && _3.label < t[2]) {
                  _3.label = t[2];
                  _3.ops.push(op);
                  break;
                }
                if (t[2]) _3.ops.pop();
                _3.trys.pop();
                continue;
            }
            op = body.call(thisArg, _3);
          } catch (e2) {
            op = [6, e2];
            y3 = 0;
          } finally {
            f3 = t = 0;
          }
          if (op[0] & 5) throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __asyncValues2 = function(o3) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m3 = o3[Symbol.asyncIterator], i2;
        return m3 ? m3.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2);
        function verb(n3) {
          i2[n3] = o3[n3] && function(v3) {
            return new Promise(function(resolve, reject) {
              v3 = o3[n3](v3), settle(resolve, reject, v3.done, v3.value);
            });
          };
        }
        function settle(resolve, reject, d2, v3) {
          Promise.resolve(v3).then(function(v4) {
            resolve({ value: v4, done: d2 });
          }, reject);
        }
      };
      __await2 = function(v3) {
        return this instanceof __await2 ? (this.v = v3, this) : new __await2(v3);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g3 = generator.apply(thisArg, _arguments || []), i2, q3 = [];
        return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
          return this;
        }, i2;
        function verb(n3) {
          if (g3[n3]) i2[n3] = function(v3) {
            return new Promise(function(a2, b3) {
              q3.push([n3, v3, a2, b3]) > 1 || resume(n3, v3);
            });
          };
        }
        function resume(n3, v3) {
          try {
            step(g3[n3](v3));
          } catch (e2) {
            settle(q3[0][3], e2);
          }
        }
        function step(r3) {
          r3.value instanceof __await2 ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q3[0][2], r3);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f3, v3) {
          if (f3(v3), q3.shift(), q3.length) resume(q3[0][0], q3[0][1]);
        }
      };
      STATE_ARRAY = "array";
      STATE_MAP_KEY = "map_key";
      STATE_MAP_VALUE = "map_value";
      StackPool = /** @class */
      function() {
        function StackPool2(useMap) {
          this.useMap = useMap;
          this.stack = [];
          this.stackHeadPosition = -1;
        }
        Object.defineProperty(StackPool2.prototype, "length", {
          get: function() {
            return this.stackHeadPosition + 1;
          },
          enumerable: false,
          configurable: true
        });
        StackPool2.prototype.top = function() {
          return this.stack[this.stackHeadPosition];
        };
        StackPool2.prototype.pushArrayState = function(size) {
          var state = this.getUninitializedStateFromPool();
          state.type = STATE_ARRAY;
          state.position = 0;
          state.size = size;
          state.array = new Array(size);
        };
        StackPool2.prototype.pushMapState = function(size) {
          var state = this.getUninitializedStateFromPool();
          state.type = STATE_MAP_KEY;
          state.readCount = 0;
          state.size = size;
          state.map = this.useMap ? /* @__PURE__ */ new Map() : {};
        };
        StackPool2.prototype.getUninitializedStateFromPool = function() {
          this.stackHeadPosition++;
          if (this.stackHeadPosition === this.stack.length) {
            var partialState = {
              type: void 0,
              size: 0,
              array: void 0,
              position: 0,
              readCount: 0,
              map: void 0,
              key: null
            };
            this.stack.push(partialState);
          }
          return this.stack[this.stackHeadPosition];
        };
        StackPool2.prototype.release = function(state) {
          var topStackState = this.stack[this.stackHeadPosition];
          if (topStackState !== state) {
            throw new Error("Invalid stack state. Released state is not on top of the stack.");
          }
          if (state.type === STATE_ARRAY) {
            var partialState = state;
            partialState.size = 0;
            partialState.array = void 0;
            partialState.position = 0;
            partialState.type = void 0;
          }
          if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
            var partialState = state;
            partialState.size = 0;
            partialState.map = void 0;
            partialState.readCount = 0;
            partialState.type = void 0;
          }
          this.stackHeadPosition--;
        };
        StackPool2.prototype.reset = function() {
          this.stack.length = 0;
          this.stackHeadPosition = -1;
        };
        return StackPool2;
      }();
      HEAD_BYTE_REQUIRED = -1;
      EMPTY_VIEW = new DataView(new ArrayBuffer(0));
      EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
      try {
        EMPTY_VIEW.getInt8(0);
      } catch (e2) {
        if (!(e2 instanceof RangeError)) {
          throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
        }
      }
      DataViewIndexOutOfBoundsError = RangeError;
      MORE_DATA = new DataViewIndexOutOfBoundsError("Insufficient data");
      sharedCachedKeyDecoder = new CachedKeyDecoder();
      Decoder = /** @class */
      function() {
        function Decoder2(options) {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
          this.totalPos = 0;
          this.pos = 0;
          this.view = EMPTY_VIEW;
          this.bytes = EMPTY_BYTES;
          this.headByte = HEAD_BYTE_REQUIRED;
          this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : ExtensionCodec.defaultCodec;
          this.context = options === null || options === void 0 ? void 0 : options.context;
          this.intMode = (_b = options === null || options === void 0 ? void 0 : options.intMode) !== null && _b !== void 0 ? _b : (options === null || options === void 0 ? void 0 : options.useBigInt64) ? IntMode.AS_ENCODED : IntMode.UNSAFE_NUMBER;
          this.rawBinaryStringValues = (_c = options === null || options === void 0 ? void 0 : options.rawBinaryStringValues) !== null && _c !== void 0 ? _c : false;
          this.rawBinaryStringKeys = (_d = options === null || options === void 0 ? void 0 : options.rawBinaryStringKeys) !== null && _d !== void 0 ? _d : false;
          this.useRawBinaryStringClass = (_e = options === null || options === void 0 ? void 0 : options.useRawBinaryStringClass) !== null && _e !== void 0 ? _e : false;
          this.useMap = (_f = options === null || options === void 0 ? void 0 : options.useMap) !== null && _f !== void 0 ? _f : false;
          this.supportObjectNumberKeys = (_g = options === null || options === void 0 ? void 0 : options.supportObjectNumberKeys) !== null && _g !== void 0 ? _g : false;
          this.maxStrLength = (_h = options === null || options === void 0 ? void 0 : options.maxStrLength) !== null && _h !== void 0 ? _h : UINT32_MAX;
          this.maxBinLength = (_j = options === null || options === void 0 ? void 0 : options.maxBinLength) !== null && _j !== void 0 ? _j : UINT32_MAX;
          this.maxArrayLength = (_k = options === null || options === void 0 ? void 0 : options.maxArrayLength) !== null && _k !== void 0 ? _k : UINT32_MAX;
          this.maxMapLength = (_l = options === null || options === void 0 ? void 0 : options.maxMapLength) !== null && _l !== void 0 ? _l : UINT32_MAX;
          this.maxExtLength = (_m = options === null || options === void 0 ? void 0 : options.maxExtLength) !== null && _m !== void 0 ? _m : UINT32_MAX;
          this.keyDecoder = (options === null || options === void 0 ? void 0 : options.keyDecoder) !== void 0 ? options.keyDecoder : sharedCachedKeyDecoder;
          if (this.rawBinaryStringKeys && !this.useMap) {
            throw new Error("rawBinaryStringKeys is only supported when useMap is true");
          }
          this.stack = new StackPool(this.useMap);
        }
        Decoder2.prototype.reinitializeState = function() {
          this.totalPos = 0;
          this.headByte = HEAD_BYTE_REQUIRED;
          this.stack.reset();
        };
        Decoder2.prototype.setBuffer = function(buffer) {
          this.bytes = ensureUint8Array(buffer);
          this.view = createDataView(this.bytes);
          this.pos = 0;
        };
        Decoder2.prototype.appendBuffer = function(buffer) {
          if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
            this.setBuffer(buffer);
          } else {
            var remainingData = this.bytes.subarray(this.pos);
            var newData = ensureUint8Array(buffer);
            var newBuffer = new Uint8Array(remainingData.length + newData.length);
            newBuffer.set(remainingData);
            newBuffer.set(newData, remainingData.length);
            this.setBuffer(newBuffer);
          }
        };
        Decoder2.prototype.hasRemaining = function(size) {
          return this.view.byteLength - this.pos >= size;
        };
        Decoder2.prototype.createExtraByteError = function(posToShow) {
          var _a = this, view = _a.view, pos = _a.pos;
          return new RangeError("Extra ".concat(view.byteLength - pos, " of ").concat(view.byteLength, " byte(s) found at buffer[").concat(posToShow, "]"));
        };
        Decoder2.prototype.decode = function(buffer) {
          this.reinitializeState();
          this.setBuffer(buffer);
          var object = this.doDecodeSync();
          if (this.hasRemaining(1)) {
            throw this.createExtraByteError(this.pos);
          }
          return object;
        };
        Decoder2.prototype.decodeMulti = function(buffer) {
          return __generator2(this, function(_a) {
            switch (_a.label) {
              case 0:
                this.reinitializeState();
                this.setBuffer(buffer);
                _a.label = 1;
              case 1:
                if (!this.hasRemaining(1)) return [3, 3];
                return [4, this.doDecodeSync()];
              case 2:
                _a.sent();
                return [3, 1];
              case 3:
                return [
                  2
                  /*return*/
                ];
            }
          });
        };
        Decoder2.prototype.decodeAsync = function(stream) {
          var _a, stream_1, stream_1_1;
          var _b, e_1, _c, _d;
          return __awaiter2(this, void 0, void 0, function() {
            var decoded, object, buffer, e_1_1, _e, headByte, pos, totalPos;
            return __generator2(this, function(_f) {
              switch (_f.label) {
                case 0:
                  decoded = false;
                  _f.label = 1;
                case 1:
                  _f.trys.push([1, 6, 7, 12]);
                  _a = true, stream_1 = __asyncValues2(stream);
                  _f.label = 2;
                case 2:
                  return [4, stream_1.next()];
                case 3:
                  if (!(stream_1_1 = _f.sent(), _b = stream_1_1.done, !_b)) return [3, 5];
                  _d = stream_1_1.value;
                  _a = false;
                  buffer = _d;
                  if (decoded) {
                    throw this.createExtraByteError(this.totalPos);
                  }
                  this.appendBuffer(buffer);
                  try {
                    object = this.doDecodeSync();
                    decoded = true;
                  } catch (e2) {
                    if (!(e2 instanceof DataViewIndexOutOfBoundsError)) {
                      throw e2;
                    }
                  }
                  this.totalPos += this.pos;
                  _f.label = 4;
                case 4:
                  _a = true;
                  return [3, 2];
                case 5:
                  return [3, 12];
                case 6:
                  e_1_1 = _f.sent();
                  e_1 = { error: e_1_1 };
                  return [3, 12];
                case 7:
                  _f.trys.push([7, , 10, 11]);
                  if (!(!_a && !_b && (_c = stream_1.return))) return [3, 9];
                  return [4, _c.call(stream_1)];
                case 8:
                  _f.sent();
                  _f.label = 9;
                case 9:
                  return [3, 11];
                case 10:
                  if (e_1) throw e_1.error;
                  return [
                    7
                    /*endfinally*/
                  ];
                case 11:
                  return [
                    7
                    /*endfinally*/
                  ];
                case 12:
                  if (decoded) {
                    if (this.hasRemaining(1)) {
                      throw this.createExtraByteError(this.totalPos);
                    }
                    return [2, object];
                  }
                  _e = this, headByte = _e.headByte, pos = _e.pos, totalPos = _e.totalPos;
                  throw new RangeError("Insufficient data in parsing ".concat(prettyByte(headByte), " at ").concat(totalPos, " (").concat(pos, " in the current buffer)"));
              }
            });
          });
        };
        Decoder2.prototype.decodeArrayStream = function(stream) {
          return this.decodeMultiAsync(stream, true);
        };
        Decoder2.prototype.decodeStream = function(stream) {
          return this.decodeMultiAsync(stream, false);
        };
        Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {
          return __asyncGenerator2(this, arguments, function decodeMultiAsync_1() {
            var isArrayHeaderRequired, arrayItemsLeft, _a, stream_2, stream_2_1, buffer, e_2, e_3_1;
            var _b, e_3, _c, _d;
            return __generator2(this, function(_e) {
              switch (_e.label) {
                case 0:
                  isArrayHeaderRequired = isArray;
                  arrayItemsLeft = -1;
                  _e.label = 1;
                case 1:
                  _e.trys.push([1, 13, 14, 19]);
                  _a = true, stream_2 = __asyncValues2(stream);
                  _e.label = 2;
                case 2:
                  return [4, __await2(stream_2.next())];
                case 3:
                  if (!(stream_2_1 = _e.sent(), _b = stream_2_1.done, !_b)) return [3, 12];
                  _d = stream_2_1.value;
                  _a = false;
                  buffer = _d;
                  if (isArray && arrayItemsLeft === 0) {
                    throw this.createExtraByteError(this.totalPos);
                  }
                  this.appendBuffer(buffer);
                  if (isArrayHeaderRequired) {
                    arrayItemsLeft = this.readArraySize();
                    isArrayHeaderRequired = false;
                    this.complete();
                  }
                  _e.label = 4;
                case 4:
                  _e.trys.push([4, 9, , 10]);
                  _e.label = 5;
                case 5:
                  if (false) return [3, 8];
                  return [4, __await2(this.doDecodeSync())];
                case 6:
                  return [4, _e.sent()];
                case 7:
                  _e.sent();
                  if (--arrayItemsLeft === 0) {
                    return [3, 8];
                  }
                  return [3, 5];
                case 8:
                  return [3, 10];
                case 9:
                  e_2 = _e.sent();
                  if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {
                    throw e_2;
                  }
                  return [3, 10];
                case 10:
                  this.totalPos += this.pos;
                  _e.label = 11;
                case 11:
                  _a = true;
                  return [3, 2];
                case 12:
                  return [3, 19];
                case 13:
                  e_3_1 = _e.sent();
                  e_3 = { error: e_3_1 };
                  return [3, 19];
                case 14:
                  _e.trys.push([14, , 17, 18]);
                  if (!(!_a && !_b && (_c = stream_2.return))) return [3, 16];
                  return [4, __await2(_c.call(stream_2))];
                case 15:
                  _e.sent();
                  _e.label = 16;
                case 16:
                  return [3, 18];
                case 17:
                  if (e_3) throw e_3.error;
                  return [
                    7
                    /*endfinally*/
                  ];
                case 18:
                  return [
                    7
                    /*endfinally*/
                  ];
                case 19:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        Decoder2.prototype.doDecodeSync = function() {
          DECODE: while (true) {
            var headByte = this.readHeadByte();
            var object = void 0;
            if (headByte >= 224) {
              object = this.convertNumber(headByte - 256);
            } else if (headByte < 192) {
              if (headByte < 128) {
                object = this.convertNumber(headByte);
              } else if (headByte < 144) {
                var size = headByte - 128;
                if (size !== 0) {
                  this.pushMapState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = this.useMap ? /* @__PURE__ */ new Map() : {};
                }
              } else if (headByte < 160) {
                var size = headByte - 144;
                if (size !== 0) {
                  this.pushArrayState(size);
                  this.complete();
                  continue DECODE;
                } else {
                  object = [];
                }
              } else {
                var byteLength = headByte - 160;
                object = this.decodeString(byteLength, 0);
              }
            } else if (headByte === 192) {
              object = null;
            } else if (headByte === 194) {
              object = false;
            } else if (headByte === 195) {
              object = true;
            } else if (headByte === 202) {
              object = this.readF32();
            } else if (headByte === 203) {
              object = this.readF64();
            } else if (headByte === 204) {
              object = this.convertNumber(this.readU8());
            } else if (headByte === 205) {
              object = this.convertNumber(this.readU16());
            } else if (headByte === 206) {
              object = this.convertNumber(this.readU32());
            } else if (headByte === 207) {
              object = this.readU64();
            } else if (headByte === 208) {
              object = this.convertNumber(this.readI8());
            } else if (headByte === 209) {
              object = this.convertNumber(this.readI16());
            } else if (headByte === 210) {
              object = this.convertNumber(this.readI32());
            } else if (headByte === 211) {
              object = this.readI64();
            } else if (headByte === 217) {
              var byteLength = this.lookU8();
              object = this.decodeString(byteLength, 1);
            } else if (headByte === 218) {
              var byteLength = this.lookU16();
              object = this.decodeString(byteLength, 2);
            } else if (headByte === 219) {
              var byteLength = this.lookU32();
              object = this.decodeString(byteLength, 4);
            } else if (headByte === 220) {
              var size = this.readU16();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 221) {
              var size = this.readU32();
              if (size !== 0) {
                this.pushArrayState(size);
                this.complete();
                continue DECODE;
              } else {
                object = [];
              }
            } else if (headByte === 222) {
              var size = this.readU16();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 223) {
              var size = this.readU32();
              if (size !== 0) {
                this.pushMapState(size);
                this.complete();
                continue DECODE;
              } else {
                object = {};
              }
            } else if (headByte === 196) {
              var size = this.lookU8();
              object = this.decodeBinary(size, 1);
            } else if (headByte === 197) {
              var size = this.lookU16();
              object = this.decodeBinary(size, 2);
            } else if (headByte === 198) {
              var size = this.lookU32();
              object = this.decodeBinary(size, 4);
            } else if (headByte === 212) {
              object = this.decodeExtension(1, 0);
            } else if (headByte === 213) {
              object = this.decodeExtension(2, 0);
            } else if (headByte === 214) {
              object = this.decodeExtension(4, 0);
            } else if (headByte === 215) {
              object = this.decodeExtension(8, 0);
            } else if (headByte === 216) {
              object = this.decodeExtension(16, 0);
            } else if (headByte === 199) {
              var size = this.lookU8();
              object = this.decodeExtension(size, 1);
            } else if (headByte === 200) {
              var size = this.lookU16();
              object = this.decodeExtension(size, 2);
            } else if (headByte === 201) {
              var size = this.lookU32();
              object = this.decodeExtension(size, 4);
            } else {
              throw new DecodeError("Unrecognized type byte: ".concat(prettyByte(headByte)));
            }
            this.complete();
            var stack = this.stack;
            while (stack.length > 0) {
              var state = stack.top();
              if (state.type === STATE_ARRAY) {
                state.array[state.position] = object;
                state.position++;
                if (state.position === state.size) {
                  object = state.array;
                  stack.release(state);
                } else {
                  continue DECODE;
                }
              } else if (state.type === STATE_MAP_KEY) {
                if (!isValidMapKeyType(object, this.useMap, this.supportObjectNumberKeys)) {
                  var acceptableTypes = this.useMap ? "string, number, bigint, or Uint8Array" : this.supportObjectNumberKeys ? "string or number" : "string";
                  throw new DecodeError("The type of key must be ".concat(acceptableTypes, " but got ").concat(typeof object));
                }
                if (!this.useMap && object === "__proto__") {
                  throw new DecodeError("The key __proto__ is not allowed");
                }
                state.key = object;
                state.type = STATE_MAP_VALUE;
                continue DECODE;
              } else {
                if (this.useMap) {
                  state.map.set(state.key, object);
                } else {
                  state.map[state.key] = object;
                }
                state.readCount++;
                if (state.readCount === state.size) {
                  object = state.map;
                  stack.release(state);
                } else {
                  state.key = null;
                  state.type = STATE_MAP_KEY;
                  continue DECODE;
                }
              }
            }
            return object;
          }
        };
        Decoder2.prototype.readHeadByte = function() {
          if (this.headByte === HEAD_BYTE_REQUIRED) {
            this.headByte = this.readU8();
          }
          return this.headByte;
        };
        Decoder2.prototype.complete = function() {
          this.headByte = HEAD_BYTE_REQUIRED;
        };
        Decoder2.prototype.readArraySize = function() {
          var headByte = this.readHeadByte();
          switch (headByte) {
            case 220:
              return this.readU16();
            case 221:
              return this.readU32();
            default: {
              if (headByte < 160) {
                return headByte - 144;
              } else {
                throw new DecodeError("Unrecognized array type byte: ".concat(prettyByte(headByte)));
              }
            }
          }
        };
        Decoder2.prototype.pushMapState = function(size) {
          if (size > this.maxMapLength) {
            throw new DecodeError("Max length exceeded: map length (".concat(size, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
          }
          this.stack.pushMapState(size);
        };
        Decoder2.prototype.pushArrayState = function(size) {
          if (size > this.maxArrayLength) {
            throw new DecodeError("Max length exceeded: array length (".concat(size, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
          }
          this.stack.pushArrayState(size);
        };
        Decoder2.prototype.decodeString = function(byteLength, headerOffset) {
          if (this.stateIsMapKey() ? this.rawBinaryStringKeys : this.rawBinaryStringValues) {
            var decoded = this.decodeBinary(byteLength, headerOffset);
            if (this.useRawBinaryStringClass) {
              return new RawBinaryString(decoded);
            }
            return decoded;
          }
          return this.decodeUtf8String(byteLength, headerOffset);
        };
        Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {
          var _a;
          if (byteLength > this.maxStrLength) {
            throw new DecodeError("Max length exceeded: UTF-8 byte length (".concat(byteLength, ") > maxStrLength (").concat(this.maxStrLength, ")"));
          }
          if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
            throw MORE_DATA;
          }
          var offset = this.pos + headerOffset;
          var object;
          if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
            object = this.keyDecoder.decode(this.bytes, offset, byteLength);
          } else {
            object = utf8Decode(this.bytes, offset, byteLength);
          }
          this.pos += headerOffset + byteLength;
          return object;
        };
        Decoder2.prototype.stateIsMapKey = function() {
          if (this.stack.length > 0) {
            var state = this.stack.top();
            return state.type === STATE_MAP_KEY;
          }
          return false;
        };
        Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {
          if (byteLength > this.maxBinLength) {
            throw new DecodeError("Max length exceeded: bin length (".concat(byteLength, ") > maxBinLength (").concat(this.maxBinLength, ")"));
          }
          if (!this.hasRemaining(byteLength + headOffset)) {
            throw MORE_DATA;
          }
          var offset = this.pos + headOffset;
          var object = this.bytes.subarray(offset, offset + byteLength);
          this.pos += headOffset + byteLength;
          return object;
        };
        Decoder2.prototype.decodeExtension = function(size, headOffset) {
          if (size > this.maxExtLength) {
            throw new DecodeError("Max length exceeded: ext length (".concat(size, ") > maxExtLength (").concat(this.maxExtLength, ")"));
          }
          var extType = this.view.getInt8(this.pos + headOffset);
          var data = this.decodeBinary(
            size,
            headOffset + 1
            /* extType */
          );
          return this.extensionCodec.decode(data, extType, this.context);
        };
        Decoder2.prototype.convertNumber = function(value) {
          return convertSafeIntegerToMode(value, this.intMode);
        };
        Decoder2.prototype.lookU8 = function() {
          return this.view.getUint8(this.pos);
        };
        Decoder2.prototype.lookU16 = function() {
          return this.view.getUint16(this.pos);
        };
        Decoder2.prototype.lookU32 = function() {
          return this.view.getUint32(this.pos);
        };
        Decoder2.prototype.readU8 = function() {
          var value = this.view.getUint8(this.pos);
          this.pos++;
          return value;
        };
        Decoder2.prototype.readI8 = function() {
          var value = this.view.getInt8(this.pos);
          this.pos++;
          return value;
        };
        Decoder2.prototype.readU16 = function() {
          var value = this.view.getUint16(this.pos);
          this.pos += 2;
          return value;
        };
        Decoder2.prototype.readI16 = function() {
          var value = this.view.getInt16(this.pos);
          this.pos += 2;
          return value;
        };
        Decoder2.prototype.readU32 = function() {
          var value = this.view.getUint32(this.pos);
          this.pos += 4;
          return value;
        };
        Decoder2.prototype.readI32 = function() {
          var value = this.view.getInt32(this.pos);
          this.pos += 4;
          return value;
        };
        Decoder2.prototype.readU64 = function() {
          var value = getUint64(this.view, this.pos, this.intMode);
          this.pos += 8;
          return value;
        };
        Decoder2.prototype.readI64 = function() {
          var value = getInt64(this.view, this.pos, this.intMode);
          this.pos += 8;
          return value;
        };
        Decoder2.prototype.readF32 = function() {
          var value = this.view.getFloat32(this.pos);
          this.pos += 4;
          return value;
        };
        Decoder2.prototype.readF64 = function() {
          var value = this.view.getFloat64(this.pos);
          this.pos += 8;
          return value;
        };
        return Decoder2;
      }();
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/decode.mjs
  function decode(buffer, options) {
    var decoder = new Decoder(options);
    return decoder.decode(buffer);
  }
  var init_decode = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/decode.mjs"() {
      init_polyfills();
      init_Decoder();
    }
  });

  // node_modules/algorand-msgpack/dist.es5+esm/index.mjs
  var init_dist = __esm({
    "node_modules/algorand-msgpack/dist.es5+esm/index.mjs"() {
      init_polyfills();
      init_encode();
      init_decode();
      init_int();
      init_typedArrays();
    }
  });

  // node_modules/algosdk/dist/esm/encoding/encoding.js
  function containsEmpty(obj) {
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        if (!obj[key] || obj[key].length === 0) {
          return { containsEmpty: true, firstEmptyKey: key };
        }
      }
    }
    return { containsEmpty: false, firstEmptyKey: void 0 };
  }
  function msgpackRawEncode(obj) {
    const options = { sortKeys: true };
    return encode(obj, options);
  }
  function encodeObj(obj) {
    const emptyCheck = containsEmpty(obj);
    if (emptyCheck.containsEmpty) {
      throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
    }
    return msgpackRawEncode(obj);
  }
  function intDecodingToIntMode(intDecoding) {
    switch (intDecoding) {
      case intDecoding_default.UNSAFE:
        return IntMode.UNSAFE_NUMBER;
      case intDecoding_default.SAFE:
        return IntMode.SAFE_NUMBER;
      case intDecoding_default.MIXED:
        return IntMode.MIXED;
      case intDecoding_default.BIGINT:
        return IntMode.BIGINT;
      default:
        throw new Error(`Invalid intDecoding: ${intDecoding}`);
    }
  }
  function msgpackRawDecode(buffer, options) {
    const decoderOptions = {
      intMode: options?.intDecoding ? intDecodingToIntMode(options?.intDecoding) : IntMode.BIGINT
    };
    return decode(buffer, decoderOptions);
  }
  function decodeObj(o3) {
    return msgpackRawDecode(o3, { intDecoding: intDecoding_default.MIXED });
  }
  function msgpackRawDecodeAsMap(encoded, options) {
    const decoderOptions = {
      intMode: options?.intDecoding ? intDecodingToIntMode(options?.intDecoding) : IntMode.BIGINT,
      useMap: true
    };
    return decode(encoded, decoderOptions);
  }
  function msgpackRawDecodeAsMapWithRawStrings(encoded, options) {
    const decoderOptions = {
      intMode: options?.intDecoding ? intDecodingToIntMode(options?.intDecoding) : IntMode.BIGINT,
      useMap: true,
      rawBinaryStringKeys: true,
      rawBinaryStringValues: true,
      useRawBinaryStringClass: true
    };
    return decode(encoded, decoderOptions);
  }
  function msgpackEncodingDataToJSONEncodingData(e2) {
    if (e2 === null || e2 === void 0) {
      return e2;
    }
    if (e2 instanceof Uint8Array) {
      return bytesToBase64(e2);
    }
    if (Array.isArray(e2)) {
      return e2.map(msgpackEncodingDataToJSONEncodingData);
    }
    if (e2 instanceof Map) {
      const obj = {};
      for (const [k3, v3] of e2) {
        if (typeof k3 !== "string") {
          throw new Error(`JSON map key must be a string: ${k3}`);
        }
        obj[k3] = msgpackEncodingDataToJSONEncodingData(v3);
      }
      return obj;
    }
    return e2;
  }
  function jsonEncodingDataToMsgpackEncodingData(e2) {
    if (e2 === null || e2 === void 0) {
      return e2;
    }
    if (typeof e2 === "string" || // Note, this will not convert base64 to Uint8Array
    typeof e2 === "number" || typeof e2 === "bigint" || typeof e2 === "boolean") {
      return e2;
    }
    if (Array.isArray(e2)) {
      return e2.map(jsonEncodingDataToMsgpackEncodingData);
    }
    if (typeof e2 === "object") {
      const obj = /* @__PURE__ */ new Map();
      for (const [key, value] of Object.entries(e2)) {
        obj.set(key, jsonEncodingDataToMsgpackEncodingData(value));
      }
      return obj;
    }
    throw new Error(`Invalid JSON encoding data: ${e2}`);
  }
  function decodeMsgpack(encoded, c2) {
    const decoded = msgpackRawDecodeAsMap(encoded);
    const rawStringProvider = new MsgpackRawStringProvider({
      baseObjectBytes: encoded
    });
    return c2.fromEncodingData(c2.encodingSchema.fromPreparedMsgpack(decoded, rawStringProvider));
  }
  function encodeMsgpack(e2) {
    return msgpackRawEncode(e2.getEncodingSchema().prepareMsgpack(e2.toEncodingData()));
  }
  function decodeJSON(encoded, c2) {
    const decoded = parseJSON(encoded, {
      intDecoding: intDecoding_default.BIGINT
    });
    return c2.fromEncodingData(c2.encodingSchema.fromPreparedJSON(decoded));
  }
  function encodeJSON(e2, options) {
    const { space, ...prepareJSONOptions } = options ?? {};
    const prepared = e2.getEncodingSchema().prepareJSON(e2.toEncodingData(), prepareJSONOptions);
    return stringifyJSON(prepared, void 0, space);
  }
  var ERROR_CONTAINS_EMPTY_STRING, MsgpackObjectPathSegmentKind, MsgpackRawStringProvider, Schema;
  var init_encoding3 = __esm({
    "node_modules/algosdk/dist/esm/encoding/encoding.js"() {
      init_polyfills();
      init_dist();
      init_binarydata();
      init_intDecoding();
      init_utils();
      ERROR_CONTAINS_EMPTY_STRING = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
      (function(MsgpackObjectPathSegmentKind2) {
        MsgpackObjectPathSegmentKind2[MsgpackObjectPathSegmentKind2["MAP_VALUE"] = 0] = "MAP_VALUE";
        MsgpackObjectPathSegmentKind2[MsgpackObjectPathSegmentKind2["ARRAY_ELEMENT"] = 1] = "ARRAY_ELEMENT";
      })(MsgpackObjectPathSegmentKind || (MsgpackObjectPathSegmentKind = {}));
      MsgpackRawStringProvider = class _MsgpackRawStringProvider {
        constructor({ parent, segment, baseObjectBytes }) {
          this.resolvedCache = null;
          this.resolvedCachePresent = false;
          this.parent = parent;
          this.segment = segment;
          this.baseObjectBytes = baseObjectBytes;
        }
        /**
         * Create a new provider that resolves to the current provider's map value at the given key.
         */
        withMapValue(key) {
          return new _MsgpackRawStringProvider({
            parent: this,
            segment: {
              kind: MsgpackObjectPathSegmentKind.MAP_VALUE,
              key
            }
          });
        }
        /**
         * Create a new provider that resolves to the current provider's array element at the given index.
         */
        withArrayElement(index) {
          return new _MsgpackRawStringProvider({
            parent: this,
            segment: {
              kind: MsgpackObjectPathSegmentKind.ARRAY_ELEMENT,
              key: index
            }
          });
        }
        /**
         * Get the raw string at the current location. If the current location is not a raw string, an error is thrown.
         */
        getRawStringAtCurrentLocation() {
          const resolved = this.resolve();
          if (resolved instanceof RawBinaryString) {
            return resolved.rawBinaryValue;
          }
          throw new Error(`Invalid type. Expected RawBinaryString, got ${resolved} (${typeof resolved})`);
        }
        /**
         * Get the raw string map keys and values at the current location. If the current location is not a map, an error is thrown.
         */
        getRawStringKeysAndValuesAtCurrentLocation() {
          const resolved = this.resolve();
          if (!(resolved instanceof Map)) {
            throw new Error(`Invalid type. Expected Map, got ${resolved} (${typeof resolved})`);
          }
          const keysAndValues = /* @__PURE__ */ new Map();
          for (const [key, value] of resolved) {
            if (key instanceof RawBinaryString) {
              keysAndValues.set(key.rawBinaryValue, value);
            } else {
              throw new Error(`Invalid type for map key. Expected RawBinaryString, got ${key} (${typeof key})`);
            }
          }
          return keysAndValues;
        }
        /**
         * Resolve the provider by extracting the value it indicates from the base msgpack object.
         */
        resolve() {
          if (this.resolvedCachePresent) {
            return this.resolvedCache;
          }
          let parentResolved;
          if (this.parent) {
            parentResolved = this.parent.resolve();
          } else {
            parentResolved = msgpackRawDecodeAsMapWithRawStrings(this.baseObjectBytes);
          }
          if (!this.segment) {
            this.resolvedCache = parentResolved;
            this.resolvedCachePresent = true;
            return parentResolved;
          }
          if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {
            if (!(parentResolved instanceof Map)) {
              throw new Error(`Invalid type. Expected Map, got ${parentResolved} (${typeof parentResolved})`);
            }
            if (typeof this.segment.key === "string" || this.segment.key instanceof Uint8Array || this.segment.key instanceof RawBinaryString) {
              const targetBytes = this.segment.key instanceof RawBinaryString ? (
                // Decoded rawBinaryValue will always be a Uint8Array
                this.segment.key.rawBinaryValue
              ) : coerceToBytes(this.segment.key);
              const targetIsRawString = typeof this.segment.key === "string" || this.segment.key instanceof RawBinaryString;
              for (const [key, value] of parentResolved) {
                let potentialKeyBytes;
                if (targetIsRawString) {
                  if (key instanceof RawBinaryString) {
                    potentialKeyBytes = key.rawBinaryValue;
                  }
                } else if (key instanceof Uint8Array) {
                  potentialKeyBytes = key;
                }
                if (potentialKeyBytes && arrayEqual(targetBytes, potentialKeyBytes)) {
                  this.resolvedCache = value;
                  break;
                }
              }
            } else {
              this.resolvedCache = parentResolved.get(this.segment.key);
            }
            this.resolvedCachePresent = true;
            return this.resolvedCache;
          }
          if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {
            if (!Array.isArray(parentResolved)) {
              throw new Error(`Invalid type. Expected Array, got ${parentResolved} (${typeof parentResolved})`);
            }
            this.resolvedCache = parentResolved[this.segment.key];
            this.resolvedCachePresent = true;
            return this.resolvedCache;
          }
          throw new Error(`Invalid segment kind: ${this.segment.kind}`);
        }
        /**
         * Get the path string of the current location indicated by the provider. Useful for debugging.
         */
        getPathString() {
          const parentPathString = this.parent ? this.parent.getPathString() : "root";
          if (!this.segment) {
            return parentPathString;
          }
          if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {
            return `${parentPathString} -> map key "${this.segment.key}" (${typeof this.segment.key})`;
          }
          if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {
            return `${parentPathString} -> array index ${this.segment.key} (${typeof this.segment.key})`;
          }
          return `${parentPathString} -> unknown segment kind ${this.segment.kind}`;
        }
      };
      Schema = class {
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/boolean.js
  var BooleanSchema;
  var init_boolean = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/boolean.js"() {
      init_polyfills();
      init_encoding3();
      BooleanSchema = class extends Schema {
        defaultValue() {
          return false;
        }
        isDefaultValue(data) {
          return data === false;
        }
        prepareMsgpack(data) {
          if (typeof data === "boolean") {
            return data;
          }
          throw new Error("Invalid boolean");
        }
        fromPreparedMsgpack(encoded, _rawStringProvider) {
          if (typeof encoded === "boolean") {
            return encoded;
          }
          throw new Error("Invalid boolean");
        }
        prepareJSON(data, _options) {
          if (typeof data === "boolean") {
            return data;
          }
          throw new Error("Invalid boolean");
        }
        fromPreparedJSON(encoded) {
          if (typeof encoded === "boolean") {
            return encoded;
          }
          throw new Error("Invalid boolean");
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/string.js
  var StringSchema;
  var init_string = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/string.js"() {
      init_polyfills();
      init_encoding3();
      StringSchema = class extends Schema {
        defaultValue() {
          return "";
        }
        isDefaultValue(data) {
          return data === "";
        }
        prepareMsgpack(data) {
          if (typeof data === "string") {
            return data;
          }
          throw new Error(`Invalid string: (${typeof data}) ${data}`);
        }
        fromPreparedMsgpack(encoded, _rawStringProvider) {
          if (typeof encoded === "string") {
            return encoded;
          }
          throw new Error(`Invalid string: (${typeof encoded}) ${encoded}`);
        }
        prepareJSON(data, _options) {
          if (typeof data === "string") {
            return data;
          }
          throw new Error(`Invalid string: (${typeof data}) ${data}`);
        }
        fromPreparedJSON(encoded) {
          if (typeof encoded === "string") {
            return encoded;
          }
          throw new Error(`Invalid string: (${typeof encoded}) ${encoded}`);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/uint64.js
  var Uint64Schema;
  var init_uint642 = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/uint64.js"() {
      init_polyfills();
      init_encoding3();
      init_utils();
      Uint64Schema = class extends Schema {
        defaultValue() {
          return BigInt(0);
        }
        isDefaultValue(data) {
          if (typeof data === "bigint")
            return data === BigInt(0);
          if (typeof data === "number")
            return data === 0;
          return false;
        }
        prepareMsgpack(data) {
          return ensureUint64(data);
        }
        fromPreparedMsgpack(encoded, _rawStringProvider) {
          return ensureUint64(encoded);
        }
        prepareJSON(data, _options) {
          return ensureUint64(data);
        }
        fromPreparedJSON(encoded) {
          return ensureUint64(encoded);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/address.js
  var AddressSchema;
  var init_address2 = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/address.js"() {
      init_polyfills();
      init_encoding3();
      init_address();
      AddressSchema = class extends Schema {
        defaultValue() {
          return Address.zeroAddress();
        }
        isDefaultValue(data) {
          return Address.zeroAddress().equals(data);
        }
        prepareMsgpack(data) {
          if (data instanceof Address) {
            return data.publicKey;
          }
          throw new Error(`Invalid address: (${typeof data}) ${data}`);
        }
        fromPreparedMsgpack(encoded, _rawStringProvider) {
          return new Address(encoded);
        }
        prepareJSON(data, _options) {
          if (data instanceof Address) {
            return data.toString();
          }
          throw new Error(`Invalid address: (${typeof data}) ${data}`);
        }
        fromPreparedJSON(encoded) {
          return Address.fromString(encoded);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/bytearray.js
  var ByteArraySchema, FixedLengthByteArraySchema;
  var init_bytearray = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/bytearray.js"() {
      init_polyfills();
      init_encoding3();
      init_binarydata();
      ByteArraySchema = class extends Schema {
        defaultValue() {
          return new Uint8Array();
        }
        isDefaultValue(data) {
          return data instanceof Uint8Array && data.byteLength === 0;
        }
        prepareMsgpack(data) {
          if (data instanceof Uint8Array) {
            return data;
          }
          throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
        }
        fromPreparedMsgpack(encoded, _rawStringProvider) {
          if (encoded instanceof Uint8Array) {
            return encoded;
          }
          throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
        }
        prepareJSON(data, _options) {
          if (data instanceof Uint8Array) {
            return bytesToBase64(data);
          }
          throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
        }
        fromPreparedJSON(encoded) {
          if (typeof encoded === "string") {
            return base64ToBytes(encoded);
          }
          throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
        }
      };
      FixedLengthByteArraySchema = class extends Schema {
        constructor(length) {
          super();
          this.length = length;
        }
        defaultValue() {
          return new Uint8Array(this.length);
        }
        isDefaultValue(data) {
          return data instanceof Uint8Array && data.byteLength === this.length && data.every((byte) => byte === 0);
        }
        prepareMsgpack(data) {
          if (data instanceof Uint8Array) {
            if (data.byteLength === this.length) {
              return data;
            }
            throw new Error(`Invalid byte array length: wanted ${this.length}, got ${data.byteLength}`);
          }
          throw new Error("Invalid byte array");
        }
        fromPreparedMsgpack(encoded, _rawStringProvider) {
          if (encoded instanceof Uint8Array) {
            if (encoded.byteLength === this.length) {
              return encoded;
            }
            throw new Error(`Invalid byte array length: wanted ${this.length}, got ${encoded.byteLength}`);
          }
          throw new Error("Invalid byte array");
        }
        prepareJSON(data) {
          if (data instanceof Uint8Array) {
            if (data.byteLength === this.length) {
              return bytesToBase64(data);
            }
            throw new Error(`Invalid byte array length: wanted ${this.length}, got ${data.byteLength}`);
          }
          throw new Error("Invalid byte array");
        }
        fromPreparedJSON(encoded) {
          if (typeof encoded === "string") {
            const bytes = base64ToBytes(encoded);
            if (bytes.byteLength === this.length) {
              return bytes;
            }
            throw new Error(`Invalid byte array length: wanted ${this.length}, got ${bytes.byteLength}`);
          }
          throw new Error("Invalid base64 byte array");
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/blockhash.js
  var import_hi_base322, blockHashByteLength, base32Length, BlockHashSchema;
  var init_blockhash = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/blockhash.js"() {
      init_polyfills();
      import_hi_base322 = __toESM(require_base32(), 1);
      init_encoding3();
      blockHashByteLength = 32;
      base32Length = 52;
      BlockHashSchema = class extends Schema {
        defaultValue() {
          return new Uint8Array(blockHashByteLength);
        }
        isDefaultValue(data) {
          return data instanceof Uint8Array && data.byteLength === blockHashByteLength && data.every((byte) => byte === 0);
        }
        prepareMsgpack(data) {
          if (data instanceof Uint8Array && data.byteLength === blockHashByteLength) {
            return data;
          }
          throw new Error(`Invalid block hash: (${typeof data}) ${data}`);
        }
        fromPreparedMsgpack(encoded, _rawStringProvider) {
          if (encoded instanceof Uint8Array && encoded.byteLength === blockHashByteLength) {
            return encoded;
          }
          throw new Error(`Invalid block hash: (${typeof encoded}) ${encoded}`);
        }
        prepareJSON(data, _options) {
          if (data instanceof Uint8Array && data.byteLength === blockHashByteLength) {
            return `blk-${import_hi_base322.default.encode(data).slice(0, base32Length)}`;
          }
          throw new Error(`Invalid block hash: (${typeof data}) ${data}`);
        }
        fromPreparedJSON(encoded) {
          if (typeof encoded === "string" && encoded.length === base32Length + 4 && encoded.startsWith("blk-")) {
            return Uint8Array.from(import_hi_base322.default.decode.asBytes(encoded.slice(4)));
          }
          throw new Error(`Invalid block hash: (${typeof encoded}) ${encoded}`);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/binarystring.js
  var SpecialCaseBinaryStringSchema;
  var init_binarystring = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/binarystring.js"() {
      init_polyfills();
      init_dist();
      init_encoding3();
      init_binarydata();
      init_utils();
      SpecialCaseBinaryStringSchema = class extends Schema {
        defaultValue() {
          return new Uint8Array();
        }
        isDefaultValue(data) {
          return data instanceof Uint8Array && data.byteLength === 0;
        }
        prepareMsgpack(data) {
          if (data instanceof Uint8Array) {
            return new RawBinaryString(data);
          }
          throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
        }
        fromPreparedMsgpack(_encoded, rawStringProvider) {
          return rawStringProvider.getRawStringAtCurrentLocation();
        }
        prepareJSON(data, options) {
          if (data instanceof Uint8Array) {
            const stringValue = bytesToString(data);
            if (!options.lossyBinaryStringConversion && !arrayEqual(coerceToBytes(stringValue), data)) {
              throw new Error(`Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(data)}`);
            }
            return stringValue;
          }
          throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
        }
        fromPreparedJSON(encoded) {
          if (typeof encoded === "string") {
            return coerceToBytes(encoded);
          }
          throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/array.js
  var ArraySchema;
  var init_array = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/array.js"() {
      init_polyfills();
      init_encoding3();
      ArraySchema = class extends Schema {
        constructor(itemSchema) {
          super();
          this.itemSchema = itemSchema;
        }
        defaultValue() {
          return [];
        }
        isDefaultValue(data) {
          return Array.isArray(data) && data.length === 0;
        }
        prepareMsgpack(data) {
          if (Array.isArray(data)) {
            return data.map((item) => this.itemSchema.prepareMsgpack(item));
          }
          throw new Error("ArraySchema data must be an array");
        }
        fromPreparedMsgpack(encoded, rawStringProvider) {
          if (Array.isArray(encoded)) {
            return encoded.map((item, index) => this.itemSchema.fromPreparedMsgpack(item, rawStringProvider.withArrayElement(index)));
          }
          throw new Error(`ArraySchema encoded data must be an array: ${encoded} (${typeof encoded})`);
        }
        prepareJSON(data, options) {
          if (Array.isArray(data)) {
            return data.map((item) => this.itemSchema.prepareJSON(item, options));
          }
          throw new Error("ArraySchema data must be an array");
        }
        fromPreparedJSON(encoded) {
          if (Array.isArray(encoded)) {
            return encoded.map((item) => this.itemSchema.fromPreparedJSON(item));
          }
          throw new Error(`ArraySchema encoded data must be an array: ${encoded} (${typeof encoded})`);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/map.js
  function allOmitEmpty(entries) {
    return entries.map((entry) => ({ ...entry, omitEmpty: true }));
  }
  function combineMaps(...maps) {
    const combined = /* @__PURE__ */ new Map();
    for (const map of maps) {
      for (const [key, value] of map) {
        if (combined.has(key)) {
          throw new Error(`Duplicate key: ${key}`);
        }
        combined.set(key, value);
      }
    }
    return combined;
  }
  function convertMap(map, func) {
    const mapped = /* @__PURE__ */ new Map();
    for (const [key, value] of map) {
      const [newKey, newValue] = func(key, value);
      mapped.set(newKey, newValue);
    }
    return mapped;
  }
  function convertRawStringsInMsgpackValue(value) {
    if (value instanceof RawBinaryString) {
      return bytesToString(value.rawBinaryValue);
    }
    if (value instanceof Map) {
      const newMap = /* @__PURE__ */ new Map();
      for (const [key, val] of value) {
        newMap.set(convertRawStringsInMsgpackValue(key), convertRawStringsInMsgpackValue(val));
      }
      return newMap;
    }
    if (Array.isArray(value)) {
      return value.map(convertRawStringsInMsgpackValue);
    }
    return value;
  }
  var NamedMapSchema, Uint64MapSchema, ByteArrayMapSchema, SpecialCaseBinaryStringMapSchema;
  var init_map = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/map.js"() {
      init_polyfills();
      init_dist();
      init_encoding3();
      init_utils();
      init_binarydata();
      NamedMapSchema = class _NamedMapSchema extends Schema {
        constructor(entries) {
          super();
          this.entries = entries;
          this.checkEntries();
        }
        /**
         * Adds new entries to the map schema. WARNING: this is a mutable operation, and you should be very
         * careful when using it. Any error that happens here is non-recoverable and will corrupt the
         * NamedMapSchema object;
         * @param entries - The entries to add.
         */
        pushEntries(...entries) {
          this.entries.push(...entries);
          this.checkEntries();
        }
        checkEntries() {
          for (const entry of this.entries) {
            if (entry.embedded) {
              if (entry.key !== "") {
                throw new Error("Embedded entries must have an empty key");
              }
              if (!(entry.valueSchema instanceof _NamedMapSchema)) {
                throw new Error("Embedded entry valueSchema must be a NamedMapSchema");
              }
            }
          }
          const keys = /* @__PURE__ */ new Set();
          for (const entry of this.getEntries()) {
            if (keys.has(entry.key)) {
              throw new Error(`Duplicate key: ${entry.key}`);
            }
            keys.add(entry.key);
          }
        }
        /**
         * Returns all top-level entries, properly accounting for fields from embedded entries.
         * @returns An array of all top-level entries for this map.
         */
        getEntries() {
          const entries = [];
          for (const entry of this.entries) {
            if (entry.embedded) {
              const embeddedMapSchema = entry.valueSchema;
              entries.push(...embeddedMapSchema.getEntries());
            } else {
              entries.push(entry);
            }
          }
          return entries;
        }
        defaultValue() {
          const map = /* @__PURE__ */ new Map();
          for (const entry of this.getEntries()) {
            map.set(entry.key, entry.valueSchema.defaultValue());
          }
          return map;
        }
        isDefaultValue(data) {
          if (!(data instanceof Map))
            return false;
          for (const entry of this.getEntries()) {
            if (!entry.valueSchema.isDefaultValue(data.get(entry.key))) {
              return false;
            }
          }
          return true;
        }
        prepareMsgpack(data) {
          if (!(data instanceof Map)) {
            throw new Error(`NamedMapSchema data must be a Map. Got (${typeof data}) ${data}`);
          }
          const map = /* @__PURE__ */ new Map();
          for (const entry of this.getEntries()) {
            const value = data.get(entry.key);
            if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {
              continue;
            }
            map.set(entry.key, entry.valueSchema.prepareMsgpack(value));
          }
          return map;
        }
        fromPreparedMsgpack(encoded, rawStringProvider) {
          if (!(encoded instanceof Map)) {
            throw new Error("NamedMapSchema data must be a Map");
          }
          const map = /* @__PURE__ */ new Map();
          for (const entry of this.getEntries()) {
            if (encoded.has(entry.key)) {
              map.set(entry.key, entry.valueSchema.fromPreparedMsgpack(encoded.get(entry.key), rawStringProvider.withMapValue(entry.key)));
            } else if (entry.omitEmpty) {
              map.set(entry.key, entry.valueSchema.defaultValue());
            } else {
              throw new Error(`Missing key: ${entry.key}`);
            }
          }
          return map;
        }
        prepareJSON(data, options) {
          if (!(data instanceof Map)) {
            throw new Error("NamedMapSchema data must be a Map");
          }
          const obj = {};
          for (const entry of this.getEntries()) {
            const value = data.get(entry.key);
            if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {
              continue;
            }
            obj[entry.key] = entry.valueSchema.prepareJSON(value, options);
          }
          return obj;
        }
        fromPreparedJSON(encoded) {
          if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
            throw new Error("NamedMapSchema data must be an object");
          }
          const map = /* @__PURE__ */ new Map();
          for (const entry of this.getEntries()) {
            if (Object.prototype.hasOwnProperty.call(encoded, entry.key)) {
              map.set(entry.key, entry.valueSchema.fromPreparedJSON(encoded[entry.key]));
            } else if (entry.omitEmpty) {
              map.set(entry.key, entry.valueSchema.defaultValue());
            } else {
              throw new Error(`Missing key: ${entry.key}`);
            }
          }
          return map;
        }
      };
      Uint64MapSchema = class extends Schema {
        constructor(valueSchema) {
          super();
          this.valueSchema = valueSchema;
        }
        defaultValue() {
          return /* @__PURE__ */ new Map();
        }
        isDefaultValue(data) {
          return data instanceof Map && data.size === 0;
        }
        prepareMsgpack(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`);
          }
          const prepared = /* @__PURE__ */ new Map();
          for (const [key, value] of data) {
            const bigintKey = ensureUint64(key);
            if (prepared.has(bigintKey)) {
              throw new Error(`Duplicate key: ${bigintKey}`);
            }
            prepared.set(bigintKey, this.valueSchema.prepareMsgpack(value));
          }
          return prepared;
        }
        fromPreparedMsgpack(encoded, rawStringProvider) {
          if (!(encoded instanceof Map)) {
            throw new Error("Uint64MapSchema data must be a Map");
          }
          const map = /* @__PURE__ */ new Map();
          for (const [key, value] of encoded) {
            const bigintKey = ensureUint64(key);
            if (map.has(bigintKey)) {
              throw new Error(`Duplicate key: ${bigintKey}`);
            }
            map.set(bigintKey, this.valueSchema.fromPreparedMsgpack(value, rawStringProvider.withMapValue(key)));
          }
          return map;
        }
        prepareJSON(data, options) {
          if (!(data instanceof Map)) {
            throw new Error(`Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`);
          }
          const prepared = /* @__PURE__ */ new Map();
          for (const [key, value] of data) {
            const bigintKey = ensureUint64(key);
            if (prepared.has(bigintKey)) {
              throw new Error(`Duplicate key: ${bigintKey}`);
            }
            prepared.set(bigintKey, this.valueSchema.prepareJSON(value, options));
          }
          const obj = {};
          for (const [key, value] of prepared) {
            obj[key.toString()] = value;
          }
          return obj;
        }
        fromPreparedJSON(encoded) {
          if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
            throw new Error("Uint64MapSchema data must be an object");
          }
          const map = /* @__PURE__ */ new Map();
          for (const [key, value] of Object.entries(encoded)) {
            const bigintKey = BigInt(key);
            if (map.has(bigintKey)) {
              throw new Error(`Duplicate key: ${bigintKey}`);
            }
            map.set(bigintKey, this.valueSchema.fromPreparedJSON(value));
          }
          return map;
        }
      };
      ByteArrayMapSchema = class extends Schema {
        constructor(valueSchema) {
          super();
          this.valueSchema = valueSchema;
        }
        defaultValue() {
          return /* @__PURE__ */ new Map();
        }
        isDefaultValue(data) {
          return data instanceof Map && data.size === 0;
        }
        prepareMsgpack(data) {
          if (!(data instanceof Map)) {
            throw new Error(`ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`);
          }
          const prepared = /* @__PURE__ */ new Map();
          for (const [key, value] of data) {
            if (!(key instanceof Uint8Array)) {
              throw new Error(`Invalid key: ${key} (${typeof key})`);
            }
            prepared.set(key, this.valueSchema.prepareMsgpack(value));
          }
          return prepared;
        }
        fromPreparedMsgpack(encoded, rawStringProvider) {
          if (!(encoded instanceof Map)) {
            throw new Error("ByteArrayMapSchema data must be a Map");
          }
          const map = /* @__PURE__ */ new Map();
          for (const [key, value] of encoded) {
            if (!(key instanceof Uint8Array)) {
              throw new Error(`Invalid key: ${key} (${typeof key})`);
            }
            map.set(key, this.valueSchema.fromPreparedMsgpack(value, rawStringProvider.withMapValue(key)));
          }
          return map;
        }
        prepareJSON(data, options) {
          if (!(data instanceof Map)) {
            throw new Error(`ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`);
          }
          const prepared = /* @__PURE__ */ new Map();
          for (const [key, value] of data) {
            if (!(key instanceof Uint8Array)) {
              throw new Error(`Invalid key: ${key} (${typeof key})`);
            }
            const b64Encoded = bytesToBase64(key);
            if (prepared.has(b64Encoded)) {
              throw new Error(`Duplicate key (base64): ${b64Encoded}`);
            }
            prepared.set(b64Encoded, this.valueSchema.prepareJSON(value, options));
          }
          const obj = {};
          for (const [key, value] of prepared) {
            obj[key] = value;
          }
          return obj;
        }
        fromPreparedJSON(encoded) {
          if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
            throw new Error("ByteArrayMapSchema data must be an object");
          }
          const map = /* @__PURE__ */ new Map();
          for (const [key, value] of Object.entries(encoded)) {
            map.set(base64ToBytes(key), this.valueSchema.fromPreparedJSON(value));
          }
          return map;
        }
      };
      SpecialCaseBinaryStringMapSchema = class extends Schema {
        constructor(valueSchema) {
          super();
          this.valueSchema = valueSchema;
        }
        defaultValue() {
          return /* @__PURE__ */ new Map();
        }
        isDefaultValue(data) {
          return data instanceof Map && data.size === 0;
        }
        prepareMsgpack(data) {
          if (!(data instanceof Map)) {
            throw new Error(`SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`);
          }
          const prepared = /* @__PURE__ */ new Map();
          for (const [key, value] of data) {
            if (!(key instanceof Uint8Array)) {
              throw new Error(`Invalid key: ${key} (${typeof key})`);
            }
            prepared.set(new RawBinaryString(key), this.valueSchema.prepareMsgpack(value));
          }
          return prepared;
        }
        fromPreparedMsgpack(_encoded, rawStringProvider) {
          const map = /* @__PURE__ */ new Map();
          const keysAndValues = rawStringProvider.getRawStringKeysAndValuesAtCurrentLocation();
          for (const [key, value] of keysAndValues) {
            map.set(key, this.valueSchema.fromPreparedMsgpack(convertRawStringsInMsgpackValue(value), rawStringProvider.withMapValue(new RawBinaryString(key))));
          }
          return map;
        }
        prepareJSON(data, options) {
          if (!(data instanceof Map)) {
            throw new Error(`SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`);
          }
          const prepared = /* @__PURE__ */ new Map();
          for (const [key, value] of data) {
            if (!(key instanceof Uint8Array)) {
              throw new Error(`Invalid key: ${key}`);
            }
            const keyStringValue = bytesToString(key);
            if (!options.lossyBinaryStringConversion && !arrayEqual(coerceToBytes(keyStringValue), key)) {
              throw new Error(`Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(key)}`);
            }
            prepared.set(keyStringValue, this.valueSchema.prepareJSON(value, options));
          }
          const obj = {};
          for (const [key, value] of prepared) {
            obj[key] = value;
          }
          return obj;
        }
        fromPreparedJSON(encoded) {
          if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
            throw new Error("SpecialCaseBinaryStringMapSchema data must be an object");
          }
          const map = /* @__PURE__ */ new Map();
          for (const [key, value] of Object.entries(encoded)) {
            map.set(coerceToBytes(key), this.valueSchema.fromPreparedJSON(value));
          }
          return map;
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/optional.js
  var OptionalSchema;
  var init_optional = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/optional.js"() {
      init_polyfills();
      init_encoding3();
      OptionalSchema = class extends Schema {
        constructor(valueSchema) {
          super();
          this.valueSchema = valueSchema;
        }
        defaultValue() {
          return void 0;
        }
        isDefaultValue(data) {
          return data === void 0 || this.valueSchema.isDefaultValue(data);
        }
        prepareMsgpack(data) {
          if (data === void 0) {
            return void 0;
          }
          return this.valueSchema.prepareMsgpack(data);
        }
        fromPreparedMsgpack(encoded, rawStringProvider) {
          if (encoded === void 0 || encoded === null) {
            return void 0;
          }
          return this.valueSchema.fromPreparedMsgpack(encoded, rawStringProvider);
        }
        prepareJSON(data, options) {
          if (data === void 0) {
            return null;
          }
          return this.valueSchema.prepareJSON(data, options);
        }
        fromPreparedJSON(encoded) {
          if (encoded === void 0 || encoded === null) {
            return void 0;
          }
          return this.valueSchema.fromPreparedJSON(encoded);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/untyped.js
  var UntypedSchema;
  var init_untyped = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/untyped.js"() {
      init_polyfills();
      init_encoding3();
      UntypedSchema = class extends Schema {
        defaultValue() {
          return void 0;
        }
        isDefaultValue(data) {
          return data === void 0;
        }
        prepareMsgpack(data) {
          return data;
        }
        fromPreparedMsgpack(encoded, _rawStringProvider) {
          return encoded;
        }
        prepareJSON(data, _options) {
          return msgpackEncodingDataToJSONEncodingData(data);
        }
        fromPreparedJSON(encoded) {
          return jsonEncodingDataToMsgpackEncodingData(encoded);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/encoding/schema/index.js
  var init_schema = __esm({
    "node_modules/algosdk/dist/esm/encoding/schema/index.js"() {
      init_polyfills();
      init_boolean();
      init_string();
      init_uint642();
      init_address2();
      init_bytearray();
      init_blockhash();
      init_binarystring();
      init_array();
      init_map();
      init_optional();
      init_untyped();
    }
  });

  // node_modules/algosdk/dist/esm/boxStorage.js
  function boxReferenceToEncodingData(reference, foreignApps, appIndex) {
    const referenceId = BigInt(reference.appIndex);
    const referenceName = reference.name;
    const isOwnReference = referenceId === BigInt(0) || referenceId === appIndex;
    const index = foreignApps.indexOf(referenceId) + 1;
    if (index === 0 && !isOwnReference) {
      throw new Error(`Box ref with appId ${referenceId} not in foreign-apps`);
    }
    return /* @__PURE__ */ new Map([
      ["i", index],
      ["n", referenceName]
    ]);
  }
  function boxReferencesToEncodingData(references, foreignApps, appIndex) {
    const appIndexBigInt = BigInt(appIndex);
    const foreignAppsBigInt = foreignApps.map(BigInt);
    return references.map((bx) => boxReferenceToEncodingData(bx, foreignAppsBigInt, appIndexBigInt));
  }
  var init_boxStorage = __esm({
    "node_modules/algosdk/dist/esm/boxStorage.js"() {
      init_polyfills();
    }
  });

  // node_modules/algosdk/dist/esm/types/transactions/base.js
  function isTransactionType(s2) {
    return s2 === TransactionType.pay || s2 === TransactionType.keyreg || s2 === TransactionType.acfg || s2 === TransactionType.axfer || s2 === TransactionType.afrz || s2 === TransactionType.appl || s2 === TransactionType.stpf || s2 === TransactionType.hb;
  }
  function isOnApplicationComplete(v3) {
    return v3 === OnApplicationComplete.NoOpOC || v3 === OnApplicationComplete.OptInOC || v3 === OnApplicationComplete.CloseOutOC || v3 === OnApplicationComplete.ClearStateOC || v3 === OnApplicationComplete.UpdateApplicationOC || v3 === OnApplicationComplete.DeleteApplicationOC;
  }
  var TransactionType, OnApplicationComplete;
  var init_base = __esm({
    "node_modules/algosdk/dist/esm/types/transactions/base.js"() {
      init_polyfills();
      (function(TransactionType2) {
        TransactionType2["pay"] = "pay";
        TransactionType2["keyreg"] = "keyreg";
        TransactionType2["acfg"] = "acfg";
        TransactionType2["axfer"] = "axfer";
        TransactionType2["afrz"] = "afrz";
        TransactionType2["appl"] = "appl";
        TransactionType2["stpf"] = "stpf";
        TransactionType2["hb"] = "hb";
      })(TransactionType || (TransactionType = {}));
      (function(OnApplicationComplete2) {
        OnApplicationComplete2[OnApplicationComplete2["NoOpOC"] = 0] = "NoOpOC";
        OnApplicationComplete2[OnApplicationComplete2["OptInOC"] = 1] = "OptInOC";
        OnApplicationComplete2[OnApplicationComplete2["CloseOutOC"] = 2] = "CloseOutOC";
        OnApplicationComplete2[OnApplicationComplete2["ClearStateOC"] = 3] = "ClearStateOC";
        OnApplicationComplete2[OnApplicationComplete2["UpdateApplicationOC"] = 4] = "UpdateApplicationOC";
        OnApplicationComplete2[OnApplicationComplete2["DeleteApplicationOC"] = 5] = "DeleteApplicationOC";
      })(OnApplicationComplete || (OnApplicationComplete = {}));
    }
  });

  // node_modules/algosdk/dist/esm/stateproof.js
  var HashFactory, MerkleArrayProof, MerkleSignatureVerifier, Participant, FalconVerifier, FalconSignatureStruct, SigslotCommit, Reveal, StateProof, StateProofMessage;
  var init_stateproof = __esm({
    "node_modules/algosdk/dist/esm/stateproof.js"() {
      init_polyfills();
      init_schema();
      HashFactory = class _HashFactory {
        constructor(params) {
          this.hashType = params.hashType;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _HashFactory.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([["t", this.hashType]]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded HashFactory: ${data}`);
          }
          return new _HashFactory({
            hashType: Number(data.get("t"))
          });
        }
      };
      HashFactory.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "t", valueSchema: new Uint64Schema() }
        // hashType
      ]));
      MerkleArrayProof = class _MerkleArrayProof {
        constructor(params) {
          this.path = params.path;
          this.hashFactory = params.hashFactory;
          this.treeDepth = params.treeDepth;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _MerkleArrayProof.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["pth", this.path],
            ["hsh", this.hashFactory.toEncodingData()],
            ["td", this.treeDepth]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded MerkleArrayProof: ${data}`);
          }
          return new _MerkleArrayProof({
            path: data.get("pth"),
            hashFactory: HashFactory.fromEncodingData(data.get("hsh")),
            treeDepth: Number(data.get("td"))
          });
        }
      };
      MerkleArrayProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "pth",
          // path
          valueSchema: new ArraySchema(new ByteArraySchema())
        },
        {
          key: "hsh",
          // hashFactory
          valueSchema: HashFactory.encodingSchema
        },
        {
          key: "td",
          // treeDepth
          valueSchema: new Uint64Schema()
        }
      ]));
      MerkleSignatureVerifier = class _MerkleSignatureVerifier {
        constructor(params) {
          this.commitment = params.commitment;
          this.keyLifetime = params.keyLifetime;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _MerkleSignatureVerifier.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["cmt", this.commitment],
            ["lf", this.keyLifetime]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded MerkleSignatureVerifier: ${data}`);
          }
          return new _MerkleSignatureVerifier({
            commitment: data.get("cmt"),
            keyLifetime: data.get("lf")
          });
        }
      };
      MerkleSignatureVerifier.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "cmt",
          // commitment
          valueSchema: new FixedLengthByteArraySchema(64)
        },
        {
          key: "lf",
          // keyLifetime
          valueSchema: new Uint64Schema()
        }
      ]));
      Participant = class _Participant {
        constructor(params) {
          this.pk = params.pk;
          this.weight = params.weight;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Participant.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["p", this.pk.toEncodingData()],
            ["w", this.weight]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Participant: ${data}`);
          }
          return new _Participant({
            pk: MerkleSignatureVerifier.fromEncodingData(data.get("p")),
            weight: data.get("w")
          });
        }
      };
      Participant.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "p",
          // pk
          valueSchema: MerkleSignatureVerifier.encodingSchema
        },
        {
          key: "w",
          // weight
          valueSchema: new Uint64Schema()
        }
      ]));
      FalconVerifier = class _FalconVerifier {
        constructor(params) {
          this.publicKey = params.publicKey;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _FalconVerifier.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([["k", this.publicKey]]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded FalconVerifier: ${data}`);
          }
          return new _FalconVerifier({
            publicKey: data.get("k")
          });
        }
      };
      FalconVerifier.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "k", valueSchema: new FixedLengthByteArraySchema(1793) }
        // publicKey
      ]));
      FalconSignatureStruct = class _FalconSignatureStruct {
        constructor(params) {
          this.signature = params.signature;
          this.vectorCommitmentIndex = params.index;
          this.proof = params.proof;
          this.verifyingKey = params.verifyingKey;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _FalconSignatureStruct.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["sig", this.signature],
            ["idx", this.vectorCommitmentIndex],
            ["prf", this.proof.toEncodingData()],
            ["vkey", this.verifyingKey.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded FalconSignatureStruct: ${data}`);
          }
          return new _FalconSignatureStruct({
            signature: data.get("sig"),
            index: data.get("idx"),
            proof: MerkleArrayProof.fromEncodingData(data.get("prf")),
            verifyingKey: FalconVerifier.fromEncodingData(data.get("vkey"))
          });
        }
      };
      FalconSignatureStruct.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "sig", valueSchema: new ByteArraySchema() },
        // signature
        { key: "idx", valueSchema: new Uint64Schema() },
        // index
        { key: "prf", valueSchema: MerkleArrayProof.encodingSchema },
        // proof
        { key: "vkey", valueSchema: FalconVerifier.encodingSchema }
        // verifyingKey
      ]));
      SigslotCommit = class _SigslotCommit {
        constructor(params) {
          this.sig = params.sig;
          this.l = params.l;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SigslotCommit.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["s", this.sig.toEncodingData()],
            ["l", this.l]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SigslotCommit: ${data}`);
          }
          return new _SigslotCommit({
            sig: FalconSignatureStruct.fromEncodingData(data.get("s")),
            l: data.get("l")
          });
        }
      };
      SigslotCommit.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "s", valueSchema: FalconSignatureStruct.encodingSchema },
        // sigslot
        { key: "l", valueSchema: new Uint64Schema() }
        // l
      ]));
      Reveal = class _Reveal {
        constructor(params) {
          this.sigslot = params.sigslot;
          this.participant = params.participant;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Reveal.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["s", this.sigslot.toEncodingData()],
            ["p", this.participant.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Reveal: ${data}`);
          }
          return new _Reveal({
            sigslot: SigslotCommit.fromEncodingData(data.get("s")),
            participant: Participant.fromEncodingData(data.get("p"))
          });
        }
      };
      Reveal.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "s", valueSchema: SigslotCommit.encodingSchema },
        // sigslotCommit
        { key: "p", valueSchema: Participant.encodingSchema }
        // participant
      ]));
      StateProof = class _StateProof {
        constructor(params) {
          this.sigCommit = params.sigCommit;
          this.signedWeight = params.signedWeight;
          this.sigProofs = params.sigProofs;
          this.partProofs = params.partProofs;
          this.merkleSignatureSaltVersion = params.merkleSignatureSaltVersion;
          this.reveals = params.reveals;
          this.positionsToReveal = params.positionsToReveal;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProof.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["c", this.sigCommit],
            ["w", this.signedWeight],
            ["S", this.sigProofs.toEncodingData()],
            ["P", this.partProofs.toEncodingData()],
            ["v", this.merkleSignatureSaltVersion],
            [
              "r",
              convertMap(this.reveals, (key, value) => [key, value.toEncodingData()])
            ],
            ["pr", this.positionsToReveal]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProof: ${data}`);
          }
          return new _StateProof({
            sigCommit: data.get("c"),
            signedWeight: data.get("w"),
            sigProofs: MerkleArrayProof.fromEncodingData(data.get("S")),
            partProofs: MerkleArrayProof.fromEncodingData(data.get("P")),
            merkleSignatureSaltVersion: Number(data.get("v")),
            reveals: convertMap(data.get("r"), (key, value) => [
              key,
              Reveal.fromEncodingData(value)
            ]),
            positionsToReveal: data.get("pr")
          });
        }
      };
      StateProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "c",
          // sigCommit
          valueSchema: new ByteArraySchema()
        },
        {
          key: "w",
          // signedWeight
          valueSchema: new Uint64Schema()
        },
        {
          key: "S",
          // sigProofs
          valueSchema: MerkleArrayProof.encodingSchema
        },
        {
          key: "P",
          // partProofs
          valueSchema: MerkleArrayProof.encodingSchema
        },
        {
          key: "v",
          // merkleSignatureSaltVersion
          valueSchema: new Uint64Schema()
        },
        {
          key: "r",
          // reveals
          valueSchema: new Uint64MapSchema(Reveal.encodingSchema)
        },
        {
          key: "pr",
          // positionsToReveal
          valueSchema: new ArraySchema(new Uint64Schema())
        }
      ]));
      StateProofMessage = class _StateProofMessage {
        constructor(params) {
          this.blockHeadersCommitment = params.blockHeadersCommitment;
          this.votersCommitment = params.votersCommitment;
          this.lnProvenWeight = params.lnProvenWeight;
          this.firstAttestedRound = params.firstAttestedRound;
          this.lastAttestedRound = params.lastAttestedRound;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProofMessage.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["b", this.blockHeadersCommitment],
            ["v", this.votersCommitment],
            ["P", this.lnProvenWeight],
            ["f", this.firstAttestedRound],
            ["l", this.lastAttestedRound]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofMessage: ${data}`);
          }
          return new _StateProofMessage({
            blockHeadersCommitment: data.get("b"),
            votersCommitment: data.get("v"),
            lnProvenWeight: data.get("P"),
            firstAttestedRound: data.get("f"),
            lastAttestedRound: data.get("l")
          });
        }
        static fromMap(data) {
          return new _StateProofMessage({
            blockHeadersCommitment: data.get("b"),
            votersCommitment: data.get("v"),
            lnProvenWeight: data.get("P"),
            firstAttestedRound: data.get("f"),
            lastAttestedRound: data.get("l")
          });
        }
      };
      StateProofMessage.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "b", valueSchema: new ByteArraySchema() },
        // blockHeadersCommitment
        { key: "v", valueSchema: new ByteArraySchema() },
        // votersCommitment
        { key: "P", valueSchema: new Uint64Schema() },
        // lnProvenWeight
        { key: "f", valueSchema: new Uint64Schema() },
        // firstAttestedRound
        { key: "l", valueSchema: new Uint64Schema() }
        // lastAttestedRound
      ]));
    }
  });

  // node_modules/algosdk/dist/esm/heartbeat.js
  var HeartbeatProof, Heartbeat;
  var init_heartbeat = __esm({
    "node_modules/algosdk/dist/esm/heartbeat.js"() {
      init_polyfills();
      init_schema();
      HeartbeatProof = class _HeartbeatProof {
        constructor(params) {
          this.sig = params.sig;
          this.pk = params.pk;
          this.pk2 = params.pk2;
          this.pk1Sig = params.pk1Sig;
          this.pk2Sig = params.pk2Sig;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _HeartbeatProof.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["s", this.sig],
            ["p", this.pk],
            ["p2", this.pk2],
            ["p1s", this.pk1Sig],
            ["p2s", this.pk2Sig]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded HeartbeatProof: ${data}`);
          }
          return new _HeartbeatProof({
            sig: data.get("s"),
            pk: data.get("p"),
            pk2: data.get("p2"),
            pk1Sig: data.get("p1s"),
            pk2Sig: data.get("p2s")
          });
        }
      };
      HeartbeatProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "s",
          // Sig
          valueSchema: new FixedLengthByteArraySchema(64)
        },
        {
          key: "p",
          // PK
          valueSchema: new FixedLengthByteArraySchema(32)
        },
        {
          key: "p2",
          // PK2
          valueSchema: new FixedLengthByteArraySchema(32)
        },
        {
          key: "p1s",
          // PK1Sig
          valueSchema: new FixedLengthByteArraySchema(64)
        },
        {
          key: "p2s",
          // PK2Sig
          valueSchema: new FixedLengthByteArraySchema(64)
        }
      ]));
      Heartbeat = class _Heartbeat {
        constructor(params) {
          this.address = params.address;
          this.proof = params.proof;
          this.seed = params.seed;
          this.voteID = params.voteID;
          this.keyDilution = params.keyDilution;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Heartbeat.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["a", this.address],
            ["prf", this.proof.toEncodingData()],
            ["sd", this.seed],
            ["vid", this.voteID],
            ["kd", this.keyDilution]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Heartbeat: ${data}`);
          }
          return new _Heartbeat({
            address: data.get("a"),
            proof: HeartbeatProof.fromEncodingData(data.get("prf")),
            seed: data.get("sd"),
            voteID: data.get("vid"),
            keyDilution: data.get("kd")
          });
        }
      };
      Heartbeat.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "a",
          // HbAddress
          valueSchema: new AddressSchema()
        },
        {
          key: "prf",
          // HbProof
          valueSchema: HeartbeatProof.encodingSchema
        },
        {
          key: "sd",
          // HbSeed
          valueSchema: new ByteArraySchema()
        },
        {
          key: "vid",
          // HbVoteID
          valueSchema: new FixedLengthByteArraySchema(32)
        },
        {
          key: "kd",
          // HbKeyDilution
          valueSchema: new Uint64Schema()
        }
      ]));
    }
  });

  // node_modules/algosdk/dist/esm/transaction.js
  function uint8ArrayIsEmpty(input) {
    return input.every((value) => value === 0);
  }
  function getKeyregKey(input, inputName, length) {
    if (input == null) {
      return void 0;
    }
    let inputBytes;
    if (input instanceof Uint8Array) {
      inputBytes = input;
    }
    if (inputBytes == null || inputBytes.byteLength !== length) {
      throw Error(`${inputName} must be a ${length} byte Uint8Array`);
    }
    return inputBytes;
  }
  function ensureAddress(input) {
    if (input == null) {
      throw new Error("Address must not be null or undefined");
    }
    if (typeof input === "string") {
      return Address.fromString(input);
    }
    if (input instanceof Address) {
      return input;
    }
    throw new Error(`Not an address: ${input}`);
  }
  function optionalAddress(input) {
    if (input == null) {
      return void 0;
    }
    let addr;
    if (input instanceof Address) {
      addr = input;
    } else if (typeof input === "string") {
      addr = Address.fromString(input);
    } else {
      throw new Error(`Not an address: ${input}`);
    }
    if (uint8ArrayIsEmpty(addr.publicKey)) {
      throw new Error("Invalid use of the zero address. To omit this value, pass in undefined");
    }
    return addr;
  }
  function optionalUint8Array(input) {
    if (typeof input === "undefined") {
      return void 0;
    }
    if (input instanceof Uint8Array) {
      return input;
    }
    throw new Error(`Not a Uint8Array: ${input}`);
  }
  function ensureUint8Array2(input) {
    if (input instanceof Uint8Array) {
      return input;
    }
    throw new Error(`Not a Uint8Array: ${input}`);
  }
  function optionalUint64(input) {
    if (typeof input === "undefined") {
      return void 0;
    }
    return ensureUint64(input);
  }
  function ensureBoolean(input) {
    if (input === true || input === false) {
      return input;
    }
    throw new Error(`Not a boolean: ${input}`);
  }
  function ensureArray(input) {
    if (Array.isArray(input)) {
      return input.slice();
    }
    throw new Error(`Not an array: ${input}`);
  }
  function optionalFixedLengthByteArray(input, length, name) {
    const bytes = optionalUint8Array(input);
    if (typeof bytes === "undefined") {
      return void 0;
    }
    if (bytes.byteLength !== length) {
      throw new Error(`${name} must be ${length} bytes long, was ${bytes.byteLength}`);
    }
    if (uint8ArrayIsEmpty(bytes)) {
      return void 0;
    }
    return bytes;
  }
  function ensureBoxReference(input) {
    if (input != null && typeof input === "object") {
      const { appIndex, name } = input;
      return {
        appIndex: ensureUint64(appIndex),
        name: ensureUint8Array2(name)
      };
    }
    throw new Error(`Not a box reference: ${input}`);
  }
  function encodeUnsignedTransaction(transactionObject) {
    return encodeMsgpack(transactionObject);
  }
  function decodeUnsignedTransaction(transactionBuffer) {
    return decodeMsgpack(transactionBuffer, Transaction);
  }
  var import_hi_base323, ALGORAND_TRANSACTION_LENGTH, ALGORAND_TRANSACTION_LEASE_LENGTH, NUM_ADDL_BYTES_AFTER_SIGNING, ASSET_METADATA_HASH_LENGTH, KEYREG_VOTE_KEY_LENGTH, KEYREG_SELECTION_KEY_LENGTH, KEYREG_STATE_PROOF_KEY_LENGTH, ALGORAND_TRANSACTION_GROUP_LENGTH, TX_TAG, Transaction;
  var init_transaction = __esm({
    "node_modules/algosdk/dist/esm/transaction.js"() {
      init_polyfills();
      import_hi_base323 = __toESM(require_base32(), 1);
      init_boxStorage();
      init_address();
      init_encoding3();
      init_schema();
      init_naclWrappers();
      init_base();
      init_stateproof();
      init_heartbeat();
      init_utils();
      ALGORAND_TRANSACTION_LENGTH = 52;
      ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
      NUM_ADDL_BYTES_AFTER_SIGNING = 75;
      ASSET_METADATA_HASH_LENGTH = 32;
      KEYREG_VOTE_KEY_LENGTH = 32;
      KEYREG_SELECTION_KEY_LENGTH = 32;
      KEYREG_STATE_PROOF_KEY_LENGTH = 64;
      ALGORAND_TRANSACTION_GROUP_LENGTH = 32;
      TX_TAG = new TextEncoder().encode("TX");
      Transaction = class _Transaction {
        constructor(params) {
          if (!isTransactionType(params.type)) {
            throw new Error(`Invalid transaction type: ${params.type}`);
          }
          this.type = params.type;
          this.sender = ensureAddress(params.sender);
          this.note = ensureUint8Array2(params.note ?? new Uint8Array());
          this.lease = optionalFixedLengthByteArray(params.lease, ALGORAND_TRANSACTION_LEASE_LENGTH, "lease");
          this.rekeyTo = optionalAddress(params.rekeyTo);
          this.group = void 0;
          this.firstValid = ensureUint64(params.suggestedParams.firstValid);
          this.lastValid = ensureUint64(params.suggestedParams.lastValid);
          if (params.suggestedParams.genesisID) {
            if (typeof params.suggestedParams.genesisID !== "string") {
              throw new Error("Genesis ID must be a string if present");
            }
            this.genesisID = params.suggestedParams.genesisID;
          }
          this.genesisHash = optionalUint8Array(params.suggestedParams.genesisHash);
          const fieldsPresent = [];
          if (params.paymentParams)
            fieldsPresent.push(TransactionType.pay);
          if (params.keyregParams)
            fieldsPresent.push(TransactionType.keyreg);
          if (params.assetConfigParams)
            fieldsPresent.push(TransactionType.acfg);
          if (params.assetTransferParams)
            fieldsPresent.push(TransactionType.axfer);
          if (params.assetFreezeParams)
            fieldsPresent.push(TransactionType.afrz);
          if (params.appCallParams)
            fieldsPresent.push(TransactionType.appl);
          if (params.stateProofParams)
            fieldsPresent.push(TransactionType.stpf);
          if (params.heartbeatParams)
            fieldsPresent.push(TransactionType.hb);
          if (fieldsPresent.length !== 1) {
            throw new Error(`Transaction has wrong number of type fields present (${fieldsPresent.length}): ${fieldsPresent}`);
          }
          if (this.type !== fieldsPresent[0]) {
            throw new Error(`Transaction has type ${this.type} but fields present for ${fieldsPresent[0]}`);
          }
          if (params.paymentParams) {
            this.payment = {
              receiver: ensureAddress(params.paymentParams.receiver),
              amount: ensureUint64(params.paymentParams.amount),
              closeRemainderTo: optionalAddress(params.paymentParams.closeRemainderTo)
            };
          }
          if (params.keyregParams) {
            this.keyreg = {
              voteKey: getKeyregKey(params.keyregParams.voteKey, "voteKey", KEYREG_VOTE_KEY_LENGTH),
              selectionKey: getKeyregKey(params.keyregParams.selectionKey, "selectionKey", KEYREG_SELECTION_KEY_LENGTH),
              stateProofKey: getKeyregKey(params.keyregParams.stateProofKey, "stateProofKey", KEYREG_STATE_PROOF_KEY_LENGTH),
              voteFirst: optionalUint64(params.keyregParams.voteFirst),
              voteLast: optionalUint64(params.keyregParams.voteLast),
              voteKeyDilution: optionalUint64(params.keyregParams.voteKeyDilution),
              nonParticipation: ensureBoolean(params.keyregParams.nonParticipation ?? false)
            };
            if (this.keyreg.nonParticipation && (this.keyreg.voteKey || this.keyreg.selectionKey || this.keyreg.stateProofKey || typeof this.keyreg.voteFirst !== "undefined" || typeof this.keyreg.voteLast !== "undefined" || typeof this.keyreg.voteKeyDilution !== "undefined")) {
              throw new Error("nonParticipation is true but participation params are present.");
            }
            if (
              // If we are participating
              !this.keyreg.nonParticipation && // And *ANY* participating fields are present
              (this.keyreg.voteKey || this.keyreg.selectionKey || this.keyreg.stateProofKey || typeof this.keyreg.voteFirst !== "undefined" || typeof this.keyreg.voteLast !== "undefined" || typeof this.keyreg.voteKeyDilution !== "undefined") && // Then *ALL* participating fields must be present (with an exception for stateProofKey,
              // which was introduced later so for backwards compatibility we don't require it)
              !(this.keyreg.voteKey && this.keyreg.selectionKey && typeof this.keyreg.voteFirst !== "undefined" && typeof this.keyreg.voteLast !== "undefined" && typeof this.keyreg.voteKeyDilution !== "undefined")
            ) {
              throw new Error(`Online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution`);
            }
          }
          if (params.assetConfigParams) {
            this.assetConfig = {
              assetIndex: ensureUint64(params.assetConfigParams.assetIndex ?? 0),
              total: ensureUint64(params.assetConfigParams.total ?? 0),
              decimals: ensureSafeUnsignedInteger(params.assetConfigParams.decimals ?? 0),
              defaultFrozen: ensureBoolean(params.assetConfigParams.defaultFrozen ?? false),
              manager: optionalAddress(params.assetConfigParams.manager),
              reserve: optionalAddress(params.assetConfigParams.reserve),
              freeze: optionalAddress(params.assetConfigParams.freeze),
              clawback: optionalAddress(params.assetConfigParams.clawback),
              unitName: params.assetConfigParams.unitName,
              assetName: params.assetConfigParams.assetName,
              assetURL: params.assetConfigParams.assetURL,
              assetMetadataHash: optionalFixedLengthByteArray(params.assetConfigParams.assetMetadataHash, ASSET_METADATA_HASH_LENGTH, "assetMetadataHash")
            };
          }
          if (params.assetTransferParams) {
            this.assetTransfer = {
              assetIndex: ensureUint64(params.assetTransferParams.assetIndex),
              amount: ensureUint64(params.assetTransferParams.amount),
              assetSender: optionalAddress(params.assetTransferParams.assetSender),
              receiver: ensureAddress(params.assetTransferParams.receiver),
              closeRemainderTo: optionalAddress(params.assetTransferParams.closeRemainderTo)
            };
          }
          if (params.assetFreezeParams) {
            this.assetFreeze = {
              assetIndex: ensureUint64(params.assetFreezeParams.assetIndex),
              freezeAccount: ensureAddress(params.assetFreezeParams.freezeTarget),
              frozen: ensureBoolean(params.assetFreezeParams.frozen)
            };
          }
          if (params.appCallParams) {
            const { onComplete } = params.appCallParams;
            if (!isOnApplicationComplete(onComplete)) {
              throw new Error(`Invalid onCompletion value: ${onComplete}`);
            }
            this.applicationCall = {
              appIndex: ensureUint64(params.appCallParams.appIndex),
              onComplete,
              numLocalInts: ensureSafeUnsignedInteger(params.appCallParams.numLocalInts ?? 0),
              numLocalByteSlices: ensureSafeUnsignedInteger(params.appCallParams.numLocalByteSlices ?? 0),
              numGlobalInts: ensureSafeUnsignedInteger(params.appCallParams.numGlobalInts ?? 0),
              numGlobalByteSlices: ensureSafeUnsignedInteger(params.appCallParams.numGlobalByteSlices ?? 0),
              extraPages: ensureSafeUnsignedInteger(params.appCallParams.extraPages ?? 0),
              approvalProgram: ensureUint8Array2(params.appCallParams.approvalProgram ?? new Uint8Array()),
              clearProgram: ensureUint8Array2(params.appCallParams.clearProgram ?? new Uint8Array()),
              appArgs: ensureArray(params.appCallParams.appArgs ?? []).map(ensureUint8Array2),
              accounts: ensureArray(params.appCallParams.accounts ?? []).map(ensureAddress),
              foreignApps: ensureArray(params.appCallParams.foreignApps ?? []).map(ensureUint64),
              foreignAssets: ensureArray(params.appCallParams.foreignAssets ?? []).map(ensureUint64),
              boxes: ensureArray(params.appCallParams.boxes ?? []).map(ensureBoxReference)
            };
          }
          if (params.stateProofParams) {
            this.stateProof = {
              stateProofType: ensureSafeUnsignedInteger(params.stateProofParams.stateProofType ?? 0),
              stateProof: params.stateProofParams.stateProof,
              message: params.stateProofParams.message
            };
          }
          if (params.heartbeatParams) {
            this.heartbeat = new Heartbeat({
              address: params.heartbeatParams.address,
              proof: params.heartbeatParams.proof,
              seed: params.heartbeatParams.seed,
              voteID: params.heartbeatParams.voteID,
              keyDilution: params.heartbeatParams.keyDilution
            });
          }
          this.fee = ensureUint64(params.suggestedParams.fee);
          const feeDependsOnSize = !ensureBoolean(params.suggestedParams.flatFee ?? false);
          if (feeDependsOnSize) {
            const minFee = ensureUint64(params.suggestedParams.minFee);
            this.fee *= BigInt(this.estimateSize());
            if (this.fee < minFee) {
              this.fee = minFee;
            }
          }
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Transaction.encodingSchema;
        }
        toEncodingData() {
          const data = /* @__PURE__ */ new Map([
            ["type", this.type],
            ["fv", this.firstValid],
            ["lv", this.lastValid],
            ["snd", this.sender],
            ["gen", this.genesisID],
            ["gh", this.genesisHash],
            ["fee", this.fee],
            ["note", this.note],
            ["lx", this.lease],
            ["rekey", this.rekeyTo],
            ["grp", this.group]
          ]);
          if (this.payment) {
            data.set("amt", this.payment.amount);
            data.set("rcv", this.payment.receiver);
            data.set("close", this.payment.closeRemainderTo);
            return data;
          }
          if (this.keyreg) {
            data.set("votekey", this.keyreg.voteKey);
            data.set("selkey", this.keyreg.selectionKey);
            data.set("sprfkey", this.keyreg.stateProofKey);
            data.set("votefst", this.keyreg.voteFirst);
            data.set("votelst", this.keyreg.voteLast);
            data.set("votekd", this.keyreg.voteKeyDilution);
            data.set("nonpart", this.keyreg.nonParticipation);
            return data;
          }
          if (this.assetConfig) {
            data.set("caid", this.assetConfig.assetIndex);
            const assetParams = /* @__PURE__ */ new Map([
              ["t", this.assetConfig.total],
              ["dc", this.assetConfig.decimals],
              ["df", this.assetConfig.defaultFrozen],
              ["m", this.assetConfig.manager],
              ["r", this.assetConfig.reserve],
              ["f", this.assetConfig.freeze],
              ["c", this.assetConfig.clawback],
              ["un", this.assetConfig.unitName],
              ["an", this.assetConfig.assetName],
              ["au", this.assetConfig.assetURL],
              ["am", this.assetConfig.assetMetadataHash]
            ]);
            data.set("apar", assetParams);
            return data;
          }
          if (this.assetTransfer) {
            data.set("xaid", this.assetTransfer.assetIndex);
            data.set("aamt", this.assetTransfer.amount);
            data.set("arcv", this.assetTransfer.receiver);
            data.set("aclose", this.assetTransfer.closeRemainderTo);
            data.set("asnd", this.assetTransfer.assetSender);
            return data;
          }
          if (this.assetFreeze) {
            data.set("faid", this.assetFreeze.assetIndex);
            data.set("afrz", this.assetFreeze.frozen);
            data.set("fadd", this.assetFreeze.freezeAccount);
            return data;
          }
          if (this.applicationCall) {
            data.set("apid", this.applicationCall.appIndex);
            data.set("apan", this.applicationCall.onComplete);
            data.set("apaa", this.applicationCall.appArgs);
            data.set("apat", this.applicationCall.accounts);
            data.set("apas", this.applicationCall.foreignAssets);
            data.set("apfa", this.applicationCall.foreignApps);
            data.set("apbx", boxReferencesToEncodingData(this.applicationCall.boxes, this.applicationCall.foreignApps, this.applicationCall.appIndex));
            data.set("apap", this.applicationCall.approvalProgram);
            data.set("apsu", this.applicationCall.clearProgram);
            data.set("apls", /* @__PURE__ */ new Map([
              ["nui", this.applicationCall.numLocalInts],
              ["nbs", this.applicationCall.numLocalByteSlices]
            ]));
            data.set("apgs", /* @__PURE__ */ new Map([
              ["nui", this.applicationCall.numGlobalInts],
              ["nbs", this.applicationCall.numGlobalByteSlices]
            ]));
            data.set("apep", this.applicationCall.extraPages);
            return data;
          }
          if (this.stateProof) {
            data.set("sptype", this.stateProof.stateProofType);
            data.set("sp", this.stateProof.stateProof ? this.stateProof.stateProof.toEncodingData() : void 0);
            data.set("spmsg", this.stateProof.message ? this.stateProof.message.toEncodingData() : void 0);
            return data;
          }
          if (this.heartbeat) {
            const heartbeat = new Heartbeat({
              address: this.heartbeat.address,
              proof: this.heartbeat.proof,
              seed: this.heartbeat.seed,
              voteID: this.heartbeat.voteID,
              keyDilution: this.heartbeat.keyDilution
            });
            data.set("hb", heartbeat.toEncodingData());
            return data;
          }
          throw new Error(`Unexpected transaction type: ${this.type}`);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded logic sig account: ${data}`);
          }
          const suggestedParams = {
            minFee: BigInt(0),
            flatFee: true,
            fee: data.get("fee") ?? 0,
            firstValid: data.get("fv") ?? 0,
            lastValid: data.get("lv") ?? 0,
            genesisHash: data.get("gh"),
            genesisID: data.get("gen")
          };
          const txnType = data.get("type");
          if (!isTransactionType(txnType)) {
            throw new Error(`Unrecognized transaction type: ${txnType}`);
          }
          const params = {
            type: txnType,
            sender: data.get("snd") ?? Address.zeroAddress(),
            note: data.get("note"),
            lease: data.get("lx"),
            suggestedParams
          };
          if (data.get("rekey")) {
            params.rekeyTo = data.get("rekey");
          }
          if (params.type === TransactionType.pay) {
            const paymentParams = {
              amount: data.get("amt") ?? 0,
              receiver: data.get("rcv") ?? Address.zeroAddress()
            };
            if (data.get("close")) {
              paymentParams.closeRemainderTo = data.get("close");
            }
            params.paymentParams = paymentParams;
          } else if (params.type === TransactionType.keyreg) {
            const keyregParams = {
              voteKey: data.get("votekey"),
              selectionKey: data.get("selkey"),
              stateProofKey: data.get("sprfkey"),
              voteFirst: data.get("votefst"),
              voteLast: data.get("votelst"),
              voteKeyDilution: data.get("votekd"),
              nonParticipation: data.get("nonpart")
            };
            params.keyregParams = keyregParams;
          } else if (params.type === TransactionType.acfg) {
            const assetConfigParams = {
              assetIndex: data.get("caid")
            };
            if (data.get("apar")) {
              const assetParams = data.get("apar");
              assetConfigParams.total = assetParams.get("t");
              assetConfigParams.decimals = assetParams.get("dc");
              assetConfigParams.defaultFrozen = assetParams.get("df");
              assetConfigParams.unitName = assetParams.get("un");
              assetConfigParams.assetName = assetParams.get("an");
              assetConfigParams.assetURL = assetParams.get("au");
              assetConfigParams.assetMetadataHash = assetParams.get("am");
              if (assetParams.get("m")) {
                assetConfigParams.manager = assetParams.get("m");
              }
              if (assetParams.get("r")) {
                assetConfigParams.reserve = assetParams.get("r");
              }
              if (assetParams.get("f")) {
                assetConfigParams.freeze = assetParams.get("f");
              }
              if (assetParams.get("c")) {
                assetConfigParams.clawback = assetParams.get("c");
              }
            }
            params.assetConfigParams = assetConfigParams;
          } else if (params.type === TransactionType.axfer) {
            const assetTransferParams = {
              assetIndex: data.get("xaid") ?? 0,
              amount: data.get("aamt") ?? 0,
              receiver: data.get("arcv") ?? Address.zeroAddress()
            };
            if (data.get("aclose")) {
              assetTransferParams.closeRemainderTo = data.get("aclose");
            }
            if (data.get("asnd")) {
              assetTransferParams.assetSender = data.get("asnd");
            }
            params.assetTransferParams = assetTransferParams;
          } else if (params.type === TransactionType.afrz) {
            const assetFreezeParams = {
              assetIndex: data.get("faid") ?? 0,
              freezeTarget: data.get("fadd") ?? Address.zeroAddress(),
              frozen: data.get("afrz") ?? false
            };
            params.assetFreezeParams = assetFreezeParams;
          } else if (params.type === TransactionType.appl) {
            const appCallParams = {
              appIndex: data.get("apid") ?? 0,
              onComplete: ensureSafeUnsignedInteger(data.get("apan") ?? 0),
              appArgs: data.get("apaa"),
              accounts: data.get("apat"),
              foreignAssets: data.get("apas"),
              foreignApps: data.get("apfa"),
              approvalProgram: data.get("apap"),
              clearProgram: data.get("apsu"),
              extraPages: data.get("apep")
            };
            const localSchema = data.get("apls");
            if (localSchema) {
              appCallParams.numLocalInts = localSchema.get("nui");
              appCallParams.numLocalByteSlices = localSchema.get("nbs");
            }
            const globalSchema = data.get("apgs");
            if (globalSchema) {
              appCallParams.numGlobalInts = globalSchema.get("nui");
              appCallParams.numGlobalByteSlices = globalSchema.get("nbs");
            }
            const boxes = data.get("apbx");
            if (boxes) {
              appCallParams.boxes = boxes.map((box) => {
                const index = ensureSafeUnsignedInteger(box.get("i") ?? 0);
                const name = ensureUint8Array2(box.get("n") ?? new Uint8Array());
                if (index === 0) {
                  return {
                    appIndex: 0,
                    name
                  };
                }
                if (!appCallParams.foreignApps || index > appCallParams.foreignApps.length) {
                  throw new Error(`Cannot find foreign app index ${index} in ${appCallParams.foreignApps}`);
                }
                return {
                  appIndex: appCallParams.foreignApps[index - 1],
                  name
                };
              });
            }
            params.appCallParams = appCallParams;
          } else if (params.type === TransactionType.stpf) {
            const stateProofParams = {
              stateProofType: data.get("sptype"),
              stateProof: data.get("sp") ? StateProof.fromEncodingData(data.get("sp")) : void 0,
              message: data.get("spmsg") ? StateProofMessage.fromEncodingData(data.get("spmsg")) : void 0
            };
            params.stateProofParams = stateProofParams;
          } else if (params.type === TransactionType.hb) {
            const heartbeat = Heartbeat.fromEncodingData(data.get("hb"));
            const heartbeatParams = {
              address: heartbeat.address,
              proof: heartbeat.proof,
              seed: heartbeat.seed,
              voteID: heartbeat.voteID,
              keyDilution: heartbeat.keyDilution
            };
            params.heartbeatParams = heartbeatParams;
          } else {
            const exhaustiveCheck = params.type;
            throw new Error(`Unexpected transaction type: ${exhaustiveCheck}`);
          }
          const txn = new _Transaction(params);
          if (data.get("grp")) {
            const group = ensureUint8Array2(data.get("grp"));
            if (group.byteLength !== ALGORAND_TRANSACTION_GROUP_LENGTH) {
              throw new Error(`Invalid group length: ${group.byteLength}`);
            }
            txn.group = group;
          }
          return txn;
        }
        estimateSize() {
          return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
        }
        bytesToSign() {
          const encodedMsg = this.toByte();
          return concatArrays2(TX_TAG, encodedMsg);
        }
        toByte() {
          return encodeMsgpack(this);
        }
        // returns the raw signature
        rawSignTxn(sk) {
          const toBeSigned = this.bytesToSign();
          const sig = sign(toBeSigned, sk);
          return sig;
        }
        signTxn(sk) {
          const keypair = keyPairFromSecretKey(sk);
          const signerAddr = new Address(keypair.publicKey);
          const sig = this.rawSignTxn(sk);
          return this.attachSignature(signerAddr, sig);
        }
        attachSignature(signerAddr, signature) {
          if (!isValidSignatureLength(signature.length)) {
            throw new Error("Invalid signature length");
          }
          const sTxn = /* @__PURE__ */ new Map([
            ["sig", signature],
            ["txn", this.toEncodingData()]
          ]);
          const signerAddrObj = ensureAddress(signerAddr);
          if (!this.sender.equals(signerAddrObj)) {
            sTxn.set("sgnr", signerAddrObj);
          }
          const stxnSchema = new NamedMapSchema(allOmitEmpty([
            {
              key: "txn",
              valueSchema: _Transaction.encodingSchema
            },
            {
              key: "sig",
              valueSchema: new FixedLengthByteArraySchema(64)
            },
            {
              key: "sgnr",
              valueSchema: new OptionalSchema(new AddressSchema())
            }
          ]));
          return msgpackRawEncode(stxnSchema.prepareMsgpack(sTxn));
        }
        rawTxID() {
          const enMsg = this.toByte();
          const gh = concatArrays2(TX_TAG, enMsg);
          return Uint8Array.from(genericHash(gh));
        }
        txID() {
          const hash = this.rawTxID();
          return import_hi_base323.default.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
        }
      };
      Transaction.encodingSchema = new NamedMapSchema(allOmitEmpty([
        // Common
        { key: "type", valueSchema: new StringSchema() },
        { key: "snd", valueSchema: new AddressSchema() },
        { key: "lv", valueSchema: new Uint64Schema() },
        { key: "gen", valueSchema: new OptionalSchema(new StringSchema()) },
        {
          key: "gh",
          valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
        },
        { key: "fee", valueSchema: new Uint64Schema() },
        { key: "fv", valueSchema: new Uint64Schema() },
        { key: "note", valueSchema: new ByteArraySchema() },
        {
          key: "lx",
          valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
        },
        { key: "rekey", valueSchema: new OptionalSchema(new AddressSchema()) },
        {
          key: "grp",
          valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
        },
        // We mark all top-level type-specific fields optional because they will not be present when
        // the transaction is not that type.
        // Payment
        { key: "amt", valueSchema: new OptionalSchema(new Uint64Schema()) },
        { key: "rcv", valueSchema: new OptionalSchema(new AddressSchema()) },
        { key: "close", valueSchema: new OptionalSchema(new AddressSchema()) },
        // Keyreg
        {
          key: "votekey",
          valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
        },
        {
          key: "selkey",
          valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
        },
        {
          key: "sprfkey",
          valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
        },
        { key: "votefst", valueSchema: new OptionalSchema(new Uint64Schema()) },
        { key: "votelst", valueSchema: new OptionalSchema(new Uint64Schema()) },
        { key: "votekd", valueSchema: new OptionalSchema(new Uint64Schema()) },
        { key: "nonpart", valueSchema: new OptionalSchema(new BooleanSchema()) },
        // AssetConfig
        { key: "caid", valueSchema: new OptionalSchema(new Uint64Schema()) },
        {
          key: "apar",
          valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
            { key: "t", valueSchema: new Uint64Schema() },
            { key: "dc", valueSchema: new Uint64Schema() },
            { key: "df", valueSchema: new BooleanSchema() },
            {
              key: "m",
              valueSchema: new OptionalSchema(new AddressSchema())
            },
            {
              key: "r",
              valueSchema: new OptionalSchema(new AddressSchema())
            },
            {
              key: "f",
              valueSchema: new OptionalSchema(new AddressSchema())
            },
            {
              key: "c",
              valueSchema: new OptionalSchema(new AddressSchema())
            },
            {
              key: "un",
              valueSchema: new OptionalSchema(new StringSchema())
            },
            {
              key: "an",
              valueSchema: new OptionalSchema(new StringSchema())
            },
            {
              key: "au",
              valueSchema: new OptionalSchema(new StringSchema())
            },
            {
              key: "am",
              valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
            }
          ])))
        },
        // AssetTransfer
        { key: "xaid", valueSchema: new OptionalSchema(new Uint64Schema()) },
        { key: "aamt", valueSchema: new OptionalSchema(new Uint64Schema()) },
        { key: "arcv", valueSchema: new OptionalSchema(new AddressSchema()) },
        { key: "aclose", valueSchema: new OptionalSchema(new AddressSchema()) },
        { key: "asnd", valueSchema: new OptionalSchema(new AddressSchema()) },
        // AssetFreeze
        { key: "faid", valueSchema: new OptionalSchema(new Uint64Schema()) },
        { key: "afrz", valueSchema: new OptionalSchema(new BooleanSchema()) },
        { key: "fadd", valueSchema: new OptionalSchema(new AddressSchema()) },
        // Application
        { key: "apid", valueSchema: new OptionalSchema(new Uint64Schema()) },
        { key: "apan", valueSchema: new OptionalSchema(new Uint64Schema()) },
        {
          key: "apaa",
          valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema()))
        },
        {
          key: "apat",
          valueSchema: new OptionalSchema(new ArraySchema(new AddressSchema()))
        },
        {
          key: "apas",
          valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema()))
        },
        {
          key: "apfa",
          valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema()))
        },
        {
          key: "apbx",
          valueSchema: new OptionalSchema(new ArraySchema(new NamedMapSchema(allOmitEmpty([
            {
              key: "i",
              valueSchema: new Uint64Schema()
            },
            {
              key: "n",
              valueSchema: new ByteArraySchema()
            }
          ]))))
        },
        { key: "apap", valueSchema: new OptionalSchema(new ByteArraySchema()) },
        { key: "apsu", valueSchema: new OptionalSchema(new ByteArraySchema()) },
        {
          key: "apls",
          valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
            {
              key: "nui",
              valueSchema: new Uint64Schema()
            },
            {
              key: "nbs",
              valueSchema: new Uint64Schema()
            }
          ])))
        },
        {
          key: "apgs",
          valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
            {
              key: "nui",
              valueSchema: new Uint64Schema()
            },
            {
              key: "nbs",
              valueSchema: new Uint64Schema()
            }
          ])))
        },
        { key: "apep", valueSchema: new OptionalSchema(new Uint64Schema()) },
        // StateProof
        { key: "sptype", valueSchema: new OptionalSchema(new Uint64Schema()) },
        { key: "sp", valueSchema: new OptionalSchema(StateProof.encodingSchema) },
        {
          key: "spmsg",
          valueSchema: new OptionalSchema(StateProofMessage.encodingSchema)
        },
        // Heartbeat
        { key: "hb", valueSchema: new OptionalSchema(Heartbeat.encodingSchema) }
      ]));
    }
  });

  // node_modules/algosdk/dist/esm/multisig.js
  function pksFromAddresses(addrs) {
    return addrs.map((addr) => {
      if (typeof addr === "string") {
        return Address.fromString(addr).publicKey;
      }
      return addr.publicKey;
    });
  }
  function addressFromMultisigPreImg({ version, threshold, pks }) {
    if (version !== 1 || version > 255 || version < 0) {
      throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);
    }
    if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {
      throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);
    }
    const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;
    if (pkLen !== PUBLIC_KEY_LENGTH) {
      throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);
    }
    const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);
    merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
    merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);
    merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
    for (let i2 = 0; i2 < pks.length; i2++) {
      if (pks[i2].length !== pkLen) {
        throw new Error(INVALID_MSIG_PK_ERROR_MSG);
      }
      merged.set(pks[i2], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i2 * pkLen);
    }
    return new Address(Uint8Array.from(genericHash(merged)));
  }
  function addressFromMultisigPreImgAddrs({ version, threshold, addrs }) {
    const pks = pksFromAddresses(addrs);
    return addressFromMultisigPreImg({ version, threshold, pks });
  }
  function verifyMultisig(toBeVerified, msig, publicKey) {
    const version = msig.v;
    const threshold = msig.thr;
    const subsigs = msig.subsig;
    const pks = subsigs.map((subsig) => subsig.pk);
    if (msig.subsig.length < threshold) {
      return false;
    }
    let pk;
    try {
      pk = addressFromMultisigPreImg({ version, threshold, pks }).publicKey;
    } catch (e2) {
      return false;
    }
    if (!arrayEqual(pk, publicKey)) {
      return false;
    }
    let counter = 0;
    for (const subsig of subsigs) {
      if (subsig.s !== void 0) {
        counter += 1;
      }
    }
    if (counter < threshold) {
      return false;
    }
    let verifiedCounter = 0;
    for (const subsig of subsigs) {
      if (subsig.s !== void 0) {
        if (verify(toBeVerified, subsig.s, subsig.pk)) {
          verifiedCounter += 1;
        }
      }
    }
    if (verifiedCounter < threshold) {
      return false;
    }
    return true;
  }
  function multisigAddress({ version, threshold, addrs }) {
    return addressFromMultisigPreImgAddrs({ version, threshold, addrs });
  }
  var MULTISIG_PREIMG2ADDR_PREFIX, INVALID_MSIG_VERSION_ERROR_MSG, INVALID_MSIG_THRESHOLD_ERROR_MSG, INVALID_MSIG_PK_ERROR_MSG, UNEXPECTED_PK_LEN_ERROR_MSG;
  var init_multisig = __esm({
    "node_modules/algosdk/dist/esm/multisig.js"() {
      init_polyfills();
      init_naclWrappers();
      init_address();
      init_utils();
      MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([
        77,
        117,
        108,
        116,
        105,
        115,
        105,
        103,
        65,
        100,
        100,
        114
      ]);
      INVALID_MSIG_VERSION_ERROR_MSG = "invalid multisig version";
      INVALID_MSIG_THRESHOLD_ERROR_MSG = "bad multisig threshold";
      INVALID_MSIG_PK_ERROR_MSG = "bad multisig public key - wrong length";
      UNEXPECTED_PK_LEN_ERROR_MSG = "nacl public key length is not 32 bytes";
    }
  });

  // node_modules/algosdk/dist/esm/types/transactions/encoded.js
  function encodedSubsigFromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EncodedSubsig: ${data}`);
    }
    const subsig = {
      pk: data.get("pk")
    };
    if (data.get("s")) {
      subsig.s = data.get("s");
    }
    return subsig;
  }
  function encodedSubsigToEncodingData(subsig) {
    const data = /* @__PURE__ */ new Map([["pk", subsig.pk]]);
    if (subsig.s) {
      data.set("s", subsig.s);
    }
    return data;
  }
  function encodedMultiSigFromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EncodedMultiSig: ${data}`);
    }
    return {
      v: ensureSafeUnsignedInteger(data.get("v")),
      thr: ensureSafeUnsignedInteger(data.get("thr")),
      subsig: data.get("subsig").map(encodedSubsigFromEncodingData)
    };
  }
  function encodedMultiSigToEncodingData(msig) {
    return /* @__PURE__ */ new Map([
      ["v", msig.v],
      ["thr", msig.thr],
      ["subsig", msig.subsig.map(encodedSubsigToEncodingData)]
    ]);
  }
  var ENCODED_SUBSIG_SCHEMA, ENCODED_MULTISIG_SCHEMA;
  var init_encoded = __esm({
    "node_modules/algosdk/dist/esm/types/transactions/encoded.js"() {
      init_polyfills();
      init_schema();
      init_utils();
      ENCODED_SUBSIG_SCHEMA = new NamedMapSchema(allOmitEmpty([
        {
          key: "pk",
          valueSchema: new FixedLengthByteArraySchema(32)
        },
        {
          key: "s",
          valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
        }
      ]));
      ENCODED_MULTISIG_SCHEMA = new NamedMapSchema(allOmitEmpty([
        {
          key: "v",
          valueSchema: new Uint64Schema()
        },
        {
          key: "thr",
          valueSchema: new Uint64Schema()
        },
        {
          key: "subsig",
          valueSchema: new ArraySchema(ENCODED_SUBSIG_SCHEMA)
        }
      ]));
    }
  });

  // node_modules/algosdk/dist/esm/logicsig.js
  function sanityCheckProgram(program) {
    if (!program || program.length === 0)
      throw new Error("empty program");
    const lineBreakOrd = "\n".charCodeAt(0);
    const blankSpaceOrd = " ".charCodeAt(0);
    const tildeOrd = "~".charCodeAt(0);
    const isPrintable = (x3) => blankSpaceOrd <= x3 && x3 <= tildeOrd;
    const isAsciiPrintable = program.every((x3) => x3 === lineBreakOrd || isPrintable(x3));
    if (isAsciiPrintable) {
      const programStr = new TextDecoder().decode(program);
      if (isValidAddress2(programStr))
        throw new Error("requesting program bytes, get Algorand address");
      if (base64regex.test(programStr))
        throw new Error("program should not be b64 encoded");
      throw new Error("program bytes are all ASCII printable characters, not looking like Teal byte code");
    }
  }
  function logicSigFromByte(encoded) {
    return decodeMsgpack(encoded, LogicSig);
  }
  function tealSign(sk, data, programHash) {
    const programAddr = typeof programHash === "string" ? Address.fromString(programHash) : programHash;
    const parts = concatArrays2(programAddr.publicKey, data);
    const toBeSigned = concatArrays2(SIGN_PROGRAM_DATA_PREFIX, parts);
    return sign(toBeSigned, sk);
  }
  function verifyTealSign(data, programHash, sig, pk) {
    const programAddr = typeof programHash === "string" ? Address.fromString(programHash) : programHash;
    const parts = concatArrays2(programAddr.publicKey, data);
    const toBeSigned = concatArrays2(SIGN_PROGRAM_DATA_PREFIX, parts);
    return verify(toBeSigned, sig, pk);
  }
  function tealSignFromProgram(sk, data, program) {
    const lsig = new LogicSig(program);
    const contractAddress = lsig.address();
    return tealSign(sk, data, contractAddress);
  }
  var base64regex, programTag, LogicSig, LogicSigAccount, SIGN_PROGRAM_DATA_PREFIX;
  var init_logicsig = __esm({
    "node_modules/algosdk/dist/esm/logicsig.js"() {
      init_polyfills();
      init_naclWrappers();
      init_address();
      init_encoding3();
      init_schema();
      init_multisig();
      init_utils();
      init_encoded();
      base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
      programTag = new TextEncoder().encode("Program");
      LogicSig = class _LogicSig {
        constructor(program, programArgs) {
          if (programArgs && (!Array.isArray(programArgs) || !programArgs.every((arg) => arg.constructor === Uint8Array))) {
            throw new TypeError("Invalid arguments");
          }
          let args = [];
          if (programArgs != null)
            args = programArgs.map((arg) => new Uint8Array(arg));
          sanityCheckProgram(program);
          this.logic = program;
          this.args = args;
          this.sig = void 0;
          this.msig = void 0;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _LogicSig.encodingSchema;
        }
        toEncodingData() {
          const data = /* @__PURE__ */ new Map([
            ["l", this.logic],
            ["arg", this.args],
            ["sig", this.sig]
          ]);
          if (this.msig) {
            data.set("msig", encodedMultiSigToEncodingData(this.msig));
          }
          return data;
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded logic sig: ${data}`);
          }
          const lsig = new _LogicSig(data.get("l"), data.get("arg"));
          lsig.sig = data.get("sig");
          if (data.get("msig")) {
            lsig.msig = encodedMultiSigFromEncodingData(data.get("msig"));
          }
          return lsig;
        }
        /**
         * Performs signature verification
         * @param publicKey - Verification key (derived from sender address or escrow address)
         */
        verify(publicKey) {
          if (this.sig && this.msig) {
            return false;
          }
          try {
            sanityCheckProgram(this.logic);
          } catch (e2) {
            return false;
          }
          const toBeSigned = concatArrays2(programTag, this.logic);
          if (!this.sig && !this.msig) {
            const hash = genericHash(toBeSigned);
            return arrayEqual(hash, publicKey);
          }
          if (this.sig) {
            return verify(toBeSigned, this.sig, publicKey);
          }
          return verifyMultisig(toBeSigned, this.msig, publicKey);
        }
        /**
         * Compute hash of the logic sig program (that is the same as escrow account address) as string address
         * @returns String representation of the address
         */
        address() {
          const toBeSigned = concatArrays2(programTag, this.logic);
          const hash = genericHash(toBeSigned);
          return new Address(Uint8Array.from(hash));
        }
        /**
         * Creates signature (if no msig provided) or multi signature otherwise
         * @param secretKey - Secret key to sign with
         * @param msig - Multisig account as \{version, threshold, addrs\}
         */
        sign(secretKey, msig) {
          if (msig == null) {
            this.sig = this.signProgram(secretKey);
          } else {
            const subsigs = pksFromAddresses(msig.addrs).map((pk) => ({ pk }));
            this.msig = {
              v: msig.version,
              thr: msig.threshold,
              subsig: subsigs
            };
            const [sig, index] = this.singleSignMultisig(secretKey, this.msig);
            this.msig.subsig[index].s = sig;
          }
        }
        /**
         * Appends a signature to multi signature
         * @param secretKey - Secret key to sign with
         */
        appendToMultisig(secretKey) {
          if (this.msig === void 0) {
            throw new Error("no multisig present");
          }
          const [sig, index] = this.singleSignMultisig(secretKey, this.msig);
          this.msig.subsig[index].s = sig;
        }
        signProgram(secretKey) {
          const toBeSigned = concatArrays2(programTag, this.logic);
          const sig = sign(toBeSigned, secretKey);
          return sig;
        }
        singleSignMultisig(secretKey, msig) {
          let index = -1;
          const myPk = keyPairFromSecretKey(secretKey).publicKey;
          for (let i2 = 0; i2 < msig.subsig.length; i2++) {
            const { pk } = msig.subsig[i2];
            if (arrayEqual(pk, myPk)) {
              index = i2;
              break;
            }
          }
          if (index === -1) {
            throw new Error("invalid secret key");
          }
          const sig = this.signProgram(secretKey);
          return [sig, index];
        }
        toByte() {
          return encodeMsgpack(this);
        }
        static fromByte(encoded) {
          return decodeMsgpack(encoded, _LogicSig);
        }
      };
      LogicSig.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "l",
          valueSchema: new ByteArraySchema()
        },
        {
          key: "arg",
          valueSchema: new ArraySchema(new ByteArraySchema())
        },
        {
          key: "sig",
          valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
        },
        {
          key: "msig",
          valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)
        }
      ]));
      LogicSigAccount = class _LogicSigAccount {
        /**
         * Create a new LogicSigAccount. By default this will create an escrow
         * LogicSig account. Call `sign` or `signMultisig` on the newly created
         * LogicSigAccount to make it a delegated account.
         *
         * @param program - The compiled TEAL program which contains the logic for
         *   this LogicSig.
         * @param args - An optional array of arguments for the program.
         */
        constructor(program, args) {
          this.lsig = new LogicSig(program, args);
          this.sigkey = void 0;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _LogicSigAccount.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["lsig", this.lsig.toEncodingData()],
            ["sigkey", this.sigkey]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded logic sig account: ${data}`);
          }
          const value = data;
          const lsig = LogicSig.fromEncodingData(value.get("lsig"));
          const lsigAccount = new _LogicSigAccount(lsig.logic, lsig.args);
          lsigAccount.lsig = lsig;
          lsigAccount.sigkey = value.get("sigkey");
          return lsigAccount;
        }
        /**
         * Encode this object into msgpack.
         */
        toByte() {
          return encodeMsgpack(this);
        }
        /**
         * Decode a msgpack object into a LogicSigAccount.
         * @param encoded - The encoded LogicSigAccount.
         */
        static fromByte(encoded) {
          return decodeMsgpack(encoded, _LogicSigAccount);
        }
        /**
         * Check if this LogicSigAccount has been delegated to another account with a
         * signature.
         *
         * Note this function only checks for the presence of a delegation signature.
         * To verify the delegation signature, use `verify`.
         */
        isDelegated() {
          return !!(this.lsig.sig || this.lsig.msig);
        }
        /**
         * Verifies this LogicSig's program and signatures.
         * @returns true if and only if the LogicSig program and signatures are valid.
         */
        verify() {
          const addr = this.address();
          return this.lsig.verify(addr.publicKey);
        }
        /**
         * Get the address of this LogicSigAccount.
         *
         * If the LogicSig is delegated to another account, this will return the
         * address of that account.
         *
         * If the LogicSig is not delegated to another account, this will return an
         *  escrow address that is the hash of the LogicSig's program code.
         */
        address() {
          if (this.lsig.sig && this.lsig.msig) {
            throw new Error("LogicSig has too many signatures. At most one of sig or msig may be present");
          }
          if (this.lsig.sig) {
            if (!this.sigkey) {
              throw new Error("Signing key for delegated account is missing");
            }
            return new Address(this.sigkey);
          }
          if (this.lsig.msig) {
            const msigMetadata = {
              version: this.lsig.msig.v,
              threshold: this.lsig.msig.thr,
              pks: this.lsig.msig.subsig.map((subsig) => subsig.pk)
            };
            return addressFromMultisigPreImg(msigMetadata);
          }
          return this.lsig.address();
        }
        /**
         * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
         * has the authority to sign transactions on behalf of another account, called
         * the delegating account. Use this function if the delegating account is a
         * multisig account.
         *
         * @param msig - The multisig delegating account
         * @param secretKey - The secret key of one of the members of the delegating
         *   multisig account. Use `appendToMultisig` to add additional signatures
         *   from other members.
         */
        signMultisig(msig, secretKey) {
          this.lsig.sign(secretKey, msig);
        }
        /**
         * Adds an additional signature from a member of the delegating multisig
         * account.
         *
         * @param secretKey - The secret key of one of the members of the delegating
         *   multisig account.
         */
        appendToMultisig(secretKey) {
          this.lsig.appendToMultisig(secretKey);
        }
        /**
         * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
         * has the authority to sign transactions on behalf of another account, called
         * the delegating account. If the delegating account is a multisig account,
         * use `signMultisig` instead.
         *
         * @param secretKey - The secret key of the delegating account.
         */
        sign(secretKey) {
          this.lsig.sign(secretKey);
          this.sigkey = keyPairFromSecretKey(secretKey).publicKey;
        }
      };
      LogicSigAccount.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "lsig",
          valueSchema: LogicSig.encodingSchema
        },
        {
          key: "sigkey",
          valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
        }
      ]));
      SIGN_PROGRAM_DATA_PREFIX = new TextEncoder().encode("ProgData");
    }
  });

  // node_modules/algosdk/dist/esm/types/transactions/index.js
  var init_transactions = __esm({
    "node_modules/algosdk/dist/esm/types/transactions/index.js"() {
      init_polyfills();
      init_base();
      init_encoded();
    }
  });

  // node_modules/algosdk/dist/esm/signedTransaction.js
  function decodeSignedTransaction(transactionBuffer) {
    return decodeMsgpack(transactionBuffer, SignedTransaction);
  }
  function encodeUnsignedSimulateTransaction(txn) {
    const stxn = new SignedTransaction({ txn });
    return encodeMsgpack(stxn);
  }
  var SignedTransaction;
  var init_signedTransaction = __esm({
    "node_modules/algosdk/dist/esm/signedTransaction.js"() {
      init_polyfills();
      init_encoding3();
      init_transaction();
      init_logicsig();
      init_transactions();
      init_schema();
      SignedTransaction = class _SignedTransaction {
        constructor({ txn, sig, msig, lsig, sgnr }) {
          this.txn = txn;
          this.sig = sig;
          this.msig = msig;
          this.lsig = lsig;
          this.sgnr = sgnr;
          let numberOfSigs = 0;
          if (sig)
            numberOfSigs += 1;
          if (msig)
            numberOfSigs += 1;
          if (lsig)
            numberOfSigs += 1;
          if (numberOfSigs > 1) {
            throw new Error(`SignedTransaction must not have more than 1 signature. Got ${numberOfSigs}`);
          }
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SignedTransaction.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["txn", this.txn.toEncodingData()],
            ["sig", this.sig],
            [
              "msig",
              this.msig ? encodedMultiSigToEncodingData(this.msig) : void 0
            ],
            ["lsig", this.lsig ? this.lsig.toEncodingData() : void 0],
            ["sgnr", this.sgnr]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SignedTransaction: ${data}`);
          }
          return new _SignedTransaction({
            txn: Transaction.fromEncodingData(data.get("txn")),
            sig: data.get("sig"),
            msig: data.get("msig") ? encodedMultiSigFromEncodingData(data.get("msig")) : void 0,
            lsig: data.get("lsig") ? LogicSig.fromEncodingData(data.get("lsig")) : void 0,
            sgnr: data.get("sgnr")
          });
        }
      };
      SignedTransaction.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "txn",
          valueSchema: Transaction.encodingSchema
        },
        {
          key: "sig",
          valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
        },
        {
          key: "msig",
          valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)
        },
        {
          key: "lsig",
          valueSchema: new OptionalSchema(LogicSig.encodingSchema)
        },
        {
          key: "sgnr",
          valueSchema: new OptionalSchema(new AddressSchema())
        }
      ]));
    }
  });

  // node_modules/algosdk/dist/esm/types/block.js
  var StateProofTrackingData, TxnCommitments, RewardState, UpgradeState, UpgradeVote, ParticipationUpdates, BlockHeader, ValueDelta, EvalDelta, ApplyData, SignedTxnWithAD, SignedTxnInBlock, Block;
  var init_block = __esm({
    "node_modules/algosdk/dist/esm/types/block.js"() {
      init_polyfills();
      init_schema();
      init_signedTransaction();
      StateProofTrackingData = class _StateProofTrackingData {
        constructor(params) {
          this.stateProofVotersCommitment = params.stateProofVotersCommitment;
          this.stateProofOnlineTotalWeight = params.stateProofOnlineTotalWeight;
          this.stateProofNextRound = params.stateProofNextRound;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProofTrackingData.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["v", this.stateProofVotersCommitment],
            ["t", this.stateProofOnlineTotalWeight],
            ["n", this.stateProofNextRound]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofTrackingData: ${data}`);
          }
          return new _StateProofTrackingData({
            stateProofVotersCommitment: data.get("v"),
            stateProofOnlineTotalWeight: data.get("t"),
            stateProofNextRound: data.get("n")
          });
        }
      };
      StateProofTrackingData.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "v",
          // stateProofVotersCommitment
          valueSchema: new ByteArraySchema()
        },
        {
          key: "t",
          // stateProofOnlineTotalWeight
          valueSchema: new Uint64Schema()
        },
        {
          key: "n",
          // stateProofNextRound
          valueSchema: new Uint64Schema()
        }
      ]));
      TxnCommitments = class _TxnCommitments {
        constructor(params) {
          this.nativeSha512_256Commitment = params.nativeSha512_256Commitment;
          this.sha256Commitment = params.sha256Commitment;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TxnCommitments.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["txn", this.nativeSha512_256Commitment],
            ["txn256", this.sha256Commitment]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TxnCommitments: ${data}`);
          }
          return new _TxnCommitments({
            nativeSha512_256Commitment: data.get("txn"),
            sha256Commitment: data.get("txn256")
          });
        }
      };
      TxnCommitments.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "txn",
          // nativeSha512_256Commitment
          valueSchema: new FixedLengthByteArraySchema(32)
        },
        {
          key: "txn256",
          // sha256Commitment
          valueSchema: new FixedLengthByteArraySchema(32)
        }
      ]));
      RewardState = class _RewardState {
        constructor(params) {
          this.feeSink = params.feeSink;
          this.rewardsPool = params.rewardsPool;
          this.rewardsLevel = params.rewardsLevel;
          this.rewardsRate = params.rewardsRate;
          this.rewardsResidue = params.rewardsResidue;
          this.rewardsRecalculationRound = params.rewardsRecalculationRound;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _RewardState.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["fees", this.feeSink],
            ["rwd", this.rewardsPool],
            ["earn", this.rewardsLevel],
            ["rate", this.rewardsRate],
            ["frac", this.rewardsResidue],
            ["rwcalr", this.rewardsRecalculationRound]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded RewardState: ${data}`);
          }
          return new _RewardState({
            feeSink: data.get("fees"),
            rewardsPool: data.get("rwd"),
            rewardsLevel: data.get("earn"),
            rewardsRate: data.get("rate"),
            rewardsResidue: data.get("frac"),
            rewardsRecalculationRound: data.get("rwcalr")
          });
        }
      };
      RewardState.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "fees",
          // feeSink
          valueSchema: new AddressSchema()
        },
        {
          key: "rwd",
          // rewardsPool
          valueSchema: new AddressSchema()
        },
        {
          key: "earn",
          // rewardsLevel
          valueSchema: new Uint64Schema()
        },
        {
          key: "rate",
          // rewardsRate
          valueSchema: new Uint64Schema()
        },
        {
          key: "frac",
          // rewardsResidue
          valueSchema: new Uint64Schema()
        },
        {
          key: "rwcalr",
          // rewardsRecalculationRound
          valueSchema: new Uint64Schema()
        }
      ]));
      UpgradeState = class _UpgradeState {
        constructor(params) {
          this.currentProtocol = params.currentProtocol;
          this.nextProtocol = params.nextProtocol;
          this.nextProtocolApprovals = params.nextProtocolApprovals;
          this.nextProtocolVoteBefore = params.nextProtocolVoteBefore;
          this.nextProtocolSwitchOn = params.nextProtocolSwitchOn;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _UpgradeState.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["proto", this.currentProtocol],
            ["nextproto", this.nextProtocol],
            ["nextyes", this.nextProtocolApprovals],
            ["nextbefore", this.nextProtocolVoteBefore],
            ["nextswitch", this.nextProtocolSwitchOn]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded UpgradeState: ${data}`);
          }
          return new _UpgradeState({
            currentProtocol: data.get("proto"),
            nextProtocol: data.get("nextproto"),
            nextProtocolApprovals: data.get("nextyes"),
            nextProtocolVoteBefore: data.get("nextbefore"),
            nextProtocolSwitchOn: data.get("nextswitch")
          });
        }
      };
      UpgradeState.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "proto",
          // currentProtocol
          valueSchema: new StringSchema()
        },
        {
          key: "nextproto",
          // nextProtocol
          valueSchema: new StringSchema()
        },
        {
          key: "nextyes",
          // nextProtocolApprovals
          valueSchema: new Uint64Schema()
        },
        {
          key: "nextbefore",
          // nextProtocolVoteBefore
          valueSchema: new Uint64Schema()
        },
        {
          key: "nextswitch",
          // nextProtocolSwitchOn
          valueSchema: new Uint64Schema()
        }
      ]));
      UpgradeVote = class _UpgradeVote {
        constructor(params) {
          this.upgradePropose = params.upgradePropose;
          this.upgradeDelay = params.upgradeDelay;
          this.upgradeApprove = params.upgradeApprove;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _UpgradeVote.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["upgradeprop", this.upgradePropose],
            ["upgradedelay", this.upgradeDelay],
            ["upgradeyes", this.upgradeApprove]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded UpgradeVote: ${data}`);
          }
          return new _UpgradeVote({
            upgradePropose: data.get("upgradeprop"),
            upgradeDelay: data.get("upgradedelay"),
            upgradeApprove: data.get("upgradeyes")
          });
        }
      };
      UpgradeVote.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "upgradeprop",
          // upgradePropose
          valueSchema: new StringSchema()
        },
        {
          key: "upgradedelay",
          // upgradeDelay
          valueSchema: new Uint64Schema()
        },
        {
          key: "upgradeyes",
          // upgradeApprove
          valueSchema: new BooleanSchema()
        }
      ]));
      ParticipationUpdates = class _ParticipationUpdates {
        constructor(params) {
          this.expiredParticipationAccounts = params.expiredParticipationAccounts;
          this.absentParticipationAccounts = params.absentParticipationAccounts;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ParticipationUpdates.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["partupdrmv", this.expiredParticipationAccounts],
            ["partupdabs", this.absentParticipationAccounts]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ParticipationUpdates: ${data}`);
          }
          return new _ParticipationUpdates({
            expiredParticipationAccounts: data.get("partupdrmv"),
            absentParticipationAccounts: data.get("partupdabs")
          });
        }
      };
      ParticipationUpdates.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "partupdrmv",
          // expiredParticipationAccounts
          valueSchema: new ArraySchema(new AddressSchema())
        },
        {
          key: "partupdabs",
          // absentParticipationAccounts
          valueSchema: new ArraySchema(new AddressSchema())
        }
      ]));
      BlockHeader = class _BlockHeader {
        constructor(params) {
          this.round = params.round;
          this.branch = params.branch;
          this.seed = params.seed;
          this.txnCommitments = params.txnCommitments;
          this.timestamp = params.timestamp;
          this.genesisID = params.genesisID;
          this.genesisHash = params.genesisHash;
          this.proposer = params.proposer;
          this.feesCollected = params.feesCollected;
          this.bonus = params.bonus;
          this.proposerPayout = params.proposerPayout;
          this.rewardState = params.rewardState;
          this.upgradeState = params.upgradeState;
          this.upgradeVote = params.upgradeVote;
          this.txnCounter = params.txnCounter;
          this.stateproofTracking = params.stateproofTracking;
          this.participationUpdates = params.participationUpdates;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BlockHeader.encodingSchema;
        }
        toEncodingData() {
          const data = /* @__PURE__ */ new Map([
            ["rnd", this.round],
            ["prev", this.branch],
            ["seed", this.seed],
            ["ts", this.timestamp],
            ["gen", this.genesisID],
            ["gh", this.genesisHash],
            ["prp", this.proposer],
            ["fc", this.feesCollected],
            ["bi", this.bonus],
            ["pp", this.proposerPayout],
            ["tc", this.txnCounter],
            [
              "spt",
              convertMap(this.stateproofTracking, (key, value) => [
                key,
                value.toEncodingData()
              ])
            ]
          ]);
          return combineMaps(data, this.txnCommitments.toEncodingData(), this.rewardState.toEncodingData(), this.upgradeState.toEncodingData(), this.upgradeVote.toEncodingData(), this.participationUpdates.toEncodingData());
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockHeader: ${data}`);
          }
          return new _BlockHeader({
            round: data.get("rnd"),
            branch: data.get("prev"),
            seed: data.get("seed"),
            txnCommitments: TxnCommitments.fromEncodingData(data),
            timestamp: data.get("ts"),
            genesisID: data.get("gen"),
            genesisHash: data.get("gh"),
            proposer: data.get("prp"),
            feesCollected: data.get("fc"),
            bonus: data.get("bi"),
            proposerPayout: data.get("pp"),
            rewardState: RewardState.fromEncodingData(data),
            upgradeState: UpgradeState.fromEncodingData(data),
            upgradeVote: UpgradeVote.fromEncodingData(data),
            txnCounter: data.get("tc"),
            stateproofTracking: convertMap(data.get("spt"), (key, value) => [
              Number(key),
              StateProofTrackingData.fromEncodingData(value)
            ]),
            participationUpdates: ParticipationUpdates.fromEncodingData(data)
          });
        }
      };
      BlockHeader.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "rnd",
          // round
          valueSchema: new Uint64Schema()
        },
        {
          key: "prev",
          // branch
          valueSchema: new BlockHashSchema()
        },
        {
          key: "seed",
          // seed
          valueSchema: new ByteArraySchema()
        },
        {
          key: "",
          valueSchema: TxnCommitments.encodingSchema,
          embedded: true
        },
        {
          key: "ts",
          // timestamp
          valueSchema: new Uint64Schema()
        },
        {
          key: "gen",
          // genesisID
          valueSchema: new StringSchema()
        },
        {
          key: "gh",
          // genesisHash
          valueSchema: new FixedLengthByteArraySchema(32)
        },
        {
          key: "prp",
          // proposer
          valueSchema: new AddressSchema()
        },
        {
          key: "fc",
          // feesCollected
          valueSchema: new Uint64Schema()
        },
        {
          key: "bi",
          // bonus
          valueSchema: new Uint64Schema()
        },
        {
          key: "pp",
          // proposerPayout
          valueSchema: new Uint64Schema()
        },
        {
          key: "",
          valueSchema: RewardState.encodingSchema,
          embedded: true
        },
        {
          key: "",
          valueSchema: UpgradeState.encodingSchema,
          embedded: true
        },
        {
          key: "",
          valueSchema: UpgradeVote.encodingSchema,
          embedded: true
        },
        {
          key: "tc",
          // txnCounter
          valueSchema: new Uint64Schema()
        },
        {
          key: "spt",
          // stateproofTracking
          valueSchema: new Uint64MapSchema(StateProofTrackingData.encodingSchema)
        },
        {
          key: "",
          valueSchema: ParticipationUpdates.encodingSchema,
          embedded: true
        }
      ]));
      ValueDelta = class _ValueDelta {
        constructor(params) {
          this.action = params.action;
          this.bytes = params.bytes;
          this.uint = params.uint;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ValueDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["at", this.action],
            ["bs", this.bytes],
            ["ui", this.uint]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ValueDelta: ${data}`);
          }
          return new _ValueDelta({
            action: Number(data.get("at")),
            bytes: data.get("bs"),
            uint: data.get("ui")
          });
        }
      };
      ValueDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "at",
          // action
          valueSchema: new Uint64Schema()
        },
        {
          key: "bs",
          // bytes
          valueSchema: new SpecialCaseBinaryStringSchema()
        },
        {
          key: "ui",
          // uint
          valueSchema: new Uint64Schema()
        }
      ]));
      EvalDelta = class _EvalDelta {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries(...allOmitEmpty([
              {
                key: "gd",
                // globalDelta
                valueSchema: new OptionalSchema(new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema))
              },
              {
                key: "ld",
                // localDeltas
                valueSchema: new OptionalSchema(new Uint64MapSchema(new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema)))
              },
              {
                key: "sa",
                // sharedAccts
                valueSchema: new OptionalSchema(new ArraySchema(new AddressSchema()))
              },
              {
                key: "lg",
                // logs
                valueSchema: new OptionalSchema(new ArraySchema(new SpecialCaseBinaryStringSchema()))
              },
              {
                key: "itx",
                // innerTxns
                valueSchema: new OptionalSchema(
                  // eslint-disable-next-line no-use-before-define
                  new ArraySchema(SignedTxnWithAD.encodingSchema)
                )
              }
            ]));
          }
          return this.encodingSchemaValue;
        }
        constructor(params) {
          this.globalDelta = params.globalDelta ?? /* @__PURE__ */ new Map();
          this.localDeltas = params.localDeltas ?? /* @__PURE__ */ new Map();
          this.sharedAccts = params.sharedAccts ?? [];
          this.logs = params.logs ?? [];
          this.innerTxns = params.innerTxns ?? [];
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _EvalDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "gd",
              convertMap(this.globalDelta, (key, value) => [
                key,
                value.toEncodingData()
              ])
            ],
            [
              "ld",
              convertMap(this.localDeltas, (key, value) => [
                key,
                convertMap(value, (k3, v3) => [k3, v3.toEncodingData()])
              ])
            ],
            ["sa", this.sharedAccts],
            ["lg", this.logs],
            ["itx", this.innerTxns.map((t) => t.toEncodingData())]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded EvalDelta: ${data}`);
          }
          return new _EvalDelta({
            globalDelta: data.get("gd") ? convertMap(data.get("gd"), (key, value) => [key, ValueDelta.fromEncodingData(value)]) : void 0,
            localDeltas: data.get("ld") ? convertMap(data.get("ld"), (key, value) => [
              Number(key),
              convertMap(value, (k3, v3) => [k3, ValueDelta.fromEncodingData(v3)])
            ]) : void 0,
            sharedAccts: data.get("sa"),
            logs: data.get("lg"),
            // eslint-disable-next-line no-use-before-define
            innerTxns: (data.get("itx") ?? []).map(SignedTxnWithAD.fromEncodingData)
          });
        }
      };
      ApplyData = class _ApplyData {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries(...allOmitEmpty([
              {
                key: "ca",
                // closingAmount
                valueSchema: new OptionalSchema(new Uint64Schema())
              },
              {
                key: "aca",
                // assetClosingAmount
                valueSchema: new OptionalSchema(new Uint64Schema())
              },
              {
                key: "rs",
                // senderRewards
                valueSchema: new OptionalSchema(new Uint64Schema())
              },
              {
                key: "rr",
                // receiverRewards
                valueSchema: new OptionalSchema(new Uint64Schema())
              },
              {
                key: "rc",
                // closeRewards
                valueSchema: new OptionalSchema(new Uint64Schema())
              },
              {
                key: "dt",
                // evalDelta
                valueSchema: new OptionalSchema(EvalDelta.encodingSchema)
              },
              {
                key: "caid",
                // configAsset
                valueSchema: new OptionalSchema(new Uint64Schema())
              },
              {
                key: "apid",
                // applicationID
                valueSchema: new OptionalSchema(new Uint64Schema())
              }
            ]));
          }
          return this.encodingSchemaValue;
        }
        constructor(params) {
          this.closingAmount = params.closingAmount;
          this.assetClosingAmount = params.assetClosingAmount;
          this.senderRewards = params.senderRewards;
          this.receiverRewards = params.receiverRewards;
          this.closeRewards = params.closeRewards;
          this.evalDelta = params.evalDelta;
          this.configAsset = params.configAsset;
          this.applicationID = params.applicationID;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplyData.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["ca", this.closingAmount],
            ["aca", this.assetClosingAmount],
            ["rs", this.senderRewards],
            ["rr", this.receiverRewards],
            ["rc", this.closeRewards],
            ["dt", this.evalDelta ? this.evalDelta.toEncodingData() : void 0],
            ["caid", this.configAsset],
            ["apid", this.applicationID]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplyData: ${data}`);
          }
          return new _ApplyData({
            closingAmount: data.get("ca"),
            assetClosingAmount: data.get("aca"),
            senderRewards: data.get("rs"),
            receiverRewards: data.get("rr"),
            closeRewards: data.get("rc"),
            evalDelta: data.get("dt") ? EvalDelta.fromEncodingData(data.get("dt")) : void 0,
            configAsset: data.get("caid"),
            applicationID: data.get("apid")
          });
        }
      };
      SignedTxnWithAD = class _SignedTxnWithAD {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries(...allOmitEmpty([
              {
                key: "",
                valueSchema: SignedTransaction.encodingSchema,
                embedded: true
              },
              {
                key: "",
                valueSchema: ApplyData.encodingSchema,
                embedded: true
              }
            ]));
          }
          return this.encodingSchemaValue;
        }
        constructor(params) {
          this.signedTxn = params.signedTxn;
          this.applyData = params.applyData;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SignedTxnWithAD.encodingSchema;
        }
        toEncodingData() {
          return combineMaps(this.signedTxn.toEncodingData(), this.applyData.toEncodingData());
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SignedTxnWithAD: ${data}`);
          }
          return new _SignedTxnWithAD({
            signedTxn: SignedTransaction.fromEncodingData(data),
            applyData: ApplyData.fromEncodingData(data)
          });
        }
      };
      SignedTxnInBlock = class _SignedTxnInBlock {
        constructor(params) {
          this.signedTxn = params.signedTxn;
          this.hasGenesisID = params.hasGenesisID;
          this.hasGenesisHash = params.hasGenesisHash;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SignedTxnInBlock.encodingSchema;
        }
        toEncodingData() {
          const data = /* @__PURE__ */ new Map([
            ["hgi", this.hasGenesisID],
            ["hgh", this.hasGenesisHash]
          ]);
          return combineMaps(data, this.signedTxn.toEncodingData());
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SignedTxnInBlock: ${data}`);
          }
          return new _SignedTxnInBlock({
            signedTxn: SignedTxnWithAD.fromEncodingData(data),
            hasGenesisID: data.get("hgi"),
            hasGenesisHash: data.get("hgh")
          });
        }
      };
      SignedTxnInBlock.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "",
          valueSchema: SignedTxnWithAD.encodingSchema,
          embedded: true
        },
        {
          key: "hgi",
          // hasGenesisID
          valueSchema: new BooleanSchema()
        },
        {
          key: "hgh",
          // hasGenesisHash
          valueSchema: new BooleanSchema()
        }
      ]));
      Block = class _Block {
        constructor(params) {
          this.header = params.header;
          this.payset = params.payset;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Block.encodingSchema;
        }
        toEncodingData() {
          const data = /* @__PURE__ */ new Map([
            ["txns", this.payset.map((p2) => p2.toEncodingData())]
          ]);
          return combineMaps(data, this.header.toEncodingData());
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockHeader: ${data}`);
          }
          return new _Block({
            header: BlockHeader.fromEncodingData(data),
            payset: data.get("txns").map(SignedTxnInBlock.fromEncodingData)
          });
        }
      };
      Block.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "",
          valueSchema: BlockHeader.encodingSchema,
          embedded: true
        },
        {
          key: "txns",
          // payset
          valueSchema: new ArraySchema(SignedTxnInBlock.encodingSchema)
        }
      ]));
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/untypedmodel.js
  var UntypedValue;
  var init_untypedmodel = __esm({
    "node_modules/algosdk/dist/esm/client/v2/untypedmodel.js"() {
      init_polyfills();
      init_schema();
      UntypedValue = class _UntypedValue {
        constructor(data) {
          this.data = data;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _UntypedValue.encodingSchema;
        }
        toEncodingData() {
          return this.data;
        }
        static fromEncodingData(data) {
          return new _UntypedValue(data);
        }
      };
      UntypedValue.encodingSchema = new UntypedSchema();
    }
  });

  // node_modules/algosdk/dist/esm/types/statedelta.js
  var TealValue, StateSchema, AppParams, AppLocalState, AppLocalStateDelta, AppParamsDelta, AppResourceRecord, AssetHolding, AssetHoldingDelta, AssetParams, AssetParamsDelta, AssetResourceRecord, VotingData, AccountBaseData, AccountData, BalanceRecord, AccountDeltas, KvValueDelta, IncludedTransactions, ModifiedCreatable, AlgoCount, AccountTotals, LedgerStateDelta;
  var init_statedelta = __esm({
    "node_modules/algosdk/dist/esm/types/statedelta.js"() {
      init_polyfills();
      init_schema();
      init_block();
      init_untypedmodel();
      TealValue = class _TealValue {
        constructor(params) {
          this.type = params.type;
          this.bytes = params.bytes;
          this.uint = params.uint;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TealValue.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["tt", this.type],
            ["tb", this.bytes],
            ["ui", this.uint]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TealValue: ${data}`);
          }
          return new _TealValue({
            type: Number(data.get("tt")),
            bytes: data.get("tb"),
            uint: data.get("ui")
          });
        }
      };
      TealValue.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "tt", valueSchema: new Uint64Schema() },
        // type
        {
          key: "tb",
          // bytes
          valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
        },
        { key: "ui", valueSchema: new OptionalSchema(new Uint64Schema()) }
        // uint
      ]));
      StateSchema = class _StateSchema {
        constructor(params) {
          this.numUints = params.numUints;
          this.numByteSlices = params.numByteSlices;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateSchema.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["nui", this.numUints],
            ["nbs", this.numByteSlices]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateSchema: ${data}`);
          }
          return new _StateSchema({
            numUints: Number(data.get("nui")),
            numByteSlices: Number(data.get("nbs"))
          });
        }
      };
      StateSchema.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "nui",
          // numUints
          valueSchema: new Uint64Schema()
        },
        {
          key: "nbs",
          // numByteSlices
          valueSchema: new Uint64Schema()
        }
      ]));
      AppParams = class _AppParams {
        constructor(params) {
          this.approvalProgram = params.approvalProgram;
          this.clearStateProgram = params.clearStateProgram;
          this.globalState = params.globalState;
          this.localStateSchema = params.localStateSchema;
          this.globalStateSchema = params.globalStateSchema;
          this.extraProgramPages = params.extraProgramPages;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AppParams.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["approv", this.approvalProgram],
            ["clearp", this.clearStateProgram],
            ["gs", convertMap(this.globalState, (k3, v3) => [k3, v3.toEncodingData()])],
            ["lsch", this.localStateSchema.toEncodingData()],
            ["gsch", this.globalStateSchema.toEncodingData()],
            ["epp", this.extraProgramPages]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AppParams: ${data}`);
          }
          return new _AppParams({
            approvalProgram: data.get("approv"),
            clearStateProgram: data.get("clearp"),
            globalState: convertMap(data.get("gs"), (k3, v3) => [k3, TealValue.fromEncodingData(v3)]),
            localStateSchema: StateSchema.fromEncodingData(data.get("lsch")),
            globalStateSchema: StateSchema.fromEncodingData(data.get("gsch")),
            extraProgramPages: Number(data.get("epp"))
          });
        }
      };
      AppParams.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "approv", valueSchema: new ByteArraySchema() },
        // approvalProgram
        { key: "clearp", valueSchema: new ByteArraySchema() },
        // alearStateProgram
        {
          key: "gs",
          valueSchema: new SpecialCaseBinaryStringMapSchema(TealValue.encodingSchema)
        },
        // globalState
        { key: "lsch", valueSchema: StateSchema.encodingSchema },
        // localStateSchema
        { key: "gsch", valueSchema: StateSchema.encodingSchema },
        // globalStateSchema
        { key: "epp", valueSchema: new Uint64Schema() }
        // extraProgramPages
      ]));
      AppLocalState = class _AppLocalState {
        constructor(params) {
          this.schema = params.schema;
          this.keyValue = params.keyValue;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AppLocalState.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["hsch", this.schema.toEncodingData()],
            ["tkv", convertMap(this.keyValue, (k3, v3) => [k3, v3.toEncodingData()])]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AppLocalState: ${data}`);
          }
          return new _AppLocalState({
            schema: StateSchema.fromEncodingData(data.get("hsch")),
            keyValue: convertMap(data.get("tkv"), (k3, v3) => [k3, TealValue.fromEncodingData(v3)])
          });
        }
      };
      AppLocalState.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "hsch", valueSchema: StateSchema.encodingSchema },
        // schema
        {
          key: "tkv",
          // keyValue
          valueSchema: new SpecialCaseBinaryStringMapSchema(TealValue.encodingSchema)
        }
      ]));
      AppLocalStateDelta = class _AppLocalStateDelta {
        constructor(params) {
          this.localState = params.localState;
          this.deleted = params.deleted;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AppLocalStateDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "LocalState",
              this.localState ? this.localState.toEncodingData() : void 0
            ],
            ["Deleted", this.deleted]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AppLocalStateDelta: ${data}`);
          }
          return new _AppLocalStateDelta({
            localState: data.get("LocalState") ? AppLocalState.fromEncodingData(data.get("LocalState")) : void 0,
            deleted: data.get("Deleted")
          });
        }
      };
      AppLocalStateDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "LocalState",
          // localState
          valueSchema: new OptionalSchema(AppLocalState.encodingSchema)
        },
        { key: "Deleted", valueSchema: new BooleanSchema() }
        // deleted
      ]));
      AppParamsDelta = class _AppParamsDelta {
        constructor(params) {
          this.params = params.params;
          this.deleted = params.deleted;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AppParamsDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Params", this.params ? this.params.toEncodingData() : void 0],
            ["Deleted", this.deleted]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AppParamsDelta: ${data}`);
          }
          return new _AppParamsDelta({
            params: data.get("Params") ? AppParams.fromEncodingData(data.get("Params")) : void 0,
            deleted: data.get("Deleted")
          });
        }
      };
      AppParamsDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "Params",
          // params
          valueSchema: new OptionalSchema(AppParams.encodingSchema)
        },
        { key: "Deleted", valueSchema: new BooleanSchema() }
        // deleted
      ]));
      AppResourceRecord = class _AppResourceRecord {
        constructor(params) {
          this.id = params.id;
          this.address = params.address;
          this.params = params.params;
          this.state = params.state;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AppResourceRecord.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Aidx", this.id],
            ["Addr", this.address],
            ["Params", this.params.toEncodingData()],
            ["State", this.state.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AppResourceRecord: ${data}`);
          }
          return new _AppResourceRecord({
            id: data.get("Aidx"),
            address: data.get("Addr"),
            params: AppParamsDelta.fromEncodingData(data.get("Params")),
            state: AppLocalStateDelta.fromEncodingData(data.get("State"))
          });
        }
      };
      AppResourceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "Aidx", valueSchema: new Uint64Schema() },
        // id
        { key: "Addr", valueSchema: new AddressSchema() },
        // address
        {
          key: "Params",
          // params
          valueSchema: AppParamsDelta.encodingSchema
        },
        {
          key: "State",
          // state
          valueSchema: AppLocalStateDelta.encodingSchema
        }
      ]));
      AssetHolding = class _AssetHolding {
        constructor(params) {
          this.amount = params.amount;
          this.frozen = params.frozen;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetHolding.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["a", this.amount],
            ["f", this.frozen]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetHolding: ${data}`);
          }
          return new _AssetHolding({
            amount: data.get("a"),
            frozen: data.get("f")
          });
        }
      };
      AssetHolding.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "a", valueSchema: new Uint64Schema() },
        // amount
        { key: "f", valueSchema: new BooleanSchema() }
        // frozen
      ]));
      AssetHoldingDelta = class _AssetHoldingDelta {
        constructor(params) {
          this.holding = params.holding;
          this.deleted = params.deleted;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetHoldingDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Holding", this.holding ? this.holding.toEncodingData() : void 0],
            ["Deleted", this.deleted]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetHoldingDelta: ${data}`);
          }
          return new _AssetHoldingDelta({
            holding: data.get("Holding") ? AssetHolding.fromEncodingData(data.get("Holding")) : void 0,
            deleted: data.get("Deleted")
          });
        }
      };
      AssetHoldingDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "Holding",
          // holding
          valueSchema: new OptionalSchema(AssetHolding.encodingSchema)
        },
        { key: "Deleted", valueSchema: new BooleanSchema() }
        // deleted
      ]));
      AssetParams = class _AssetParams {
        constructor(params) {
          this.total = params.total;
          this.decimals = params.decimals;
          this.defaultFrozen = params.defaultFrozen;
          this.unitName = params.unitName;
          this.assetName = params.assetName;
          this.url = params.url;
          this.metadataHash = params.metadataHash;
          this.manager = params.manager;
          this.reserve = params.reserve;
          this.freeze = params.freeze;
          this.clawback = params.clawback;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetParams.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["t", this.total],
            ["dc", this.decimals],
            ["df", this.defaultFrozen],
            ["un", this.unitName],
            ["an", this.assetName],
            ["au", this.url],
            ["am", this.metadataHash],
            ["m", this.manager],
            ["r", this.reserve],
            ["f", this.freeze],
            ["c", this.clawback]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetParams: ${data}`);
          }
          return new _AssetParams({
            total: data.get("t"),
            decimals: data.get("dc"),
            defaultFrozen: data.get("df"),
            unitName: data.get("un"),
            assetName: data.get("an"),
            url: data.get("au"),
            metadataHash: data.get("am"),
            manager: data.get("m"),
            reserve: data.get("r"),
            freeze: data.get("f"),
            clawback: data.get("c")
          });
        }
      };
      AssetParams.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "t", valueSchema: new Uint64Schema() },
        // total
        { key: "dc", valueSchema: new Uint64Schema() },
        // decimals
        { key: "df", valueSchema: new BooleanSchema() },
        // defaultFrozen
        {
          key: "un",
          // unitName
          valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
        },
        {
          key: "an",
          // assetName
          valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
        },
        {
          key: "au",
          // url
          valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
        },
        { key: "am", valueSchema: new FixedLengthByteArraySchema(32) },
        // metadataHash
        { key: "m", valueSchema: new OptionalSchema(new AddressSchema()) },
        // manager
        { key: "r", valueSchema: new OptionalSchema(new AddressSchema()) },
        // reserve
        { key: "f", valueSchema: new OptionalSchema(new AddressSchema()) },
        // freeze
        { key: "c", valueSchema: new OptionalSchema(new AddressSchema()) }
        // clawback
      ]));
      AssetParamsDelta = class _AssetParamsDelta {
        constructor(params) {
          this.params = params.params;
          this.deleted = params.deleted;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetParamsDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Params", this.params ? this.params.toEncodingData() : void 0],
            ["Deleted", this.deleted]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetParamsDelta: ${data}`);
          }
          return new _AssetParamsDelta({
            params: data.get("Params") ? AssetParams.fromEncodingData(data.get("Params")) : void 0,
            deleted: data.get("Deleted")
          });
        }
      };
      AssetParamsDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "Params",
          // params
          valueSchema: new OptionalSchema(AssetParams.encodingSchema)
        },
        { key: "Deleted", valueSchema: new BooleanSchema() }
        // deleted
      ]));
      AssetResourceRecord = class _AssetResourceRecord {
        constructor(params) {
          this.id = params.id;
          this.address = params.address;
          this.params = params.params;
          this.holding = params.holding;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetResourceRecord.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Aidx", this.id],
            ["Addr", this.address],
            ["Params", this.params.toEncodingData()],
            ["Holding", this.holding.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetResourceRecord: ${data}`);
          }
          return new _AssetResourceRecord({
            id: data.get("Aidx"),
            address: data.get("Addr"),
            params: AssetParamsDelta.fromEncodingData(data.get("Params")),
            holding: AssetHoldingDelta.fromEncodingData(data.get("Holding"))
          });
        }
      };
      AssetResourceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "Aidx", valueSchema: new Uint64Schema() },
        // id
        { key: "Addr", valueSchema: new AddressSchema() },
        // address
        {
          key: "Params",
          // params
          valueSchema: AssetParamsDelta.encodingSchema
        },
        {
          key: "Holding",
          // holding
          valueSchema: AssetHoldingDelta.encodingSchema
        }
      ]));
      VotingData = class _VotingData {
        constructor(params) {
          this.voteID = params.voteID;
          this.selectionID = params.selectionID;
          this.stateProofID = params.stateProofID;
          this.voteFirstValid = params.voteFirstValid;
          this.voteLastValid = params.voteLastValid;
          this.voteKeyDilution = params.voteKeyDilution;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _VotingData.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["VoteID", this.voteID],
            ["SelectionID", this.selectionID],
            ["StateProofID", this.stateProofID],
            ["VoteFirstValid", this.voteFirstValid],
            ["VoteLastValid", this.voteLastValid],
            ["VoteKeyDilution", this.voteKeyDilution]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded VotingData: ${data}`);
          }
          return new _VotingData({
            voteID: data.get("VoteID"),
            selectionID: data.get("SelectionID"),
            stateProofID: data.get("StateProofID"),
            voteFirstValid: data.get("VoteFirstValid"),
            voteLastValid: data.get("VoteLastValid"),
            voteKeyDilution: data.get("VoteKeyDilution")
          });
        }
      };
      VotingData.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "VoteID",
          // voteID
          valueSchema: new FixedLengthByteArraySchema(32)
        },
        {
          key: "SelectionID",
          // selectionID
          valueSchema: new FixedLengthByteArraySchema(32)
        },
        {
          key: "StateProofID",
          // stateProofID
          valueSchema: new FixedLengthByteArraySchema(64)
        },
        {
          key: "VoteFirstValid",
          // voteFirstValid
          valueSchema: new Uint64Schema()
        },
        {
          key: "VoteLastValid",
          // voteLastValid
          valueSchema: new Uint64Schema()
        },
        {
          key: "VoteKeyDilution",
          // voteKeyDilution
          valueSchema: new Uint64Schema()
        }
      ]));
      AccountBaseData = class _AccountBaseData {
        constructor(params) {
          this.status = params.status;
          this.microAlgos = params.microAlgos;
          this.rewardsBase = params.rewardsBase;
          this.rewardedMicroAlgos = params.rewardedMicroAlgos;
          this.authAddr = params.authAddr;
          this.incentiveEligible = params.incentiveEligible;
          this.totalAppSchema = params.totalAppSchema;
          this.totalExtraAppPages = params.totalExtraAppPages;
          this.totalAppParams = params.totalAppParams;
          this.totalAppLocalStates = params.totalAppLocalStates;
          this.totalAssetParams = params.totalAssetParams;
          this.totalAssets = params.totalAssets;
          this.totalBoxes = params.totalBoxes;
          this.totalBoxBytes = params.totalBoxBytes;
          this.lastProposed = params.lastProposed;
          this.lastHeartbeat = params.lastHeartbeat;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountBaseData.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Status", this.status],
            ["MicroAlgos", this.microAlgos],
            ["RewardsBase", this.rewardsBase],
            ["RewardedMicroAlgos", this.rewardedMicroAlgos],
            ["AuthAddr", this.authAddr],
            ["IncentiveEligible", this.incentiveEligible],
            ["TotalAppSchema", this.totalAppSchema.toEncodingData()],
            ["TotalExtraAppPages", this.totalExtraAppPages],
            ["TotalAppParams", this.totalAppParams],
            ["TotalAppLocalStates", this.totalAppLocalStates],
            ["TotalAssetParams", this.totalAssetParams],
            ["TotalAssets", this.totalAssets],
            ["TotalBoxes", this.totalBoxes],
            ["TotalBoxBytes", this.totalBoxBytes],
            ["LastProposed", this.lastProposed],
            ["LastHeartbeat", this.lastHeartbeat]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountBaseData: ${data}`);
          }
          return new _AccountBaseData({
            status: Number(data.get("Status")),
            microAlgos: data.get("MicroAlgos"),
            rewardsBase: data.get("RewardsBase"),
            rewardedMicroAlgos: data.get("RewardedMicroAlgos"),
            authAddr: data.get("AuthAddr"),
            incentiveEligible: data.get("IncentiveEligible"),
            totalAppSchema: StateSchema.fromEncodingData(data.get("TotalAppSchema")),
            totalExtraAppPages: Number(data.get("TotalExtraAppPages")),
            totalAppParams: data.get("TotalAppParams"),
            totalAppLocalStates: data.get("TotalAppLocalStates"),
            totalAssetParams: data.get("TotalAssetParams"),
            totalAssets: data.get("TotalAssets"),
            totalBoxes: data.get("TotalBoxes"),
            totalBoxBytes: data.get("TotalBoxBytes"),
            lastProposed: data.get("LastProposed"),
            lastHeartbeat: data.get("LastHeartbeat")
          });
        }
      };
      AccountBaseData.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "Status", valueSchema: new Uint64Schema() },
        // status
        { key: "MicroAlgos", valueSchema: new Uint64Schema() },
        // microAlgos
        { key: "RewardsBase", valueSchema: new Uint64Schema() },
        // rewardsBase
        {
          key: "RewardedMicroAlgos",
          // rewardedMicroAlgos
          valueSchema: new Uint64Schema()
        },
        { key: "AuthAddr", valueSchema: new AddressSchema() },
        // authAddr
        {
          key: "IncentiveEligible",
          // incentiveEligible
          valueSchema: new BooleanSchema()
        },
        {
          key: "TotalAppSchema",
          // totalAppSchema
          valueSchema: StateSchema.encodingSchema
        },
        {
          key: "TotalExtraAppPages",
          // totalExtraAppPages
          valueSchema: new Uint64Schema()
        },
        {
          key: "TotalAppParams",
          // totalAppParams
          valueSchema: new Uint64Schema()
        },
        {
          key: "TotalAppLocalStates",
          // totalAppLocalStates
          valueSchema: new Uint64Schema()
        },
        {
          key: "TotalAssetParams",
          // totalAssetParams
          valueSchema: new Uint64Schema()
        },
        { key: "TotalAssets", valueSchema: new Uint64Schema() },
        // totalAssets
        { key: "TotalBoxes", valueSchema: new Uint64Schema() },
        // totalBoxes
        {
          key: "TotalBoxBytes",
          // totalBoxBytes
          valueSchema: new Uint64Schema()
        },
        { key: "LastProposed", valueSchema: new Uint64Schema() },
        // lastProposed
        {
          key: "LastHeartbeat",
          // lastHeartbeat
          valueSchema: new Uint64Schema()
        }
      ]));
      AccountData = class _AccountData {
        constructor(params) {
          this.accountBaseData = params.accountBaseData;
          this.votingData = params.votingData;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountData.encodingSchema;
        }
        toEncodingData() {
          return combineMaps(this.accountBaseData.toEncodingData(), this.votingData.toEncodingData());
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountData: ${data}`);
          }
          return new _AccountData({
            accountBaseData: AccountBaseData.fromEncodingData(data),
            votingData: VotingData.fromEncodingData(data)
          });
        }
      };
      AccountData.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "",
          valueSchema: AccountBaseData.encodingSchema,
          embedded: true
        },
        {
          key: "",
          valueSchema: VotingData.encodingSchema,
          embedded: true
        }
      ]));
      BalanceRecord = class _BalanceRecord {
        constructor(params) {
          this.addr = params.addr;
          this.accountData = params.accountData;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BalanceRecord.encodingSchema;
        }
        toEncodingData() {
          return combineMaps(/* @__PURE__ */ new Map([["Addr", this.addr]]), this.accountData.toEncodingData());
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BalanceRecord: ${data}`);
          }
          return new _BalanceRecord({
            addr: data.get("Addr"),
            accountData: AccountData.fromEncodingData(data)
          });
        }
      };
      BalanceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "Addr",
          valueSchema: new AddressSchema()
        },
        {
          key: "",
          valueSchema: AccountData.encodingSchema,
          embedded: true
        }
      ]));
      AccountDeltas = class _AccountDeltas {
        constructor(params) {
          this.accounts = params.accounts;
          this.appResources = params.appResources;
          this.assetResources = params.assetResources;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountDeltas.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Accts", this.accounts.map((account) => account.toEncodingData())],
            [
              "AppResources",
              this.appResources.length === 0 ? void 0 : this.appResources.map((appResource) => appResource.toEncodingData())
            ],
            [
              "AssetResources",
              this.assetResources.length === 0 ? void 0 : this.assetResources.map((assetResource) => assetResource.toEncodingData())
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountDeltas: ${data}`);
          }
          return new _AccountDeltas({
            accounts: (data.get("Accts") ?? []).map(BalanceRecord.fromEncodingData),
            appResources: (data.get("AppResources") ?? []).map(AppResourceRecord.fromEncodingData),
            assetResources: (data.get("AssetResources") ?? []).map(AssetResourceRecord.fromEncodingData)
          });
        }
      };
      AccountDeltas.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "Accts",
          // accounts
          valueSchema: new ArraySchema(BalanceRecord.encodingSchema)
        },
        {
          key: "AppResources",
          // appResources
          valueSchema: new OptionalSchema(new ArraySchema(AppResourceRecord.encodingSchema))
        },
        {
          key: "AssetResources",
          // assetResources
          valueSchema: new OptionalSchema(new ArraySchema(AssetResourceRecord.encodingSchema))
        }
      ]));
      KvValueDelta = class _KvValueDelta {
        constructor(params) {
          this.data = params.data;
          this.oldData = params.oldData;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _KvValueDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Data", this.data],
            ["OldData", this.oldData]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded KvValueDelta: ${data}`);
          }
          return new _KvValueDelta({
            data: data.get("Data"),
            oldData: data.get("OldData")
          });
        }
      };
      KvValueDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "Data",
          valueSchema: new OptionalSchema(new ByteArraySchema())
        },
        {
          key: "OldData",
          valueSchema: new OptionalSchema(new ByteArraySchema())
        }
      ]));
      IncludedTransactions = class _IncludedTransactions {
        constructor(params) {
          this.lastValid = params.lastValid;
          this.intra = params.intra;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _IncludedTransactions.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["LastValid", this.lastValid],
            ["Intra", this.intra]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded IncludedTransactions: ${data}`);
          }
          return new _IncludedTransactions({
            lastValid: data.get("LastValid"),
            intra: Number(data.get("Intra"))
          });
        }
      };
      IncludedTransactions.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "LastValid",
          valueSchema: new Uint64Schema()
        },
        {
          key: "Intra",
          valueSchema: new Uint64Schema()
        }
      ]));
      ModifiedCreatable = class _ModifiedCreatable {
        constructor(params) {
          this.creatableType = params.creatableType;
          this.created = params.created;
          this.creator = params.creator;
          this.ndeltas = params.ndeltas;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ModifiedCreatable.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Ctype", this.creatableType],
            ["Created", this.created],
            ["Creator", this.creator],
            ["Ndeltas", this.ndeltas]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ModifiedCreatable: ${data}`);
          }
          return new _ModifiedCreatable({
            creatableType: Number(data.get("Ctype")),
            created: data.get("Created"),
            creator: data.get("Creator"),
            ndeltas: Number(data.get("Ndeltas"))
          });
        }
      };
      ModifiedCreatable.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "Ctype",
          // creatableType
          valueSchema: new Uint64Schema()
        },
        {
          key: "Created",
          // created
          valueSchema: new BooleanSchema()
        },
        {
          key: "Creator",
          // creator
          valueSchema: new AddressSchema()
        },
        {
          key: "Ndeltas",
          // ndeltas
          valueSchema: new Uint64Schema()
        }
      ]));
      AlgoCount = class _AlgoCount {
        constructor(params) {
          this.money = params.money;
          this.rewardUnits = params.rewardUnits;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AlgoCount.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["mon", this.money],
            ["rwd", this.rewardUnits]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AlgoCount: ${data}`);
          }
          return new _AlgoCount({
            money: data.get("mon"),
            rewardUnits: data.get("rwd")
          });
        }
      };
      AlgoCount.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "mon", valueSchema: new Uint64Schema() },
        // money
        { key: "rwd", valueSchema: new Uint64Schema() }
        // rewardUnits
      ]));
      AccountTotals = class _AccountTotals {
        constructor(params) {
          this.online = params.online;
          this.offline = params.offline;
          this.notParticipating = params.notParticipating;
          this.rewardsLevel = params.rewardsLevel;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountTotals.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["online", this.online.toEncodingData()],
            ["offline", this.offline.toEncodingData()],
            ["notpart", this.notParticipating.toEncodingData()],
            ["rwdlvl", this.rewardsLevel]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountTotals: ${data}`);
          }
          return new _AccountTotals({
            online: AlgoCount.fromEncodingData(data.get("online")),
            offline: AlgoCount.fromEncodingData(data.get("offline")),
            notParticipating: AlgoCount.fromEncodingData(data.get("notpart")),
            rewardsLevel: data.get("rwdlvl")
          });
        }
      };
      AccountTotals.encodingSchema = new NamedMapSchema(allOmitEmpty([
        { key: "online", valueSchema: AlgoCount.encodingSchema },
        // online
        { key: "offline", valueSchema: AlgoCount.encodingSchema },
        // offline
        { key: "notpart", valueSchema: AlgoCount.encodingSchema },
        // notParticipating
        { key: "rwdlvl", valueSchema: new Uint64Schema() }
        // rewardsLevel
      ]));
      LedgerStateDelta = class _LedgerStateDelta {
        constructor(params) {
          this.accounts = params.accounts;
          this.kvMods = params.kvMods;
          this.txids = params.txids;
          this.txleases = params.txleases;
          this.creatables = params.creatables;
          this.blockHeader = params.blockHeader;
          this.stateProofNext = params.stateProofNext;
          this.prevTimestamp = params.prevTimestamp;
          this.totals = params.totals;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _LedgerStateDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Accts", this.accounts.toEncodingData()],
            [
              "KvMods",
              this.kvMods.size === 0 ? void 0 : convertMap(this.kvMods, (key, value) => [
                key,
                value.toEncodingData()
              ])
            ],
            [
              "Txids",
              convertMap(this.txids, (key, value) => [key, value.toEncodingData()])
            ],
            ["Txleases", this.txleases.toEncodingData()],
            [
              "Creatables",
              this.creatables.size === 0 ? void 0 : convertMap(this.creatables, (key, value) => [
                key,
                value.toEncodingData()
              ])
            ],
            ["Hdr", this.blockHeader.toEncodingData()],
            ["StateProofNext", this.stateProofNext],
            ["PrevTimestamp", this.prevTimestamp],
            ["Totals", this.totals.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded LedgerStateDelta: ${data}`);
          }
          return new _LedgerStateDelta({
            accounts: AccountDeltas.fromEncodingData(data.get("Accts")),
            kvMods: convertMap(data.get("KvMods") ?? /* @__PURE__ */ new Map(), (key, value) => [key, KvValueDelta.fromEncodingData(value)]),
            txids: convertMap(data.get("Txids"), (key, value) => [key, IncludedTransactions.fromEncodingData(value)]),
            txleases: UntypedValue.fromEncodingData(data.get("Txleases")),
            creatables: convertMap(data.get("Creatables") ?? /* @__PURE__ */ new Map(), (key, value) => [key, ModifiedCreatable.fromEncodingData(value)]),
            blockHeader: BlockHeader.fromEncodingData(data.get("Hdr")),
            stateProofNext: data.get("StateProofNext"),
            prevTimestamp: data.get("PrevTimestamp"),
            totals: AccountTotals.fromEncodingData(data.get("Totals"))
          });
        }
      };
      LedgerStateDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
        {
          key: "Accts",
          // accounts
          valueSchema: AccountDeltas.encodingSchema
        },
        {
          key: "KvMods",
          // kvMods
          valueSchema: new OptionalSchema(new SpecialCaseBinaryStringMapSchema(KvValueDelta.encodingSchema))
        },
        {
          key: "Txids",
          // txids
          valueSchema: new ByteArrayMapSchema(IncludedTransactions.encodingSchema)
        },
        {
          key: "Txleases",
          // txleases
          // Note: because txleases is currently just an UntypedSchema and we are expected to decode
          // null values for this field, we use OptionalSchema to coerce null values to undefined so
          // that the values can be properly omitted during encoding.
          valueSchema: new OptionalSchema(new UntypedSchema())
        },
        {
          key: "Creatables",
          // creatables
          valueSchema: new OptionalSchema(new Uint64MapSchema(ModifiedCreatable.encodingSchema))
        },
        {
          key: "Hdr",
          // blockHeader
          valueSchema: BlockHeader.encodingSchema
        },
        {
          key: "StateProofNext",
          // stateProofNext
          valueSchema: new Uint64Schema()
        },
        {
          key: "PrevTimestamp",
          // prevTimestamp
          valueSchema: new Uint64Schema()
        },
        {
          key: "Totals",
          // totals
          valueSchema: AccountTotals.encodingSchema
        }
      ]));
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/models/types.js
  var types_exports = {};
  __export(types_exports, {
    Account: () => Account,
    AccountApplicationResponse: () => AccountApplicationResponse,
    AccountAssetHolding: () => AccountAssetHolding,
    AccountAssetResponse: () => AccountAssetResponse,
    AccountAssetsInformationResponse: () => AccountAssetsInformationResponse,
    AccountParticipation: () => AccountParticipation,
    AccountStateDelta: () => AccountStateDelta,
    AppCallLogs: () => AppCallLogs,
    Application: () => Application,
    ApplicationInitialStates: () => ApplicationInitialStates,
    ApplicationKVStorage: () => ApplicationKVStorage,
    ApplicationLocalReference: () => ApplicationLocalReference,
    ApplicationLocalState: () => ApplicationLocalState,
    ApplicationParams: () => ApplicationParams,
    ApplicationStateOperation: () => ApplicationStateOperation,
    ApplicationStateSchema: () => ApplicationStateSchema,
    Asset: () => Asset,
    AssetHolding: () => AssetHolding2,
    AssetHoldingReference: () => AssetHoldingReference,
    AssetParams: () => AssetParams2,
    AvmKeyValue: () => AvmKeyValue,
    AvmValue: () => AvmValue,
    BlockHashResponse: () => BlockHashResponse,
    BlockLogsResponse: () => BlockLogsResponse,
    BlockResponse: () => BlockResponse,
    BlockTxidsResponse: () => BlockTxidsResponse,
    Box: () => Box,
    BoxDescriptor: () => BoxDescriptor,
    BoxReference: () => BoxReference,
    BoxesResponse: () => BoxesResponse,
    BuildVersion: () => BuildVersion,
    CompileResponse: () => CompileResponse,
    DisassembleResponse: () => DisassembleResponse,
    DryrunRequest: () => DryrunRequest,
    DryrunResponse: () => DryrunResponse,
    DryrunSource: () => DryrunSource,
    DryrunState: () => DryrunState,
    DryrunTxnResult: () => DryrunTxnResult,
    ErrorResponse: () => ErrorResponse,
    EvalDelta: () => EvalDelta2,
    EvalDeltaKeyValue: () => EvalDeltaKeyValue,
    GetBlockTimeStampOffsetResponse: () => GetBlockTimeStampOffsetResponse,
    GetSyncRoundResponse: () => GetSyncRoundResponse,
    KvDelta: () => KvDelta,
    LedgerStateDeltaForTransactionGroup: () => LedgerStateDeltaForTransactionGroup,
    LightBlockHeaderProof: () => LightBlockHeaderProof,
    NodeStatusResponse: () => NodeStatusResponse,
    PendingTransactionResponse: () => PendingTransactionResponse,
    PendingTransactionsResponse: () => PendingTransactionsResponse,
    PostTransactionsResponse: () => PostTransactionsResponse,
    ScratchChange: () => ScratchChange,
    SimulateInitialStates: () => SimulateInitialStates,
    SimulateRequest: () => SimulateRequest,
    SimulateRequestTransactionGroup: () => SimulateRequestTransactionGroup,
    SimulateResponse: () => SimulateResponse,
    SimulateTraceConfig: () => SimulateTraceConfig,
    SimulateTransactionGroupResult: () => SimulateTransactionGroupResult,
    SimulateTransactionResult: () => SimulateTransactionResult,
    SimulateUnnamedResourcesAccessed: () => SimulateUnnamedResourcesAccessed,
    SimulationEvalOverrides: () => SimulationEvalOverrides,
    SimulationOpcodeTraceUnit: () => SimulationOpcodeTraceUnit,
    SimulationTransactionExecTrace: () => SimulationTransactionExecTrace,
    StateProof: () => StateProof2,
    StateProofMessage: () => StateProofMessage2,
    SupplyResponse: () => SupplyResponse,
    TealKeyValue: () => TealKeyValue,
    TealValue: () => TealValue2,
    TransactionGroupLedgerStateDeltasForRoundResponse: () => TransactionGroupLedgerStateDeltasForRoundResponse,
    TransactionParametersResponse: () => TransactionParametersResponse,
    TransactionProofResponse: () => TransactionProofResponse,
    Version: () => Version
  });
  var Account, AccountApplicationResponse, AccountAssetHolding, AccountAssetResponse, AccountAssetsInformationResponse, AccountParticipation, AccountStateDelta, AppCallLogs, Application, ApplicationInitialStates, ApplicationKVStorage, ApplicationLocalReference, ApplicationLocalState, ApplicationParams, ApplicationStateOperation, ApplicationStateSchema, Asset, AssetHolding2, AssetHoldingReference, AssetParams2, AvmKeyValue, AvmValue, BlockHashResponse, BlockLogsResponse, BlockResponse, BlockTxidsResponse, Box, BoxDescriptor, BoxReference, BoxesResponse, BuildVersion, CompileResponse, DisassembleResponse, DryrunRequest, DryrunResponse, DryrunSource, DryrunState, DryrunTxnResult, ErrorResponse, EvalDelta2, EvalDeltaKeyValue, GetBlockTimeStampOffsetResponse, GetSyncRoundResponse, KvDelta, LedgerStateDeltaForTransactionGroup, LightBlockHeaderProof, NodeStatusResponse, PendingTransactionResponse, PendingTransactionsResponse, PostTransactionsResponse, ScratchChange, SimulateInitialStates, SimulateRequest, SimulateRequestTransactionGroup, SimulateResponse, SimulateTraceConfig, SimulateTransactionGroupResult, SimulateTransactionResult, SimulateUnnamedResourcesAccessed, SimulationEvalOverrides, SimulationOpcodeTraceUnit, SimulationTransactionExecTrace, StateProof2, StateProofMessage2, SupplyResponse, TealKeyValue, TealValue2, TransactionGroupLedgerStateDeltasForRoundResponse, TransactionParametersResponse, TransactionProofResponse, Version;
  var init_types3 = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/models/types.js"() {
      init_polyfills();
      init_utils();
      init_schema();
      init_binarydata();
      init_block();
      init_statedelta();
      init_signedTransaction();
      init_address();
      init_untypedmodel();
      Account = class _Account {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "amount-without-pending-rewards",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "min-balance",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "pending-rewards",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, { key: "rewards", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "status", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "total-apps-opted-in",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "total-assets-opted-in",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "total-created-apps",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "total-created-assets",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "apps-local-state",
              valueSchema: new OptionalSchema(new ArraySchema(ApplicationLocalState.encodingSchema)),
              omitEmpty: true
            }, {
              key: "apps-total-extra-pages",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "apps-total-schema",
              valueSchema: new OptionalSchema(ApplicationStateSchema.encodingSchema),
              omitEmpty: true
            }, {
              key: "assets",
              valueSchema: new OptionalSchema(new ArraySchema(AssetHolding2.encodingSchema)),
              omitEmpty: true
            }, {
              key: "auth-addr",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "created-apps",
              valueSchema: new OptionalSchema(new ArraySchema(Application.encodingSchema)),
              omitEmpty: true
            }, {
              key: "created-assets",
              valueSchema: new OptionalSchema(new ArraySchema(Asset.encodingSchema)),
              omitEmpty: true
            }, {
              key: "incentive-eligible",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "last-heartbeat",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "last-proposed",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "participation",
              valueSchema: new OptionalSchema(AccountParticipation.encodingSchema),
              omitEmpty: true
            }, {
              key: "reward-base",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "sig-type",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "total-box-bytes",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "total-boxes",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `Account` object.
         * @param address - the account public key
         * @param amount - (algo) total number of MicroAlgos in the account
         * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
         * @param minBalance - MicroAlgo balance required by the account.
         * The requirement grows based on asset and application usage.
         * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
         * @param rewards - (ern) total rewards of MicroAlgos the account has received, including pending
         * rewards.
         * @param round - The round for which this information is relevant.
         * @param status - (onl) delegation status of the account's MicroAlgos
         * * Offline - indicates that the associated account is delegated.
         * * Online - indicates that the associated account used as part of the delegation
         * pool.
         * * NotParticipating - indicates that the associated account is neither a
         * delegator nor a delegate.
         * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
         * of application local data (AppLocalState objects) stored in this account.
         * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
         * AssetHolding objects held by this account.
         * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
         * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
         * @param appsLocalState - (appl) applications local data stored in this account.
         * Note the raw object uses `map[int] -> AppLocalState` for this type.
         * @param appsTotalExtraPages - (teap) the sum of all extra application program pages for this account.
         * @param appsTotalSchema - (tsch) stores the sum of all of the local schemas and global schemas in this
         * account.
         * Note: the raw account uses `StateSchema` for this type.
         * @param assets - (asset) assets held by this account.
         * Note the raw object uses `map[int] -> AssetHolding` for this type.
         * @param authAddr - (spend) the address against which signing should be checked. If empty, the
         * address of the current account is used. This field can be updated in any
         * transaction by setting the RekeyTo field.
         * @param createdApps - (appp) parameters of applications created by this account including app global
         * data.
         * Note: the raw account uses `map[int] -> AppParams` for this type.
         * @param createdAssets - (apar) parameters of assets created by this account.
         * Note: the raw account uses `map[int] -> Asset` for this type.
         * @param incentiveEligible - Whether or not the account can receive block incentives if its balance is in
         * range at proposal time.
         * @param lastHeartbeat - The round in which this account last went online, or explicitly renewed their
         * online status.
         * @param lastProposed - The round in which this account last proposed the block.
         * @param participation - AccountParticipation describes the parameters used by this account in consensus
         * protocol.
         * @param rewardBase - (ebase) used as part of the rewards computation. Only applicable to accounts
         * which are participating.
         * @param sigType - Indicates what type of signature is used by this account, must be one of:
         * * sig
         * * msig
         * * lsig
         * @param totalBoxBytes - (tbxb) The total number of bytes used by this account's app's box keys and
         * values.
         * @param totalBoxes - (tbx) The number of existing boxes created by this account's app.
         */
        constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, createdApps, createdAssets, incentiveEligible, lastHeartbeat, lastProposed, participation, rewardBase, sigType, totalBoxBytes, totalBoxes }) {
          this.address = address;
          this.amount = ensureBigInt(amount);
          this.amountWithoutPendingRewards = ensureBigInt(amountWithoutPendingRewards);
          this.minBalance = ensureBigInt(minBalance);
          this.pendingRewards = ensureBigInt(pendingRewards);
          this.rewards = ensureBigInt(rewards);
          this.round = ensureBigInt(round);
          this.status = status;
          this.totalAppsOptedIn = ensureSafeInteger(totalAppsOptedIn);
          this.totalAssetsOptedIn = ensureSafeInteger(totalAssetsOptedIn);
          this.totalCreatedApps = ensureSafeInteger(totalCreatedApps);
          this.totalCreatedAssets = ensureSafeInteger(totalCreatedAssets);
          this.appsLocalState = appsLocalState;
          this.appsTotalExtraPages = typeof appsTotalExtraPages === "undefined" ? void 0 : ensureSafeInteger(appsTotalExtraPages);
          this.appsTotalSchema = appsTotalSchema;
          this.assets = assets;
          this.authAddr = typeof authAddr === "string" ? Address.fromString(authAddr) : authAddr;
          this.createdApps = createdApps;
          this.createdAssets = createdAssets;
          this.incentiveEligible = incentiveEligible;
          this.lastHeartbeat = typeof lastHeartbeat === "undefined" ? void 0 : ensureSafeInteger(lastHeartbeat);
          this.lastProposed = typeof lastProposed === "undefined" ? void 0 : ensureSafeInteger(lastProposed);
          this.participation = participation;
          this.rewardBase = typeof rewardBase === "undefined" ? void 0 : ensureBigInt(rewardBase);
          this.sigType = sigType;
          this.totalBoxBytes = typeof totalBoxBytes === "undefined" ? void 0 : ensureSafeInteger(totalBoxBytes);
          this.totalBoxes = typeof totalBoxes === "undefined" ? void 0 : ensureSafeInteger(totalBoxes);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Account.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["address", this.address],
            ["amount", this.amount],
            ["amount-without-pending-rewards", this.amountWithoutPendingRewards],
            ["min-balance", this.minBalance],
            ["pending-rewards", this.pendingRewards],
            ["rewards", this.rewards],
            ["round", this.round],
            ["status", this.status],
            ["total-apps-opted-in", this.totalAppsOptedIn],
            ["total-assets-opted-in", this.totalAssetsOptedIn],
            ["total-created-apps", this.totalCreatedApps],
            ["total-created-assets", this.totalCreatedAssets],
            [
              "apps-local-state",
              typeof this.appsLocalState !== "undefined" ? this.appsLocalState.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["apps-total-extra-pages", this.appsTotalExtraPages],
            [
              "apps-total-schema",
              typeof this.appsTotalSchema !== "undefined" ? this.appsTotalSchema.toEncodingData() : void 0
            ],
            [
              "assets",
              typeof this.assets !== "undefined" ? this.assets.map((v3) => v3.toEncodingData()) : void 0
            ],
            [
              "auth-addr",
              typeof this.authAddr !== "undefined" ? this.authAddr.toString() : void 0
            ],
            [
              "created-apps",
              typeof this.createdApps !== "undefined" ? this.createdApps.map((v3) => v3.toEncodingData()) : void 0
            ],
            [
              "created-assets",
              typeof this.createdAssets !== "undefined" ? this.createdAssets.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["incentive-eligible", this.incentiveEligible],
            ["last-heartbeat", this.lastHeartbeat],
            ["last-proposed", this.lastProposed],
            [
              "participation",
              typeof this.participation !== "undefined" ? this.participation.toEncodingData() : void 0
            ],
            ["reward-base", this.rewardBase],
            ["sig-type", this.sigType],
            ["total-box-bytes", this.totalBoxBytes],
            ["total-boxes", this.totalBoxes]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Account: ${data}`);
          }
          return new _Account({
            address: data.get("address"),
            amount: data.get("amount"),
            amountWithoutPendingRewards: data.get("amount-without-pending-rewards"),
            minBalance: data.get("min-balance"),
            pendingRewards: data.get("pending-rewards"),
            rewards: data.get("rewards"),
            round: data.get("round"),
            status: data.get("status"),
            totalAppsOptedIn: data.get("total-apps-opted-in"),
            totalAssetsOptedIn: data.get("total-assets-opted-in"),
            totalCreatedApps: data.get("total-created-apps"),
            totalCreatedAssets: data.get("total-created-assets"),
            appsLocalState: typeof data.get("apps-local-state") !== "undefined" ? data.get("apps-local-state").map((v3) => ApplicationLocalState.fromEncodingData(v3)) : void 0,
            appsTotalExtraPages: data.get("apps-total-extra-pages"),
            appsTotalSchema: typeof data.get("apps-total-schema") !== "undefined" ? ApplicationStateSchema.fromEncodingData(data.get("apps-total-schema")) : void 0,
            assets: typeof data.get("assets") !== "undefined" ? data.get("assets").map((v3) => AssetHolding2.fromEncodingData(v3)) : void 0,
            authAddr: data.get("auth-addr"),
            createdApps: typeof data.get("created-apps") !== "undefined" ? data.get("created-apps").map((v3) => Application.fromEncodingData(v3)) : void 0,
            createdAssets: typeof data.get("created-assets") !== "undefined" ? data.get("created-assets").map((v3) => Asset.fromEncodingData(v3)) : void 0,
            incentiveEligible: data.get("incentive-eligible"),
            lastHeartbeat: data.get("last-heartbeat"),
            lastProposed: data.get("last-proposed"),
            participation: typeof data.get("participation") !== "undefined" ? AccountParticipation.fromEncodingData(data.get("participation")) : void 0,
            rewardBase: data.get("reward-base"),
            sigType: data.get("sig-type"),
            totalBoxBytes: data.get("total-box-bytes"),
            totalBoxes: data.get("total-boxes")
          });
        }
      };
      AccountApplicationResponse = class _AccountApplicationResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "app-local-state",
              valueSchema: new OptionalSchema(ApplicationLocalState.encodingSchema),
              omitEmpty: true
            }, {
              key: "created-app",
              valueSchema: new OptionalSchema(ApplicationParams.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AccountApplicationResponse` object.
         * @param round - The round for which this information is relevant.
         * @param appLocalState - (appl) the application local data stored in this account.
         * The raw account uses `AppLocalState` for this type.
         * @param createdApp - (appp) parameters of the application created by this account including app
         * global data.
         * The raw account uses `AppParams` for this type.
         */
        constructor({ round, appLocalState, createdApp }) {
          this.round = ensureBigInt(round);
          this.appLocalState = appLocalState;
          this.createdApp = createdApp;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountApplicationResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["round", this.round],
            [
              "app-local-state",
              typeof this.appLocalState !== "undefined" ? this.appLocalState.toEncodingData() : void 0
            ],
            [
              "created-app",
              typeof this.createdApp !== "undefined" ? this.createdApp.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountApplicationResponse: ${data}`);
          }
          return new _AccountApplicationResponse({
            round: data.get("round"),
            appLocalState: typeof data.get("app-local-state") !== "undefined" ? ApplicationLocalState.fromEncodingData(data.get("app-local-state")) : void 0,
            createdApp: typeof data.get("created-app") !== "undefined" ? ApplicationParams.fromEncodingData(data.get("created-app")) : void 0
          });
        }
      };
      AccountAssetHolding = class _AccountAssetHolding {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "asset-holding",
              valueSchema: AssetHolding2.encodingSchema,
              omitEmpty: true
            }, {
              key: "asset-params",
              valueSchema: new OptionalSchema(AssetParams2.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AccountAssetHolding` object.
         * @param assetHolding - (asset) Details about the asset held by this account.
         * The raw account uses `AssetHolding` for this type.
         * @param assetParams - (apar) parameters of the asset held by this account.
         * The raw account uses `AssetParams` for this type.
         */
        constructor({ assetHolding, assetParams }) {
          this.assetHolding = assetHolding;
          this.assetParams = assetParams;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountAssetHolding.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["asset-holding", this.assetHolding.toEncodingData()],
            [
              "asset-params",
              typeof this.assetParams !== "undefined" ? this.assetParams.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountAssetHolding: ${data}`);
          }
          return new _AccountAssetHolding({
            assetHolding: AssetHolding2.fromEncodingData(data.get("asset-holding") ?? /* @__PURE__ */ new Map()),
            assetParams: typeof data.get("asset-params") !== "undefined" ? AssetParams2.fromEncodingData(data.get("asset-params")) : void 0
          });
        }
      };
      AccountAssetResponse = class _AccountAssetResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "asset-holding",
              valueSchema: new OptionalSchema(AssetHolding2.encodingSchema),
              omitEmpty: true
            }, {
              key: "created-asset",
              valueSchema: new OptionalSchema(AssetParams2.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AccountAssetResponse` object.
         * @param round - The round for which this information is relevant.
         * @param assetHolding - (asset) Details about the asset held by this account.
         * The raw account uses `AssetHolding` for this type.
         * @param createdAsset - (apar) parameters of the asset created by this account.
         * The raw account uses `AssetParams` for this type.
         */
        constructor({ round, assetHolding, createdAsset }) {
          this.round = ensureBigInt(round);
          this.assetHolding = assetHolding;
          this.createdAsset = createdAsset;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountAssetResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["round", this.round],
            [
              "asset-holding",
              typeof this.assetHolding !== "undefined" ? this.assetHolding.toEncodingData() : void 0
            ],
            [
              "created-asset",
              typeof this.createdAsset !== "undefined" ? this.createdAsset.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountAssetResponse: ${data}`);
          }
          return new _AccountAssetResponse({
            round: data.get("round"),
            assetHolding: typeof data.get("asset-holding") !== "undefined" ? AssetHolding2.fromEncodingData(data.get("asset-holding")) : void 0,
            createdAsset: typeof data.get("created-asset") !== "undefined" ? AssetParams2.fromEncodingData(data.get("created-asset")) : void 0
          });
        }
      };
      AccountAssetsInformationResponse = class _AccountAssetsInformationResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "asset-holdings",
              valueSchema: new OptionalSchema(new ArraySchema(AccountAssetHolding.encodingSchema)),
              omitEmpty: true
            }, {
              key: "next-token",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AccountAssetsInformationResponse` object.
         * @param round - The round for which this information is relevant.
         * @param assetHoldings -
         * @param nextToken - Used for pagination, when making another request provide this token with the
         * next parameter.
         */
        constructor({ round, assetHoldings, nextToken }) {
          this.round = ensureSafeInteger(round);
          this.assetHoldings = assetHoldings;
          this.nextToken = nextToken;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountAssetsInformationResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["round", this.round],
            [
              "asset-holdings",
              typeof this.assetHoldings !== "undefined" ? this.assetHoldings.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["next-token", this.nextToken]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountAssetsInformationResponse: ${data}`);
          }
          return new _AccountAssetsInformationResponse({
            round: data.get("round"),
            assetHoldings: typeof data.get("asset-holdings") !== "undefined" ? data.get("asset-holdings").map((v3) => AccountAssetHolding.fromEncodingData(v3)) : void 0,
            nextToken: data.get("next-token")
          });
        }
      };
      AccountParticipation = class _AccountParticipation {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "selection-participation-key",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, {
              key: "vote-first-valid",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "vote-key-dilution",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "vote-last-valid",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "vote-participation-key",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, {
              key: "state-proof-key",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AccountParticipation` object.
         * @param selectionParticipationKey - (sel) Selection public key (if any) currently registered for this round.
         * @param voteFirstValid - (voteFst) First round for which this participation is valid.
         * @param voteKeyDilution - (voteKD) Number of subkeys in each batch of participation keys.
         * @param voteLastValid - (voteLst) Last round for which this participation is valid.
         * @param voteParticipationKey - (vote) root participation public key (if any) currently registered for this
         * round.
         * @param stateProofKey - (stprf) Root of the state proof key (if any)
         */
        constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
          this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? base64ToBytes(selectionParticipationKey) : selectionParticipationKey;
          this.voteFirstValid = ensureBigInt(voteFirstValid);
          this.voteKeyDilution = ensureBigInt(voteKeyDilution);
          this.voteLastValid = ensureBigInt(voteLastValid);
          this.voteParticipationKey = typeof voteParticipationKey === "string" ? base64ToBytes(voteParticipationKey) : voteParticipationKey;
          this.stateProofKey = typeof stateProofKey === "string" ? base64ToBytes(stateProofKey) : stateProofKey;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountParticipation.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["selection-participation-key", this.selectionParticipationKey],
            ["vote-first-valid", this.voteFirstValid],
            ["vote-key-dilution", this.voteKeyDilution],
            ["vote-last-valid", this.voteLastValid],
            ["vote-participation-key", this.voteParticipationKey],
            ["state-proof-key", this.stateProofKey]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountParticipation: ${data}`);
          }
          return new _AccountParticipation({
            selectionParticipationKey: data.get("selection-participation-key"),
            voteFirstValid: data.get("vote-first-valid"),
            voteKeyDilution: data.get("vote-key-dilution"),
            voteLastValid: data.get("vote-last-valid"),
            voteParticipationKey: data.get("vote-participation-key"),
            stateProofKey: data.get("state-proof-key")
          });
        }
      };
      AccountStateDelta = class _AccountStateDelta {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "delta",
              valueSchema: new ArraySchema(EvalDeltaKeyValue.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AccountStateDelta` object.
         * @param address -
         * @param delta - Application state delta.
         */
        constructor({ address, delta }) {
          this.address = address;
          this.delta = delta;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountStateDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["address", this.address],
            ["delta", this.delta.map((v3) => v3.toEncodingData())]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountStateDelta: ${data}`);
          }
          return new _AccountStateDelta({
            address: data.get("address"),
            delta: (data.get("delta") ?? []).map((v3) => EvalDeltaKeyValue.fromEncodingData(v3))
          });
        }
      };
      AppCallLogs = class _AppCallLogs {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "application-index",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "logs",
              valueSchema: new ArraySchema(new ByteArraySchema()),
              omitEmpty: true
            }, { key: "txId", valueSchema: new StringSchema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AppCallLogs` object.
         * @param applicationIndex - The application from which the logs were generated
         * @param logs - An array of logs
         * @param txid - The transaction ID of the outer app call that lead to these logs
         */
        constructor({ applicationIndex, logs, txid }) {
          this.applicationIndex = ensureSafeInteger(applicationIndex);
          this.logs = logs;
          this.txid = txid;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AppCallLogs.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["application-index", this.applicationIndex],
            ["logs", this.logs],
            ["txId", this.txid]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AppCallLogs: ${data}`);
          }
          return new _AppCallLogs({
            applicationIndex: data.get("application-index"),
            logs: data.get("logs"),
            txid: data.get("txId")
          });
        }
      };
      Application = class _Application {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "params",
              valueSchema: ApplicationParams.encodingSchema,
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `Application` object.
         * @param id - (appidx) application index.
         * @param params - (appparams) application parameters.
         */
        constructor({ id, params }) {
          this.id = ensureBigInt(id);
          this.params = params;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Application.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["id", this.id],
            ["params", this.params.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Application: ${data}`);
          }
          return new _Application({
            id: data.get("id"),
            params: ApplicationParams.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map())
          });
        }
      };
      ApplicationInitialStates = class _ApplicationInitialStates {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "app-boxes",
              valueSchema: new OptionalSchema(ApplicationKVStorage.encodingSchema),
              omitEmpty: true
            }, {
              key: "app-globals",
              valueSchema: new OptionalSchema(ApplicationKVStorage.encodingSchema),
              omitEmpty: true
            }, {
              key: "app-locals",
              valueSchema: new OptionalSchema(new ArraySchema(ApplicationKVStorage.encodingSchema)),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationInitialStates` object.
         * @param id - Application index.
         * @param appBoxes - An application's global/local/box state.
         * @param appGlobals - An application's global/local/box state.
         * @param appLocals - An application's initial local states tied to different accounts.
         */
        constructor({ id, appBoxes, appGlobals, appLocals }) {
          this.id = ensureBigInt(id);
          this.appBoxes = appBoxes;
          this.appGlobals = appGlobals;
          this.appLocals = appLocals;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationInitialStates.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["id", this.id],
            [
              "app-boxes",
              typeof this.appBoxes !== "undefined" ? this.appBoxes.toEncodingData() : void 0
            ],
            [
              "app-globals",
              typeof this.appGlobals !== "undefined" ? this.appGlobals.toEncodingData() : void 0
            ],
            [
              "app-locals",
              typeof this.appLocals !== "undefined" ? this.appLocals.map((v3) => v3.toEncodingData()) : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationInitialStates: ${data}`);
          }
          return new _ApplicationInitialStates({
            id: data.get("id"),
            appBoxes: typeof data.get("app-boxes") !== "undefined" ? ApplicationKVStorage.fromEncodingData(data.get("app-boxes")) : void 0,
            appGlobals: typeof data.get("app-globals") !== "undefined" ? ApplicationKVStorage.fromEncodingData(data.get("app-globals")) : void 0,
            appLocals: typeof data.get("app-locals") !== "undefined" ? data.get("app-locals").map((v3) => ApplicationKVStorage.fromEncodingData(v3)) : void 0
          });
        }
      };
      ApplicationKVStorage = class _ApplicationKVStorage {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "kvs",
              valueSchema: new ArraySchema(AvmKeyValue.encodingSchema),
              omitEmpty: true
            }, {
              key: "account",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationKVStorage` object.
         * @param kvs - Key-Value pairs representing application states.
         * @param account - The address of the account associated with the local state.
         */
        constructor({ kvs, account }) {
          this.kvs = kvs;
          this.account = typeof account === "string" ? Address.fromString(account) : account;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationKVStorage.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["kvs", this.kvs.map((v3) => v3.toEncodingData())],
            [
              "account",
              typeof this.account !== "undefined" ? this.account.toString() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationKVStorage: ${data}`);
          }
          return new _ApplicationKVStorage({
            kvs: (data.get("kvs") ?? []).map((v3) => AvmKeyValue.fromEncodingData(v3)),
            account: data.get("account")
          });
        }
      };
      ApplicationLocalReference = class _ApplicationLocalReference {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "account", valueSchema: new StringSchema(), omitEmpty: true }, { key: "app", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationLocalReference` object.
         * @param account - Address of the account with the local state.
         * @param app - Application ID of the local state application.
         */
        constructor({ account, app }) {
          this.account = typeof account === "string" ? Address.fromString(account) : account;
          this.app = ensureBigInt(app);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationLocalReference.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["account", this.account.toString()],
            ["app", this.app]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationLocalReference: ${data}`);
          }
          return new _ApplicationLocalReference({
            account: data.get("account"),
            app: data.get("app")
          });
        }
      };
      ApplicationLocalState = class _ApplicationLocalState {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "schema",
              valueSchema: ApplicationStateSchema.encodingSchema,
              omitEmpty: true
            }, {
              key: "key-value",
              valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue.encodingSchema)),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationLocalState` object.
         * @param id - The application which this local state is for.
         * @param schema - (hsch) schema.
         * @param keyValue - (tkv) storage.
         */
        constructor({ id, schema, keyValue }) {
          this.id = ensureBigInt(id);
          this.schema = schema;
          this.keyValue = keyValue;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationLocalState.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["id", this.id],
            ["schema", this.schema.toEncodingData()],
            [
              "key-value",
              typeof this.keyValue !== "undefined" ? this.keyValue.map((v3) => v3.toEncodingData()) : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationLocalState: ${data}`);
          }
          return new _ApplicationLocalState({
            id: data.get("id"),
            schema: ApplicationStateSchema.fromEncodingData(data.get("schema") ?? /* @__PURE__ */ new Map()),
            keyValue: typeof data.get("key-value") !== "undefined" ? data.get("key-value").map((v3) => TealKeyValue.fromEncodingData(v3)) : void 0
          });
        }
      };
      ApplicationParams = class _ApplicationParams {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "approval-program",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, {
              key: "clear-state-program",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, { key: "creator", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "extra-program-pages",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "global-state",
              valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue.encodingSchema)),
              omitEmpty: true
            }, {
              key: "global-state-schema",
              valueSchema: new OptionalSchema(ApplicationStateSchema.encodingSchema),
              omitEmpty: true
            }, {
              key: "local-state-schema",
              valueSchema: new OptionalSchema(ApplicationStateSchema.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationParams` object.
         * @param approvalProgram - (approv) approval program.
         * @param clearStateProgram - (clearp) approval program.
         * @param creator - The address that created this application. This is the address where the
         * parameters and global state for this application can be found.
         * @param extraProgramPages - (epp) the amount of extra program pages available to this app.
         * @param globalState - (gs) global state
         * @param globalStateSchema - (gsch) global schema
         * @param localStateSchema - (lsch) local schema
         */
        constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema }) {
          this.approvalProgram = typeof approvalProgram === "string" ? base64ToBytes(approvalProgram) : approvalProgram;
          this.clearStateProgram = typeof clearStateProgram === "string" ? base64ToBytes(clearStateProgram) : clearStateProgram;
          this.creator = typeof creator === "string" ? Address.fromString(creator) : creator;
          this.extraProgramPages = typeof extraProgramPages === "undefined" ? void 0 : ensureSafeInteger(extraProgramPages);
          this.globalState = globalState;
          this.globalStateSchema = globalStateSchema;
          this.localStateSchema = localStateSchema;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationParams.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["approval-program", this.approvalProgram],
            ["clear-state-program", this.clearStateProgram],
            ["creator", this.creator.toString()],
            ["extra-program-pages", this.extraProgramPages],
            [
              "global-state",
              typeof this.globalState !== "undefined" ? this.globalState.map((v3) => v3.toEncodingData()) : void 0
            ],
            [
              "global-state-schema",
              typeof this.globalStateSchema !== "undefined" ? this.globalStateSchema.toEncodingData() : void 0
            ],
            [
              "local-state-schema",
              typeof this.localStateSchema !== "undefined" ? this.localStateSchema.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationParams: ${data}`);
          }
          return new _ApplicationParams({
            approvalProgram: data.get("approval-program"),
            clearStateProgram: data.get("clear-state-program"),
            creator: data.get("creator"),
            extraProgramPages: data.get("extra-program-pages"),
            globalState: typeof data.get("global-state") !== "undefined" ? data.get("global-state").map((v3) => TealKeyValue.fromEncodingData(v3)) : void 0,
            globalStateSchema: typeof data.get("global-state-schema") !== "undefined" ? ApplicationStateSchema.fromEncodingData(data.get("global-state-schema")) : void 0,
            localStateSchema: typeof data.get("local-state-schema") !== "undefined" ? ApplicationStateSchema.fromEncodingData(data.get("local-state-schema")) : void 0
          });
        }
      };
      ApplicationStateOperation = class _ApplicationStateOperation {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "app-state-type",
              valueSchema: new StringSchema(),
              omitEmpty: true
            }, { key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "operation", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "account",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "new-value",
              valueSchema: new OptionalSchema(AvmValue.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationStateOperation` object.
         * @param appStateType - Type of application state. Value `g` is **global state**, `l` is **local
         * state**, `b` is **boxes**.
         * @param key - The key (name) of the global/local/box state.
         * @param operation - Operation type. Value `w` is **write**, `d` is **delete**.
         * @param account - For local state changes, the address of the account associated with the local
         * state.
         * @param newValue - Represents an AVM value.
         */
        constructor({ appStateType, key, operation, account, newValue }) {
          this.appStateType = appStateType;
          this.key = typeof key === "string" ? base64ToBytes(key) : key;
          this.operation = operation;
          this.account = typeof account === "string" ? Address.fromString(account) : account;
          this.newValue = newValue;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationStateOperation.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["app-state-type", this.appStateType],
            ["key", this.key],
            ["operation", this.operation],
            [
              "account",
              typeof this.account !== "undefined" ? this.account.toString() : void 0
            ],
            [
              "new-value",
              typeof this.newValue !== "undefined" ? this.newValue.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationStateOperation: ${data}`);
          }
          return new _ApplicationStateOperation({
            appStateType: data.get("app-state-type"),
            key: data.get("key"),
            operation: data.get("operation"),
            account: data.get("account"),
            newValue: typeof data.get("new-value") !== "undefined" ? AvmValue.fromEncodingData(data.get("new-value")) : void 0
          });
        }
      };
      ApplicationStateSchema = class _ApplicationStateSchema {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "num-byte-slice",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, { key: "num-uint", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationStateSchema` object.
         * @param numByteSlice - (nbs) num of byte slices.
         * @param numUint - (nui) num of uints.
         */
        constructor({ numByteSlice, numUint }) {
          this.numByteSlice = ensureSafeInteger(numByteSlice);
          this.numUint = ensureSafeInteger(numUint);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationStateSchema.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["num-byte-slice", this.numByteSlice],
            ["num-uint", this.numUint]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationStateSchema: ${data}`);
          }
          return new _ApplicationStateSchema({
            numByteSlice: data.get("num-byte-slice"),
            numUint: data.get("num-uint")
          });
        }
      };
      Asset = class _Asset {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "index", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "params",
              valueSchema: AssetParams2.encodingSchema,
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `Asset` object.
         * @param index - unique asset identifier
         * @param params - AssetParams specifies the parameters for an asset.
         * (apar) when part of an AssetConfig transaction.
         * Definition:
         * data/transactions/asset.go : AssetParams
         */
        constructor({ index, params }) {
          this.index = ensureBigInt(index);
          this.params = params;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Asset.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["index", this.index],
            ["params", this.params.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Asset: ${data}`);
          }
          return new _Asset({
            index: data.get("index"),
            params: AssetParams2.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map())
          });
        }
      };
      AssetHolding2 = class _AssetHolding {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "is-frozen", valueSchema: new BooleanSchema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AssetHolding` object.
         * @param amount - (a) number of units held.
         * @param assetId - Asset ID of the holding.
         * @param isFrozen - (f) whether or not the holding is frozen.
         */
        constructor({ amount, assetId, isFrozen }) {
          this.amount = ensureBigInt(amount);
          this.assetId = ensureBigInt(assetId);
          this.isFrozen = isFrozen;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetHolding.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["amount", this.amount],
            ["asset-id", this.assetId],
            ["is-frozen", this.isFrozen]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetHolding: ${data}`);
          }
          return new _AssetHolding({
            amount: data.get("amount"),
            assetId: data.get("asset-id"),
            isFrozen: data.get("is-frozen")
          });
        }
      };
      AssetHoldingReference = class _AssetHoldingReference {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "account", valueSchema: new StringSchema(), omitEmpty: true }, { key: "asset", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AssetHoldingReference` object.
         * @param account - Address of the account holding the asset.
         * @param asset - Asset ID of the holding.
         */
        constructor({ account, asset }) {
          this.account = typeof account === "string" ? Address.fromString(account) : account;
          this.asset = ensureBigInt(asset);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetHoldingReference.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["account", this.account.toString()],
            ["asset", this.asset]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetHoldingReference: ${data}`);
          }
          return new _AssetHoldingReference({
            account: data.get("account"),
            asset: data.get("asset")
          });
        }
      };
      AssetParams2 = class _AssetParams {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "creator", valueSchema: new StringSchema(), omitEmpty: true }, { key: "decimals", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "total", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "clawback",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "default-frozen",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "freeze",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "manager",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "metadata-hash",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "name",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "name-b64",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "reserve",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "unit-name",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "unit-name-b64",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "url",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "url-b64",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AssetParams` object.
         * @param creator - The address that created this asset. This is the address where the parameters
         * for this asset can be found, and also the address where unwanted asset units can
         * be sent in the worst case.
         * @param decimals - (dc) The number of digits to use after the decimal point when displaying this
         * asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in
         * tenths. If 2, the base unit of the asset is in hundredths, and so on. This value
         * must be between 0 and 19 (inclusive).
         * @param total - (t) The total number of units of this asset.
         * @param clawback - (c) Address of account used to clawback holdings of this asset. If empty,
         * clawback is not permitted.
         * @param defaultFrozen - (df) Whether holdings of this asset are frozen by default.
         * @param freeze - (f) Address of account used to freeze holdings of this asset. If empty, freezing
         * is not permitted.
         * @param manager - (m) Address of account used to manage the keys of this asset and to destroy it.
         * @param metadataHash - (am) A commitment to some unspecified asset metadata. The format of this
         * metadata is up to the application.
         * @param name - (an) Name of this asset, as supplied by the creator. Included only when the
         * asset name is composed of printable utf-8 characters.
         * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
         * @param reserve - (r) Address of account holding reserve (non-minted) units of this asset.
         * @param unitName - (un) Name of a unit of this asset, as supplied by the creator. Included only
         * when the name of a unit of this asset is composed of printable utf-8 characters.
         * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
         * @param url - (au) URL where more information about the asset can be retrieved. Included only
         * when the URL is composed of printable utf-8 characters.
         * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
         */
        constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
          this.creator = creator;
          this.decimals = ensureSafeInteger(decimals);
          this.total = ensureBigInt(total);
          this.clawback = clawback;
          this.defaultFrozen = defaultFrozen;
          this.freeze = freeze;
          this.manager = manager;
          this.metadataHash = typeof metadataHash === "string" ? base64ToBytes(metadataHash) : metadataHash;
          this.name = name;
          this.nameB64 = typeof nameB64 === "string" ? base64ToBytes(nameB64) : nameB64;
          this.reserve = reserve;
          this.unitName = unitName;
          this.unitNameB64 = typeof unitNameB64 === "string" ? base64ToBytes(unitNameB64) : unitNameB64;
          this.url = url;
          this.urlB64 = typeof urlB64 === "string" ? base64ToBytes(urlB64) : urlB64;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetParams.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["creator", this.creator],
            ["decimals", this.decimals],
            ["total", this.total],
            ["clawback", this.clawback],
            ["default-frozen", this.defaultFrozen],
            ["freeze", this.freeze],
            ["manager", this.manager],
            ["metadata-hash", this.metadataHash],
            ["name", this.name],
            ["name-b64", this.nameB64],
            ["reserve", this.reserve],
            ["unit-name", this.unitName],
            ["unit-name-b64", this.unitNameB64],
            ["url", this.url],
            ["url-b64", this.urlB64]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetParams: ${data}`);
          }
          return new _AssetParams({
            creator: data.get("creator"),
            decimals: data.get("decimals"),
            total: data.get("total"),
            clawback: data.get("clawback"),
            defaultFrozen: data.get("default-frozen"),
            freeze: data.get("freeze"),
            manager: data.get("manager"),
            metadataHash: data.get("metadata-hash"),
            name: data.get("name"),
            nameB64: data.get("name-b64"),
            reserve: data.get("reserve"),
            unitName: data.get("unit-name"),
            unitNameB64: data.get("unit-name-b64"),
            url: data.get("url"),
            urlB64: data.get("url-b64")
          });
        }
      };
      AvmKeyValue = class _AvmKeyValue {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "value", valueSchema: AvmValue.encodingSchema, omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AvmKeyValue` object.
         * @param key -
         * @param value - Represents an AVM value.
         */
        constructor({ key, value }) {
          this.key = typeof key === "string" ? base64ToBytes(key) : key;
          this.value = value;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AvmKeyValue.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["key", this.key],
            ["value", this.value.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AvmKeyValue: ${data}`);
          }
          return new _AvmKeyValue({
            key: data.get("key"),
            value: AvmValue.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
          });
        }
      };
      AvmValue = class _AvmValue {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "type", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "bytes",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "uint",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AvmValue` object.
         * @param type - value type. Value `1` refers to **bytes**, value `2` refers to **uint64**
         * @param bytes - bytes value.
         * @param uint - uint value.
         */
        constructor({ type, bytes, uint }) {
          this.type = ensureSafeInteger(type);
          this.bytes = typeof bytes === "string" ? base64ToBytes(bytes) : bytes;
          this.uint = typeof uint === "undefined" ? void 0 : ensureBigInt(uint);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AvmValue.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["type", this.type],
            ["bytes", this.bytes],
            ["uint", this.uint]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AvmValue: ${data}`);
          }
          return new _AvmValue({
            type: data.get("type"),
            bytes: data.get("bytes"),
            uint: data.get("uint")
          });
        }
      };
      BlockHashResponse = class _BlockHashResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "blockHash",
              valueSchema: new StringSchema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BlockHashResponse` object.
         * @param blockhash - Block header hash.
         */
        constructor({ blockhash }) {
          this.blockhash = blockhash;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BlockHashResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([["blockHash", this.blockhash]]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockHashResponse: ${data}`);
          }
          return new _BlockHashResponse({
            blockhash: data.get("blockHash")
          });
        }
      };
      BlockLogsResponse = class _BlockLogsResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "logs",
              valueSchema: new ArraySchema(AppCallLogs.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BlockLogsResponse` object.
         * @param logs -
         */
        constructor({ logs }) {
          this.logs = logs;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BlockLogsResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["logs", this.logs.map((v3) => v3.toEncodingData())]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockLogsResponse: ${data}`);
          }
          return new _BlockLogsResponse({
            logs: (data.get("logs") ?? []).map((v3) => AppCallLogs.fromEncodingData(v3))
          });
        }
      };
      BlockResponse = class _BlockResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "block", valueSchema: Block.encodingSchema, omitEmpty: true }, {
              key: "cert",
              valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BlockResponse` object.
         * @param block - Block header data.
         * @param cert - Optional certificate object. This is only included when the format is set to
         * message pack.
         */
        constructor({ block, cert }) {
          this.block = block;
          this.cert = cert;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BlockResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["block", this.block.toEncodingData()],
            [
              "cert",
              typeof this.cert !== "undefined" ? this.cert.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockResponse: ${data}`);
          }
          return new _BlockResponse({
            block: Block.fromEncodingData(data.get("block") ?? /* @__PURE__ */ new Map()),
            cert: typeof data.get("cert") !== "undefined" ? UntypedValue.fromEncodingData(data.get("cert")) : void 0
          });
        }
      };
      BlockTxidsResponse = class _BlockTxidsResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "blockTxids",
              valueSchema: new ArraySchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BlockTxidsResponse` object.
         * @param blocktxids - Block transaction IDs.
         */
        constructor({ blocktxids }) {
          this.blocktxids = blocktxids;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BlockTxidsResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([["blockTxids", this.blocktxids]]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockTxidsResponse: ${data}`);
          }
          return new _BlockTxidsResponse({
            blocktxids: data.get("blockTxids")
          });
        }
      };
      Box = class _Box {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "name", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "value", valueSchema: new ByteArraySchema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `Box` object.
         * @param name - (name) box name, base64 encoded
         * @param round - The round for which this information is relevant
         * @param value - (value) box value, base64 encoded.
         */
        constructor({ name, round, value }) {
          this.name = typeof name === "string" ? base64ToBytes(name) : name;
          this.round = ensureBigInt(round);
          this.value = typeof value === "string" ? base64ToBytes(value) : value;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Box.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["name", this.name],
            ["round", this.round],
            ["value", this.value]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Box: ${data}`);
          }
          return new _Box({
            name: data.get("name"),
            round: data.get("round"),
            value: data.get("value")
          });
        }
      };
      BoxDescriptor = class _BoxDescriptor {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "name",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BoxDescriptor` object.
         * @param name - Base64 encoded box name
         */
        constructor({ name }) {
          this.name = typeof name === "string" ? base64ToBytes(name) : name;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BoxDescriptor.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([["name", this.name]]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BoxDescriptor: ${data}`);
          }
          return new _BoxDescriptor({
            name: data.get("name")
          });
        }
      };
      BoxReference = class _BoxReference {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "app", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "name", valueSchema: new ByteArraySchema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BoxReference` object.
         * @param app - Application ID which this box belongs to
         * @param name - Base64 encoded box name
         */
        constructor({ app, name }) {
          this.app = ensureBigInt(app);
          this.name = typeof name === "string" ? base64ToBytes(name) : name;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BoxReference.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["app", this.app],
            ["name", this.name]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BoxReference: ${data}`);
          }
          return new _BoxReference({
            app: data.get("app"),
            name: data.get("name")
          });
        }
      };
      BoxesResponse = class _BoxesResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "boxes",
              valueSchema: new ArraySchema(BoxDescriptor.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BoxesResponse` object.
         * @param boxes -
         */
        constructor({ boxes }) {
          this.boxes = boxes;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BoxesResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["boxes", this.boxes.map((v3) => v3.toEncodingData())]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BoxesResponse: ${data}`);
          }
          return new _BoxesResponse({
            boxes: (data.get("boxes") ?? []).map((v3) => BoxDescriptor.fromEncodingData(v3))
          });
        }
      };
      BuildVersion = class _BuildVersion {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "branch", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "build_number",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, { key: "channel", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "commit_hash",
              valueSchema: new StringSchema(),
              omitEmpty: true
            }, { key: "major", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "minor", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BuildVersion` object.
         * @param branch -
         * @param buildNumber -
         * @param channel -
         * @param commitHash -
         * @param major -
         * @param minor -
         */
        constructor({ branch, buildNumber, channel, commitHash, major, minor }) {
          this.branch = branch;
          this.buildNumber = ensureSafeInteger(buildNumber);
          this.channel = channel;
          this.commitHash = commitHash;
          this.major = ensureSafeInteger(major);
          this.minor = ensureSafeInteger(minor);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BuildVersion.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["branch", this.branch],
            ["build_number", this.buildNumber],
            ["channel", this.channel],
            ["commit_hash", this.commitHash],
            ["major", this.major],
            ["minor", this.minor]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BuildVersion: ${data}`);
          }
          return new _BuildVersion({
            branch: data.get("branch"),
            buildNumber: data.get("build_number"),
            channel: data.get("channel"),
            commitHash: data.get("commit_hash"),
            major: data.get("major"),
            minor: data.get("minor")
          });
        }
      };
      CompileResponse = class _CompileResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "hash", valueSchema: new StringSchema(), omitEmpty: true }, { key: "result", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "sourcemap",
              valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `CompileResponse` object.
         * @param hash - base32 SHA512_256 of program bytes (Address style)
         * @param result - base64 encoded program bytes
         * @param sourcemap - JSON of the source map
         */
        constructor({ hash, result, sourcemap }) {
          this.hash = hash;
          this.result = result;
          this.sourcemap = sourcemap;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _CompileResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["hash", this.hash],
            ["result", this.result],
            [
              "sourcemap",
              typeof this.sourcemap !== "undefined" ? this.sourcemap.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded CompileResponse: ${data}`);
          }
          return new _CompileResponse({
            hash: data.get("hash"),
            result: data.get("result"),
            sourcemap: typeof data.get("sourcemap") !== "undefined" ? UntypedValue.fromEncodingData(data.get("sourcemap")) : void 0
          });
        }
      };
      DisassembleResponse = class _DisassembleResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "result",
              valueSchema: new StringSchema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `DisassembleResponse` object.
         * @param result - disassembled Teal code
         */
        constructor({ result }) {
          this.result = result;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _DisassembleResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([["result", this.result]]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DisassembleResponse: ${data}`);
          }
          return new _DisassembleResponse({
            result: data.get("result")
          });
        }
      };
      DryrunRequest = class _DryrunRequest {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "accounts",
              valueSchema: new ArraySchema(Account.encodingSchema),
              omitEmpty: true
            }, {
              key: "apps",
              valueSchema: new ArraySchema(Application.encodingSchema),
              omitEmpty: true
            }, {
              key: "latest-timestamp",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "protocol-version",
              valueSchema: new StringSchema(),
              omitEmpty: true
            }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "sources",
              valueSchema: new ArraySchema(DryrunSource.encodingSchema),
              omitEmpty: true
            }, {
              key: "txns",
              valueSchema: new ArraySchema(SignedTransaction.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `DryrunRequest` object.
         * @param accounts -
         * @param apps -
         * @param latestTimestamp - LatestTimestamp is available to some TEAL scripts. Defaults to the latest
         * confirmed timestamp this algod is attached to.
         * @param protocolVersion - ProtocolVersion specifies a specific version string to operate under, otherwise
         * whatever the current protocol of the network this algod is running in.
         * @param round - Round is available to some TEAL scripts. Defaults to the current round on the
         * network this algod is attached to.
         * @param sources -
         * @param txns -
         */
        constructor({ accounts, apps, latestTimestamp, protocolVersion, round, sources, txns }) {
          this.accounts = accounts;
          this.apps = apps;
          this.latestTimestamp = ensureSafeInteger(latestTimestamp);
          this.protocolVersion = protocolVersion;
          this.round = ensureBigInt(round);
          this.sources = sources;
          this.txns = txns;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _DryrunRequest.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["accounts", this.accounts.map((v3) => v3.toEncodingData())],
            ["apps", this.apps.map((v3) => v3.toEncodingData())],
            ["latest-timestamp", this.latestTimestamp],
            ["protocol-version", this.protocolVersion],
            ["round", this.round],
            ["sources", this.sources.map((v3) => v3.toEncodingData())],
            ["txns", this.txns.map((v3) => v3.toEncodingData())]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DryrunRequest: ${data}`);
          }
          return new _DryrunRequest({
            accounts: (data.get("accounts") ?? []).map((v3) => Account.fromEncodingData(v3)),
            apps: (data.get("apps") ?? []).map((v3) => Application.fromEncodingData(v3)),
            latestTimestamp: data.get("latest-timestamp"),
            protocolVersion: data.get("protocol-version"),
            round: data.get("round"),
            sources: (data.get("sources") ?? []).map((v3) => DryrunSource.fromEncodingData(v3)),
            txns: (data.get("txns") ?? []).map((v3) => SignedTransaction.fromEncodingData(v3))
          });
        }
      };
      DryrunResponse = class _DryrunResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "error", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "protocol-version",
              valueSchema: new StringSchema(),
              omitEmpty: true
            }, {
              key: "txns",
              valueSchema: new ArraySchema(DryrunTxnResult.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `DryrunResponse` object.
         * @param error -
         * @param protocolVersion - Protocol version is the protocol version Dryrun was operated under.
         * @param txns -
         */
        constructor({ error, protocolVersion, txns }) {
          this.error = error;
          this.protocolVersion = protocolVersion;
          this.txns = txns;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _DryrunResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["error", this.error],
            ["protocol-version", this.protocolVersion],
            ["txns", this.txns.map((v3) => v3.toEncodingData())]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DryrunResponse: ${data}`);
          }
          return new _DryrunResponse({
            error: data.get("error"),
            protocolVersion: data.get("protocol-version"),
            txns: (data.get("txns") ?? []).map((v3) => DryrunTxnResult.fromEncodingData(v3))
          });
        }
      };
      DryrunSource = class _DryrunSource {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "app-index", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "field-name", valueSchema: new StringSchema(), omitEmpty: true }, { key: "source", valueSchema: new StringSchema(), omitEmpty: true }, { key: "txn-index", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `DryrunSource` object.
         * @param appIndex -
         * @param fieldName - FieldName is what kind of sources this is. If lsig then it goes into the
         * transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the
         * Approval Program or Clear State Program of application[this.AppIndex].
         * @param source -
         * @param txnIndex -
         */
        constructor({ appIndex, fieldName, source, txnIndex }) {
          this.appIndex = ensureBigInt(appIndex);
          this.fieldName = fieldName;
          this.source = source;
          this.txnIndex = ensureSafeInteger(txnIndex);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _DryrunSource.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["app-index", this.appIndex],
            ["field-name", this.fieldName],
            ["source", this.source],
            ["txn-index", this.txnIndex]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DryrunSource: ${data}`);
          }
          return new _DryrunSource({
            appIndex: data.get("app-index"),
            fieldName: data.get("field-name"),
            source: data.get("source"),
            txnIndex: data.get("txn-index")
          });
        }
      };
      DryrunState = class _DryrunState {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "line", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "pc", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "stack",
              valueSchema: new ArraySchema(TealValue2.encodingSchema),
              omitEmpty: true
            }, {
              key: "error",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "scratch",
              valueSchema: new OptionalSchema(new ArraySchema(TealValue2.encodingSchema)),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `DryrunState` object.
         * @param line - Line number
         * @param pc - Program counter
         * @param stack -
         * @param error - Evaluation error if any
         * @param scratch -
         */
        constructor({ line, pc, stack, error, scratch }) {
          this.line = ensureSafeInteger(line);
          this.pc = ensureSafeInteger(pc);
          this.stack = stack;
          this.error = error;
          this.scratch = scratch;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _DryrunState.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["line", this.line],
            ["pc", this.pc],
            ["stack", this.stack.map((v3) => v3.toEncodingData())],
            ["error", this.error],
            [
              "scratch",
              typeof this.scratch !== "undefined" ? this.scratch.map((v3) => v3.toEncodingData()) : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DryrunState: ${data}`);
          }
          return new _DryrunState({
            line: data.get("line"),
            pc: data.get("pc"),
            stack: (data.get("stack") ?? []).map((v3) => TealValue2.fromEncodingData(v3)),
            error: data.get("error"),
            scratch: typeof data.get("scratch") !== "undefined" ? data.get("scratch").map((v3) => TealValue2.fromEncodingData(v3)) : void 0
          });
        }
      };
      DryrunTxnResult = class _DryrunTxnResult {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "disassembly",
              valueSchema: new ArraySchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "app-call-messages",
              valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
              omitEmpty: true
            }, {
              key: "app-call-trace",
              valueSchema: new OptionalSchema(new ArraySchema(DryrunState.encodingSchema)),
              omitEmpty: true
            }, {
              key: "budget-added",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "budget-consumed",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "global-delta",
              valueSchema: new OptionalSchema(new ArraySchema(EvalDeltaKeyValue.encodingSchema)),
              omitEmpty: true
            }, {
              key: "local-deltas",
              valueSchema: new OptionalSchema(new ArraySchema(AccountStateDelta.encodingSchema)),
              omitEmpty: true
            }, {
              key: "logic-sig-disassembly",
              valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
              omitEmpty: true
            }, {
              key: "logic-sig-messages",
              valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
              omitEmpty: true
            }, {
              key: "logic-sig-trace",
              valueSchema: new OptionalSchema(new ArraySchema(DryrunState.encodingSchema)),
              omitEmpty: true
            }, {
              key: "logs",
              valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `DryrunTxnResult` object.
         * @param disassembly - Disassembled program line by line.
         * @param appCallMessages -
         * @param appCallTrace -
         * @param budgetAdded - Budget added during execution of app call transaction.
         * @param budgetConsumed - Budget consumed during execution of app call transaction.
         * @param globalDelta - Application state delta.
         * @param localDeltas -
         * @param logicSigDisassembly - Disassembled lsig program line by line.
         * @param logicSigMessages -
         * @param logicSigTrace -
         * @param logs -
         */
        constructor({ disassembly, appCallMessages, appCallTrace, budgetAdded, budgetConsumed, globalDelta, localDeltas, logicSigDisassembly, logicSigMessages, logicSigTrace, logs }) {
          this.disassembly = disassembly;
          this.appCallMessages = appCallMessages;
          this.appCallTrace = appCallTrace;
          this.budgetAdded = typeof budgetAdded === "undefined" ? void 0 : ensureSafeInteger(budgetAdded);
          this.budgetConsumed = typeof budgetConsumed === "undefined" ? void 0 : ensureSafeInteger(budgetConsumed);
          this.globalDelta = globalDelta;
          this.localDeltas = localDeltas;
          this.logicSigDisassembly = logicSigDisassembly;
          this.logicSigMessages = logicSigMessages;
          this.logicSigTrace = logicSigTrace;
          this.logs = logs;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _DryrunTxnResult.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["disassembly", this.disassembly],
            ["app-call-messages", this.appCallMessages],
            [
              "app-call-trace",
              typeof this.appCallTrace !== "undefined" ? this.appCallTrace.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["budget-added", this.budgetAdded],
            ["budget-consumed", this.budgetConsumed],
            [
              "global-delta",
              typeof this.globalDelta !== "undefined" ? this.globalDelta.map((v3) => v3.toEncodingData()) : void 0
            ],
            [
              "local-deltas",
              typeof this.localDeltas !== "undefined" ? this.localDeltas.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["logic-sig-disassembly", this.logicSigDisassembly],
            ["logic-sig-messages", this.logicSigMessages],
            [
              "logic-sig-trace",
              typeof this.logicSigTrace !== "undefined" ? this.logicSigTrace.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["logs", this.logs]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded DryrunTxnResult: ${data}`);
          }
          return new _DryrunTxnResult({
            disassembly: data.get("disassembly"),
            appCallMessages: data.get("app-call-messages"),
            appCallTrace: typeof data.get("app-call-trace") !== "undefined" ? data.get("app-call-trace").map((v3) => DryrunState.fromEncodingData(v3)) : void 0,
            budgetAdded: data.get("budget-added"),
            budgetConsumed: data.get("budget-consumed"),
            globalDelta: typeof data.get("global-delta") !== "undefined" ? data.get("global-delta").map((v3) => EvalDeltaKeyValue.fromEncodingData(v3)) : void 0,
            localDeltas: typeof data.get("local-deltas") !== "undefined" ? data.get("local-deltas").map((v3) => AccountStateDelta.fromEncodingData(v3)) : void 0,
            logicSigDisassembly: data.get("logic-sig-disassembly"),
            logicSigMessages: data.get("logic-sig-messages"),
            logicSigTrace: typeof data.get("logic-sig-trace") !== "undefined" ? data.get("logic-sig-trace").map((v3) => DryrunState.fromEncodingData(v3)) : void 0,
            logs: data.get("logs")
          });
        }
      };
      ErrorResponse = class _ErrorResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "message", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "data",
              valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ErrorResponse` object.
         * @param message -
         * @param data -
         */
        constructor({ message, data }) {
          this.message = message;
          this.data = data;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ErrorResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["message", this.message],
            [
              "data",
              typeof this.data !== "undefined" ? this.data.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ErrorResponse: ${data}`);
          }
          return new _ErrorResponse({
            message: data.get("message"),
            data: typeof data.get("data") !== "undefined" ? UntypedValue.fromEncodingData(data.get("data")) : void 0
          });
        }
      };
      EvalDelta2 = class _EvalDelta {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "action", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "bytes",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "uint",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `EvalDelta` object.
         * @param action - (at) delta action.
         * @param bytes - (bs) bytes value.
         * @param uint - (ui) uint value.
         */
        constructor({ action, bytes, uint }) {
          this.action = ensureSafeInteger(action);
          this.bytes = bytes;
          this.uint = typeof uint === "undefined" ? void 0 : ensureBigInt(uint);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _EvalDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["action", this.action],
            ["bytes", this.bytes],
            ["uint", this.uint]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded EvalDelta: ${data}`);
          }
          return new _EvalDelta({
            action: data.get("action"),
            bytes: data.get("bytes"),
            uint: data.get("uint")
          });
        }
      };
      EvalDeltaKeyValue = class _EvalDeltaKeyValue {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new StringSchema(), omitEmpty: true }, { key: "value", valueSchema: EvalDelta2.encodingSchema, omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `EvalDeltaKeyValue` object.
         * @param key -
         * @param value - Represents a TEAL value delta.
         */
        constructor({ key, value }) {
          this.key = key;
          this.value = value;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _EvalDeltaKeyValue.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["key", this.key],
            ["value", this.value.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded EvalDeltaKeyValue: ${data}`);
          }
          return new _EvalDeltaKeyValue({
            key: data.get("key"),
            value: EvalDelta2.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
          });
        }
      };
      GetBlockTimeStampOffsetResponse = class _GetBlockTimeStampOffsetResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "offset",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `GetBlockTimeStampOffsetResponse` object.
         * @param offset - Timestamp offset in seconds.
         */
        constructor({ offset }) {
          this.offset = ensureSafeInteger(offset);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _GetBlockTimeStampOffsetResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([["offset", this.offset]]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded GetBlockTimeStampOffsetResponse: ${data}`);
          }
          return new _GetBlockTimeStampOffsetResponse({
            offset: data.get("offset")
          });
        }
      };
      GetSyncRoundResponse = class _GetSyncRoundResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `GetSyncRoundResponse` object.
         * @param round - The minimum sync round for the ledger.
         */
        constructor({ round }) {
          this.round = ensureBigInt(round);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _GetSyncRoundResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([["round", this.round]]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded GetSyncRoundResponse: ${data}`);
          }
          return new _GetSyncRoundResponse({
            round: data.get("round")
          });
        }
      };
      KvDelta = class _KvDelta {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "key",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "value",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `KvDelta` object.
         * @param key - The key, base64 encoded.
         * @param value - The new value of the KV store entry, base64 encoded.
         */
        constructor({ key, value }) {
          this.key = typeof key === "string" ? base64ToBytes(key) : key;
          this.value = typeof value === "string" ? base64ToBytes(value) : value;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _KvDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["key", this.key],
            ["value", this.value]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded KvDelta: ${data}`);
          }
          return new _KvDelta({
            key: data.get("key"),
            value: data.get("value")
          });
        }
      };
      LedgerStateDeltaForTransactionGroup = class _LedgerStateDeltaForTransactionGroup {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "Delta",
              valueSchema: LedgerStateDelta.encodingSchema,
              omitEmpty: true
            }, {
              key: "Ids",
              valueSchema: new ArraySchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `LedgerStateDeltaForTransactionGroup` object.
         * @param delta - Ledger StateDelta object
         * @param ids -
         */
        constructor({ delta, ids }) {
          this.delta = delta;
          this.ids = ids;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _LedgerStateDeltaForTransactionGroup.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Delta", this.delta.toEncodingData()],
            ["Ids", this.ids]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded LedgerStateDeltaForTransactionGroup: ${data}`);
          }
          return new _LedgerStateDeltaForTransactionGroup({
            delta: LedgerStateDelta.fromEncodingData(data.get("Delta") ?? /* @__PURE__ */ new Map()),
            ids: data.get("Ids")
          });
        }
      };
      LightBlockHeaderProof = class _LightBlockHeaderProof {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "index", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "proof", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "treedepth", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `LightBlockHeaderProof` object.
         * @param index - The index of the light block header in the vector commitment tree
         * @param proof - The encoded proof.
         * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
         * from a leaf to the root.
         */
        constructor({ index, proof, treedepth }) {
          this.index = ensureSafeInteger(index);
          this.proof = typeof proof === "string" ? base64ToBytes(proof) : proof;
          this.treedepth = ensureSafeInteger(treedepth);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _LightBlockHeaderProof.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["index", this.index],
            ["proof", this.proof],
            ["treedepth", this.treedepth]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded LightBlockHeaderProof: ${data}`);
          }
          return new _LightBlockHeaderProof({
            index: data.get("index"),
            proof: data.get("proof"),
            treedepth: data.get("treedepth")
          });
        }
      };
      NodeStatusResponse = class _NodeStatusResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "catchup-time",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, { key: "last-round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "last-version",
              valueSchema: new StringSchema(),
              omitEmpty: true
            }, {
              key: "next-version",
              valueSchema: new StringSchema(),
              omitEmpty: true
            }, {
              key: "next-version-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "next-version-supported",
              valueSchema: new BooleanSchema(),
              omitEmpty: true
            }, {
              key: "stopped-at-unsupported-round",
              valueSchema: new BooleanSchema(),
              omitEmpty: true
            }, {
              key: "time-since-last-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "catchpoint",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "catchpoint-acquired-blocks",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "catchpoint-processed-accounts",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "catchpoint-processed-kvs",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "catchpoint-total-accounts",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "catchpoint-total-blocks",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "catchpoint-total-kvs",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "catchpoint-verified-accounts",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "catchpoint-verified-kvs",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "last-catchpoint",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "upgrade-delay",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "upgrade-next-protocol-vote-before",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "upgrade-no-votes",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "upgrade-node-vote",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "upgrade-vote-rounds",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "upgrade-votes",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "upgrade-votes-required",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "upgrade-yes-votes",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `NodeStatusResponse` object.
         * @param catchupTime - CatchupTime in nanoseconds
         * @param lastRound - LastRound indicates the last round seen
         * @param lastVersion - LastVersion indicates the last consensus version supported
         * @param nextVersion - NextVersion of consensus protocol to use
         * @param nextVersionRound - NextVersionRound is the round at which the next consensus version will apply
         * @param nextVersionSupported - NextVersionSupported indicates whether the next consensus version is supported
         * by this node
         * @param stoppedAtUnsupportedRound - StoppedAtUnsupportedRound indicates that the node does not support the new
         * rounds and has stopped making progress
         * @param timeSinceLastRound - TimeSinceLastRound in nanoseconds
         * @param catchpoint - The current catchpoint that is being caught up to
         * @param catchpointAcquiredBlocks - The number of blocks that have already been obtained by the node as part of the
         * catchup
         * @param catchpointProcessedAccounts - The number of accounts from the current catchpoint that have been processed so
         * far as part of the catchup
         * @param catchpointProcessedKvs - The number of key-values (KVs) from the current catchpoint that have been
         * processed so far as part of the catchup
         * @param catchpointTotalAccounts - The total number of accounts included in the current catchpoint
         * @param catchpointTotalBlocks - The total number of blocks that are required to complete the current catchpoint
         * catchup
         * @param catchpointTotalKvs - The total number of key-values (KVs) included in the current catchpoint
         * @param catchpointVerifiedAccounts - The number of accounts from the current catchpoint that have been verified so
         * far as part of the catchup
         * @param catchpointVerifiedKvs - The number of key-values (KVs) from the current catchpoint that have been
         * verified so far as part of the catchup
         * @param lastCatchpoint - The last catchpoint seen by the node
         * @param upgradeDelay - Upgrade delay
         * @param upgradeNextProtocolVoteBefore - Next protocol round
         * @param upgradeNoVotes - No votes cast for consensus upgrade
         * @param upgradeNodeVote - This node's upgrade vote
         * @param upgradeVoteRounds - Total voting rounds for current upgrade
         * @param upgradeVotes - Total votes cast for consensus upgrade
         * @param upgradeVotesRequired - Yes votes required for consensus upgrade
         * @param upgradeYesVotes - Yes votes cast for consensus upgrade
         */
        constructor({ catchupTime, lastRound, lastVersion, nextVersion, nextVersionRound, nextVersionSupported, stoppedAtUnsupportedRound, timeSinceLastRound, catchpoint, catchpointAcquiredBlocks, catchpointProcessedAccounts, catchpointProcessedKvs, catchpointTotalAccounts, catchpointTotalBlocks, catchpointTotalKvs, catchpointVerifiedAccounts, catchpointVerifiedKvs, lastCatchpoint, upgradeDelay, upgradeNextProtocolVoteBefore, upgradeNoVotes, upgradeNodeVote, upgradeVoteRounds, upgradeVotes, upgradeVotesRequired, upgradeYesVotes }) {
          this.catchupTime = ensureBigInt(catchupTime);
          this.lastRound = ensureBigInt(lastRound);
          this.lastVersion = lastVersion;
          this.nextVersion = nextVersion;
          this.nextVersionRound = ensureBigInt(nextVersionRound);
          this.nextVersionSupported = nextVersionSupported;
          this.stoppedAtUnsupportedRound = stoppedAtUnsupportedRound;
          this.timeSinceLastRound = ensureBigInt(timeSinceLastRound);
          this.catchpoint = catchpoint;
          this.catchpointAcquiredBlocks = typeof catchpointAcquiredBlocks === "undefined" ? void 0 : ensureSafeInteger(catchpointAcquiredBlocks);
          this.catchpointProcessedAccounts = typeof catchpointProcessedAccounts === "undefined" ? void 0 : ensureSafeInteger(catchpointProcessedAccounts);
          this.catchpointProcessedKvs = typeof catchpointProcessedKvs === "undefined" ? void 0 : ensureSafeInteger(catchpointProcessedKvs);
          this.catchpointTotalAccounts = typeof catchpointTotalAccounts === "undefined" ? void 0 : ensureSafeInteger(catchpointTotalAccounts);
          this.catchpointTotalBlocks = typeof catchpointTotalBlocks === "undefined" ? void 0 : ensureSafeInteger(catchpointTotalBlocks);
          this.catchpointTotalKvs = typeof catchpointTotalKvs === "undefined" ? void 0 : ensureSafeInteger(catchpointTotalKvs);
          this.catchpointVerifiedAccounts = typeof catchpointVerifiedAccounts === "undefined" ? void 0 : ensureSafeInteger(catchpointVerifiedAccounts);
          this.catchpointVerifiedKvs = typeof catchpointVerifiedKvs === "undefined" ? void 0 : ensureSafeInteger(catchpointVerifiedKvs);
          this.lastCatchpoint = lastCatchpoint;
          this.upgradeDelay = typeof upgradeDelay === "undefined" ? void 0 : ensureBigInt(upgradeDelay);
          this.upgradeNextProtocolVoteBefore = typeof upgradeNextProtocolVoteBefore === "undefined" ? void 0 : ensureBigInt(upgradeNextProtocolVoteBefore);
          this.upgradeNoVotes = typeof upgradeNoVotes === "undefined" ? void 0 : ensureSafeInteger(upgradeNoVotes);
          this.upgradeNodeVote = upgradeNodeVote;
          this.upgradeVoteRounds = typeof upgradeVoteRounds === "undefined" ? void 0 : ensureSafeInteger(upgradeVoteRounds);
          this.upgradeVotes = typeof upgradeVotes === "undefined" ? void 0 : ensureSafeInteger(upgradeVotes);
          this.upgradeVotesRequired = typeof upgradeVotesRequired === "undefined" ? void 0 : ensureSafeInteger(upgradeVotesRequired);
          this.upgradeYesVotes = typeof upgradeYesVotes === "undefined" ? void 0 : ensureSafeInteger(upgradeYesVotes);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _NodeStatusResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["catchup-time", this.catchupTime],
            ["last-round", this.lastRound],
            ["last-version", this.lastVersion],
            ["next-version", this.nextVersion],
            ["next-version-round", this.nextVersionRound],
            ["next-version-supported", this.nextVersionSupported],
            ["stopped-at-unsupported-round", this.stoppedAtUnsupportedRound],
            ["time-since-last-round", this.timeSinceLastRound],
            ["catchpoint", this.catchpoint],
            ["catchpoint-acquired-blocks", this.catchpointAcquiredBlocks],
            ["catchpoint-processed-accounts", this.catchpointProcessedAccounts],
            ["catchpoint-processed-kvs", this.catchpointProcessedKvs],
            ["catchpoint-total-accounts", this.catchpointTotalAccounts],
            ["catchpoint-total-blocks", this.catchpointTotalBlocks],
            ["catchpoint-total-kvs", this.catchpointTotalKvs],
            ["catchpoint-verified-accounts", this.catchpointVerifiedAccounts],
            ["catchpoint-verified-kvs", this.catchpointVerifiedKvs],
            ["last-catchpoint", this.lastCatchpoint],
            ["upgrade-delay", this.upgradeDelay],
            ["upgrade-next-protocol-vote-before", this.upgradeNextProtocolVoteBefore],
            ["upgrade-no-votes", this.upgradeNoVotes],
            ["upgrade-node-vote", this.upgradeNodeVote],
            ["upgrade-vote-rounds", this.upgradeVoteRounds],
            ["upgrade-votes", this.upgradeVotes],
            ["upgrade-votes-required", this.upgradeVotesRequired],
            ["upgrade-yes-votes", this.upgradeYesVotes]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded NodeStatusResponse: ${data}`);
          }
          return new _NodeStatusResponse({
            catchupTime: data.get("catchup-time"),
            lastRound: data.get("last-round"),
            lastVersion: data.get("last-version"),
            nextVersion: data.get("next-version"),
            nextVersionRound: data.get("next-version-round"),
            nextVersionSupported: data.get("next-version-supported"),
            stoppedAtUnsupportedRound: data.get("stopped-at-unsupported-round"),
            timeSinceLastRound: data.get("time-since-last-round"),
            catchpoint: data.get("catchpoint"),
            catchpointAcquiredBlocks: data.get("catchpoint-acquired-blocks"),
            catchpointProcessedAccounts: data.get("catchpoint-processed-accounts"),
            catchpointProcessedKvs: data.get("catchpoint-processed-kvs"),
            catchpointTotalAccounts: data.get("catchpoint-total-accounts"),
            catchpointTotalBlocks: data.get("catchpoint-total-blocks"),
            catchpointTotalKvs: data.get("catchpoint-total-kvs"),
            catchpointVerifiedAccounts: data.get("catchpoint-verified-accounts"),
            catchpointVerifiedKvs: data.get("catchpoint-verified-kvs"),
            lastCatchpoint: data.get("last-catchpoint"),
            upgradeDelay: data.get("upgrade-delay"),
            upgradeNextProtocolVoteBefore: data.get("upgrade-next-protocol-vote-before"),
            upgradeNoVotes: data.get("upgrade-no-votes"),
            upgradeNodeVote: data.get("upgrade-node-vote"),
            upgradeVoteRounds: data.get("upgrade-vote-rounds"),
            upgradeVotes: data.get("upgrade-votes"),
            upgradeVotesRequired: data.get("upgrade-votes-required"),
            upgradeYesVotes: data.get("upgrade-yes-votes")
          });
        }
      };
      PendingTransactionResponse = class _PendingTransactionResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "pool-error", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "txn",
              valueSchema: SignedTransaction.encodingSchema,
              omitEmpty: true
            }, {
              key: "application-index",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "asset-closing-amount",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "asset-index",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "close-rewards",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "closing-amount",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "confirmed-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "global-state-delta",
              valueSchema: new OptionalSchema(new ArraySchema(EvalDeltaKeyValue.encodingSchema)),
              omitEmpty: true
            }, {
              key: "inner-txns",
              valueSchema: new OptionalSchema(new ArraySchema(_PendingTransactionResponse.encodingSchema)),
              omitEmpty: true
            }, {
              key: "local-state-delta",
              valueSchema: new OptionalSchema(new ArraySchema(AccountStateDelta.encodingSchema)),
              omitEmpty: true
            }, {
              key: "logs",
              valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
              omitEmpty: true
            }, {
              key: "receiver-rewards",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "sender-rewards",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `PendingTransactionResponse` object.
         * @param poolError - Indicates that the transaction was kicked out of this node's transaction pool
         * (and specifies why that happened). An empty string indicates the transaction
         * wasn't kicked out of this node's txpool due to an error.
         * @param txn - The raw signed transaction.
         * @param applicationIndex - The application index if the transaction was found and it created an
         * application.
         * @param assetClosingAmount - The number of the asset's unit that were transferred to the close-to address.
         * @param assetIndex - The asset index if the transaction was found and it created an asset.
         * @param closeRewards - Rewards in microalgos applied to the close remainder to account.
         * @param closingAmount - Closing amount for the transaction.
         * @param confirmedRound - The round where this transaction was confirmed, if present.
         * @param globalStateDelta - Global state key/value changes for the application being executed by this
         * transaction.
         * @param innerTxns - Inner transactions produced by application execution.
         * @param localStateDelta - Local state key/value changes for the application being executed by this
         * transaction.
         * @param logs - Logs for the application being executed by this transaction.
         * @param receiverRewards - Rewards in microalgos applied to the receiver account.
         * @param senderRewards - Rewards in microalgos applied to the sender account.
         */
        constructor({ poolError, txn, applicationIndex, assetClosingAmount, assetIndex, closeRewards, closingAmount, confirmedRound, globalStateDelta, innerTxns, localStateDelta, logs, receiverRewards, senderRewards }) {
          this.poolError = poolError;
          this.txn = txn;
          this.applicationIndex = typeof applicationIndex === "undefined" ? void 0 : ensureBigInt(applicationIndex);
          this.assetClosingAmount = typeof assetClosingAmount === "undefined" ? void 0 : ensureBigInt(assetClosingAmount);
          this.assetIndex = typeof assetIndex === "undefined" ? void 0 : ensureBigInt(assetIndex);
          this.closeRewards = typeof closeRewards === "undefined" ? void 0 : ensureBigInt(closeRewards);
          this.closingAmount = typeof closingAmount === "undefined" ? void 0 : ensureBigInt(closingAmount);
          this.confirmedRound = typeof confirmedRound === "undefined" ? void 0 : ensureBigInt(confirmedRound);
          this.globalStateDelta = globalStateDelta;
          this.innerTxns = innerTxns;
          this.localStateDelta = localStateDelta;
          this.logs = logs;
          this.receiverRewards = typeof receiverRewards === "undefined" ? void 0 : ensureBigInt(receiverRewards);
          this.senderRewards = typeof senderRewards === "undefined" ? void 0 : ensureBigInt(senderRewards);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _PendingTransactionResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["pool-error", this.poolError],
            ["txn", this.txn.toEncodingData()],
            ["application-index", this.applicationIndex],
            ["asset-closing-amount", this.assetClosingAmount],
            ["asset-index", this.assetIndex],
            ["close-rewards", this.closeRewards],
            ["closing-amount", this.closingAmount],
            ["confirmed-round", this.confirmedRound],
            [
              "global-state-delta",
              typeof this.globalStateDelta !== "undefined" ? this.globalStateDelta.map((v3) => v3.toEncodingData()) : void 0
            ],
            [
              "inner-txns",
              typeof this.innerTxns !== "undefined" ? this.innerTxns.map((v3) => v3.toEncodingData()) : void 0
            ],
            [
              "local-state-delta",
              typeof this.localStateDelta !== "undefined" ? this.localStateDelta.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["logs", this.logs],
            ["receiver-rewards", this.receiverRewards],
            ["sender-rewards", this.senderRewards]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded PendingTransactionResponse: ${data}`);
          }
          return new _PendingTransactionResponse({
            poolError: data.get("pool-error"),
            txn: SignedTransaction.fromEncodingData(data.get("txn") ?? /* @__PURE__ */ new Map()),
            applicationIndex: data.get("application-index"),
            assetClosingAmount: data.get("asset-closing-amount"),
            assetIndex: data.get("asset-index"),
            closeRewards: data.get("close-rewards"),
            closingAmount: data.get("closing-amount"),
            confirmedRound: data.get("confirmed-round"),
            globalStateDelta: typeof data.get("global-state-delta") !== "undefined" ? data.get("global-state-delta").map((v3) => EvalDeltaKeyValue.fromEncodingData(v3)) : void 0,
            innerTxns: typeof data.get("inner-txns") !== "undefined" ? data.get("inner-txns").map((v3) => _PendingTransactionResponse.fromEncodingData(v3)) : void 0,
            localStateDelta: typeof data.get("local-state-delta") !== "undefined" ? data.get("local-state-delta").map((v3) => AccountStateDelta.fromEncodingData(v3)) : void 0,
            logs: data.get("logs"),
            receiverRewards: data.get("receiver-rewards"),
            senderRewards: data.get("sender-rewards")
          });
        }
      };
      PendingTransactionsResponse = class _PendingTransactionsResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "top-transactions",
              valueSchema: new ArraySchema(SignedTransaction.encodingSchema),
              omitEmpty: true
            }, {
              key: "total-transactions",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `PendingTransactionsResponse` object.
         * @param topTransactions - An array of signed transaction objects.
         * @param totalTransactions - Total number of transactions in the pool.
         */
        constructor({ topTransactions, totalTransactions }) {
          this.topTransactions = topTransactions;
          this.totalTransactions = ensureSafeInteger(totalTransactions);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _PendingTransactionsResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["top-transactions", this.topTransactions.map((v3) => v3.toEncodingData())],
            ["total-transactions", this.totalTransactions]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded PendingTransactionsResponse: ${data}`);
          }
          return new _PendingTransactionsResponse({
            topTransactions: (data.get("top-transactions") ?? []).map((v3) => SignedTransaction.fromEncodingData(v3)),
            totalTransactions: data.get("total-transactions")
          });
        }
      };
      PostTransactionsResponse = class _PostTransactionsResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "txId",
              valueSchema: new StringSchema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `PostTransactionsResponse` object.
         * @param txid - encoding of the transaction hash.
         */
        constructor({ txid }) {
          this.txid = txid;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _PostTransactionsResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([["txId", this.txid]]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded PostTransactionsResponse: ${data}`);
          }
          return new _PostTransactionsResponse({
            txid: data.get("txId")
          });
        }
      };
      ScratchChange = class _ScratchChange {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "new-value",
              valueSchema: AvmValue.encodingSchema,
              omitEmpty: true
            }, { key: "slot", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ScratchChange` object.
         * @param newValue - Represents an AVM value.
         * @param slot - The scratch slot written.
         */
        constructor({ newValue, slot }) {
          this.newValue = newValue;
          this.slot = ensureSafeInteger(slot);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ScratchChange.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["new-value", this.newValue.toEncodingData()],
            ["slot", this.slot]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ScratchChange: ${data}`);
          }
          return new _ScratchChange({
            newValue: AvmValue.fromEncodingData(data.get("new-value") ?? /* @__PURE__ */ new Map()),
            slot: data.get("slot")
          });
        }
      };
      SimulateInitialStates = class _SimulateInitialStates {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "app-initial-states",
              valueSchema: new OptionalSchema(new ArraySchema(ApplicationInitialStates.encodingSchema)),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SimulateInitialStates` object.
         * @param appInitialStates - The initial states of accessed application before simulation. The order of this
         * array is arbitrary.
         */
        constructor({ appInitialStates }) {
          this.appInitialStates = appInitialStates;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SimulateInitialStates.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "app-initial-states",
              typeof this.appInitialStates !== "undefined" ? this.appInitialStates.map((v3) => v3.toEncodingData()) : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateInitialStates: ${data}`);
          }
          return new _SimulateInitialStates({
            appInitialStates: typeof data.get("app-initial-states") !== "undefined" ? data.get("app-initial-states").map((v3) => ApplicationInitialStates.fromEncodingData(v3)) : void 0
          });
        }
      };
      SimulateRequest = class _SimulateRequest {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "txn-groups",
              valueSchema: new ArraySchema(SimulateRequestTransactionGroup.encodingSchema),
              omitEmpty: true
            }, {
              key: "allow-empty-signatures",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "allow-more-logging",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "allow-unnamed-resources",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "exec-trace-config",
              valueSchema: new OptionalSchema(SimulateTraceConfig.encodingSchema),
              omitEmpty: true
            }, {
              key: "extra-opcode-budget",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "fix-signers",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SimulateRequest` object.
         * @param txnGroups - The transaction groups to simulate.
         * @param allowEmptySignatures - Allows transactions without signatures to be simulated as if they had correct
         * signatures.
         * @param allowMoreLogging - Lifts limits on log opcode usage during simulation.
         * @param allowUnnamedResources - Allows access to unnamed resources during simulation.
         * @param execTraceConfig - An object that configures simulation execution trace.
         * @param extraOpcodeBudget - Applies extra opcode budget during simulation for each transaction group.
         * @param fixSigners - If true, signers for transactions that are missing signatures will be fixed
         * during evaluation.
         * @param round - If provided, specifies the round preceding the simulation. State changes through
         * this round will be used to run this simulation. Usually only the 4 most recent
         * rounds will be available (controlled by the node config value MaxAcctLookback).
         * If not specified, defaults to the latest available round.
         */
        constructor({ txnGroups, allowEmptySignatures, allowMoreLogging, allowUnnamedResources, execTraceConfig, extraOpcodeBudget, fixSigners, round }) {
          this.txnGroups = txnGroups;
          this.allowEmptySignatures = allowEmptySignatures;
          this.allowMoreLogging = allowMoreLogging;
          this.allowUnnamedResources = allowUnnamedResources;
          this.execTraceConfig = execTraceConfig;
          this.extraOpcodeBudget = typeof extraOpcodeBudget === "undefined" ? void 0 : ensureSafeInteger(extraOpcodeBudget);
          this.fixSigners = fixSigners;
          this.round = typeof round === "undefined" ? void 0 : ensureBigInt(round);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SimulateRequest.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["txn-groups", this.txnGroups.map((v3) => v3.toEncodingData())],
            ["allow-empty-signatures", this.allowEmptySignatures],
            ["allow-more-logging", this.allowMoreLogging],
            ["allow-unnamed-resources", this.allowUnnamedResources],
            [
              "exec-trace-config",
              typeof this.execTraceConfig !== "undefined" ? this.execTraceConfig.toEncodingData() : void 0
            ],
            ["extra-opcode-budget", this.extraOpcodeBudget],
            ["fix-signers", this.fixSigners],
            ["round", this.round]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateRequest: ${data}`);
          }
          return new _SimulateRequest({
            txnGroups: (data.get("txn-groups") ?? []).map((v3) => SimulateRequestTransactionGroup.fromEncodingData(v3)),
            allowEmptySignatures: data.get("allow-empty-signatures"),
            allowMoreLogging: data.get("allow-more-logging"),
            allowUnnamedResources: data.get("allow-unnamed-resources"),
            execTraceConfig: typeof data.get("exec-trace-config") !== "undefined" ? SimulateTraceConfig.fromEncodingData(data.get("exec-trace-config")) : void 0,
            extraOpcodeBudget: data.get("extra-opcode-budget"),
            fixSigners: data.get("fix-signers"),
            round: data.get("round")
          });
        }
      };
      SimulateRequestTransactionGroup = class _SimulateRequestTransactionGroup {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "txns",
              valueSchema: new ArraySchema(SignedTransaction.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SimulateRequestTransactionGroup` object.
         * @param txns - An atomic transaction group.
         */
        constructor({ txns }) {
          this.txns = txns;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SimulateRequestTransactionGroup.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["txns", this.txns.map((v3) => v3.toEncodingData())]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateRequestTransactionGroup: ${data}`);
          }
          return new _SimulateRequestTransactionGroup({
            txns: (data.get("txns") ?? []).map((v3) => SignedTransaction.fromEncodingData(v3))
          });
        }
      };
      SimulateResponse = class _SimulateResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "last-round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "txn-groups",
              valueSchema: new ArraySchema(SimulateTransactionGroupResult.encodingSchema),
              omitEmpty: true
            }, { key: "version", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "eval-overrides",
              valueSchema: new OptionalSchema(SimulationEvalOverrides.encodingSchema),
              omitEmpty: true
            }, {
              key: "exec-trace-config",
              valueSchema: new OptionalSchema(SimulateTraceConfig.encodingSchema),
              omitEmpty: true
            }, {
              key: "initial-states",
              valueSchema: new OptionalSchema(SimulateInitialStates.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SimulateResponse` object.
         * @param lastRound - The round immediately preceding this simulation. State changes through this
         * round were used to run this simulation.
         * @param txnGroups - A result object for each transaction group that was simulated.
         * @param version - The version of this response object.
         * @param evalOverrides - The set of parameters and limits override during simulation. If this set of
         * parameters is present, then evaluation parameters may differ from standard
         * evaluation in certain ways.
         * @param execTraceConfig - An object that configures simulation execution trace.
         * @param initialStates - Initial states of resources that were accessed during simulation.
         */
        constructor({ lastRound, txnGroups, version, evalOverrides, execTraceConfig, initialStates }) {
          this.lastRound = ensureBigInt(lastRound);
          this.txnGroups = txnGroups;
          this.version = ensureSafeInteger(version);
          this.evalOverrides = evalOverrides;
          this.execTraceConfig = execTraceConfig;
          this.initialStates = initialStates;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SimulateResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["last-round", this.lastRound],
            ["txn-groups", this.txnGroups.map((v3) => v3.toEncodingData())],
            ["version", this.version],
            [
              "eval-overrides",
              typeof this.evalOverrides !== "undefined" ? this.evalOverrides.toEncodingData() : void 0
            ],
            [
              "exec-trace-config",
              typeof this.execTraceConfig !== "undefined" ? this.execTraceConfig.toEncodingData() : void 0
            ],
            [
              "initial-states",
              typeof this.initialStates !== "undefined" ? this.initialStates.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateResponse: ${data}`);
          }
          return new _SimulateResponse({
            lastRound: data.get("last-round"),
            txnGroups: (data.get("txn-groups") ?? []).map((v3) => SimulateTransactionGroupResult.fromEncodingData(v3)),
            version: data.get("version"),
            evalOverrides: typeof data.get("eval-overrides") !== "undefined" ? SimulationEvalOverrides.fromEncodingData(data.get("eval-overrides")) : void 0,
            execTraceConfig: typeof data.get("exec-trace-config") !== "undefined" ? SimulateTraceConfig.fromEncodingData(data.get("exec-trace-config")) : void 0,
            initialStates: typeof data.get("initial-states") !== "undefined" ? SimulateInitialStates.fromEncodingData(data.get("initial-states")) : void 0
          });
        }
      };
      SimulateTraceConfig = class _SimulateTraceConfig {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "enable",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "scratch-change",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "stack-change",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "state-change",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SimulateTraceConfig` object.
         * @param enable - A boolean option for opting in execution trace features simulation endpoint.
         * @param scratchChange - A boolean option enabling returning scratch slot changes together with execution
         * trace during simulation.
         * @param stackChange - A boolean option enabling returning stack changes together with execution trace
         * during simulation.
         * @param stateChange - A boolean option enabling returning application state changes (global, local,
         * and box changes) with the execution trace during simulation.
         */
        constructor({ enable, scratchChange, stackChange, stateChange }) {
          this.enable = enable;
          this.scratchChange = scratchChange;
          this.stackChange = stackChange;
          this.stateChange = stateChange;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SimulateTraceConfig.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["enable", this.enable],
            ["scratch-change", this.scratchChange],
            ["stack-change", this.stackChange],
            ["state-change", this.stateChange]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateTraceConfig: ${data}`);
          }
          return new _SimulateTraceConfig({
            enable: data.get("enable"),
            scratchChange: data.get("scratch-change"),
            stackChange: data.get("stack-change"),
            stateChange: data.get("state-change")
          });
        }
      };
      SimulateTransactionGroupResult = class _SimulateTransactionGroupResult {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "txn-results",
              valueSchema: new ArraySchema(SimulateTransactionResult.encodingSchema),
              omitEmpty: true
            }, {
              key: "app-budget-added",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "app-budget-consumed",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "failed-at",
              valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
              omitEmpty: true
            }, {
              key: "failure-message",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "unnamed-resources-accessed",
              valueSchema: new OptionalSchema(SimulateUnnamedResourcesAccessed.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SimulateTransactionGroupResult` object.
         * @param txnResults - Simulation result for individual transactions
         * @param appBudgetAdded - Total budget added during execution of app calls in the transaction group.
         * @param appBudgetConsumed - Total budget consumed during execution of app calls in the transaction group.
         * @param failedAt - If present, indicates which transaction in this group caused the failure. This
         * array represents the path to the failing transaction. Indexes are zero based,
         * the first element indicates the top-level transaction, and successive elements
         * indicate deeper inner transactions.
         * @param failureMessage - If present, indicates that the transaction group failed and specifies why that
         * happened
         * @param unnamedResourcesAccessed - These are resources that were accessed by this group that would normally have
         * caused failure, but were allowed in simulation. Depending on where this object
         * is in the response, the unnamed resources it contains may or may not qualify for
         * group resource sharing. If this is a field in SimulateTransactionGroupResult,
         * the resources do qualify, but if this is a field in SimulateTransactionResult,
         * they do not qualify. In order to make this group valid for actual submission,
         * resources that qualify for group sharing can be made available by any
         * transaction of the group; otherwise, resources must be placed in the same
         * transaction which accessed them.
         */
        constructor({ txnResults, appBudgetAdded, appBudgetConsumed, failedAt, failureMessage, unnamedResourcesAccessed }) {
          this.txnResults = txnResults;
          this.appBudgetAdded = typeof appBudgetAdded === "undefined" ? void 0 : ensureSafeInteger(appBudgetAdded);
          this.appBudgetConsumed = typeof appBudgetConsumed === "undefined" ? void 0 : ensureSafeInteger(appBudgetConsumed);
          this.failedAt = typeof failedAt === "undefined" ? void 0 : failedAt.map(ensureSafeInteger);
          this.failureMessage = failureMessage;
          this.unnamedResourcesAccessed = unnamedResourcesAccessed;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SimulateTransactionGroupResult.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["txn-results", this.txnResults.map((v3) => v3.toEncodingData())],
            ["app-budget-added", this.appBudgetAdded],
            ["app-budget-consumed", this.appBudgetConsumed],
            ["failed-at", this.failedAt],
            ["failure-message", this.failureMessage],
            [
              "unnamed-resources-accessed",
              typeof this.unnamedResourcesAccessed !== "undefined" ? this.unnamedResourcesAccessed.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateTransactionGroupResult: ${data}`);
          }
          return new _SimulateTransactionGroupResult({
            txnResults: (data.get("txn-results") ?? []).map((v3) => SimulateTransactionResult.fromEncodingData(v3)),
            appBudgetAdded: data.get("app-budget-added"),
            appBudgetConsumed: data.get("app-budget-consumed"),
            failedAt: data.get("failed-at"),
            failureMessage: data.get("failure-message"),
            unnamedResourcesAccessed: typeof data.get("unnamed-resources-accessed") !== "undefined" ? SimulateUnnamedResourcesAccessed.fromEncodingData(data.get("unnamed-resources-accessed")) : void 0
          });
        }
      };
      SimulateTransactionResult = class _SimulateTransactionResult {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "txn-result",
              valueSchema: PendingTransactionResponse.encodingSchema,
              omitEmpty: true
            }, {
              key: "app-budget-consumed",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "exec-trace",
              valueSchema: new OptionalSchema(SimulationTransactionExecTrace.encodingSchema),
              omitEmpty: true
            }, {
              key: "fixed-signer",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "logic-sig-budget-consumed",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "unnamed-resources-accessed",
              valueSchema: new OptionalSchema(SimulateUnnamedResourcesAccessed.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SimulateTransactionResult` object.
         * @param txnResult - Details about a pending transaction. If the transaction was recently confirmed,
         * includes confirmation details like the round and reward details.
         * @param appBudgetConsumed - Budget used during execution of an app call transaction. This value includes
         * budged used by inner app calls spawned by this transaction.
         * @param execTrace - The execution trace of calling an app or a logic sig, containing the inner app
         * call trace in a recursive way.
         * @param fixedSigner - The account that needed to sign this transaction when no signature was provided
         * and the provided signer was incorrect.
         * @param logicSigBudgetConsumed - Budget used during execution of a logic sig transaction.
         * @param unnamedResourcesAccessed - These are resources that were accessed by this group that would normally have
         * caused failure, but were allowed in simulation. Depending on where this object
         * is in the response, the unnamed resources it contains may or may not qualify for
         * group resource sharing. If this is a field in SimulateTransactionGroupResult,
         * the resources do qualify, but if this is a field in SimulateTransactionResult,
         * they do not qualify. In order to make this group valid for actual submission,
         * resources that qualify for group sharing can be made available by any
         * transaction of the group; otherwise, resources must be placed in the same
         * transaction which accessed them.
         */
        constructor({ txnResult, appBudgetConsumed, execTrace, fixedSigner, logicSigBudgetConsumed, unnamedResourcesAccessed }) {
          this.txnResult = txnResult;
          this.appBudgetConsumed = typeof appBudgetConsumed === "undefined" ? void 0 : ensureSafeInteger(appBudgetConsumed);
          this.execTrace = execTrace;
          this.fixedSigner = typeof fixedSigner === "string" ? Address.fromString(fixedSigner) : fixedSigner;
          this.logicSigBudgetConsumed = typeof logicSigBudgetConsumed === "undefined" ? void 0 : ensureSafeInteger(logicSigBudgetConsumed);
          this.unnamedResourcesAccessed = unnamedResourcesAccessed;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SimulateTransactionResult.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["txn-result", this.txnResult.toEncodingData()],
            ["app-budget-consumed", this.appBudgetConsumed],
            [
              "exec-trace",
              typeof this.execTrace !== "undefined" ? this.execTrace.toEncodingData() : void 0
            ],
            [
              "fixed-signer",
              typeof this.fixedSigner !== "undefined" ? this.fixedSigner.toString() : void 0
            ],
            ["logic-sig-budget-consumed", this.logicSigBudgetConsumed],
            [
              "unnamed-resources-accessed",
              typeof this.unnamedResourcesAccessed !== "undefined" ? this.unnamedResourcesAccessed.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateTransactionResult: ${data}`);
          }
          return new _SimulateTransactionResult({
            txnResult: PendingTransactionResponse.fromEncodingData(data.get("txn-result") ?? /* @__PURE__ */ new Map()),
            appBudgetConsumed: data.get("app-budget-consumed"),
            execTrace: typeof data.get("exec-trace") !== "undefined" ? SimulationTransactionExecTrace.fromEncodingData(data.get("exec-trace")) : void 0,
            fixedSigner: data.get("fixed-signer"),
            logicSigBudgetConsumed: data.get("logic-sig-budget-consumed"),
            unnamedResourcesAccessed: typeof data.get("unnamed-resources-accessed") !== "undefined" ? SimulateUnnamedResourcesAccessed.fromEncodingData(data.get("unnamed-resources-accessed")) : void 0
          });
        }
      };
      SimulateUnnamedResourcesAccessed = class _SimulateUnnamedResourcesAccessed {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "accounts",
              valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
              omitEmpty: true
            }, {
              key: "app-locals",
              valueSchema: new OptionalSchema(new ArraySchema(ApplicationLocalReference.encodingSchema)),
              omitEmpty: true
            }, {
              key: "apps",
              valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
              omitEmpty: true
            }, {
              key: "asset-holdings",
              valueSchema: new OptionalSchema(new ArraySchema(AssetHoldingReference.encodingSchema)),
              omitEmpty: true
            }, {
              key: "assets",
              valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
              omitEmpty: true
            }, {
              key: "boxes",
              valueSchema: new OptionalSchema(new ArraySchema(BoxReference.encodingSchema)),
              omitEmpty: true
            }, {
              key: "extra-box-refs",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SimulateUnnamedResourcesAccessed` object.
         * @param accounts - The unnamed accounts that were referenced. The order of this array is arbitrary.
         * @param appLocals - The unnamed application local states that were referenced. The order of this
         * array is arbitrary.
         * @param apps - The unnamed applications that were referenced. The order of this array is
         * arbitrary.
         * @param assetHoldings - The unnamed asset holdings that were referenced. The order of this array is
         * arbitrary.
         * @param assets - The unnamed assets that were referenced. The order of this array is arbitrary.
         * @param boxes - The unnamed boxes that were referenced. The order of this array is arbitrary.
         * @param extraBoxRefs - The number of extra box references used to increase the IO budget. This is in
         * addition to the references defined in the input transaction group and any
         * referenced to unnamed boxes.
         */
        constructor({ accounts, appLocals, apps, assetHoldings, assets, boxes, extraBoxRefs }) {
          this.accounts = typeof accounts !== "undefined" ? accounts.map((addr) => typeof addr === "string" ? Address.fromString(addr) : addr) : void 0;
          this.appLocals = appLocals;
          this.apps = typeof apps === "undefined" ? void 0 : apps.map(ensureBigInt);
          this.assetHoldings = assetHoldings;
          this.assets = typeof assets === "undefined" ? void 0 : assets.map(ensureBigInt);
          this.boxes = boxes;
          this.extraBoxRefs = typeof extraBoxRefs === "undefined" ? void 0 : ensureSafeInteger(extraBoxRefs);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SimulateUnnamedResourcesAccessed.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "accounts",
              typeof this.accounts !== "undefined" ? this.accounts.map((v3) => v3.toString()) : void 0
            ],
            [
              "app-locals",
              typeof this.appLocals !== "undefined" ? this.appLocals.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["apps", this.apps],
            [
              "asset-holdings",
              typeof this.assetHoldings !== "undefined" ? this.assetHoldings.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["assets", this.assets],
            [
              "boxes",
              typeof this.boxes !== "undefined" ? this.boxes.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["extra-box-refs", this.extraBoxRefs]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulateUnnamedResourcesAccessed: ${data}`);
          }
          return new _SimulateUnnamedResourcesAccessed({
            accounts: data.get("accounts"),
            appLocals: typeof data.get("app-locals") !== "undefined" ? data.get("app-locals").map((v3) => ApplicationLocalReference.fromEncodingData(v3)) : void 0,
            apps: data.get("apps"),
            assetHoldings: typeof data.get("asset-holdings") !== "undefined" ? data.get("asset-holdings").map((v3) => AssetHoldingReference.fromEncodingData(v3)) : void 0,
            assets: data.get("assets"),
            boxes: typeof data.get("boxes") !== "undefined" ? data.get("boxes").map((v3) => BoxReference.fromEncodingData(v3)) : void 0,
            extraBoxRefs: data.get("extra-box-refs")
          });
        }
      };
      SimulationEvalOverrides = class _SimulationEvalOverrides {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "allow-empty-signatures",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "allow-unnamed-resources",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "extra-opcode-budget",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "fix-signers",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "max-log-calls",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "max-log-size",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SimulationEvalOverrides` object.
         * @param allowEmptySignatures - If true, transactions without signatures are allowed and simulated as if they
         * were properly signed.
         * @param allowUnnamedResources - If true, allows access to unnamed resources during simulation.
         * @param extraOpcodeBudget - The extra opcode budget added to each transaction group during simulation
         * @param fixSigners - If true, signers for transactions that are missing signatures will be fixed
         * during evaluation.
         * @param maxLogCalls - The maximum log calls one can make during simulation
         * @param maxLogSize - The maximum byte number to log during simulation
         */
        constructor({ allowEmptySignatures, allowUnnamedResources, extraOpcodeBudget, fixSigners, maxLogCalls, maxLogSize }) {
          this.allowEmptySignatures = allowEmptySignatures;
          this.allowUnnamedResources = allowUnnamedResources;
          this.extraOpcodeBudget = typeof extraOpcodeBudget === "undefined" ? void 0 : ensureSafeInteger(extraOpcodeBudget);
          this.fixSigners = fixSigners;
          this.maxLogCalls = typeof maxLogCalls === "undefined" ? void 0 : ensureSafeInteger(maxLogCalls);
          this.maxLogSize = typeof maxLogSize === "undefined" ? void 0 : ensureSafeInteger(maxLogSize);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SimulationEvalOverrides.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["allow-empty-signatures", this.allowEmptySignatures],
            ["allow-unnamed-resources", this.allowUnnamedResources],
            ["extra-opcode-budget", this.extraOpcodeBudget],
            ["fix-signers", this.fixSigners],
            ["max-log-calls", this.maxLogCalls],
            ["max-log-size", this.maxLogSize]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulationEvalOverrides: ${data}`);
          }
          return new _SimulationEvalOverrides({
            allowEmptySignatures: data.get("allow-empty-signatures"),
            allowUnnamedResources: data.get("allow-unnamed-resources"),
            extraOpcodeBudget: data.get("extra-opcode-budget"),
            fixSigners: data.get("fix-signers"),
            maxLogCalls: data.get("max-log-calls"),
            maxLogSize: data.get("max-log-size")
          });
        }
      };
      SimulationOpcodeTraceUnit = class _SimulationOpcodeTraceUnit {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "pc", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "scratch-changes",
              valueSchema: new OptionalSchema(new ArraySchema(ScratchChange.encodingSchema)),
              omitEmpty: true
            }, {
              key: "spawned-inners",
              valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
              omitEmpty: true
            }, {
              key: "stack-additions",
              valueSchema: new OptionalSchema(new ArraySchema(AvmValue.encodingSchema)),
              omitEmpty: true
            }, {
              key: "stack-pop-count",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "state-changes",
              valueSchema: new OptionalSchema(new ArraySchema(ApplicationStateOperation.encodingSchema)),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SimulationOpcodeTraceUnit` object.
         * @param pc - The program counter of the current opcode being evaluated.
         * @param scratchChanges - The writes into scratch slots.
         * @param spawnedInners - The indexes of the traces for inner transactions spawned by this opcode, if any.
         * @param stackAdditions - The values added by this opcode to the stack.
         * @param stackPopCount - The number of deleted stack values by this opcode.
         * @param stateChanges - The operations against the current application's states.
         */
        constructor({ pc, scratchChanges, spawnedInners, stackAdditions, stackPopCount, stateChanges }) {
          this.pc = ensureSafeInteger(pc);
          this.scratchChanges = scratchChanges;
          this.spawnedInners = typeof spawnedInners === "undefined" ? void 0 : spawnedInners.map(ensureSafeInteger);
          this.stackAdditions = stackAdditions;
          this.stackPopCount = typeof stackPopCount === "undefined" ? void 0 : ensureSafeInteger(stackPopCount);
          this.stateChanges = stateChanges;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SimulationOpcodeTraceUnit.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["pc", this.pc],
            [
              "scratch-changes",
              typeof this.scratchChanges !== "undefined" ? this.scratchChanges.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["spawned-inners", this.spawnedInners],
            [
              "stack-additions",
              typeof this.stackAdditions !== "undefined" ? this.stackAdditions.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["stack-pop-count", this.stackPopCount],
            [
              "state-changes",
              typeof this.stateChanges !== "undefined" ? this.stateChanges.map((v3) => v3.toEncodingData()) : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulationOpcodeTraceUnit: ${data}`);
          }
          return new _SimulationOpcodeTraceUnit({
            pc: data.get("pc"),
            scratchChanges: typeof data.get("scratch-changes") !== "undefined" ? data.get("scratch-changes").map((v3) => ScratchChange.fromEncodingData(v3)) : void 0,
            spawnedInners: data.get("spawned-inners"),
            stackAdditions: typeof data.get("stack-additions") !== "undefined" ? data.get("stack-additions").map((v3) => AvmValue.fromEncodingData(v3)) : void 0,
            stackPopCount: data.get("stack-pop-count"),
            stateChanges: typeof data.get("state-changes") !== "undefined" ? data.get("state-changes").map((v3) => ApplicationStateOperation.fromEncodingData(v3)) : void 0
          });
        }
      };
      SimulationTransactionExecTrace = class _SimulationTransactionExecTrace {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "approval-program-hash",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "approval-program-trace",
              valueSchema: new OptionalSchema(new ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
              omitEmpty: true
            }, {
              key: "clear-state-program-hash",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "clear-state-program-trace",
              valueSchema: new OptionalSchema(new ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
              omitEmpty: true
            }, {
              key: "clear-state-rollback",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "clear-state-rollback-error",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "inner-trace",
              valueSchema: new OptionalSchema(new ArraySchema(_SimulationTransactionExecTrace.encodingSchema)),
              omitEmpty: true
            }, {
              key: "logic-sig-hash",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "logic-sig-trace",
              valueSchema: new OptionalSchema(new ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SimulationTransactionExecTrace` object.
         * @param approvalProgramHash - SHA512_256 hash digest of the approval program executed in transaction.
         * @param approvalProgramTrace - Program trace that contains a trace of opcode effects in an approval program.
         * @param clearStateProgramHash - SHA512_256 hash digest of the clear state program executed in transaction.
         * @param clearStateProgramTrace - Program trace that contains a trace of opcode effects in a clear state program.
         * @param clearStateRollback - If true, indicates that the clear state program failed and any persistent state
         * changes it produced should be reverted once the program exits.
         * @param clearStateRollbackError - The error message explaining why the clear state program failed. This field will
         * only be populated if clear-state-rollback is true and the failure was due to an
         * execution error.
         * @param innerTrace - An array of SimulationTransactionExecTrace representing the execution trace of
         * any inner transactions executed.
         * @param logicSigHash - SHA512_256 hash digest of the logic sig executed in transaction.
         * @param logicSigTrace - Program trace that contains a trace of opcode effects in a logic sig.
         */
        constructor({ approvalProgramHash, approvalProgramTrace, clearStateProgramHash, clearStateProgramTrace, clearStateRollback, clearStateRollbackError, innerTrace, logicSigHash, logicSigTrace }) {
          this.approvalProgramHash = typeof approvalProgramHash === "string" ? base64ToBytes(approvalProgramHash) : approvalProgramHash;
          this.approvalProgramTrace = approvalProgramTrace;
          this.clearStateProgramHash = typeof clearStateProgramHash === "string" ? base64ToBytes(clearStateProgramHash) : clearStateProgramHash;
          this.clearStateProgramTrace = clearStateProgramTrace;
          this.clearStateRollback = clearStateRollback;
          this.clearStateRollbackError = clearStateRollbackError;
          this.innerTrace = innerTrace;
          this.logicSigHash = typeof logicSigHash === "string" ? base64ToBytes(logicSigHash) : logicSigHash;
          this.logicSigTrace = logicSigTrace;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SimulationTransactionExecTrace.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["approval-program-hash", this.approvalProgramHash],
            [
              "approval-program-trace",
              typeof this.approvalProgramTrace !== "undefined" ? this.approvalProgramTrace.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["clear-state-program-hash", this.clearStateProgramHash],
            [
              "clear-state-program-trace",
              typeof this.clearStateProgramTrace !== "undefined" ? this.clearStateProgramTrace.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["clear-state-rollback", this.clearStateRollback],
            ["clear-state-rollback-error", this.clearStateRollbackError],
            [
              "inner-trace",
              typeof this.innerTrace !== "undefined" ? this.innerTrace.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["logic-sig-hash", this.logicSigHash],
            [
              "logic-sig-trace",
              typeof this.logicSigTrace !== "undefined" ? this.logicSigTrace.map((v3) => v3.toEncodingData()) : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SimulationTransactionExecTrace: ${data}`);
          }
          return new _SimulationTransactionExecTrace({
            approvalProgramHash: data.get("approval-program-hash"),
            approvalProgramTrace: typeof data.get("approval-program-trace") !== "undefined" ? data.get("approval-program-trace").map((v3) => SimulationOpcodeTraceUnit.fromEncodingData(v3)) : void 0,
            clearStateProgramHash: data.get("clear-state-program-hash"),
            clearStateProgramTrace: typeof data.get("clear-state-program-trace") !== "undefined" ? data.get("clear-state-program-trace").map((v3) => SimulationOpcodeTraceUnit.fromEncodingData(v3)) : void 0,
            clearStateRollback: data.get("clear-state-rollback"),
            clearStateRollbackError: data.get("clear-state-rollback-error"),
            innerTrace: typeof data.get("inner-trace") !== "undefined" ? data.get("inner-trace").map((v3) => _SimulationTransactionExecTrace.fromEncodingData(v3)) : void 0,
            logicSigHash: data.get("logic-sig-hash"),
            logicSigTrace: typeof data.get("logic-sig-trace") !== "undefined" ? data.get("logic-sig-trace").map((v3) => SimulationOpcodeTraceUnit.fromEncodingData(v3)) : void 0
          });
        }
      };
      StateProof2 = class _StateProof {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "Message",
              valueSchema: StateProofMessage2.encodingSchema,
              omitEmpty: true
            }, {
              key: "StateProof",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `StateProof` object.
         * @param message - Represents the message that the state proofs are attesting to.
         * @param stateproof - The encoded StateProof for the message.
         */
        constructor({ message, stateproof }) {
          this.message = message;
          this.stateproof = typeof stateproof === "string" ? base64ToBytes(stateproof) : stateproof;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProof.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Message", this.message.toEncodingData()],
            ["StateProof", this.stateproof]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProof: ${data}`);
          }
          return new _StateProof({
            message: StateProofMessage2.fromEncodingData(data.get("Message") ?? /* @__PURE__ */ new Map()),
            stateproof: data.get("StateProof")
          });
        }
      };
      StateProofMessage2 = class _StateProofMessage {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "BlockHeadersCommitment",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, {
              key: "FirstAttestedRound",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "LastAttestedRound",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "LnProvenWeight",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "VotersCommitment",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `StateProofMessage` object.
         * @param blockheaderscommitment - The vector commitment root on all light block headers within a state proof
         * interval.
         * @param firstattestedround - The first round the message attests to.
         * @param lastattestedround - The last round the message attests to.
         * @param lnprovenweight - An integer value representing the natural log of the proven weight with 16 bits
         * of precision. This value would be used to verify the next state proof.
         * @param voterscommitment - The vector commitment root of the top N accounts to sign the next StateProof.
         */
        constructor({ blockheaderscommitment, firstattestedround, lastattestedround, lnprovenweight, voterscommitment }) {
          this.blockheaderscommitment = typeof blockheaderscommitment === "string" ? base64ToBytes(blockheaderscommitment) : blockheaderscommitment;
          this.firstattestedround = ensureBigInt(firstattestedround);
          this.lastattestedround = ensureBigInt(lastattestedround);
          this.lnprovenweight = ensureBigInt(lnprovenweight);
          this.voterscommitment = typeof voterscommitment === "string" ? base64ToBytes(voterscommitment) : voterscommitment;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProofMessage.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["BlockHeadersCommitment", this.blockheaderscommitment],
            ["FirstAttestedRound", this.firstattestedround],
            ["LastAttestedRound", this.lastattestedround],
            ["LnProvenWeight", this.lnprovenweight],
            ["VotersCommitment", this.voterscommitment]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofMessage: ${data}`);
          }
          return new _StateProofMessage({
            blockheaderscommitment: data.get("BlockHeadersCommitment"),
            firstattestedround: data.get("FirstAttestedRound"),
            lastattestedround: data.get("LastAttestedRound"),
            lnprovenweight: data.get("LnProvenWeight"),
            voterscommitment: data.get("VotersCommitment")
          });
        }
      };
      SupplyResponse = class _SupplyResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "current_round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "online-money",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, { key: "total-money", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `SupplyResponse` object.
         * @param currentRound - Round
         * @param onlineMoney - OnlineMoney
         * @param totalMoney - TotalMoney
         */
        constructor({ currentRound, onlineMoney, totalMoney }) {
          this.currentRound = ensureBigInt(currentRound);
          this.onlineMoney = ensureBigInt(onlineMoney);
          this.totalMoney = ensureBigInt(totalMoney);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _SupplyResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["current_round", this.currentRound],
            ["online-money", this.onlineMoney],
            ["total-money", this.totalMoney]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded SupplyResponse: ${data}`);
          }
          return new _SupplyResponse({
            currentRound: data.get("current_round"),
            onlineMoney: data.get("online-money"),
            totalMoney: data.get("total-money")
          });
        }
      };
      TealKeyValue = class _TealKeyValue {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "value", valueSchema: TealValue2.encodingSchema, omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TealKeyValue` object.
         * @param key -
         * @param value - Represents a TEAL value.
         */
        constructor({ key, value }) {
          this.key = typeof key === "string" ? base64ToBytes(key) : key;
          this.value = value;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TealKeyValue.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["key", this.key],
            ["value", this.value.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TealKeyValue: ${data}`);
          }
          return new _TealKeyValue({
            key: data.get("key"),
            value: TealValue2.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
          });
        }
      };
      TealValue2 = class _TealValue {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "bytes", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "type", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "uint", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TealValue` object.
         * @param bytes - (tb) bytes value.
         * @param type - (tt) value type. Value `1` refers to **bytes**, value `2` refers to **uint**
         * @param uint - (ui) uint value.
         */
        constructor({ bytes, type, uint }) {
          this.bytes = typeof bytes === "string" ? base64ToBytes(bytes) : bytes;
          this.type = ensureSafeInteger(type);
          this.uint = ensureBigInt(uint);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TealValue.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["bytes", this.bytes],
            ["type", this.type],
            ["uint", this.uint]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TealValue: ${data}`);
          }
          return new _TealValue({
            bytes: data.get("bytes"),
            type: data.get("type"),
            uint: data.get("uint")
          });
        }
      };
      TransactionGroupLedgerStateDeltasForRoundResponse = class _TransactionGroupLedgerStateDeltasForRoundResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "Deltas",
              valueSchema: new ArraySchema(LedgerStateDeltaForTransactionGroup.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionGroupLedgerStateDeltasForRoundResponse` object.
         * @param deltas -
         */
        constructor({ deltas }) {
          this.deltas = deltas;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionGroupLedgerStateDeltasForRoundResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["Deltas", this.deltas.map((v3) => v3.toEncodingData())]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionGroupLedgerStateDeltasForRoundResponse: ${data}`);
          }
          return new _TransactionGroupLedgerStateDeltasForRoundResponse({
            deltas: (data.get("Deltas") ?? []).map((v3) => LedgerStateDeltaForTransactionGroup.fromEncodingData(v3))
          });
        }
      };
      TransactionParametersResponse = class _TransactionParametersResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "consensus-version",
              valueSchema: new StringSchema(),
              omitEmpty: true
            }, { key: "fee", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "genesis-hash",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, { key: "genesis-id", valueSchema: new StringSchema(), omitEmpty: true }, { key: "last-round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "min-fee", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionParametersResponse` object.
         * @param consensusVersion - ConsensusVersion indicates the consensus protocol version
         * as of LastRound.
         * @param fee - Fee is the suggested transaction fee
         * Fee is in units of micro-Algos per byte.
         * Fee may fall to zero but transactions must still have a fee of
         * at least MinTxnFee for the current network protocol.
         * @param genesisHash - GenesisHash is the hash of the genesis block.
         * @param genesisId - GenesisID is an ID listed in the genesis block.
         * @param lastRound - LastRound indicates the last round seen
         * @param minFee - The minimum transaction fee (not per byte) required for the
         * txn to validate for the current network protocol.
         */
        constructor({ consensusVersion, fee, genesisHash, genesisId, lastRound, minFee }) {
          this.consensusVersion = consensusVersion;
          this.fee = ensureBigInt(fee);
          this.genesisHash = typeof genesisHash === "string" ? base64ToBytes(genesisHash) : genesisHash;
          this.genesisId = genesisId;
          this.lastRound = ensureBigInt(lastRound);
          this.minFee = ensureBigInt(minFee);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionParametersResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["consensus-version", this.consensusVersion],
            ["fee", this.fee],
            ["genesis-hash", this.genesisHash],
            ["genesis-id", this.genesisId],
            ["last-round", this.lastRound],
            ["min-fee", this.minFee]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionParametersResponse: ${data}`);
          }
          return new _TransactionParametersResponse({
            consensusVersion: data.get("consensus-version"),
            fee: data.get("fee"),
            genesisHash: data.get("genesis-hash"),
            genesisId: data.get("genesis-id"),
            lastRound: data.get("last-round"),
            minFee: data.get("min-fee")
          });
        }
      };
      TransactionProofResponse = class _TransactionProofResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "idx", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "proof", valueSchema: new ByteArraySchema(), omitEmpty: true }, {
              key: "stibhash",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, { key: "treedepth", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "hashtype",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionProofResponse` object.
         * @param idx - Index of the transaction in the block's payset.
         * @param proof - Proof of transaction membership.
         * @param stibhash - Hash of SignedTxnInBlock for verifying proof.
         * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
         * from a leaf to the root.
         * @param hashtype - The type of hash function used to create the proof, must be one of:
         * * sha512_256
         * * sha256
         */
        constructor({ idx, proof, stibhash, treedepth, hashtype }) {
          this.idx = ensureSafeInteger(idx);
          this.proof = typeof proof === "string" ? base64ToBytes(proof) : proof;
          this.stibhash = typeof stibhash === "string" ? base64ToBytes(stibhash) : stibhash;
          this.treedepth = ensureSafeInteger(treedepth);
          this.hashtype = hashtype;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionProofResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["idx", this.idx],
            ["proof", this.proof],
            ["stibhash", this.stibhash],
            ["treedepth", this.treedepth],
            ["hashtype", this.hashtype]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionProofResponse: ${data}`);
          }
          return new _TransactionProofResponse({
            idx: data.get("idx"),
            proof: data.get("proof"),
            stibhash: data.get("stibhash"),
            treedepth: data.get("treedepth"),
            hashtype: data.get("hashtype")
          });
        }
      };
      Version = class _Version {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "build",
              valueSchema: BuildVersion.encodingSchema,
              omitEmpty: true
            }, {
              key: "genesis_hash_b64",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, { key: "genesis_id", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "versions",
              valueSchema: new ArraySchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `Version` object.
         * @param build -
         * @param genesisHashB64 -
         * @param genesisId -
         * @param versions -
         */
        constructor({ build, genesisHashB64, genesisId, versions }) {
          this.build = build;
          this.genesisHashB64 = typeof genesisHashB64 === "string" ? base64ToBytes(genesisHashB64) : genesisHashB64;
          this.genesisId = genesisId;
          this.versions = versions;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Version.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["build", this.build.toEncodingData()],
            ["genesis_hash_b64", this.genesisHashB64],
            ["genesis_id", this.genesisId],
            ["versions", this.versions]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Version: ${data}`);
          }
          return new _Version({
            build: BuildVersion.fromEncodingData(data.get("build") ?? /* @__PURE__ */ new Map()),
            genesisHashB64: data.get("genesis_hash_b64"),
            genesisId: data.get("genesis_id"),
            versions: data.get("versions")
          });
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/jsonrequest.js
  var JSONRequest;
  var init_jsonrequest = __esm({
    "node_modules/algosdk/dist/esm/client/v2/jsonrequest.js"() {
      init_polyfills();
      JSONRequest = class {
        /**
         * @param client - HTTPClient object.
         */
        constructor(client) {
          this.c = client;
          this.query = {};
        }
        /**
         * Execute the request
         */
        executeRequest(headers, customOptions) {
          return this.c.get({
            relativePath: this.path(),
            query: this.query,
            requestHeaders: headers,
            customOptions
          });
        }
        /**
         * Execute the request and decode the response.
         * @param headers - Additional headers to send in the request. Optional.
         * @param customOptions - Additional options to pass to the underlying BaseHTTPClient. For
         *   {@link URLTokenBaseHTTPClient}, which is the default client, this will be treated as
         *   additional options to pass to the network `fetch` method.
         * @returns A promise which resolves to the parsed response object.
         * @category JSONRequest
         */
        async do(headers, customOptions) {
          const res = await this.executeRequest(headers, customOptions);
          return this.prepare(res);
        }
        /**
         * Execute the request, but do not process the response data in any way.
         * @param headers - Additional headers to send in the request. Optional.
         * @param customOptions - Additional options to pass to the underlying BaseHTTPClient. For
         *   {@link URLTokenBaseHTTPClient}, which is the default client, this will be treated as
         *   additional options to pass to the network `fetch` method.
         * @returns A promise which resolves to the raw response data, exactly as returned by the server.
         * @category JSONRequest
         */
        async doRaw(headers, customOptions) {
          const res = await this.executeRequest(headers, customOptions);
          return res.body;
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/accountInformation.js
  var AccountInformation;
  var init_accountInformation = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/accountInformation.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      AccountInformation = class extends JSONRequest {
        constructor(c2, account) {
          super(c2);
          this.account = account.toString();
        }
        path() {
          return `/v2/accounts/${this.account}`;
        }
        /**
         * Exclude assets and application data from results
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountInfo = await algodClient.accountInformation(address)
         *        .exclude('all')
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        exclude(exclude) {
          this.query.exclude = exclude;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), Account);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/accountAssetInformation.js
  var AccountAssetInformation;
  var init_accountAssetInformation = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/accountAssetInformation.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      AccountAssetInformation = class extends JSONRequest {
        constructor(c2, account, assetID) {
          super(c2);
          this.account = account.toString();
          this.assetID = BigInt(assetID);
        }
        path() {
          return `/v2/accounts/${this.account}/assets/${this.assetID}`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), AccountAssetResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/accountApplicationInformation.js
  var AccountApplicationInformation;
  var init_accountApplicationInformation = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/accountApplicationInformation.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      AccountApplicationInformation = class extends JSONRequest {
        constructor(c2, account, applicationID) {
          super(c2);
          this.account = account.toString();
          this.applicationID = BigInt(applicationID);
        }
        path() {
          return `/v2/accounts/${this.account}/applications/${this.applicationID}`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), AccountApplicationResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/block.js
  var Block2;
  var init_block2 = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/block.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      Block2 = class extends JSONRequest {
        constructor(c2, roundNumber) {
          super(c2);
          this.round = BigInt(roundNumber);
          this.query = { format: "msgpack" };
        }
        path() {
          return `/v2/blocks/${this.round}`;
        }
        /**
         * If true, only the block header (exclusive of payset or certificate) may be included in response.
         *
         * #### Example
         * ```typescript
         *
         * const roundNumber = 41000000;
         *
         * const blockResponse = await algodClient
         *        .block(roundNumber)
         *        .headerOnly(true)
         *        .do();
         * ```
         *
         * @param headerOnly - the flag indicating whether exclusively return header in response
         * @category query
         */
        headerOnly(headerOnly) {
          this.query["header-only"] = headerOnly;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeMsgpack(response.body, BlockResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/compile.js
  function setHeaders(headers = {}) {
    let hdrs = headers;
    if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
      hdrs = { ...headers };
      hdrs["Content-Type"] = "text/plain";
    }
    return hdrs;
  }
  var Compile;
  var init_compile = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/compile.js"() {
      init_polyfills();
      init_binarydata();
      init_encoding3();
      init_types3();
      init_jsonrequest();
      Compile = class extends JSONRequest {
        constructor(c2, source) {
          super(c2);
          this.source = source;
        }
        // eslint-disable-next-line class-methods-use-this
        path() {
          return `/v2/teal/compile`;
        }
        sourcemap(map = true) {
          this.query.sourcemap = map;
          return this;
        }
        executeRequest(headers, customOptions) {
          const txHeaders = setHeaders(headers);
          return this.c.post({
            relativePath: this.path(),
            data: coerceToBytes(this.source),
            query: this.query,
            requestHeaders: txHeaders,
            customOptions
          });
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), CompileResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/dryrun.js
  var Dryrun;
  var init_dryrun = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/dryrun.js"() {
      init_polyfills();
      init_encoding3();
      init_jsonrequest();
      init_compile();
      init_types3();
      Dryrun = class extends JSONRequest {
        constructor(c2, dr) {
          super(c2);
          this.blob = encodeMsgpack(dr);
        }
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/v2/teal/dryrun";
        }
        executeRequest(headers, customOptions) {
          const txHeaders = setHeaders(headers);
          return this.c.post({
            relativePath: this.path(),
            data: this.blob,
            requestHeaders: txHeaders,
            customOptions
          });
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), DryrunResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/genesis.js
  var Genesis;
  var init_genesis = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/genesis.js"() {
      init_polyfills();
      init_jsonrequest();
      Genesis = class extends JSONRequest {
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/genesis";
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return response.getJSONText();
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getAssetByID.js
  var GetAssetByID;
  var init_getAssetByID = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getAssetByID.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      GetAssetByID = class extends JSONRequest {
        constructor(c2, index) {
          super(c2);
          this.index = BigInt(index);
        }
        path() {
          return `/v2/assets/${this.index}`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), Asset);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getApplicationByID.js
  var GetApplicationByID;
  var init_getApplicationByID = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getApplicationByID.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      GetApplicationByID = class extends JSONRequest {
        constructor(c2, index) {
          super(c2);
          this.index = BigInt(index);
        }
        path() {
          return `/v2/applications/${this.index}`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), Application);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getBlockHash.js
  var GetBlockHash;
  var init_getBlockHash = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getBlockHash.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      GetBlockHash = class extends JSONRequest {
        constructor(c2, roundNumber) {
          super(c2);
          this.round = BigInt(roundNumber);
        }
        path() {
          return `/v2/blocks/${this.round}/hash`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), BlockHashResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getBlockTxids.js
  var GetBlockTxids;
  var init_getBlockTxids = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getBlockTxids.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      GetBlockTxids = class extends JSONRequest {
        constructor(c2, roundNumber) {
          super(c2);
          this.round = BigInt(roundNumber);
        }
        path() {
          return `/v2/blocks/${this.round}/txids`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), BlockTxidsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getApplicationBoxByName.js
  var GetApplicationBoxByName;
  var init_getApplicationBoxByName = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getApplicationBoxByName.js"() {
      init_polyfills();
      init_binarydata();
      init_encoding3();
      init_jsonrequest();
      init_types3();
      GetApplicationBoxByName = class extends JSONRequest {
        constructor(c2, index, name) {
          super(c2);
          this.index = BigInt(index);
          const encodedName = bytesToBase64(name);
          this.query.name = encodeURI(`b64:${encodedName}`);
        }
        /**
         * @returns `/v2/applications/${index}/box`
         */
        path() {
          return `/v2/applications/${this.index}/box`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), Box);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getApplicationBoxes.js
  var GetApplicationBoxes;
  var init_getApplicationBoxes = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getApplicationBoxes.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      GetApplicationBoxes = class extends JSONRequest {
        constructor(c2, index) {
          super(c2);
          this.index = BigInt(index);
          this.query.max = 0;
        }
        /**
         * @returns `/v2/applications/${index}/boxes`
         */
        path() {
          return `/v2/applications/${this.index}/boxes`;
        }
        /**
         * Limit results for pagination.
         *
         * #### Example
         * ```typescript
         * const maxResults = 20;
         * const boxesResult = await algodClient
         *        .GetApplicationBoxes(1234)
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit - maximum number of results to return.
         * @category query
         */
        max(max) {
          this.query.max = max;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), BoxesResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/healthCheck.js
  var HealthCheck;
  var init_healthCheck = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/healthCheck.js"() {
      init_polyfills();
      init_jsonrequest();
      HealthCheck = class extends JSONRequest {
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/health";
        }
        // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
        prepare(_response) {
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactionInformation.js
  var PendingTransactionInformation;
  var init_pendingTransactionInformation = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactionInformation.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      PendingTransactionInformation = class extends JSONRequest {
        constructor(c2, txid) {
          super(c2);
          this.txid = txid;
          this.query.format = "msgpack";
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeMsgpack(response.body, PendingTransactionResponse);
        }
        path() {
          return `/v2/transactions/pending/${this.txid}`;
        }
        // max sets the maximum number of txs to return
        max(max) {
          this.query.max = max;
          return this;
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactions.js
  var PendingTransactions;
  var init_pendingTransactions = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactions.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      PendingTransactions = class extends JSONRequest {
        constructor(c2) {
          super(c2);
          this.query.format = "msgpack";
        }
        /* eslint-disable class-methods-use-this */
        path() {
          return "/v2/transactions/pending";
        }
        prepare(response) {
          return decodeMsgpack(response.body, PendingTransactionsResponse);
        }
        /* eslint-enable class-methods-use-this */
        // max sets the maximum number of txs to return
        max(max) {
          this.query.max = max;
          return this;
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactionsByAddress.js
  var PendingTransactionsByAddress;
  var init_pendingTransactionsByAddress = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactionsByAddress.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      PendingTransactionsByAddress = class extends JSONRequest {
        constructor(c2, address) {
          super(c2);
          this.address = address.toString();
          this.query.format = "msgpack";
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeMsgpack(response.body, PendingTransactionsResponse);
        }
        path() {
          return `/v2/accounts/${this.address}/transactions/pending`;
        }
        // max sets the maximum number of txs to return
        max(max) {
          this.query.max = max;
          return this;
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getTransactionProof.js
  var GetTransactionProof;
  var init_getTransactionProof = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getTransactionProof.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      GetTransactionProof = class extends JSONRequest {
        constructor(c2, round, txID) {
          super(c2);
          this.txID = txID;
          this.round = BigInt(round);
        }
        path() {
          return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
        }
        /**
         * Exclude assets and application data from results
         * The type of hash function used to create the proof, must be one of: "sha512_256", "sha256"
         *
         * #### Example
         * ```typescript
         * const hashType = "sha256";
         * const round = 123456;
         * const txId = "abc123;
         * const txProof = await algodClient.getTransactionProof(round, txId)
         *        .hashType(hashType)
         *        .do();
         * ```
         *
         * @param hashType
         * @category query
         */
        hashType(hashType) {
          this.query.hashtype = hashType;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), TransactionProofResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/sendRawTransaction.js
  function setSendTransactionHeaders(headers = {}) {
    let hdrs = headers;
    if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
      hdrs = { ...headers };
      hdrs["Content-Type"] = "application/x-binary";
    }
    return hdrs;
  }
  function isByteArray(array) {
    return array && array.byteLength !== void 0;
  }
  var SendRawTransaction;
  var init_sendRawTransaction = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/sendRawTransaction.js"() {
      init_polyfills();
      init_utils();
      init_types3();
      init_encoding3();
      init_jsonrequest();
      SendRawTransaction = class extends JSONRequest {
        constructor(c2, stxOrStxs) {
          super(c2);
          let forPosting = stxOrStxs;
          if (Array.isArray(stxOrStxs)) {
            if (!stxOrStxs.every(isByteArray)) {
              throw new TypeError("Array elements must be byte arrays");
            }
            forPosting = concatArrays2(...stxOrStxs);
          } else if (!isByteArray(forPosting)) {
            throw new TypeError("Argument must be byte array");
          }
          this.txnBytesToPost = forPosting;
        }
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/v2/transactions";
        }
        executeRequest(headers, customOptions) {
          const txHeaders = setSendTransactionHeaders(headers);
          return this.c.post({
            relativePath: this.path(),
            data: this.txnBytesToPost,
            requestHeaders: txHeaders,
            customOptions
          });
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), PostTransactionsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/status.js
  var Status;
  var init_status = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/status.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      Status = class extends JSONRequest {
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/v2/status";
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), NodeStatusResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/statusAfterBlock.js
  var StatusAfterBlock;
  var init_statusAfterBlock = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/statusAfterBlock.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      StatusAfterBlock = class extends JSONRequest {
        constructor(c2, round) {
          super(c2);
          this.round = BigInt(round);
        }
        path() {
          return `/v2/status/wait-for-block-after/${this.round}`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), NodeStatusResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/suggestedParams.js
  var SuggestedParamsRequest;
  var init_suggestedParams = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/suggestedParams.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      SuggestedParamsRequest = class extends JSONRequest {
        /* eslint-disable class-methods-use-this */
        path() {
          return "/v2/transactions/params";
        }
        prepare(response) {
          const params = decodeJSON(response.getJSONText(), TransactionParametersResponse);
          return {
            flatFee: false,
            fee: params.fee,
            firstValid: params.lastRound,
            lastValid: params.lastRound + BigInt(1e3),
            genesisID: params.genesisId,
            genesisHash: params.genesisHash,
            minFee: params.minFee,
            consensusVersion: params.consensusVersion
          };
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/supply.js
  var Supply;
  var init_supply = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/supply.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      Supply = class extends JSONRequest {
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/v2/ledger/supply";
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), SupplyResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/versions.js
  var Versions;
  var init_versions = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/versions.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      Versions = class extends JSONRequest {
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/versions";
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), Version);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/lightBlockHeaderProof.js
  var LightBlockHeaderProof2;
  var init_lightBlockHeaderProof = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/lightBlockHeaderProof.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      LightBlockHeaderProof2 = class extends JSONRequest {
        constructor(c2, round) {
          super(c2);
          this.round = BigInt(round);
        }
        path() {
          return `/v2/blocks/${this.round}/lightheader/proof`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), LightBlockHeaderProof);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/stateproof.js
  var StateProof3;
  var init_stateproof2 = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/stateproof.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      StateProof3 = class extends JSONRequest {
        constructor(c2, round) {
          super(c2);
          this.round = BigInt(round);
        }
        path() {
          return `/v2/stateproofs/${this.round}`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), StateProof2);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/setSyncRound.js
  var SetSyncRound;
  var init_setSyncRound = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/setSyncRound.js"() {
      init_polyfills();
      init_jsonrequest();
      SetSyncRound = class extends JSONRequest {
        constructor(c2, round) {
          super(c2);
          this.round = BigInt(round);
        }
        path() {
          return `/v2/ledger/sync/${this.round}`;
        }
        executeRequest(headers, customOptions) {
          return this.c.post({
            relativePath: this.path(),
            data: null,
            requestHeaders: headers,
            customOptions
          });
        }
        // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
        prepare(_response) {
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getSyncRound.js
  var GetSyncRound;
  var init_getSyncRound = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getSyncRound.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      GetSyncRound = class extends JSONRequest {
        // eslint-disable-next-line class-methods-use-this
        path() {
          return `/v2/ledger/sync`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), GetSyncRoundResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/setBlockOffsetTimestamp.js
  var SetBlockOffsetTimestamp;
  var init_setBlockOffsetTimestamp = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/setBlockOffsetTimestamp.js"() {
      init_polyfills();
      init_jsonrequest();
      SetBlockOffsetTimestamp = class extends JSONRequest {
        constructor(c2, offset) {
          super(c2);
          this.offset = BigInt(offset);
        }
        path() {
          return `/v2/devmode/blocks/offset/${this.offset}`;
        }
        executeRequest(headers, customOptions) {
          return this.c.post({
            relativePath: this.path(),
            data: null,
            requestHeaders: headers,
            customOptions
          });
        }
        // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
        prepare(_response) {
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getBlockOffsetTimestamp.js
  var GetBlockOffsetTimestamp;
  var init_getBlockOffsetTimestamp = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getBlockOffsetTimestamp.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types3();
      GetBlockOffsetTimestamp = class extends JSONRequest {
        // eslint-disable-next-line class-methods-use-this
        path() {
          return `/v2/devmode/blocks/offset`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), GetBlockTimeStampOffsetResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/disassemble.js
  function setHeaders2(headers = {}) {
    let hdrs = headers;
    if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
      hdrs = { ...headers };
      hdrs["Content-Type"] = "text/plain";
    }
    return hdrs;
  }
  var Disassemble;
  var init_disassemble = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/disassemble.js"() {
      init_polyfills();
      init_binarydata();
      init_encoding3();
      init_types3();
      init_jsonrequest();
      Disassemble = class extends JSONRequest {
        constructor(c2, source) {
          super(c2);
          this.source = source;
        }
        // eslint-disable-next-line class-methods-use-this
        path() {
          return `/v2/teal/disassemble`;
        }
        executeRequest(headers, customOptions) {
          const txHeaders = setHeaders2(headers);
          return this.c.post({
            relativePath: this.path(),
            data: coerceToBytes(this.source),
            query: this.query,
            requestHeaders: txHeaders,
            customOptions
          });
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), DisassembleResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/simulateTransaction.js
  function setSimulateTransactionsHeaders(headers = {}) {
    let hdrs = headers;
    if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
      hdrs = { ...headers };
      hdrs["Content-Type"] = "application/msgpack";
    }
    return hdrs;
  }
  var SimulateRawTransactions;
  var init_simulateTransaction = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/simulateTransaction.js"() {
      init_polyfills();
      init_encoding3();
      init_jsonrequest();
      init_types3();
      SimulateRawTransactions = class extends JSONRequest {
        constructor(c2, request) {
          super(c2);
          this.query.format = "msgpack";
          this.requestBytes = encodeMsgpack(request);
        }
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/v2/transactions/simulate";
        }
        executeRequest(headers, customOptions) {
          const txHeaders = setSimulateTransactionsHeaders(headers);
          return this.c.post({
            relativePath: this.path(),
            data: this.requestBytes,
            query: this.query,
            requestHeaders: txHeaders,
            customOptions
          });
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeMsgpack(response.body, SimulateResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/ready.js
  var Ready;
  var init_ready = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/ready.js"() {
      init_polyfills();
      init_jsonrequest();
      Ready = class extends JSONRequest {
        // eslint-disable-next-line class-methods-use-this
        path() {
          return `/ready`;
        }
        // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
        prepare(_response) {
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/unsetSyncRound.js
  var UnsetSyncRound;
  var init_unsetSyncRound = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/unsetSyncRound.js"() {
      init_polyfills();
      init_jsonrequest();
      UnsetSyncRound = class extends JSONRequest {
        // eslint-disable-next-line class-methods-use-this
        path() {
          return `/v2/ledger/sync`;
        }
        executeRequest(headers, customOptions) {
          return this.c.delete({
            relativePath: this.path(),
            data: void 0,
            requestHeaders: headers,
            customOptions
          });
        }
        // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
        prepare(_response) {
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getLedgerStateDeltaForTransactionGroup.js
  var GetLedgerStateDeltaForTransactionGroup;
  var init_getLedgerStateDeltaForTransactionGroup = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getLedgerStateDeltaForTransactionGroup.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_statedelta();
      GetLedgerStateDeltaForTransactionGroup = class extends JSONRequest {
        constructor(c2, id) {
          super(c2);
          this.id = id;
          this.query = { format: "msgpack" };
        }
        // eslint-disable-next-line class-methods-use-this
        path() {
          return `/v2/deltas/txn/group/${this.id}`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeMsgpack(response.body, LedgerStateDelta);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getLedgerStateDelta.js
  var GetLedgerStateDelta;
  var init_getLedgerStateDelta = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getLedgerStateDelta.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_statedelta();
      GetLedgerStateDelta = class extends JSONRequest {
        constructor(c2, round) {
          super(c2);
          this.round = BigInt(round);
          this.query = { format: "msgpack" };
        }
        // eslint-disable-next-line class-methods-use-this
        path() {
          return `/v2/deltas/${this.round}`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeMsgpack(response.body, LedgerStateDelta);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/getTransactionGroupLedgerStateDeltasForRound.js
  var GetTransactionGroupLedgerStateDeltasForRound;
  var init_getTransactionGroupLedgerStateDeltasForRound = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/getTransactionGroupLedgerStateDeltasForRound.js"() {
      init_polyfills();
      init_jsonrequest();
      init_types3();
      init_encoding3();
      GetTransactionGroupLedgerStateDeltasForRound = class extends JSONRequest {
        constructor(c2, round) {
          super(c2);
          this.round = BigInt(round);
          this.query = { format: "msgpack" };
        }
        // eslint-disable-next-line class-methods-use-this
        path() {
          return `/v2/deltas/${this.round}/txn/group`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeMsgpack(response.body, TransactionGroupLedgerStateDeltasForRoundResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/algod/algod.js
  var AlgodClient;
  var init_algod = __esm({
    "node_modules/algosdk/dist/esm/client/v2/algod/algod.js"() {
      init_polyfills();
      init_serviceClient();
      init_types3();
      init_accountInformation();
      init_accountAssetInformation();
      init_accountApplicationInformation();
      init_block2();
      init_compile();
      init_dryrun();
      init_genesis();
      init_getAssetByID();
      init_getApplicationByID();
      init_getBlockHash();
      init_getBlockTxids();
      init_getApplicationBoxByName();
      init_getApplicationBoxes();
      init_healthCheck();
      init_pendingTransactionInformation();
      init_pendingTransactions();
      init_pendingTransactionsByAddress();
      init_getTransactionProof();
      init_sendRawTransaction();
      init_status();
      init_statusAfterBlock();
      init_suggestedParams();
      init_supply();
      init_versions();
      init_lightBlockHeaderProof();
      init_stateproof2();
      init_setSyncRound();
      init_getSyncRound();
      init_setBlockOffsetTimestamp();
      init_getBlockOffsetTimestamp();
      init_disassemble();
      init_simulateTransaction();
      init_signedTransaction();
      init_encoding3();
      init_ready();
      init_unsetSyncRound();
      init_getLedgerStateDeltaForTransactionGroup();
      init_getLedgerStateDelta();
      init_getTransactionGroupLedgerStateDeltasForRound();
      AlgodClient = class extends ServiceClient {
        /**
         * Create an AlgodClient from
         * * either a token, baseServer, port, and optional headers
         * * or a base client server for interoperability with external dApp wallets
         *
         * #### Example
         * ```typescript
         * const token  = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
         * const server = "http://localhost";
         * const port   = 4001;
         * const algodClient = new algosdk.Algodv2(token, server, port);
         * ```
         * @remarks
         * The above configuration is for a sandbox private network.
         * For applications on production, you are encouraged to run your own node, or use an Algorand REST API provider with a dedicated API key.
         *
         * @param tokenOrBaseClient - The algod token from the Algorand node you are interacting with
         * @param baseServer - REST endpoint
         * @param port - Port number if specifically configured by the server
         * @param headers - Optional headers
         */
        constructor(tokenOrBaseClient, baseServer, port, headers = {}) {
          super("X-Algo-API-Token", tokenOrBaseClient, baseServer, port, headers);
        }
        /**
         * Returns OK if healthy.
         *
         * #### Example
         * ```typescript
         * await algodClient.healthCheck().do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-health)
         * @category GET
         */
        healthCheck() {
          return new HealthCheck(this.c);
        }
        /**
         * Retrieves the supported API versions, binary build versions, and genesis information.
         *
         * #### Example
         * ```typescript
         * const versionsDetails = await algodClient.versionsCheck().do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-versions)
         * @category GET
         */
        versionsCheck() {
          return new Versions(this.c);
        }
        /**
         * Broadcasts a raw transaction to the network.
         *
         * #### Example
         * ```typescript
         * const { txid } = await algodClient.sendRawTransaction(signedTxns).do();
         * const result = await waitForConfirmation(algodClient, txid, 3);
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactions)
         *
         * @remarks
         * Often used with {@linkcode waitForConfirmation}
         * @param stxOrStxs - Signed transactions
         * @category POST
         */
        sendRawTransaction(stxOrStxs) {
          return new SendRawTransaction(this.c, stxOrStxs);
        }
        /**
         * Returns the given account's status, balance and spendable amounts.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountInfo = await algodClient.accountInformation(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
         * @param account - The address of the account to look up.
         * @category GET
         */
        accountInformation(account) {
          return new AccountInformation(this.c, account);
        }
        /**
         * Returns the given account's asset information for a specific asset.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const index = 60553466;
         * const accountAssetInfo = await algodClient.accountAssetInformation(address, index).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
         * @param account - The address of the account to look up.
         * @param index - The asset ID to look up.
         * @category GET
         */
        accountAssetInformation(account, index) {
          return new AccountAssetInformation(this.c, account, index);
        }
        /**
         * Returns the given account's application information for a specific application.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const index = 60553466;
         * const accountInfo = await algodClient.accountApplicationInformation(address, index).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
         * @param account - The address of the account to look up.
         * @param index - The application ID to look up.
         * @category GET
         */
        accountApplicationInformation(account, index) {
          return new AccountApplicationInformation(this.c, account, index);
        }
        /**
         * Gets the block info for the given round.
         *
         * #### Example
         * ```typescript
         * const roundNumber = 18038133;
         * const block = await algodClient.block(roundNumber).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksround)
         * @param roundNumber - The round number of the block to get.
         * @category GET
         */
        block(roundNumber) {
          return new Block2(this.c, roundNumber);
        }
        /**
         * Get the block hash for the block on the given round.
         *
         * #### Example
         * ```typescript
         * const roundNumber = 18038133;
         * const block = await algodClient.getBlockHash(roundNumber).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksroundhash)
         * @param roundNumber - The round number of the block to get.
         * @category GET
         */
        getBlockHash(roundNumber) {
          return new GetBlockHash(this.c, roundNumber);
        }
        /**
         * Get the top level transaction IDs for the block on the given round.
         *
         * #### Example
         * ```typescript
         * const roundNumber = 18038133;
         * const block = await algodClient.getBlockTxids(roundNumber).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksroundtxids)
         * @param roundNumber - The round number of the block to get.
         * @category GET
         */
        getBlockTxids(roundNumber) {
          return new GetBlockTxids(this.c, roundNumber);
        }
        /**
         * Returns the transaction information for a specific pending transaction.
         *
         * #### Example
         * ```typescript
         * const txId = "DRJS6R745A7GFVMXEXWP4TGVDGKW7VILFTA7HC2BR2GRLHNY5CTA";
         * const pending = await algodClient.pendingTransactionInformation(txId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionspendingtxid)
         *
         * @remarks
         * <br><br>
         * There are several cases when this might succeed:
         * - transaction committed (committed round > 0)
         * - transaction still in the pool (committed round = 0, pool error = "")
         * - transaction removed from pool due to error (committed round = 0, pool error != "")
         *
         * Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
         *
         * @param txid - The TxID string of the pending transaction to look up.
         * @category GET
         */
        pendingTransactionInformation(txid) {
          return new PendingTransactionInformation(this.c, txid);
        }
        /**
         * Returns the list of pending transactions in the pool, sorted by priority, in decreasing order, truncated at the end at MAX.
         * If MAX = 0, returns all pending transactions.
         *
         * #### Example 1
         * ```typescript
         * const pendingTxns = await algodClient.pendingTransactionsInformation().do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const maxTxns = 5;
         * const pendingTxns = await algodClient
         *     .pendingTransactionsInformation()
         *     .max(maxTxns)
         *     .do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionspending)
         * @category GET
         */
        pendingTransactionsInformation() {
          return new PendingTransactions(this.c);
        }
        /**
         * Returns the list of pending transactions sent by the address, sorted by priority, in decreasing order, truncated at the end at MAX.
         * If MAX = 0, returns all pending transactions.
         *
         * #### Example 1
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const pendingTxnsByAddr = await algodClient.pendingTransactionByAddress(address).do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const maxTxns = 5;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const pendingTxns = await algodClient
         *     .pendingTransactionByAddress(address)
         *     .max(maxTxns)
         *     .do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddresstransactionspending)
         * @param address - The address of the sender.
         * @category GET
         */
        pendingTransactionByAddress(address) {
          return new PendingTransactionsByAddress(this.c, address);
        }
        /**
         * Retrieves the StatusResponse from the running node.
         *
         * #### Example
         * ```typescript
         * const status = await algodClient.status().do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2status)
         * @category GET
         */
        status() {
          return new Status(this.c);
        }
        /**
         * Waits for a specific round to occur then returns the `StatusResponse` for that round.
         *
         * #### Example
         * ```typescript
         * const round = 18038133;
         * const statusAfterBlock = await algodClient.statusAfterBlock(round).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2statuswait-for-block-afterround)
         * @param round - The number of the round to wait for.
         * @category GET
         */
        statusAfterBlock(round) {
          return new StatusAfterBlock(this.c, round);
        }
        /**
         * Returns the common needed parameters for a new transaction.
         *
         * #### Example
         * ```typescript
         * const suggestedParams = await algodClient.getTransactionParams().do();
         * const amountInMicroAlgos = algosdk.algosToMicroalgos(2); // 2 Algos
         * const unsignedTxn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
         *   sender: senderAddress,
         *   receiver: receiverAddress,
         *   amount: amountInMicroAlgos,
         *   suggestedParams: suggestedParams,
         * });
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionsparams)
         *
         * @remarks
         * Often used with
         * {@linkcode makePaymentTxnWithSuggestedParamsFromObject}, {@linkcode algosToMicroalgos}
         * @category GET
         */
        getTransactionParams() {
          return new SuggestedParamsRequest(this.c);
        }
        /**
         * Returns the supply details for the specified node's ledger.
         *
         * #### Example
         * ```typescript
         * const supplyDetails = await algodClient.supply().do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2ledgersupply)
         * @category GET
         */
        supply() {
          return new Supply(this.c);
        }
        /**
         * Compiles TEAL source code to binary, returns base64 encoded program bytes and base32 SHA512_256 hash of program bytes (Address style).
         *
         * #### Example
         * ```typescript
         * const source = "TEAL SOURCE CODE";
         * const compiledSmartContract = await algodClient.compile(source).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2tealcompile)
         * @remarks
         * This endpoint is only enabled when a node's configuration file sets `EnableDeveloperAPI` to true.
         * @param source
         * @category POST
         */
        compile(source) {
          return new Compile(this.c, source);
        }
        /**
         * Given the program bytes, return the TEAL source code in plain text.
         *
         * #### Example
         * ```typescript
         * const bytecode = "TEAL bytecode";
         * const disassembledSource = await algodClient.disassemble(bytecode).do();
         * ```
         *
         * @remarks This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
         * @param source
         */
        disassemble(source) {
          return new Disassemble(this.c, source);
        }
        /**
         * Provides debugging information for a transaction (or group).
         *
         * Executes TEAL program(s) in context and returns debugging information about the execution. This endpoint is only enabled when a node's configureation file sets `EnableDeveloperAPI` to true.
         *
         * #### Example
         * ```typescript
         * const dryRunResult = await algodClient.dryrun(dr).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2tealdryrun)
         * @param dr
         * @category POST
         */
        dryrun(dr) {
          return new Dryrun(this.c, dr);
        }
        /**
         * Given an asset ID, return asset information including creator, name, total supply and
         * special addresses.
         *
         * #### Example
         * ```typescript
         * const asset_id = 163650;
         * const asset = await algodClient.getAssetByID(asset_id).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2assetsasset-id)
         * @param index - The asset ID to look up.
         * @category GET
         */
        getAssetByID(index) {
          return new GetAssetByID(this.c, index);
        }
        /**
         * Given an application ID, return the application information including creator, approval
         * and clear programs, global and local schemas, and global state.
         *
         * #### Example
         * ```typescript
         * const index = 60553466;
         * const app = await algodClient.getApplicationByID(index).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-id)
         * @param index - The application ID to look up.
         * @category GET
         */
        getApplicationByID(index) {
          return new GetApplicationByID(this.c, index);
        }
        /**
         * Given an application ID and the box name (key), return the value stored in the box.
         *
         * #### Example
         * ```typescript
         * const index = 60553466;
         * const boxName = Buffer.from("foo");
         * const boxResponse = await algodClient.getApplicationBoxByName(index, boxName).do();
         * const boxValue = boxResponse.value;
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-idbox)
         * @param index - The application ID to look up.
         * @category GET
         */
        getApplicationBoxByName(index, boxName) {
          return new GetApplicationBoxByName(this.c, index, boxName);
        }
        /**
         * Given an application ID, return all the box names associated with the app.
         *
         * #### Example
         * ```typescript
         * const index = 60553466;
         * const boxesResponse = await algodClient.getApplicationBoxes(index).max(3).do();
         * const boxNames = boxesResponse.boxes.map(box => box.name);
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-idboxes)
         * @param index - The application ID to look up.
         * @category GET
         */
        getApplicationBoxes(index) {
          return new GetApplicationBoxes(this.c, index);
        }
        /**
         * Returns the entire genesis file.
         *
         * #### Example
         * ```typescript
         * const genesis = await algodClient.genesis().do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-genesis)
         * @category GET
         */
        genesis() {
          return new Genesis(this.c);
        }
        /**
         * Returns a Merkle proof for a given transaction in a block.
         *
         * #### Example
         * ```typescript
         * const round = 18038133;
         * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
         * const proof = await algodClient.getTransactionProof(round, txId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksroundtransactionstxidproof)
         * @param round - The round in which the transaction appears.
         * @param txID - The transaction ID for which to generate a proof.
         * @category GET
         */
        getTransactionProof(round, txID) {
          return new GetTransactionProof(this.c, round, txID);
        }
        /**
         * Gets a proof for a given light block header inside a state proof commitment.
         *
         * #### Example
         * ```typescript
         * const round = 11111111;
         * const lightBlockHeaderProof = await algodClient.getLightBlockHeaderProof(round).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2blocksroundlightheaderproof)
         * @param round
         */
        getLightBlockHeaderProof(round) {
          return new LightBlockHeaderProof2(this.c, round);
        }
        /**
         * Gets a state proof that covers a given round.
         *
         * #### Example
         * ```typescript
         * const round = 11111111;
         * const stateProof = await algodClient.getStateProof(round).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2stateproofsround)
         * @param round
         */
        getStateProof(round) {
          return new StateProof3(this.c, round);
        }
        /**
         * Simulate a list of a signed transaction objects being sent to the network.
         *
         * #### Example
         * ```typescript
         * const txn1 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn1Params);
         * const txn2 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn2Params);
         * const txgroup = algosdk.assignGroupID([txn1, txn2]);
         *
         * // Actually sign the first transaction
         * const signedTxn1 = txgroup[0].signTxn(senderSk).blob;
         * // Simulate does not require signed transactions -- use this method to encode an unsigned transaction
         * const signedTxn2 = algosdk.encodeUnsignedSimulateTransaction(txgroup[1]);
         *
         * const resp = await client.simulateRawTransactions([signedTxn1, signedTxn2]).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactionssimulate)
         * @param stxOrStxs
         * @category POST
         */
        simulateRawTransactions(stxOrStxs) {
          const txnObjects = [];
          if (Array.isArray(stxOrStxs)) {
            for (const stxn of stxOrStxs) {
              txnObjects.push(decodeMsgpack(stxn, SignedTransaction));
            }
          } else {
            txnObjects.push(decodeMsgpack(stxOrStxs, SignedTransaction));
          }
          const request = new SimulateRequest({
            txnGroups: [
              new SimulateRequestTransactionGroup({
                txns: txnObjects
              })
            ]
          });
          return this.simulateTransactions(request);
        }
        /**
         * Simulate transactions being sent to the network.
         *
         * #### Example
         * ```typescript
         * const txn1 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn1Params);
         * const txn2 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn2Params);
         * const txgroup = algosdk.assignGroupID([txn1, txn2]);
         *
         * // Actually sign the first transaction
         * const signedTxn1 = txgroup[0].signTxn(senderSk).blob;
         * // Simulate does not require signed transactions -- use this method to encode an unsigned transaction
         * const signedTxn2 = algosdk.encodeUnsignedSimulateTransaction(txgroup[1]);
         *
         * const request = new modelsv2.SimulateRequest({
         *  txnGroups: [
         *    new modelsv2.SimulateRequestTransactionGroup({
         *       // Must decode the signed txn bytes into an object
         *       txns: [algosdk.decodeObj(signedTxn1), algosdk.decodeObj(signedTxn2)]
         *     }),
         *   ],
         * });
         * const resp = await client.simulateRawTransactions(request).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactionssimulate)
         * @param request
         * @category POST
         */
        simulateTransactions(request) {
          return new SimulateRawTransactions(this.c, request);
        }
        /**
         * Set the offset (in seconds) applied to the block timestamp when creating new blocks in devmode.
         *
         *  #### Example
         *  ```typesecript
         *  const offset = 60
         *  await client.setBlockOffsetTimestamp(offset).do();
         *  ```
         *
         [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2devmodeblocksoffsetoffset)
         * @param offset
         * @category POST
         */
        setBlockOffsetTimestamp(offset) {
          return new SetBlockOffsetTimestamp(this.c, offset);
        }
        /**
         * Get the offset (in seconds) applied to the block timestamp when creating new blocks in devmode.
         *
         *  #### Example
         *  ```typesecript
         *  const currentOffset = await client.getBlockOffsetTimestamp().do();
         *  ```
         *
         [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2devmodeblocksoffset)
         * @category GET
         */
        getBlockOffsetTimestamp() {
          return new GetBlockOffsetTimestamp(this.c);
        }
        /**
         * Set the sync round on the ledger (algod must have EnableFollowMode: true), restricting catchup.
         *
         *  #### Example
         *  ```typesecript
         *  const round = 10000
         *  await client.setSyncRound(round).do();
         *  ```
         *
         [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2ledgersyncround)
         * @param round
         * @category POST
         */
        setSyncRound(round) {
          return new SetSyncRound(this.c, round);
        }
        /**
         * Un-Set the sync round on the ledger (algod must have EnableFollowMode: true), removing the restriction on catchup.
         *
         *  #### Example
         *  ```typesecript
         *  await client.unsetSyncRound().do();
         *  ```
         *
         [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#delete-v2ledgersync)
         * @category DELETE
         */
        unsetSyncRound() {
          return new UnsetSyncRound(this.c);
        }
        /**
         * Get the current sync round on the ledger (algod must have EnableFollowMode: true).
         *
         *  #### Example
         *  ```typesecript
         *  const currentSyncRound = await client.getSyncRound().do();
         *  ```
         *
         [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2ledgersync)
         * @category GET
         */
        getSyncRound() {
          return new GetSyncRound(this.c);
        }
        /**
         * Ready check which returns 200 OK if algod is healthy and caught up
         *
         *  #### Example
         *  ```typesecript
         *  await client.ready().do();
         *  ```
         *
         [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-ready)
         * @category GET
         */
        ready() {
          return new Ready(this.c);
        }
        /**
         * GetLedgerStateDeltaForTransactionGroup returns the ledger delta for the txn group identified by id
         *
         * #### Example
         * ```typescript
         * const id = "ABC123";
         * await client.getLedgerStateDeltaForTransactionGroup(id).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltastxngroupid)
         * @param id txn ID or group ID to be searched for
         * @category GET
         */
        getLedgerStateDeltaForTransactionGroup(id) {
          return new GetLedgerStateDeltaForTransactionGroup(this.c, id);
        }
        /**
         * GetLedgerStateDelta returns the ledger delta for the entire round
         *
         * #### Example
         * ```typescript
         * const round = 12345;
         * await client.getLedgerStateDelta(round).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltasround)
         * @param round the round number to be searched for
         * @category GET
         */
        getLedgerStateDelta(round) {
          return new GetLedgerStateDelta(this.c, round);
        }
        /**
         * GetTransactionGroupLedgerStateDeltasForRound returns all ledger deltas for txn groups in the provided round
         *
         * #### Example
         * ```typescript
         * const round = 12345;
         * await client.getTransactionGroupLedgerStateDeltasForRound(round).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltasroundtxngroup)
         * @param round the round number to be searched for
         * @category GET
         */
        getTransactionGroupLedgerStateDeltasForRound(round) {
          return new GetTransactionGroupLedgerStateDeltasForRound(this.c, round);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/kmd.js
  var KmdClient;
  var init_kmd = __esm({
    "node_modules/algosdk/dist/esm/client/kmd.js"() {
      init_polyfills();
      init_binarydata();
      init_intDecoding();
      init_serviceClient();
      KmdClient = class extends ServiceClient {
        constructor(token, baseServer = "http://127.0.0.1", port = 7833, headers = {}) {
          super("X-KMD-API-Token", token, baseServer, port, headers);
        }
        async get(relativePath) {
          const res = await this.c.get({
            relativePath
          });
          return res.parseBodyAsJSON({
            // Using SAFE for all KMD endpoints because no integers in responses should ever be too big
            intDecoding: intDecoding_default.SAFE
          });
        }
        async delete(relativePath, data) {
          const res = await this.c.delete({
            relativePath,
            data
          });
          return res.parseBodyAsJSON({
            // Using SAFE for all KMD endpoints because no integers in responses should ever be too big
            intDecoding: intDecoding_default.SAFE
          });
        }
        async post(relativePath, data) {
          const res = await this.c.post({
            relativePath,
            data
          });
          return res.parseBodyAsJSON({
            // Using SAFE for all KMD endpoints because no integers in responses should ever be too big
            intDecoding: intDecoding_default.SAFE
          });
        }
        /**
         * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.
         */
        async versions() {
          return this.get("/versions");
        }
        /**
         * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID
         * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle
         */
        async listWallets() {
          return this.get("/v1/wallets");
        }
        /**
         * createWallet creates a wallet with the specified name, password, driver,
         * and master derivation key. If the master derivation key is blank, one is
         * generated internally to kmd. CreateWallet returns a CreateWalletResponse
         * containing information about the new wallet.
         * @param walletName
         * @param walletPassword
         * @param walletDriverName
         * @param walletMDK
         */
        async createWallet(walletName, walletPassword, walletMDK = new Uint8Array(), walletDriverName = "sqlite") {
          const req = {
            wallet_name: walletName,
            wallet_driver_name: walletDriverName,
            wallet_password: walletPassword,
            master_derivation_key: bytesToBase64(walletMDK)
          };
          return this.post("/v1/wallet", req);
        }
        /**
         * initWalletHandle accepts a wallet ID and a wallet password, and returns an
         * initWalletHandleResponse containing a wallet handle token. This wallet
         * handle token can be used for subsequent operations on this wallet, like key
         * generation, transaction signing, etc.. WalletHandleTokens expire after a
         * configurable number of seconds, and must be renewed periodically with
         * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when
         * you're done interacting with this wallet.
         * @param walletID
         * @param walletPassword
         */
        async initWalletHandle(walletID, walletPassword) {
          const req = {
            wallet_id: walletID,
            wallet_password: walletPassword
          };
          return this.post("/v1/wallet/init", req);
        }
        /**
         * releaseWalletHandle invalidates the passed wallet handle token, making
         * it unusuable for subsequent wallet operations.
         * @param walletHandle
         */
        async releaseWalletHandle(walletHandle) {
          const req = {
            wallet_handle_token: walletHandle
          };
          return this.post("/v1/wallet/release", req);
        }
        /**
         * renewWalletHandle accepts a wallet handle and attempts to renew it, moving
         * the expiration time to some number of seconds in the future. It returns a
         * RenewWalletHandleResponse containing the walletHandle and the number of
         * seconds until expiration
         * @param walletHandle
         */
        async renewWalletHandle(walletHandle) {
          const req = {
            wallet_handle_token: walletHandle
          };
          return this.post("/v1/wallet/renew", req);
        }
        /**
         * renameWallet accepts a wallet ID, wallet password, and a new wallet name,
         * and renames the underlying wallet.
         * @param walletID
         * @param walletPassword
         * @param newWalletName
         */
        async renameWallet(walletID, walletPassword, newWalletName) {
          const req = {
            wallet_id: walletID,
            wallet_password: walletPassword,
            wallet_name: newWalletName
          };
          return this.post("/v1/wallet/rename", req);
        }
        /**
         * getWallet accepts a wallet handle and returns high level information about
         * this wallet in a GetWalletResponse.
         * @param walletHandle
         */
        async getWallet(walletHandle) {
          const req = {
            wallet_handle_token: walletHandle
          };
          return this.post("/v1/wallet/info", req);
        }
        /**
         * exportMasterDerivationKey accepts a wallet handle and a wallet password, and
         * returns an ExportMasterDerivationKeyResponse containing the master
         * derivation key. This key can be used as an argument to CreateWallet in
         * order to recover the keys generated by this wallet. The master derivation
         * key can be encoded as a sequence of words using the mnemonic library, and
         * @param walletHandle
         * @param walletPassword
         */
        async exportMasterDerivationKey(walletHandle, walletPassword) {
          const req = {
            wallet_handle_token: walletHandle,
            wallet_password: walletPassword
          };
          const res = await this.post("/v1/master-key/export", req);
          return {
            master_derivation_key: base64ToBytes(res.master_derivation_key)
          };
        }
        /**
         * importKey accepts a wallet handle and an ed25519 private key, and imports
         * the key into the wallet. It returns an ImportKeyResponse containing the
         * address corresponding to this private key.
         * @param walletHandle
         * @param secretKey
         */
        async importKey(walletHandle, secretKey) {
          const req = {
            wallet_handle_token: walletHandle,
            private_key: bytesToBase64(secretKey)
          };
          return this.post("/v1/key/import", req);
        }
        /**
         * exportKey accepts a wallet handle, wallet password, and address, and returns
         * an ExportKeyResponse containing the ed25519 private key corresponding to the
         * address stored in the wallet.
         * @param walletHandle
         * @param walletPassword
         * @param addr
         */
        async exportKey(walletHandle, walletPassword, addr) {
          const req = {
            wallet_handle_token: walletHandle,
            address: addr,
            wallet_password: walletPassword
          };
          const res = await this.post("/v1/key/export", req);
          return { private_key: base64ToBytes(res.private_key) };
        }
        /**
         * generateKey accepts a wallet handle, and then generates the next key in the
         * wallet using its internal master derivation key. Two wallets with the same
         * master derivation key will generate the same sequence of keys.
         * @param walletHandle
         */
        async generateKey(walletHandle) {
          const req = {
            wallet_handle_token: walletHandle,
            display_mnemonic: false
          };
          return this.post("/v1/key", req);
        }
        /**
         * deleteKey accepts a wallet handle, wallet password, and address, and deletes
         * the information about this address from the wallet (including address and
         * secret key). If DeleteKey is called on a key generated using GenerateKey,
         * the same key will not be generated again. However, if a wallet is recovered
         * using the master derivation key, a key generated in this way can be
         * recovered.
         * @param walletHandle
         * @param walletPassword
         * @param addr
         */
        async deleteKey(walletHandle, walletPassword, addr) {
          const req = {
            wallet_handle_token: walletHandle,
            address: addr,
            wallet_password: walletPassword
          };
          return this.delete("/v1/key", req);
        }
        /**
         * ListKeys accepts a wallet handle and returns a ListKeysResponse containing
         * all of the addresses for which this wallet contains secret keys.
         * @param walletHandle
         */
        async listKeys(walletHandle) {
          const req = {
            wallet_handle_token: walletHandle
          };
          return this.post("/v1/key/list", req);
        }
        /**
         * signTransaction accepts a wallet handle, wallet password, and a transaction,
         * and returns and SignTransactionResponse containing an encoded, signed
         * transaction. The transaction is signed using the key corresponding to the
         * Sender field.
         * @param walletHandle
         * @param walletPassword
         * @param transaction
         */
        async signTransaction(walletHandle, walletPassword, transaction) {
          const req = {
            wallet_handle_token: walletHandle,
            wallet_password: walletPassword,
            transaction: bytesToBase64(transaction.toByte())
          };
          const res = await this.post("/v1/transaction/sign", req);
          return base64ToBytes(res.signed_transaction);
        }
        /**
         * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,
         * and returns and SignTransactionResponse containing an encoded, signed
         * transaction. The transaction is signed using the key corresponding to the
         * publicKey arg.
         * @param walletHandle
         * @param walletPassword
         * @param transaction
         * @param publicKey - sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)
         */
        async signTransactionWithSpecificPublicKey(walletHandle, walletPassword, transaction, publicKey) {
          const pk = coerceToBytes(publicKey);
          const req = {
            wallet_handle_token: walletHandle,
            wallet_password: walletPassword,
            transaction: bytesToBase64(transaction.toByte()),
            public_key: bytesToBase64(pk)
          };
          const res = await this.post("/v1/transaction/sign", req);
          return base64ToBytes(res.signed_transaction);
        }
        /**
         * listMultisig accepts a wallet handle and returns a ListMultisigResponse
         * containing the multisig addresses whose preimages are stored in this wallet.
         * A preimage is the information needed to reconstruct this multisig address,
         * including multisig version information, threshold information, and a list
         * of public keys.
         * @param walletHandle
         */
        async listMultisig(walletHandle) {
          const req = {
            wallet_handle_token: walletHandle
          };
          return this.post("/v1/multisig/list", req);
        }
        /**
         * importMultisig accepts a wallet handle and the information required to
         * generate a multisig address. It derives this address, and stores all of the
         * information within the wallet. It returns a ImportMultisigResponse with the
         * derived address.
         * @param walletHandle
         * @param version
         * @param threshold
         * @param pks
         */
        async importMultisig(walletHandle, version, threshold, pks) {
          const req = {
            wallet_handle_token: walletHandle,
            multisig_version: version,
            threshold,
            pks
          };
          return this.post("/v1/multisig/import", req);
        }
        /**
         * exportMultisig accepts a wallet handle, wallet password, and multisig
         * address, and returns an ExportMultisigResponse containing the stored
         * multisig preimage. The preimage contains all of the information necessary
         * to derive the multisig address, including version, threshold, and a list of
         * public keys.
         * @param walletHandle
         * @param walletPassword
         * @param addr
         */
        async exportMultisig(walletHandle, addr) {
          const req = {
            wallet_handle_token: walletHandle,
            address: addr
          };
          return this.post("/v1/multisig/export", req);
        }
        /**
         * signMultisigTransaction accepts a wallet handle, wallet password,
         * transaction, public key (*not* an address), and an optional partial
         * MultisigSig. It looks up the secret key corresponding to the public key, and
         * returns a SignMultisigTransactionResponse containing a MultisigSig with a
         * signature by the secret key included.
         * @param walletHandle
         * @param pw
         * @param tx
         * @param pk
         * @param partial
         */
        async signMultisigTransaction(walletHandle, pw, transaction, pk, partial) {
          const pubkey = coerceToBytes(pk);
          const req = {
            wallet_handle_token: walletHandle,
            transaction: bytesToBase64(transaction.toByte()),
            public_key: bytesToBase64(pubkey),
            partial_multisig: partial,
            wallet_password: pw
          };
          return this.post("/v1/multisig/sign", req);
        }
        /**
         * deleteMultisig accepts a wallet handle, wallet password, and multisig
         * address, and deletes the information about this multisig address from the
         * wallet (including address and secret key).
         * @param walletHandle
         * @param walletPassword
         * @param addr
         */
        async deleteMultisig(walletHandle, walletPassword, addr) {
          const req = {
            wallet_handle_token: walletHandle,
            address: addr,
            wallet_password: walletPassword
          };
          return this.delete("/v1/multisig", req);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/models/types.js
  var types_exports2 = {};
  __export(types_exports2, {
    Account: () => Account2,
    AccountParticipation: () => AccountParticipation2,
    AccountResponse: () => AccountResponse,
    AccountStateDelta: () => AccountStateDelta2,
    AccountsResponse: () => AccountsResponse,
    Application: () => Application2,
    ApplicationLocalState: () => ApplicationLocalState2,
    ApplicationLocalStatesResponse: () => ApplicationLocalStatesResponse,
    ApplicationLogData: () => ApplicationLogData,
    ApplicationLogsResponse: () => ApplicationLogsResponse,
    ApplicationParams: () => ApplicationParams2,
    ApplicationResponse: () => ApplicationResponse,
    ApplicationStateSchema: () => ApplicationStateSchema2,
    ApplicationsResponse: () => ApplicationsResponse,
    Asset: () => Asset2,
    AssetBalancesResponse: () => AssetBalancesResponse,
    AssetHolding: () => AssetHolding3,
    AssetHoldingsResponse: () => AssetHoldingsResponse,
    AssetParams: () => AssetParams3,
    AssetResponse: () => AssetResponse,
    AssetsResponse: () => AssetsResponse,
    Block: () => Block3,
    BlockHeadersResponse: () => BlockHeadersResponse,
    BlockRewards: () => BlockRewards,
    BlockUpgradeState: () => BlockUpgradeState,
    BlockUpgradeVote: () => BlockUpgradeVote,
    Box: () => Box2,
    BoxDescriptor: () => BoxDescriptor2,
    BoxesResponse: () => BoxesResponse2,
    ErrorResponse: () => ErrorResponse2,
    EvalDelta: () => EvalDelta3,
    EvalDeltaKeyValue: () => EvalDeltaKeyValue2,
    HashFactory: () => HashFactory2,
    HbProofFields: () => HbProofFields,
    HealthCheck: () => HealthCheck2,
    IndexerStateProofMessage: () => IndexerStateProofMessage,
    MerkleArrayProof: () => MerkleArrayProof2,
    MiniAssetHolding: () => MiniAssetHolding,
    ParticipationUpdates: () => ParticipationUpdates2,
    StateProofFields: () => StateProofFields,
    StateProofParticipant: () => StateProofParticipant,
    StateProofReveal: () => StateProofReveal,
    StateProofSigSlot: () => StateProofSigSlot,
    StateProofSignature: () => StateProofSignature,
    StateProofTracking: () => StateProofTracking,
    StateProofVerifier: () => StateProofVerifier,
    StateSchema: () => StateSchema2,
    TealKeyValue: () => TealKeyValue2,
    TealValue: () => TealValue3,
    Transaction: () => Transaction2,
    TransactionApplication: () => TransactionApplication,
    TransactionAssetConfig: () => TransactionAssetConfig,
    TransactionAssetFreeze: () => TransactionAssetFreeze,
    TransactionAssetTransfer: () => TransactionAssetTransfer,
    TransactionHeartbeat: () => TransactionHeartbeat,
    TransactionKeyreg: () => TransactionKeyreg,
    TransactionPayment: () => TransactionPayment,
    TransactionResponse: () => TransactionResponse,
    TransactionSignature: () => TransactionSignature,
    TransactionSignatureLogicsig: () => TransactionSignatureLogicsig,
    TransactionSignatureMultisig: () => TransactionSignatureMultisig,
    TransactionSignatureMultisigSubsignature: () => TransactionSignatureMultisigSubsignature,
    TransactionStateProof: () => TransactionStateProof,
    TransactionsResponse: () => TransactionsResponse
  });
  var Account2, AccountParticipation2, AccountResponse, AccountStateDelta2, AccountsResponse, Application2, ApplicationLocalState2, ApplicationLocalStatesResponse, ApplicationLogData, ApplicationLogsResponse, ApplicationParams2, ApplicationResponse, ApplicationStateSchema2, ApplicationsResponse, Asset2, AssetBalancesResponse, AssetHolding3, AssetHoldingsResponse, AssetParams3, AssetResponse, AssetsResponse, Block3, BlockHeadersResponse, BlockRewards, BlockUpgradeState, BlockUpgradeVote, Box2, BoxDescriptor2, BoxesResponse2, ErrorResponse2, EvalDelta3, EvalDeltaKeyValue2, HashFactory2, HbProofFields, HealthCheck2, IndexerStateProofMessage, MerkleArrayProof2, MiniAssetHolding, ParticipationUpdates2, StateProofFields, StateProofParticipant, StateProofReveal, StateProofSigSlot, StateProofSignature, StateProofTracking, StateProofVerifier, StateSchema2, TealKeyValue2, TealValue3, Transaction2, TransactionApplication, TransactionAssetConfig, TransactionAssetFreeze, TransactionAssetTransfer, TransactionHeartbeat, TransactionKeyreg, TransactionPayment, TransactionResponse, TransactionSignature, TransactionSignatureLogicsig, TransactionSignatureMultisig, TransactionSignatureMultisigSubsignature, TransactionStateProof, TransactionsResponse;
  var init_types4 = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/models/types.js"() {
      init_polyfills();
      init_utils();
      init_schema();
      init_binarydata();
      init_address();
      init_untypedmodel();
      Account2 = class _Account {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "amount-without-pending-rewards",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "min-balance",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "pending-rewards",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, { key: "rewards", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "status", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "total-apps-opted-in",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "total-assets-opted-in",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "total-box-bytes",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "total-boxes",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "total-created-apps",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "total-created-assets",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "apps-local-state",
              valueSchema: new OptionalSchema(new ArraySchema(ApplicationLocalState2.encodingSchema)),
              omitEmpty: true
            }, {
              key: "apps-total-extra-pages",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "apps-total-schema",
              valueSchema: new OptionalSchema(ApplicationStateSchema2.encodingSchema),
              omitEmpty: true
            }, {
              key: "assets",
              valueSchema: new OptionalSchema(new ArraySchema(AssetHolding3.encodingSchema)),
              omitEmpty: true
            }, {
              key: "auth-addr",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "closed-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "created-apps",
              valueSchema: new OptionalSchema(new ArraySchema(Application2.encodingSchema)),
              omitEmpty: true
            }, {
              key: "created-assets",
              valueSchema: new OptionalSchema(new ArraySchema(Asset2.encodingSchema)),
              omitEmpty: true
            }, {
              key: "created-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "deleted",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "incentive-eligible",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "last-heartbeat",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "last-proposed",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "participation",
              valueSchema: new OptionalSchema(AccountParticipation2.encodingSchema),
              omitEmpty: true
            }, {
              key: "reward-base",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "sig-type",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `Account` object.
         * @param address - the account public key
         * @param amount - total number of MicroAlgos in the account
         * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
         * @param minBalance - MicroAlgo balance required by the account.
         * The requirement grows based on asset and application usage.
         * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
         * @param rewards - total rewards of MicroAlgos the account has received, including pending rewards.
         * @param round - The round for which this information is relevant.
         * @param status - voting status of the account's MicroAlgos
         * * Offline - indicates that the associated account is delegated.
         * * Online - indicates that the associated account used as part of the delegation
         * pool.
         * * NotParticipating - indicates that the associated account is neither a
         * delegator nor a delegate.
         * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
         * of application local data (AppLocalState objects) stored in this account.
         * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
         * AssetHolding objects held by this account.
         * @param totalBoxBytes - For app-accounts only. The total number of bytes allocated for the keys and
         * values of boxes which belong to the associated application.
         * @param totalBoxes - For app-accounts only. The total number of boxes which belong to the associated
         * application.
         * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
         * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
         * @param appsLocalState - application local data stored in this account.
         * Note the raw object uses `map[int] -> AppLocalState` for this type.
         * @param appsTotalExtraPages - the sum of all extra application program pages for this account.
         * @param appsTotalSchema - the sum of all of the local schemas and global schemas in this account.
         * Note: the raw account uses `StateSchema` for this type.
         * @param assets - assets held by this account.
         * Note the raw object uses `map[int] -> AssetHolding` for this type.
         * @param authAddr - The address against which signing should be checked. If empty, the address of
         * the current account is used. This field can be updated in any transaction by
         * setting the RekeyTo field.
         * @param closedAtRound - Round during which this account was most recently closed.
         * @param createdApps - parameters of applications created by this account including app global data.
         * Note: the raw account uses `map[int] -> AppParams` for this type.
         * @param createdAssets - parameters of assets created by this account.
         * Note: the raw account uses `map[int] -> Asset` for this type.
         * @param createdAtRound - Round during which this account first appeared in a transaction.
         * @param deleted - Whether or not this account is currently closed.
         * @param incentiveEligible - can the account receive block incentives if its balance is in range at proposal
         * time.
         * @param lastHeartbeat - The round in which this account last went online, or explicitly renewed their
         * online status.
         * @param lastProposed - The round in which this account last proposed the block.
         * @param participation - AccountParticipation describes the parameters used by this account in consensus
         * protocol.
         * @param rewardBase - used as part of the rewards computation. Only applicable to accounts which are
         * participating.
         * @param sigType - the type of signature used by this account, must be one of:
         * * sig
         * * msig
         * * lsig
         * * or null if unknown
         */
        constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalBoxBytes, totalBoxes, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, closedAtRound, createdApps, createdAssets, createdAtRound, deleted, incentiveEligible, lastHeartbeat, lastProposed, participation, rewardBase, sigType }) {
          this.address = address;
          this.amount = ensureBigInt(amount);
          this.amountWithoutPendingRewards = ensureBigInt(amountWithoutPendingRewards);
          this.minBalance = ensureSafeInteger(minBalance);
          this.pendingRewards = ensureBigInt(pendingRewards);
          this.rewards = ensureBigInt(rewards);
          this.round = ensureBigInt(round);
          this.status = status;
          this.totalAppsOptedIn = ensureSafeInteger(totalAppsOptedIn);
          this.totalAssetsOptedIn = ensureSafeInteger(totalAssetsOptedIn);
          this.totalBoxBytes = ensureSafeInteger(totalBoxBytes);
          this.totalBoxes = ensureSafeInteger(totalBoxes);
          this.totalCreatedApps = ensureSafeInteger(totalCreatedApps);
          this.totalCreatedAssets = ensureSafeInteger(totalCreatedAssets);
          this.appsLocalState = appsLocalState;
          this.appsTotalExtraPages = typeof appsTotalExtraPages === "undefined" ? void 0 : ensureSafeInteger(appsTotalExtraPages);
          this.appsTotalSchema = appsTotalSchema;
          this.assets = assets;
          this.authAddr = typeof authAddr === "string" ? Address.fromString(authAddr) : authAddr;
          this.closedAtRound = typeof closedAtRound === "undefined" ? void 0 : ensureBigInt(closedAtRound);
          this.createdApps = createdApps;
          this.createdAssets = createdAssets;
          this.createdAtRound = typeof createdAtRound === "undefined" ? void 0 : ensureBigInt(createdAtRound);
          this.deleted = deleted;
          this.incentiveEligible = incentiveEligible;
          this.lastHeartbeat = typeof lastHeartbeat === "undefined" ? void 0 : ensureSafeInteger(lastHeartbeat);
          this.lastProposed = typeof lastProposed === "undefined" ? void 0 : ensureSafeInteger(lastProposed);
          this.participation = participation;
          this.rewardBase = typeof rewardBase === "undefined" ? void 0 : ensureBigInt(rewardBase);
          this.sigType = sigType;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Account.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["address", this.address],
            ["amount", this.amount],
            ["amount-without-pending-rewards", this.amountWithoutPendingRewards],
            ["min-balance", this.minBalance],
            ["pending-rewards", this.pendingRewards],
            ["rewards", this.rewards],
            ["round", this.round],
            ["status", this.status],
            ["total-apps-opted-in", this.totalAppsOptedIn],
            ["total-assets-opted-in", this.totalAssetsOptedIn],
            ["total-box-bytes", this.totalBoxBytes],
            ["total-boxes", this.totalBoxes],
            ["total-created-apps", this.totalCreatedApps],
            ["total-created-assets", this.totalCreatedAssets],
            [
              "apps-local-state",
              typeof this.appsLocalState !== "undefined" ? this.appsLocalState.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["apps-total-extra-pages", this.appsTotalExtraPages],
            [
              "apps-total-schema",
              typeof this.appsTotalSchema !== "undefined" ? this.appsTotalSchema.toEncodingData() : void 0
            ],
            [
              "assets",
              typeof this.assets !== "undefined" ? this.assets.map((v3) => v3.toEncodingData()) : void 0
            ],
            [
              "auth-addr",
              typeof this.authAddr !== "undefined" ? this.authAddr.toString() : void 0
            ],
            ["closed-at-round", this.closedAtRound],
            [
              "created-apps",
              typeof this.createdApps !== "undefined" ? this.createdApps.map((v3) => v3.toEncodingData()) : void 0
            ],
            [
              "created-assets",
              typeof this.createdAssets !== "undefined" ? this.createdAssets.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["created-at-round", this.createdAtRound],
            ["deleted", this.deleted],
            ["incentive-eligible", this.incentiveEligible],
            ["last-heartbeat", this.lastHeartbeat],
            ["last-proposed", this.lastProposed],
            [
              "participation",
              typeof this.participation !== "undefined" ? this.participation.toEncodingData() : void 0
            ],
            ["reward-base", this.rewardBase],
            ["sig-type", this.sigType]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Account: ${data}`);
          }
          return new _Account({
            address: data.get("address"),
            amount: data.get("amount"),
            amountWithoutPendingRewards: data.get("amount-without-pending-rewards"),
            minBalance: data.get("min-balance"),
            pendingRewards: data.get("pending-rewards"),
            rewards: data.get("rewards"),
            round: data.get("round"),
            status: data.get("status"),
            totalAppsOptedIn: data.get("total-apps-opted-in"),
            totalAssetsOptedIn: data.get("total-assets-opted-in"),
            totalBoxBytes: data.get("total-box-bytes"),
            totalBoxes: data.get("total-boxes"),
            totalCreatedApps: data.get("total-created-apps"),
            totalCreatedAssets: data.get("total-created-assets"),
            appsLocalState: typeof data.get("apps-local-state") !== "undefined" ? data.get("apps-local-state").map((v3) => ApplicationLocalState2.fromEncodingData(v3)) : void 0,
            appsTotalExtraPages: data.get("apps-total-extra-pages"),
            appsTotalSchema: typeof data.get("apps-total-schema") !== "undefined" ? ApplicationStateSchema2.fromEncodingData(data.get("apps-total-schema")) : void 0,
            assets: typeof data.get("assets") !== "undefined" ? data.get("assets").map((v3) => AssetHolding3.fromEncodingData(v3)) : void 0,
            authAddr: data.get("auth-addr"),
            closedAtRound: data.get("closed-at-round"),
            createdApps: typeof data.get("created-apps") !== "undefined" ? data.get("created-apps").map((v3) => Application2.fromEncodingData(v3)) : void 0,
            createdAssets: typeof data.get("created-assets") !== "undefined" ? data.get("created-assets").map((v3) => Asset2.fromEncodingData(v3)) : void 0,
            createdAtRound: data.get("created-at-round"),
            deleted: data.get("deleted"),
            incentiveEligible: data.get("incentive-eligible"),
            lastHeartbeat: data.get("last-heartbeat"),
            lastProposed: data.get("last-proposed"),
            participation: typeof data.get("participation") !== "undefined" ? AccountParticipation2.fromEncodingData(data.get("participation")) : void 0,
            rewardBase: data.get("reward-base"),
            sigType: data.get("sig-type")
          });
        }
      };
      AccountParticipation2 = class _AccountParticipation {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "selection-participation-key",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, {
              key: "vote-first-valid",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "vote-key-dilution",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "vote-last-valid",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "vote-participation-key",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, {
              key: "state-proof-key",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AccountParticipation` object.
         * @param selectionParticipationKey - Selection public key (if any) currently registered for this round.
         * @param voteFirstValid - First round for which this participation is valid.
         * @param voteKeyDilution - Number of subkeys in each batch of participation keys.
         * @param voteLastValid - Last round for which this participation is valid.
         * @param voteParticipationKey - root participation public key (if any) currently registered for this round.
         * @param stateProofKey - Root of the state proof key (if any)
         */
        constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
          this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? base64ToBytes(selectionParticipationKey) : selectionParticipationKey;
          this.voteFirstValid = ensureBigInt(voteFirstValid);
          this.voteKeyDilution = ensureBigInt(voteKeyDilution);
          this.voteLastValid = ensureBigInt(voteLastValid);
          this.voteParticipationKey = typeof voteParticipationKey === "string" ? base64ToBytes(voteParticipationKey) : voteParticipationKey;
          this.stateProofKey = typeof stateProofKey === "string" ? base64ToBytes(stateProofKey) : stateProofKey;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountParticipation.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["selection-participation-key", this.selectionParticipationKey],
            ["vote-first-valid", this.voteFirstValid],
            ["vote-key-dilution", this.voteKeyDilution],
            ["vote-last-valid", this.voteLastValid],
            ["vote-participation-key", this.voteParticipationKey],
            ["state-proof-key", this.stateProofKey]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountParticipation: ${data}`);
          }
          return new _AccountParticipation({
            selectionParticipationKey: data.get("selection-participation-key"),
            voteFirstValid: data.get("vote-first-valid"),
            voteKeyDilution: data.get("vote-key-dilution"),
            voteLastValid: data.get("vote-last-valid"),
            voteParticipationKey: data.get("vote-participation-key"),
            stateProofKey: data.get("state-proof-key")
          });
        }
      };
      AccountResponse = class _AccountResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "account",
              valueSchema: Account2.encodingSchema,
              omitEmpty: true
            }, {
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AccountResponse` object.
         * @param account - Account information at a given round.
         * Definition:
         * data/basics/userBalance.go : AccountData
         * @param currentRound - Round at which the results were computed.
         */
        constructor({ account, currentRound }) {
          this.account = account;
          this.currentRound = ensureBigInt(currentRound);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["account", this.account.toEncodingData()],
            ["current-round", this.currentRound]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountResponse: ${data}`);
          }
          return new _AccountResponse({
            account: Account2.fromEncodingData(data.get("account") ?? /* @__PURE__ */ new Map()),
            currentRound: data.get("current-round")
          });
        }
      };
      AccountStateDelta2 = class _AccountStateDelta {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "delta",
              valueSchema: new ArraySchema(EvalDeltaKeyValue2.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AccountStateDelta` object.
         * @param address -
         * @param delta - Application state delta.
         */
        constructor({ address, delta }) {
          this.address = address;
          this.delta = delta;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountStateDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["address", this.address],
            ["delta", this.delta.map((v3) => v3.toEncodingData())]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountStateDelta: ${data}`);
          }
          return new _AccountStateDelta({
            address: data.get("address"),
            delta: (data.get("delta") ?? []).map((v3) => EvalDeltaKeyValue2.fromEncodingData(v3))
          });
        }
      };
      AccountsResponse = class _AccountsResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "accounts",
              valueSchema: new ArraySchema(Account2.encodingSchema),
              omitEmpty: true
            }, {
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "next-token",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AccountsResponse` object.
         * @param accounts -
         * @param currentRound - Round at which the results were computed.
         * @param nextToken - Used for pagination, when making another request provide this token with the
         * next parameter.
         */
        constructor({ accounts, currentRound, nextToken }) {
          this.accounts = accounts;
          this.currentRound = ensureBigInt(currentRound);
          this.nextToken = nextToken;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AccountsResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["accounts", this.accounts.map((v3) => v3.toEncodingData())],
            ["current-round", this.currentRound],
            ["next-token", this.nextToken]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AccountsResponse: ${data}`);
          }
          return new _AccountsResponse({
            accounts: (data.get("accounts") ?? []).map((v3) => Account2.fromEncodingData(v3)),
            currentRound: data.get("current-round"),
            nextToken: data.get("next-token")
          });
        }
      };
      Application2 = class _Application {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "params",
              valueSchema: ApplicationParams2.encodingSchema,
              omitEmpty: true
            }, {
              key: "created-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "deleted",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "deleted-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `Application` object.
         * @param id - application index.
         * @param params - application parameters.
         * @param createdAtRound - Round when this application was created.
         * @param deleted - Whether or not this application is currently deleted.
         * @param deletedAtRound - Round when this application was deleted.
         */
        constructor({ id, params, createdAtRound, deleted, deletedAtRound }) {
          this.id = ensureBigInt(id);
          this.params = params;
          this.createdAtRound = typeof createdAtRound === "undefined" ? void 0 : ensureBigInt(createdAtRound);
          this.deleted = deleted;
          this.deletedAtRound = typeof deletedAtRound === "undefined" ? void 0 : ensureBigInt(deletedAtRound);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Application.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["id", this.id],
            ["params", this.params.toEncodingData()],
            ["created-at-round", this.createdAtRound],
            ["deleted", this.deleted],
            ["deleted-at-round", this.deletedAtRound]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Application: ${data}`);
          }
          return new _Application({
            id: data.get("id"),
            params: ApplicationParams2.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map()),
            createdAtRound: data.get("created-at-round"),
            deleted: data.get("deleted"),
            deletedAtRound: data.get("deleted-at-round")
          });
        }
      };
      ApplicationLocalState2 = class _ApplicationLocalState {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "schema",
              valueSchema: ApplicationStateSchema2.encodingSchema,
              omitEmpty: true
            }, {
              key: "closed-out-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "deleted",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "key-value",
              valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue2.encodingSchema)),
              omitEmpty: true
            }, {
              key: "opted-in-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationLocalState` object.
         * @param id - The application which this local state is for.
         * @param schema - schema.
         * @param closedOutAtRound - Round when account closed out of the application.
         * @param deleted - Whether or not the application local state is currently deleted from its
         * account.
         * @param keyValue - storage.
         * @param optedInAtRound - Round when the account opted into the application.
         */
        constructor({ id, schema, closedOutAtRound, deleted, keyValue, optedInAtRound }) {
          this.id = ensureBigInt(id);
          this.schema = schema;
          this.closedOutAtRound = typeof closedOutAtRound === "undefined" ? void 0 : ensureBigInt(closedOutAtRound);
          this.deleted = deleted;
          this.keyValue = keyValue;
          this.optedInAtRound = typeof optedInAtRound === "undefined" ? void 0 : ensureBigInt(optedInAtRound);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationLocalState.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["id", this.id],
            ["schema", this.schema.toEncodingData()],
            ["closed-out-at-round", this.closedOutAtRound],
            ["deleted", this.deleted],
            [
              "key-value",
              typeof this.keyValue !== "undefined" ? this.keyValue.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["opted-in-at-round", this.optedInAtRound]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationLocalState: ${data}`);
          }
          return new _ApplicationLocalState({
            id: data.get("id"),
            schema: ApplicationStateSchema2.fromEncodingData(data.get("schema") ?? /* @__PURE__ */ new Map()),
            closedOutAtRound: data.get("closed-out-at-round"),
            deleted: data.get("deleted"),
            keyValue: typeof data.get("key-value") !== "undefined" ? data.get("key-value").map((v3) => TealKeyValue2.fromEncodingData(v3)) : void 0,
            optedInAtRound: data.get("opted-in-at-round")
          });
        }
      };
      ApplicationLocalStatesResponse = class _ApplicationLocalStatesResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "apps-local-states",
              valueSchema: new ArraySchema(ApplicationLocalState2.encodingSchema),
              omitEmpty: true
            }, {
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "next-token",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationLocalStatesResponse` object.
         * @param appsLocalStates -
         * @param currentRound - Round at which the results were computed.
         * @param nextToken - Used for pagination, when making another request provide this token with the
         * next parameter.
         */
        constructor({ appsLocalStates, currentRound, nextToken }) {
          this.appsLocalStates = appsLocalStates;
          this.currentRound = ensureBigInt(currentRound);
          this.nextToken = nextToken;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationLocalStatesResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "apps-local-states",
              this.appsLocalStates.map((v3) => v3.toEncodingData())
            ],
            ["current-round", this.currentRound],
            ["next-token", this.nextToken]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationLocalStatesResponse: ${data}`);
          }
          return new _ApplicationLocalStatesResponse({
            appsLocalStates: (data.get("apps-local-states") ?? []).map((v3) => ApplicationLocalState2.fromEncodingData(v3)),
            currentRound: data.get("current-round"),
            nextToken: data.get("next-token")
          });
        }
      };
      ApplicationLogData = class _ApplicationLogData {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "logs",
              valueSchema: new ArraySchema(new ByteArraySchema()),
              omitEmpty: true
            }, { key: "txid", valueSchema: new StringSchema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationLogData` object.
         * @param logs - Logs for the application being executed by the transaction.
         * @param txid - Transaction ID
         */
        constructor({ logs, txid }) {
          this.logs = logs;
          this.txid = txid;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationLogData.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["logs", this.logs],
            ["txid", this.txid]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationLogData: ${data}`);
          }
          return new _ApplicationLogData({
            logs: data.get("logs"),
            txid: data.get("txid")
          });
        }
      };
      ApplicationLogsResponse = class _ApplicationLogsResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "application-id",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "log-data",
              valueSchema: new OptionalSchema(new ArraySchema(ApplicationLogData.encodingSchema)),
              omitEmpty: true
            }, {
              key: "next-token",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationLogsResponse` object.
         * @param applicationId - (appidx) application index.
         * @param currentRound - Round at which the results were computed.
         * @param logData -
         * @param nextToken - Used for pagination, when making another request provide this token with the
         * next parameter.
         */
        constructor({ applicationId, currentRound, logData, nextToken }) {
          this.applicationId = ensureBigInt(applicationId);
          this.currentRound = ensureBigInt(currentRound);
          this.logData = logData;
          this.nextToken = nextToken;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationLogsResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["application-id", this.applicationId],
            ["current-round", this.currentRound],
            [
              "log-data",
              typeof this.logData !== "undefined" ? this.logData.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["next-token", this.nextToken]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationLogsResponse: ${data}`);
          }
          return new _ApplicationLogsResponse({
            applicationId: data.get("application-id"),
            currentRound: data.get("current-round"),
            logData: typeof data.get("log-data") !== "undefined" ? data.get("log-data").map((v3) => ApplicationLogData.fromEncodingData(v3)) : void 0,
            nextToken: data.get("next-token")
          });
        }
      };
      ApplicationParams2 = class _ApplicationParams {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "approval-program",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, {
              key: "clear-state-program",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, {
              key: "creator",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "extra-program-pages",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "global-state",
              valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue2.encodingSchema)),
              omitEmpty: true
            }, {
              key: "global-state-schema",
              valueSchema: new OptionalSchema(ApplicationStateSchema2.encodingSchema),
              omitEmpty: true
            }, {
              key: "local-state-schema",
              valueSchema: new OptionalSchema(ApplicationStateSchema2.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationParams` object.
         * @param approvalProgram - approval program.
         * @param clearStateProgram - clear state program.
         * @param creator - The address that created this application. This is the address where the
         * parameters and global state for this application can be found.
         * @param extraProgramPages - the number of extra program pages available to this app.
         * @param globalState - global state
         * @param globalStateSchema - global schema
         * @param localStateSchema - local schema
         */
        constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema }) {
          this.approvalProgram = typeof approvalProgram === "string" ? base64ToBytes(approvalProgram) : approvalProgram;
          this.clearStateProgram = typeof clearStateProgram === "string" ? base64ToBytes(clearStateProgram) : clearStateProgram;
          this.creator = typeof creator === "string" ? Address.fromString(creator) : creator;
          this.extraProgramPages = typeof extraProgramPages === "undefined" ? void 0 : ensureSafeInteger(extraProgramPages);
          this.globalState = globalState;
          this.globalStateSchema = globalStateSchema;
          this.localStateSchema = localStateSchema;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationParams.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["approval-program", this.approvalProgram],
            ["clear-state-program", this.clearStateProgram],
            [
              "creator",
              typeof this.creator !== "undefined" ? this.creator.toString() : void 0
            ],
            ["extra-program-pages", this.extraProgramPages],
            [
              "global-state",
              typeof this.globalState !== "undefined" ? this.globalState.map((v3) => v3.toEncodingData()) : void 0
            ],
            [
              "global-state-schema",
              typeof this.globalStateSchema !== "undefined" ? this.globalStateSchema.toEncodingData() : void 0
            ],
            [
              "local-state-schema",
              typeof this.localStateSchema !== "undefined" ? this.localStateSchema.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationParams: ${data}`);
          }
          return new _ApplicationParams({
            approvalProgram: data.get("approval-program"),
            clearStateProgram: data.get("clear-state-program"),
            creator: data.get("creator"),
            extraProgramPages: data.get("extra-program-pages"),
            globalState: typeof data.get("global-state") !== "undefined" ? data.get("global-state").map((v3) => TealKeyValue2.fromEncodingData(v3)) : void 0,
            globalStateSchema: typeof data.get("global-state-schema") !== "undefined" ? ApplicationStateSchema2.fromEncodingData(data.get("global-state-schema")) : void 0,
            localStateSchema: typeof data.get("local-state-schema") !== "undefined" ? ApplicationStateSchema2.fromEncodingData(data.get("local-state-schema")) : void 0
          });
        }
      };
      ApplicationResponse = class _ApplicationResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "application",
              valueSchema: new OptionalSchema(Application2.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationResponse` object.
         * @param currentRound - Round at which the results were computed.
         * @param application - Application index and its parameters
         */
        constructor({ currentRound, application }) {
          this.currentRound = ensureBigInt(currentRound);
          this.application = application;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["current-round", this.currentRound],
            [
              "application",
              typeof this.application !== "undefined" ? this.application.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationResponse: ${data}`);
          }
          return new _ApplicationResponse({
            currentRound: data.get("current-round"),
            application: typeof data.get("application") !== "undefined" ? Application2.fromEncodingData(data.get("application")) : void 0
          });
        }
      };
      ApplicationStateSchema2 = class _ApplicationStateSchema {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "num-byte-slice",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, { key: "num-uint", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationStateSchema` object.
         * @param numByteSlice - number of byte slices.
         * @param numUint - number of uints.
         */
        constructor({ numByteSlice, numUint }) {
          this.numByteSlice = ensureSafeInteger(numByteSlice);
          this.numUint = ensureSafeInteger(numUint);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationStateSchema.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["num-byte-slice", this.numByteSlice],
            ["num-uint", this.numUint]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationStateSchema: ${data}`);
          }
          return new _ApplicationStateSchema({
            numByteSlice: data.get("num-byte-slice"),
            numUint: data.get("num-uint")
          });
        }
      };
      ApplicationsResponse = class _ApplicationsResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "applications",
              valueSchema: new ArraySchema(Application2.encodingSchema),
              omitEmpty: true
            }, {
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "next-token",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ApplicationsResponse` object.
         * @param applications -
         * @param currentRound - Round at which the results were computed.
         * @param nextToken - Used for pagination, when making another request provide this token with the
         * next parameter.
         */
        constructor({ applications, currentRound, nextToken }) {
          this.applications = applications;
          this.currentRound = ensureBigInt(currentRound);
          this.nextToken = nextToken;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ApplicationsResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["applications", this.applications.map((v3) => v3.toEncodingData())],
            ["current-round", this.currentRound],
            ["next-token", this.nextToken]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ApplicationsResponse: ${data}`);
          }
          return new _ApplicationsResponse({
            applications: (data.get("applications") ?? []).map((v3) => Application2.fromEncodingData(v3)),
            currentRound: data.get("current-round"),
            nextToken: data.get("next-token")
          });
        }
      };
      Asset2 = class _Asset {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "index", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "params",
              valueSchema: AssetParams3.encodingSchema,
              omitEmpty: true
            }, {
              key: "created-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "deleted",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "destroyed-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `Asset` object.
         * @param index - unique asset identifier
         * @param params - AssetParams specifies the parameters for an asset.
         * (apar) when part of an AssetConfig transaction.
         * Definition:
         * data/transactions/asset.go : AssetParams
         * @param createdAtRound - Round during which this asset was created.
         * @param deleted - Whether or not this asset is currently deleted.
         * @param destroyedAtRound - Round during which this asset was destroyed.
         */
        constructor({ index, params, createdAtRound, deleted, destroyedAtRound }) {
          this.index = ensureBigInt(index);
          this.params = params;
          this.createdAtRound = typeof createdAtRound === "undefined" ? void 0 : ensureBigInt(createdAtRound);
          this.deleted = deleted;
          this.destroyedAtRound = typeof destroyedAtRound === "undefined" ? void 0 : ensureBigInt(destroyedAtRound);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Asset.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["index", this.index],
            ["params", this.params.toEncodingData()],
            ["created-at-round", this.createdAtRound],
            ["deleted", this.deleted],
            ["destroyed-at-round", this.destroyedAtRound]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Asset: ${data}`);
          }
          return new _Asset({
            index: data.get("index"),
            params: AssetParams3.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map()),
            createdAtRound: data.get("created-at-round"),
            deleted: data.get("deleted"),
            destroyedAtRound: data.get("destroyed-at-round")
          });
        }
      };
      AssetBalancesResponse = class _AssetBalancesResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "balances",
              valueSchema: new ArraySchema(MiniAssetHolding.encodingSchema),
              omitEmpty: true
            }, {
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "next-token",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AssetBalancesResponse` object.
         * @param balances -
         * @param currentRound - Round at which the results were computed.
         * @param nextToken - Used for pagination, when making another request provide this token with the
         * next parameter.
         */
        constructor({ balances, currentRound, nextToken }) {
          this.balances = balances;
          this.currentRound = ensureBigInt(currentRound);
          this.nextToken = nextToken;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetBalancesResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["balances", this.balances.map((v3) => v3.toEncodingData())],
            ["current-round", this.currentRound],
            ["next-token", this.nextToken]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetBalancesResponse: ${data}`);
          }
          return new _AssetBalancesResponse({
            balances: (data.get("balances") ?? []).map((v3) => MiniAssetHolding.fromEncodingData(v3)),
            currentRound: data.get("current-round"),
            nextToken: data.get("next-token")
          });
        }
      };
      AssetHolding3 = class _AssetHolding {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "is-frozen", valueSchema: new BooleanSchema(), omitEmpty: true }, {
              key: "deleted",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "opted-in-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "opted-out-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AssetHolding` object.
         * @param amount - number of units held.
         * @param assetId - Asset ID of the holding.
         * @param isFrozen - whether or not the holding is frozen.
         * @param deleted - Whether or not the asset holding is currently deleted from its account.
         * @param optedInAtRound - Round during which the account opted into this asset holding.
         * @param optedOutAtRound - Round during which the account opted out of this asset holding.
         */
        constructor({ amount, assetId, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
          this.amount = ensureBigInt(amount);
          this.assetId = ensureBigInt(assetId);
          this.isFrozen = isFrozen;
          this.deleted = deleted;
          this.optedInAtRound = typeof optedInAtRound === "undefined" ? void 0 : ensureBigInt(optedInAtRound);
          this.optedOutAtRound = typeof optedOutAtRound === "undefined" ? void 0 : ensureBigInt(optedOutAtRound);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetHolding.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["amount", this.amount],
            ["asset-id", this.assetId],
            ["is-frozen", this.isFrozen],
            ["deleted", this.deleted],
            ["opted-in-at-round", this.optedInAtRound],
            ["opted-out-at-round", this.optedOutAtRound]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetHolding: ${data}`);
          }
          return new _AssetHolding({
            amount: data.get("amount"),
            assetId: data.get("asset-id"),
            isFrozen: data.get("is-frozen"),
            deleted: data.get("deleted"),
            optedInAtRound: data.get("opted-in-at-round"),
            optedOutAtRound: data.get("opted-out-at-round")
          });
        }
      };
      AssetHoldingsResponse = class _AssetHoldingsResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "assets",
              valueSchema: new ArraySchema(AssetHolding3.encodingSchema),
              omitEmpty: true
            }, {
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "next-token",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AssetHoldingsResponse` object.
         * @param assets -
         * @param currentRound - Round at which the results were computed.
         * @param nextToken - Used for pagination, when making another request provide this token with the
         * next parameter.
         */
        constructor({ assets, currentRound, nextToken }) {
          this.assets = assets;
          this.currentRound = ensureBigInt(currentRound);
          this.nextToken = nextToken;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetHoldingsResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["assets", this.assets.map((v3) => v3.toEncodingData())],
            ["current-round", this.currentRound],
            ["next-token", this.nextToken]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetHoldingsResponse: ${data}`);
          }
          return new _AssetHoldingsResponse({
            assets: (data.get("assets") ?? []).map((v3) => AssetHolding3.fromEncodingData(v3)),
            currentRound: data.get("current-round"),
            nextToken: data.get("next-token")
          });
        }
      };
      AssetParams3 = class _AssetParams {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "creator", valueSchema: new StringSchema(), omitEmpty: true }, { key: "decimals", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "total", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "clawback",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "default-frozen",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "freeze",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "manager",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "metadata-hash",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "name",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "name-b64",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "reserve",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "unit-name",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "unit-name-b64",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "url",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "url-b64",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AssetParams` object.
         * @param creator - The address that created this asset. This is the address where the parameters
         * for this asset can be found, and also the address where unwanted asset units can
         * be sent in the worst case.
         * @param decimals - The number of digits to use after the decimal point when displaying this asset.
         * If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths.
         * If 2, the base unit of the asset is in hundredths, and so on. This value must be
         * between 0 and 19 (inclusive).
         * @param total - The total number of units of this asset.
         * @param clawback - Address of account used to clawback holdings of this asset. If empty, clawback
         * is not permitted.
         * @param defaultFrozen - Whether holdings of this asset are frozen by default.
         * @param freeze - Address of account used to freeze holdings of this asset. If empty, freezing is
         * not permitted.
         * @param manager - Address of account used to manage the keys of this asset and to destroy it.
         * @param metadataHash - A commitment to some unspecified asset metadata. The format of this metadata is
         * up to the application.
         * @param name - Name of this asset, as supplied by the creator. Included only when the asset
         * name is composed of printable utf-8 characters.
         * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
         * @param reserve - Address of account holding reserve (non-minted) units of this asset.
         * @param unitName - Name of a unit of this asset, as supplied by the creator. Included only when the
         * name of a unit of this asset is composed of printable utf-8 characters.
         * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
         * @param url - URL where more information about the asset can be retrieved. Included only when
         * the URL is composed of printable utf-8 characters.
         * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
         */
        constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
          this.creator = creator;
          this.decimals = ensureSafeInteger(decimals);
          this.total = ensureBigInt(total);
          this.clawback = clawback;
          this.defaultFrozen = defaultFrozen;
          this.freeze = freeze;
          this.manager = manager;
          this.metadataHash = typeof metadataHash === "string" ? base64ToBytes(metadataHash) : metadataHash;
          this.name = name;
          this.nameB64 = typeof nameB64 === "string" ? base64ToBytes(nameB64) : nameB64;
          this.reserve = reserve;
          this.unitName = unitName;
          this.unitNameB64 = typeof unitNameB64 === "string" ? base64ToBytes(unitNameB64) : unitNameB64;
          this.url = url;
          this.urlB64 = typeof urlB64 === "string" ? base64ToBytes(urlB64) : urlB64;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetParams.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["creator", this.creator],
            ["decimals", this.decimals],
            ["total", this.total],
            ["clawback", this.clawback],
            ["default-frozen", this.defaultFrozen],
            ["freeze", this.freeze],
            ["manager", this.manager],
            ["metadata-hash", this.metadataHash],
            ["name", this.name],
            ["name-b64", this.nameB64],
            ["reserve", this.reserve],
            ["unit-name", this.unitName],
            ["unit-name-b64", this.unitNameB64],
            ["url", this.url],
            ["url-b64", this.urlB64]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetParams: ${data}`);
          }
          return new _AssetParams({
            creator: data.get("creator"),
            decimals: data.get("decimals"),
            total: data.get("total"),
            clawback: data.get("clawback"),
            defaultFrozen: data.get("default-frozen"),
            freeze: data.get("freeze"),
            manager: data.get("manager"),
            metadataHash: data.get("metadata-hash"),
            name: data.get("name"),
            nameB64: data.get("name-b64"),
            reserve: data.get("reserve"),
            unitName: data.get("unit-name"),
            unitNameB64: data.get("unit-name-b64"),
            url: data.get("url"),
            urlB64: data.get("url-b64")
          });
        }
      };
      AssetResponse = class _AssetResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "asset", valueSchema: Asset2.encodingSchema, omitEmpty: true }, {
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AssetResponse` object.
         * @param asset - Specifies both the unique identifier and the parameters for an asset
         * @param currentRound - Round at which the results were computed.
         */
        constructor({ asset, currentRound }) {
          this.asset = asset;
          this.currentRound = ensureBigInt(currentRound);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["asset", this.asset.toEncodingData()],
            ["current-round", this.currentRound]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetResponse: ${data}`);
          }
          return new _AssetResponse({
            asset: Asset2.fromEncodingData(data.get("asset") ?? /* @__PURE__ */ new Map()),
            currentRound: data.get("current-round")
          });
        }
      };
      AssetsResponse = class _AssetsResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "assets",
              valueSchema: new ArraySchema(Asset2.encodingSchema),
              omitEmpty: true
            }, {
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "next-token",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `AssetsResponse` object.
         * @param assets -
         * @param currentRound - Round at which the results were computed.
         * @param nextToken - Used for pagination, when making another request provide this token with the
         * next parameter.
         */
        constructor({ assets, currentRound, nextToken }) {
          this.assets = assets;
          this.currentRound = ensureBigInt(currentRound);
          this.nextToken = nextToken;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _AssetsResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["assets", this.assets.map((v3) => v3.toEncodingData())],
            ["current-round", this.currentRound],
            ["next-token", this.nextToken]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded AssetsResponse: ${data}`);
          }
          return new _AssetsResponse({
            assets: (data.get("assets") ?? []).map((v3) => Asset2.fromEncodingData(v3)),
            currentRound: data.get("current-round"),
            nextToken: data.get("next-token")
          });
        }
      };
      Block3 = class _Block {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "genesis-hash",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, { key: "genesis-id", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "previous-block-hash",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "seed", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "timestamp", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "transactions-root",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, {
              key: "transactions-root-sha256",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            }, {
              key: "bonus",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "fees-collected",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "participation-updates",
              valueSchema: new OptionalSchema(ParticipationUpdates2.encodingSchema),
              omitEmpty: true
            }, {
              key: "proposer",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "proposer-payout",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "rewards",
              valueSchema: new OptionalSchema(BlockRewards.encodingSchema),
              omitEmpty: true
            }, {
              key: "state-proof-tracking",
              valueSchema: new OptionalSchema(new ArraySchema(StateProofTracking.encodingSchema)),
              omitEmpty: true
            }, {
              key: "transactions",
              valueSchema: new OptionalSchema(new ArraySchema(Transaction2.encodingSchema)),
              omitEmpty: true
            }, {
              key: "txn-counter",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "upgrade-state",
              valueSchema: new OptionalSchema(BlockUpgradeState.encodingSchema),
              omitEmpty: true
            }, {
              key: "upgrade-vote",
              valueSchema: new OptionalSchema(BlockUpgradeVote.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `Block` object.
         * @param genesisHash - (gh) hash to which this block belongs.
         * @param genesisId - (gen) ID to which this block belongs.
         * @param previousBlockHash - (prev) Previous block hash.
         * @param round - (rnd) Current round on which this block was appended to the chain.
         * @param seed - (seed) Sortition seed.
         * @param timestamp - (ts) Block creation timestamp in seconds since eposh
         * @param transactionsRoot - (txn) TransactionsRoot authenticates the set of transactions appearing in the
         * block. More specifically, it's the root of a merkle tree whose leaves are the
         * block's Txids, in lexicographic order. For the empty block, it's 0. Note that
         * the TxnRoot does not authenticate the signatures on the transactions, only the
         * transactions themselves. Two blocks with the same transactions but in a
         * different order and with different signatures will have the same TxnRoot.
         * @param transactionsRootSha256 - (txn256) TransactionsRootSHA256 is an auxiliary TransactionRoot, built using a
         * vector commitment instead of a merkle tree, and SHA256 hash function instead of
         * the default SHA512_256. This commitment can be used on environments where only
         * the SHA256 function exists.
         * @param bonus - the potential bonus payout for this block.
         * @param feesCollected - the sum of all fees paid by transactions in this block.
         * @param participationUpdates - Participation account data that needs to be checked/acted on by the network.
         * @param proposer - the proposer of this block.
         * @param proposerPayout - the actual amount transferred to the proposer from the fee sink.
         * @param rewards - Fields relating to rewards,
         * @param stateProofTracking - Tracks the status of state proofs.
         * @param transactions - (txns) list of transactions corresponding to a given round.
         * @param txnCounter - (tc) TxnCounter counts the number of transactions committed in the ledger, from
         * the time at which support for this feature was introduced.
         * Specifically, TxnCounter is the number of the next transaction that will be
         * committed after this block. It is 0 when no transactions have ever been
         * committed (since TxnCounter started being supported).
         * @param upgradeState - Fields relating to a protocol upgrade.
         * @param upgradeVote - Fields relating to voting for a protocol upgrade.
         */
        constructor({ genesisHash, genesisId, previousBlockHash, round, seed, timestamp, transactionsRoot, transactionsRootSha256, bonus, feesCollected, participationUpdates, proposer, proposerPayout, rewards, stateProofTracking, transactions, txnCounter, upgradeState, upgradeVote }) {
          this.genesisHash = typeof genesisHash === "string" ? base64ToBytes(genesisHash) : genesisHash;
          this.genesisId = genesisId;
          this.previousBlockHash = typeof previousBlockHash === "string" ? base64ToBytes(previousBlockHash) : previousBlockHash;
          this.round = ensureBigInt(round);
          this.seed = typeof seed === "string" ? base64ToBytes(seed) : seed;
          this.timestamp = ensureSafeInteger(timestamp);
          this.transactionsRoot = typeof transactionsRoot === "string" ? base64ToBytes(transactionsRoot) : transactionsRoot;
          this.transactionsRootSha256 = typeof transactionsRootSha256 === "string" ? base64ToBytes(transactionsRootSha256) : transactionsRootSha256;
          this.bonus = typeof bonus === "undefined" ? void 0 : ensureSafeInteger(bonus);
          this.feesCollected = typeof feesCollected === "undefined" ? void 0 : ensureSafeInteger(feesCollected);
          this.participationUpdates = participationUpdates;
          this.proposer = typeof proposer === "string" ? Address.fromString(proposer) : proposer;
          this.proposerPayout = typeof proposerPayout === "undefined" ? void 0 : ensureSafeInteger(proposerPayout);
          this.rewards = rewards;
          this.stateProofTracking = stateProofTracking;
          this.transactions = transactions;
          this.txnCounter = typeof txnCounter === "undefined" ? void 0 : ensureSafeInteger(txnCounter);
          this.upgradeState = upgradeState;
          this.upgradeVote = upgradeVote;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Block.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["genesis-hash", this.genesisHash],
            ["genesis-id", this.genesisId],
            ["previous-block-hash", this.previousBlockHash],
            ["round", this.round],
            ["seed", this.seed],
            ["timestamp", this.timestamp],
            ["transactions-root", this.transactionsRoot],
            ["transactions-root-sha256", this.transactionsRootSha256],
            ["bonus", this.bonus],
            ["fees-collected", this.feesCollected],
            [
              "participation-updates",
              typeof this.participationUpdates !== "undefined" ? this.participationUpdates.toEncodingData() : void 0
            ],
            [
              "proposer",
              typeof this.proposer !== "undefined" ? this.proposer.toString() : void 0
            ],
            ["proposer-payout", this.proposerPayout],
            [
              "rewards",
              typeof this.rewards !== "undefined" ? this.rewards.toEncodingData() : void 0
            ],
            [
              "state-proof-tracking",
              typeof this.stateProofTracking !== "undefined" ? this.stateProofTracking.map((v3) => v3.toEncodingData()) : void 0
            ],
            [
              "transactions",
              typeof this.transactions !== "undefined" ? this.transactions.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["txn-counter", this.txnCounter],
            [
              "upgrade-state",
              typeof this.upgradeState !== "undefined" ? this.upgradeState.toEncodingData() : void 0
            ],
            [
              "upgrade-vote",
              typeof this.upgradeVote !== "undefined" ? this.upgradeVote.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Block: ${data}`);
          }
          return new _Block({
            genesisHash: data.get("genesis-hash"),
            genesisId: data.get("genesis-id"),
            previousBlockHash: data.get("previous-block-hash"),
            round: data.get("round"),
            seed: data.get("seed"),
            timestamp: data.get("timestamp"),
            transactionsRoot: data.get("transactions-root"),
            transactionsRootSha256: data.get("transactions-root-sha256"),
            bonus: data.get("bonus"),
            feesCollected: data.get("fees-collected"),
            participationUpdates: typeof data.get("participation-updates") !== "undefined" ? ParticipationUpdates2.fromEncodingData(data.get("participation-updates")) : void 0,
            proposer: data.get("proposer"),
            proposerPayout: data.get("proposer-payout"),
            rewards: typeof data.get("rewards") !== "undefined" ? BlockRewards.fromEncodingData(data.get("rewards")) : void 0,
            stateProofTracking: typeof data.get("state-proof-tracking") !== "undefined" ? data.get("state-proof-tracking").map((v3) => StateProofTracking.fromEncodingData(v3)) : void 0,
            transactions: typeof data.get("transactions") !== "undefined" ? data.get("transactions").map((v3) => Transaction2.fromEncodingData(v3)) : void 0,
            txnCounter: data.get("txn-counter"),
            upgradeState: typeof data.get("upgrade-state") !== "undefined" ? BlockUpgradeState.fromEncodingData(data.get("upgrade-state")) : void 0,
            upgradeVote: typeof data.get("upgrade-vote") !== "undefined" ? BlockUpgradeVote.fromEncodingData(data.get("upgrade-vote")) : void 0
          });
        }
      };
      BlockHeadersResponse = class _BlockHeadersResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "blocks",
              valueSchema: new ArraySchema(Block3.encodingSchema),
              omitEmpty: true
            }, {
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "next-token",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BlockHeadersResponse` object.
         * @param blocks -
         * @param currentRound - Round at which the results were computed.
         * @param nextToken - Used for pagination, when making another request provide this token with the
         * next parameter.
         */
        constructor({ blocks, currentRound, nextToken }) {
          this.blocks = blocks;
          this.currentRound = ensureBigInt(currentRound);
          this.nextToken = nextToken;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BlockHeadersResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["blocks", this.blocks.map((v3) => v3.toEncodingData())],
            ["current-round", this.currentRound],
            ["next-token", this.nextToken]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockHeadersResponse: ${data}`);
          }
          return new _BlockHeadersResponse({
            blocks: (data.get("blocks") ?? []).map((v3) => Block3.fromEncodingData(v3)),
            currentRound: data.get("current-round"),
            nextToken: data.get("next-token")
          });
        }
      };
      BlockRewards = class _BlockRewards {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "fee-sink", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "rewards-calculation-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "rewards-level",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "rewards-pool",
              valueSchema: new StringSchema(),
              omitEmpty: true
            }, {
              key: "rewards-rate",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "rewards-residue",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BlockRewards` object.
         * @param feeSink - (fees) accepts transaction fees, it can only spend to the incentive pool.
         * @param rewardsCalculationRound - (rwcalr) number of leftover MicroAlgos after the distribution of rewards-rate
         * MicroAlgos for every reward unit in the next round.
         * @param rewardsLevel - (earn) How many rewards, in MicroAlgos, have been distributed to each RewardUnit
         * of MicroAlgos since genesis.
         * @param rewardsPool - (rwd) accepts periodic injections from the fee-sink and continually
         * redistributes them as rewards.
         * @param rewardsRate - (rate) Number of new MicroAlgos added to the participation stake from rewards at
         * the next round.
         * @param rewardsResidue - (frac) Number of leftover MicroAlgos after the distribution of
         * RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.
         */
        constructor({ feeSink, rewardsCalculationRound, rewardsLevel, rewardsPool, rewardsRate, rewardsResidue }) {
          this.feeSink = feeSink;
          this.rewardsCalculationRound = ensureBigInt(rewardsCalculationRound);
          this.rewardsLevel = ensureBigInt(rewardsLevel);
          this.rewardsPool = rewardsPool;
          this.rewardsRate = ensureBigInt(rewardsRate);
          this.rewardsResidue = ensureBigInt(rewardsResidue);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BlockRewards.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["fee-sink", this.feeSink],
            ["rewards-calculation-round", this.rewardsCalculationRound],
            ["rewards-level", this.rewardsLevel],
            ["rewards-pool", this.rewardsPool],
            ["rewards-rate", this.rewardsRate],
            ["rewards-residue", this.rewardsResidue]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockRewards: ${data}`);
          }
          return new _BlockRewards({
            feeSink: data.get("fee-sink"),
            rewardsCalculationRound: data.get("rewards-calculation-round"),
            rewardsLevel: data.get("rewards-level"),
            rewardsPool: data.get("rewards-pool"),
            rewardsRate: data.get("rewards-rate"),
            rewardsResidue: data.get("rewards-residue")
          });
        }
      };
      BlockUpgradeState = class _BlockUpgradeState {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "current-protocol",
              valueSchema: new StringSchema(),
              omitEmpty: true
            }, {
              key: "next-protocol",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "next-protocol-approvals",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "next-protocol-switch-on",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "next-protocol-vote-before",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BlockUpgradeState` object.
         * @param currentProtocol - (proto) The current protocol version.
         * @param nextProtocol - (nextproto) The next proposed protocol version.
         * @param nextProtocolApprovals - (nextyes) Number of blocks which approved the protocol upgrade.
         * @param nextProtocolSwitchOn - (nextswitch) Round on which the protocol upgrade will take effect.
         * @param nextProtocolVoteBefore - (nextbefore) Deadline round for this protocol upgrade (No votes will be consider
         * after this round).
         */
        constructor({ currentProtocol, nextProtocol, nextProtocolApprovals, nextProtocolSwitchOn, nextProtocolVoteBefore }) {
          this.currentProtocol = currentProtocol;
          this.nextProtocol = nextProtocol;
          this.nextProtocolApprovals = typeof nextProtocolApprovals === "undefined" ? void 0 : ensureSafeInteger(nextProtocolApprovals);
          this.nextProtocolSwitchOn = typeof nextProtocolSwitchOn === "undefined" ? void 0 : ensureBigInt(nextProtocolSwitchOn);
          this.nextProtocolVoteBefore = typeof nextProtocolVoteBefore === "undefined" ? void 0 : ensureBigInt(nextProtocolVoteBefore);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BlockUpgradeState.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["current-protocol", this.currentProtocol],
            ["next-protocol", this.nextProtocol],
            ["next-protocol-approvals", this.nextProtocolApprovals],
            ["next-protocol-switch-on", this.nextProtocolSwitchOn],
            ["next-protocol-vote-before", this.nextProtocolVoteBefore]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockUpgradeState: ${data}`);
          }
          return new _BlockUpgradeState({
            currentProtocol: data.get("current-protocol"),
            nextProtocol: data.get("next-protocol"),
            nextProtocolApprovals: data.get("next-protocol-approvals"),
            nextProtocolSwitchOn: data.get("next-protocol-switch-on"),
            nextProtocolVoteBefore: data.get("next-protocol-vote-before")
          });
        }
      };
      BlockUpgradeVote = class _BlockUpgradeVote {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "upgrade-approve",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "upgrade-delay",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "upgrade-propose",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BlockUpgradeVote` object.
         * @param upgradeApprove - (upgradeyes) Indicates a yes vote for the current proposal.
         * @param upgradeDelay - (upgradedelay) Indicates the time between acceptance and execution.
         * @param upgradePropose - (upgradeprop) Indicates a proposed upgrade.
         */
        constructor({ upgradeApprove, upgradeDelay, upgradePropose }) {
          this.upgradeApprove = upgradeApprove;
          this.upgradeDelay = typeof upgradeDelay === "undefined" ? void 0 : ensureBigInt(upgradeDelay);
          this.upgradePropose = upgradePropose;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BlockUpgradeVote.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["upgrade-approve", this.upgradeApprove],
            ["upgrade-delay", this.upgradeDelay],
            ["upgrade-propose", this.upgradePropose]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BlockUpgradeVote: ${data}`);
          }
          return new _BlockUpgradeVote({
            upgradeApprove: data.get("upgrade-approve"),
            upgradeDelay: data.get("upgrade-delay"),
            upgradePropose: data.get("upgrade-propose")
          });
        }
      };
      Box2 = class _Box {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "name", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "value", valueSchema: new ByteArraySchema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `Box` object.
         * @param name - (name) box name, base64 encoded
         * @param round - The round for which this information is relevant
         * @param value - (value) box value, base64 encoded.
         */
        constructor({ name, round, value }) {
          this.name = typeof name === "string" ? base64ToBytes(name) : name;
          this.round = ensureBigInt(round);
          this.value = typeof value === "string" ? base64ToBytes(value) : value;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Box.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["name", this.name],
            ["round", this.round],
            ["value", this.value]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Box: ${data}`);
          }
          return new _Box({
            name: data.get("name"),
            round: data.get("round"),
            value: data.get("value")
          });
        }
      };
      BoxDescriptor2 = class _BoxDescriptor {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "name",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BoxDescriptor` object.
         * @param name - Base64 encoded box name
         */
        constructor({ name }) {
          this.name = typeof name === "string" ? base64ToBytes(name) : name;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BoxDescriptor.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([["name", this.name]]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BoxDescriptor: ${data}`);
          }
          return new _BoxDescriptor({
            name: data.get("name")
          });
        }
      };
      BoxesResponse2 = class _BoxesResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "application-id",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "boxes",
              valueSchema: new ArraySchema(BoxDescriptor2.encodingSchema),
              omitEmpty: true
            }, {
              key: "next-token",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `BoxesResponse` object.
         * @param applicationId - (appidx) application index.
         * @param boxes -
         * @param nextToken - Used for pagination, when making another request provide this token with the
         * next parameter.
         */
        constructor({ applicationId, boxes, nextToken }) {
          this.applicationId = ensureBigInt(applicationId);
          this.boxes = boxes;
          this.nextToken = nextToken;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _BoxesResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["application-id", this.applicationId],
            ["boxes", this.boxes.map((v3) => v3.toEncodingData())],
            ["next-token", this.nextToken]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded BoxesResponse: ${data}`);
          }
          return new _BoxesResponse({
            applicationId: data.get("application-id"),
            boxes: (data.get("boxes") ?? []).map((v3) => BoxDescriptor2.fromEncodingData(v3)),
            nextToken: data.get("next-token")
          });
        }
      };
      ErrorResponse2 = class _ErrorResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "message", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "data",
              valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ErrorResponse` object.
         * @param message -
         * @param data -
         */
        constructor({ message, data }) {
          this.message = message;
          this.data = data;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ErrorResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["message", this.message],
            [
              "data",
              typeof this.data !== "undefined" ? this.data.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ErrorResponse: ${data}`);
          }
          return new _ErrorResponse({
            message: data.get("message"),
            data: typeof data.get("data") !== "undefined" ? UntypedValue.fromEncodingData(data.get("data")) : void 0
          });
        }
      };
      EvalDelta3 = class _EvalDelta {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "action", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "bytes",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "uint",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `EvalDelta` object.
         * @param action - (at) delta action.
         * @param bytes - (bs) bytes value.
         * @param uint - (ui) uint value.
         */
        constructor({ action, bytes, uint }) {
          this.action = ensureSafeInteger(action);
          this.bytes = bytes;
          this.uint = typeof uint === "undefined" ? void 0 : ensureBigInt(uint);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _EvalDelta.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["action", this.action],
            ["bytes", this.bytes],
            ["uint", this.uint]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded EvalDelta: ${data}`);
          }
          return new _EvalDelta({
            action: data.get("action"),
            bytes: data.get("bytes"),
            uint: data.get("uint")
          });
        }
      };
      EvalDeltaKeyValue2 = class _EvalDeltaKeyValue {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new StringSchema(), omitEmpty: true }, { key: "value", valueSchema: EvalDelta3.encodingSchema, omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `EvalDeltaKeyValue` object.
         * @param key -
         * @param value - Represents a TEAL value delta.
         */
        constructor({ key, value }) {
          this.key = key;
          this.value = value;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _EvalDeltaKeyValue.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["key", this.key],
            ["value", this.value.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded EvalDeltaKeyValue: ${data}`);
          }
          return new _EvalDeltaKeyValue({
            key: data.get("key"),
            value: EvalDelta3.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
          });
        }
      };
      HashFactory2 = class _HashFactory {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "hash-type",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `HashFactory` object.
         * @param hashType - (t)
         */
        constructor({ hashType }) {
          this.hashType = typeof hashType === "undefined" ? void 0 : ensureSafeInteger(hashType);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _HashFactory.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([["hash-type", this.hashType]]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded HashFactory: ${data}`);
          }
          return new _HashFactory({
            hashType: data.get("hash-type")
          });
        }
      };
      HbProofFields = class _HbProofFields {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "hb-pk",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "hb-pk1sig",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "hb-pk2",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "hb-pk2sig",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "hb-sig",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `HbProofFields` object.
         * @param hbPk - (p) Public key of the heartbeat message.
         * @param hbPk1sig - (p1s) Signature of OneTimeSignatureSubkeyOffsetID(PK, Batch, Offset) under the
         * key PK2.
         * @param hbPk2 - (p2) Key for new-style two-level ephemeral signature.
         * @param hbPk2sig - (p2s) Signature of OneTimeSignatureSubkeyBatchID(PK2, Batch) under the master
         * key (OneTimeSignatureVerifier).
         * @param hbSig - (s) Signature of the heartbeat message.
         */
        constructor({ hbPk, hbPk1sig, hbPk2, hbPk2sig, hbSig }) {
          this.hbPk = typeof hbPk === "string" ? base64ToBytes(hbPk) : hbPk;
          this.hbPk1sig = typeof hbPk1sig === "string" ? base64ToBytes(hbPk1sig) : hbPk1sig;
          this.hbPk2 = typeof hbPk2 === "string" ? base64ToBytes(hbPk2) : hbPk2;
          this.hbPk2sig = typeof hbPk2sig === "string" ? base64ToBytes(hbPk2sig) : hbPk2sig;
          this.hbSig = typeof hbSig === "string" ? base64ToBytes(hbSig) : hbSig;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _HbProofFields.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["hb-pk", this.hbPk],
            ["hb-pk1sig", this.hbPk1sig],
            ["hb-pk2", this.hbPk2],
            ["hb-pk2sig", this.hbPk2sig],
            ["hb-sig", this.hbSig]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded HbProofFields: ${data}`);
          }
          return new _HbProofFields({
            hbPk: data.get("hb-pk"),
            hbPk1sig: data.get("hb-pk1sig"),
            hbPk2: data.get("hb-pk2"),
            hbPk2sig: data.get("hb-pk2sig"),
            hbSig: data.get("hb-sig")
          });
        }
      };
      HealthCheck2 = class _HealthCheck {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "db-available",
              valueSchema: new BooleanSchema(),
              omitEmpty: true
            }, {
              key: "is-migrating",
              valueSchema: new BooleanSchema(),
              omitEmpty: true
            }, { key: "message", valueSchema: new StringSchema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "version", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "data",
              valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
              omitEmpty: true
            }, {
              key: "errors",
              valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `HealthCheck` object.
         * @param dbAvailable -
         * @param isMigrating -
         * @param message -
         * @param round -
         * @param version - Current version.
         * @param data -
         * @param errors -
         */
        constructor({ dbAvailable, isMigrating, message, round, version, data, errors }) {
          this.dbAvailable = dbAvailable;
          this.isMigrating = isMigrating;
          this.message = message;
          this.round = ensureBigInt(round);
          this.version = version;
          this.data = data;
          this.errors = errors;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _HealthCheck.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["db-available", this.dbAvailable],
            ["is-migrating", this.isMigrating],
            ["message", this.message],
            ["round", this.round],
            ["version", this.version],
            [
              "data",
              typeof this.data !== "undefined" ? this.data.toEncodingData() : void 0
            ],
            ["errors", this.errors]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded HealthCheck: ${data}`);
          }
          return new _HealthCheck({
            dbAvailable: data.get("db-available"),
            isMigrating: data.get("is-migrating"),
            message: data.get("message"),
            round: data.get("round"),
            version: data.get("version"),
            data: typeof data.get("data") !== "undefined" ? UntypedValue.fromEncodingData(data.get("data")) : void 0,
            errors: data.get("errors")
          });
        }
      };
      IndexerStateProofMessage = class _IndexerStateProofMessage {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "block-headers-commitment",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "first-attested-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "latest-attested-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "ln-proven-weight",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "voters-commitment",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `IndexerStateProofMessage` object.
         * @param blockHeadersCommitment - (b)
         * @param firstAttestedRound - (f)
         * @param latestAttestedRound - (l)
         * @param lnProvenWeight - (P)
         * @param votersCommitment - (v)
         */
        constructor({ blockHeadersCommitment, firstAttestedRound, latestAttestedRound, lnProvenWeight, votersCommitment }) {
          this.blockHeadersCommitment = typeof blockHeadersCommitment === "string" ? base64ToBytes(blockHeadersCommitment) : blockHeadersCommitment;
          this.firstAttestedRound = typeof firstAttestedRound === "undefined" ? void 0 : ensureBigInt(firstAttestedRound);
          this.latestAttestedRound = typeof latestAttestedRound === "undefined" ? void 0 : ensureBigInt(latestAttestedRound);
          this.lnProvenWeight = typeof lnProvenWeight === "undefined" ? void 0 : ensureBigInt(lnProvenWeight);
          this.votersCommitment = typeof votersCommitment === "string" ? base64ToBytes(votersCommitment) : votersCommitment;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _IndexerStateProofMessage.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["block-headers-commitment", this.blockHeadersCommitment],
            ["first-attested-round", this.firstAttestedRound],
            ["latest-attested-round", this.latestAttestedRound],
            ["ln-proven-weight", this.lnProvenWeight],
            ["voters-commitment", this.votersCommitment]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded IndexerStateProofMessage: ${data}`);
          }
          return new _IndexerStateProofMessage({
            blockHeadersCommitment: data.get("block-headers-commitment"),
            firstAttestedRound: data.get("first-attested-round"),
            latestAttestedRound: data.get("latest-attested-round"),
            lnProvenWeight: data.get("ln-proven-weight"),
            votersCommitment: data.get("voters-commitment")
          });
        }
      };
      MerkleArrayProof2 = class _MerkleArrayProof {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "hash-factory",
              valueSchema: new OptionalSchema(HashFactory2.encodingSchema),
              omitEmpty: true
            }, {
              key: "path",
              valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
              omitEmpty: true
            }, {
              key: "tree-depth",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `MerkleArrayProof` object.
         * @param hashFactory -
         * @param path - (pth)
         * @param treeDepth - (td)
         */
        constructor({ hashFactory, path, treeDepth }) {
          this.hashFactory = hashFactory;
          this.path = path;
          this.treeDepth = typeof treeDepth === "undefined" ? void 0 : ensureSafeInteger(treeDepth);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _MerkleArrayProof.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "hash-factory",
              typeof this.hashFactory !== "undefined" ? this.hashFactory.toEncodingData() : void 0
            ],
            ["path", this.path],
            ["tree-depth", this.treeDepth]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded MerkleArrayProof: ${data}`);
          }
          return new _MerkleArrayProof({
            hashFactory: typeof data.get("hash-factory") !== "undefined" ? HashFactory2.fromEncodingData(data.get("hash-factory")) : void 0,
            path: data.get("path"),
            treeDepth: data.get("tree-depth")
          });
        }
      };
      MiniAssetHolding = class _MiniAssetHolding {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "is-frozen", valueSchema: new BooleanSchema(), omitEmpty: true }, {
              key: "deleted",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "opted-in-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "opted-out-at-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `MiniAssetHolding` object.
         * @param address -
         * @param amount -
         * @param isFrozen -
         * @param deleted - Whether or not this asset holding is currently deleted from its account.
         * @param optedInAtRound - Round during which the account opted into the asset.
         * @param optedOutAtRound - Round during which the account opted out of the asset.
         */
        constructor({ address, amount, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
          this.address = address;
          this.amount = ensureBigInt(amount);
          this.isFrozen = isFrozen;
          this.deleted = deleted;
          this.optedInAtRound = typeof optedInAtRound === "undefined" ? void 0 : ensureBigInt(optedInAtRound);
          this.optedOutAtRound = typeof optedOutAtRound === "undefined" ? void 0 : ensureBigInt(optedOutAtRound);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _MiniAssetHolding.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["address", this.address],
            ["amount", this.amount],
            ["is-frozen", this.isFrozen],
            ["deleted", this.deleted],
            ["opted-in-at-round", this.optedInAtRound],
            ["opted-out-at-round", this.optedOutAtRound]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded MiniAssetHolding: ${data}`);
          }
          return new _MiniAssetHolding({
            address: data.get("address"),
            amount: data.get("amount"),
            isFrozen: data.get("is-frozen"),
            deleted: data.get("deleted"),
            optedInAtRound: data.get("opted-in-at-round"),
            optedOutAtRound: data.get("opted-out-at-round")
          });
        }
      };
      ParticipationUpdates2 = class _ParticipationUpdates {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "absent-participation-accounts",
              valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
              omitEmpty: true
            }, {
              key: "expired-participation-accounts",
              valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `ParticipationUpdates` object.
         * @param absentParticipationAccounts - (partupabs) a list of online accounts that need to be suspended.
         * @param expiredParticipationAccounts - (partupdrmv) a list of online accounts that needs to be converted to offline
         * since their participation key expired.
         */
        constructor({ absentParticipationAccounts, expiredParticipationAccounts }) {
          this.absentParticipationAccounts = absentParticipationAccounts;
          this.expiredParticipationAccounts = expiredParticipationAccounts;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _ParticipationUpdates.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["absent-participation-accounts", this.absentParticipationAccounts],
            ["expired-participation-accounts", this.expiredParticipationAccounts]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded ParticipationUpdates: ${data}`);
          }
          return new _ParticipationUpdates({
            absentParticipationAccounts: data.get("absent-participation-accounts"),
            expiredParticipationAccounts: data.get("expired-participation-accounts")
          });
        }
      };
      StateProofFields = class _StateProofFields {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "part-proofs",
              valueSchema: new OptionalSchema(MerkleArrayProof2.encodingSchema),
              omitEmpty: true
            }, {
              key: "positions-to-reveal",
              valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
              omitEmpty: true
            }, {
              key: "reveals",
              valueSchema: new OptionalSchema(new ArraySchema(StateProofReveal.encodingSchema)),
              omitEmpty: true
            }, {
              key: "salt-version",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "sig-commit",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "sig-proofs",
              valueSchema: new OptionalSchema(MerkleArrayProof2.encodingSchema),
              omitEmpty: true
            }, {
              key: "signed-weight",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `StateProofFields` object.
         * @param partProofs - (P)
         * @param positionsToReveal - (pr) Sequence of reveal positions.
         * @param reveals - (r) Note that this is actually stored as a map[uint64] - Reveal in the actual
         * msgp
         * @param saltVersion - (v) Salt version of the merkle signature.
         * @param sigCommit - (c)
         * @param sigProofs - (S)
         * @param signedWeight - (w)
         */
        constructor({ partProofs, positionsToReveal, reveals, saltVersion, sigCommit, sigProofs, signedWeight }) {
          this.partProofs = partProofs;
          this.positionsToReveal = typeof positionsToReveal === "undefined" ? void 0 : positionsToReveal.map(ensureBigInt);
          this.reveals = reveals;
          this.saltVersion = typeof saltVersion === "undefined" ? void 0 : ensureSafeInteger(saltVersion);
          this.sigCommit = typeof sigCommit === "string" ? base64ToBytes(sigCommit) : sigCommit;
          this.sigProofs = sigProofs;
          this.signedWeight = typeof signedWeight === "undefined" ? void 0 : ensureBigInt(signedWeight);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProofFields.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "part-proofs",
              typeof this.partProofs !== "undefined" ? this.partProofs.toEncodingData() : void 0
            ],
            ["positions-to-reveal", this.positionsToReveal],
            [
              "reveals",
              typeof this.reveals !== "undefined" ? this.reveals.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["salt-version", this.saltVersion],
            ["sig-commit", this.sigCommit],
            [
              "sig-proofs",
              typeof this.sigProofs !== "undefined" ? this.sigProofs.toEncodingData() : void 0
            ],
            ["signed-weight", this.signedWeight]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofFields: ${data}`);
          }
          return new _StateProofFields({
            partProofs: typeof data.get("part-proofs") !== "undefined" ? MerkleArrayProof2.fromEncodingData(data.get("part-proofs")) : void 0,
            positionsToReveal: data.get("positions-to-reveal"),
            reveals: typeof data.get("reveals") !== "undefined" ? data.get("reveals").map((v3) => StateProofReveal.fromEncodingData(v3)) : void 0,
            saltVersion: data.get("salt-version"),
            sigCommit: data.get("sig-commit"),
            sigProofs: typeof data.get("sig-proofs") !== "undefined" ? MerkleArrayProof2.fromEncodingData(data.get("sig-proofs")) : void 0,
            signedWeight: data.get("signed-weight")
          });
        }
      };
      StateProofParticipant = class _StateProofParticipant {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "verifier",
              valueSchema: new OptionalSchema(StateProofVerifier.encodingSchema),
              omitEmpty: true
            }, {
              key: "weight",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `StateProofParticipant` object.
         * @param verifier - (p)
         * @param weight - (w)
         */
        constructor({ verifier, weight }) {
          this.verifier = verifier;
          this.weight = typeof weight === "undefined" ? void 0 : ensureBigInt(weight);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProofParticipant.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "verifier",
              typeof this.verifier !== "undefined" ? this.verifier.toEncodingData() : void 0
            ],
            ["weight", this.weight]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofParticipant: ${data}`);
          }
          return new _StateProofParticipant({
            verifier: typeof data.get("verifier") !== "undefined" ? StateProofVerifier.fromEncodingData(data.get("verifier")) : void 0,
            weight: data.get("weight")
          });
        }
      };
      StateProofReveal = class _StateProofReveal {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "participant",
              valueSchema: new OptionalSchema(StateProofParticipant.encodingSchema),
              omitEmpty: true
            }, {
              key: "position",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "sig-slot",
              valueSchema: new OptionalSchema(StateProofSigSlot.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `StateProofReveal` object.
         * @param participant - (p)
         * @param position - The position in the signature and participants arrays corresponding to this
         * entry.
         * @param sigSlot - (s)
         */
        constructor({ participant, position, sigSlot }) {
          this.participant = participant;
          this.position = typeof position === "undefined" ? void 0 : ensureBigInt(position);
          this.sigSlot = sigSlot;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProofReveal.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "participant",
              typeof this.participant !== "undefined" ? this.participant.toEncodingData() : void 0
            ],
            ["position", this.position],
            [
              "sig-slot",
              typeof this.sigSlot !== "undefined" ? this.sigSlot.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofReveal: ${data}`);
          }
          return new _StateProofReveal({
            participant: typeof data.get("participant") !== "undefined" ? StateProofParticipant.fromEncodingData(data.get("participant")) : void 0,
            position: data.get("position"),
            sigSlot: typeof data.get("sig-slot") !== "undefined" ? StateProofSigSlot.fromEncodingData(data.get("sig-slot")) : void 0
          });
        }
      };
      StateProofSigSlot = class _StateProofSigSlot {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "lower-sig-weight",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "signature",
              valueSchema: new OptionalSchema(StateProofSignature.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `StateProofSigSlot` object.
         * @param lowerSigWeight - (l) The total weight of signatures in the lower-numbered slots.
         * @param signature -
         */
        constructor({ lowerSigWeight, signature }) {
          this.lowerSigWeight = typeof lowerSigWeight === "undefined" ? void 0 : ensureBigInt(lowerSigWeight);
          this.signature = signature;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProofSigSlot.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["lower-sig-weight", this.lowerSigWeight],
            [
              "signature",
              typeof this.signature !== "undefined" ? this.signature.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofSigSlot: ${data}`);
          }
          return new _StateProofSigSlot({
            lowerSigWeight: data.get("lower-sig-weight"),
            signature: typeof data.get("signature") !== "undefined" ? StateProofSignature.fromEncodingData(data.get("signature")) : void 0
          });
        }
      };
      StateProofSignature = class _StateProofSignature {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "falcon-signature",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "merkle-array-index",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "proof",
              valueSchema: new OptionalSchema(MerkleArrayProof2.encodingSchema),
              omitEmpty: true
            }, {
              key: "verifying-key",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `StateProofSignature` object.
         * @param falconSignature -
         * @param merkleArrayIndex -
         * @param proof -
         * @param verifyingKey - (vkey)
         */
        constructor({ falconSignature, merkleArrayIndex, proof, verifyingKey }) {
          this.falconSignature = typeof falconSignature === "string" ? base64ToBytes(falconSignature) : falconSignature;
          this.merkleArrayIndex = typeof merkleArrayIndex === "undefined" ? void 0 : ensureSafeInteger(merkleArrayIndex);
          this.proof = proof;
          this.verifyingKey = typeof verifyingKey === "string" ? base64ToBytes(verifyingKey) : verifyingKey;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProofSignature.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["falcon-signature", this.falconSignature],
            ["merkle-array-index", this.merkleArrayIndex],
            [
              "proof",
              typeof this.proof !== "undefined" ? this.proof.toEncodingData() : void 0
            ],
            ["verifying-key", this.verifyingKey]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofSignature: ${data}`);
          }
          return new _StateProofSignature({
            falconSignature: data.get("falcon-signature"),
            merkleArrayIndex: data.get("merkle-array-index"),
            proof: typeof data.get("proof") !== "undefined" ? MerkleArrayProof2.fromEncodingData(data.get("proof")) : void 0,
            verifyingKey: data.get("verifying-key")
          });
        }
      };
      StateProofTracking = class _StateProofTracking {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "next-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "online-total-weight",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "type",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "voters-commitment",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `StateProofTracking` object.
         * @param nextRound - (n) Next round for which we will accept a state proof transaction.
         * @param onlineTotalWeight - (t) The total number of microalgos held by the online accounts during the
         * StateProof round.
         * @param type - State Proof Type. Note the raw object uses map with this as key.
         * @param votersCommitment - (v) Root of a vector commitment containing online accounts that will help sign
         * the proof.
         */
        constructor({ nextRound, onlineTotalWeight, type, votersCommitment }) {
          this.nextRound = typeof nextRound === "undefined" ? void 0 : ensureBigInt(nextRound);
          this.onlineTotalWeight = typeof onlineTotalWeight === "undefined" ? void 0 : ensureBigInt(onlineTotalWeight);
          this.type = typeof type === "undefined" ? void 0 : ensureSafeInteger(type);
          this.votersCommitment = typeof votersCommitment === "string" ? base64ToBytes(votersCommitment) : votersCommitment;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProofTracking.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["next-round", this.nextRound],
            ["online-total-weight", this.onlineTotalWeight],
            ["type", this.type],
            ["voters-commitment", this.votersCommitment]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofTracking: ${data}`);
          }
          return new _StateProofTracking({
            nextRound: data.get("next-round"),
            onlineTotalWeight: data.get("online-total-weight"),
            type: data.get("type"),
            votersCommitment: data.get("voters-commitment")
          });
        }
      };
      StateProofVerifier = class _StateProofVerifier {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "commitment",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "key-lifetime",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `StateProofVerifier` object.
         * @param commitment - (cmt) Represents the root of the vector commitment tree.
         * @param keyLifetime - (lf) Key lifetime.
         */
        constructor({ commitment, keyLifetime }) {
          this.commitment = typeof commitment === "string" ? base64ToBytes(commitment) : commitment;
          this.keyLifetime = typeof keyLifetime === "undefined" ? void 0 : ensureBigInt(keyLifetime);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateProofVerifier.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["commitment", this.commitment],
            ["key-lifetime", this.keyLifetime]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateProofVerifier: ${data}`);
          }
          return new _StateProofVerifier({
            commitment: data.get("commitment"),
            keyLifetime: data.get("key-lifetime")
          });
        }
      };
      StateSchema2 = class _StateSchema {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "num-byte-slice",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, { key: "num-uint", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `StateSchema` object.
         * @param numByteSlice - Maximum number of TEAL byte slices that may be stored in the key/value store.
         * @param numUint - Maximum number of TEAL uints that may be stored in the key/value store.
         */
        constructor({ numByteSlice, numUint }) {
          this.numByteSlice = ensureSafeInteger(numByteSlice);
          this.numUint = ensureSafeInteger(numUint);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _StateSchema.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["num-byte-slice", this.numByteSlice],
            ["num-uint", this.numUint]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded StateSchema: ${data}`);
          }
          return new _StateSchema({
            numByteSlice: data.get("num-byte-slice"),
            numUint: data.get("num-uint")
          });
        }
      };
      TealKeyValue2 = class _TealKeyValue {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "value", valueSchema: TealValue3.encodingSchema, omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TealKeyValue` object.
         * @param key -
         * @param value - Represents a TEAL value.
         */
        constructor({ key, value }) {
          this.key = typeof key === "string" ? base64ToBytes(key) : key;
          this.value = value;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TealKeyValue.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["key", this.key],
            ["value", this.value.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TealKeyValue: ${data}`);
          }
          return new _TealKeyValue({
            key: data.get("key"),
            value: TealValue3.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
          });
        }
      };
      TealValue3 = class _TealValue {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "bytes", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "type", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "uint", valueSchema: new Uint64Schema(), omitEmpty: true });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TealValue` object.
         * @param bytes - bytes value.
         * @param type - type of the value. Value `1` refers to **bytes**, value `2` refers to **uint**
         * @param uint - uint value.
         */
        constructor({ bytes, type, uint }) {
          this.bytes = typeof bytes === "string" ? base64ToBytes(bytes) : bytes;
          this.type = ensureSafeInteger(type);
          this.uint = ensureBigInt(uint);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TealValue.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["bytes", this.bytes],
            ["type", this.type],
            ["uint", this.uint]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TealValue: ${data}`);
          }
          return new _TealValue({
            bytes: data.get("bytes"),
            type: data.get("type"),
            uint: data.get("uint")
          });
        }
      };
      Transaction2 = class _Transaction {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "fee", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "first-valid",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, { key: "last-valid", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "sender", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "application-transaction",
              valueSchema: new OptionalSchema(TransactionApplication.encodingSchema),
              omitEmpty: true
            }, {
              key: "asset-config-transaction",
              valueSchema: new OptionalSchema(TransactionAssetConfig.encodingSchema),
              omitEmpty: true
            }, {
              key: "asset-freeze-transaction",
              valueSchema: new OptionalSchema(TransactionAssetFreeze.encodingSchema),
              omitEmpty: true
            }, {
              key: "asset-transfer-transaction",
              valueSchema: new OptionalSchema(TransactionAssetTransfer.encodingSchema),
              omitEmpty: true
            }, {
              key: "auth-addr",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "close-rewards",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "closing-amount",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "confirmed-round",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "created-application-index",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "created-asset-index",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "genesis-hash",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "genesis-id",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "global-state-delta",
              valueSchema: new OptionalSchema(new ArraySchema(EvalDeltaKeyValue2.encodingSchema)),
              omitEmpty: true
            }, {
              key: "group",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "heartbeat-transaction",
              valueSchema: new OptionalSchema(TransactionHeartbeat.encodingSchema),
              omitEmpty: true
            }, {
              key: "id",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "inner-txns",
              valueSchema: new OptionalSchema(new ArraySchema(_Transaction.encodingSchema)),
              omitEmpty: true
            }, {
              key: "intra-round-offset",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "keyreg-transaction",
              valueSchema: new OptionalSchema(TransactionKeyreg.encodingSchema),
              omitEmpty: true
            }, {
              key: "lease",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "local-state-delta",
              valueSchema: new OptionalSchema(new ArraySchema(AccountStateDelta2.encodingSchema)),
              omitEmpty: true
            }, {
              key: "logs",
              valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
              omitEmpty: true
            }, {
              key: "note",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "payment-transaction",
              valueSchema: new OptionalSchema(TransactionPayment.encodingSchema),
              omitEmpty: true
            }, {
              key: "receiver-rewards",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "rekey-to",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "round-time",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "sender-rewards",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "signature",
              valueSchema: new OptionalSchema(TransactionSignature.encodingSchema),
              omitEmpty: true
            }, {
              key: "state-proof-transaction",
              valueSchema: new OptionalSchema(TransactionStateProof.encodingSchema),
              omitEmpty: true
            }, {
              key: "tx-type",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `Transaction` object.
         * @param fee - (fee) Transaction fee.
         * @param firstValid - (fv) First valid round for this transaction.
         * @param lastValid - (lv) Last valid round for this transaction.
         * @param sender - (snd) Sender's address.
         * @param applicationTransaction - Fields for application transactions.
         * Definition:
         * data/transactions/application.go : ApplicationCallTxnFields
         * @param assetConfigTransaction - Fields for asset allocation, re-configuration, and destruction.
         * A zero value for asset-id indicates asset creation.
         * A zero value for the params indicates asset destruction.
         * Definition:
         * data/transactions/asset.go : AssetConfigTxnFields
         * @param assetFreezeTransaction - Fields for an asset freeze transaction.
         * Definition:
         * data/transactions/asset.go : AssetFreezeTxnFields
         * @param assetTransferTransaction - Fields for an asset transfer transaction.
         * Definition:
         * data/transactions/asset.go : AssetTransferTxnFields
         * @param authAddr - (sgnr) this is included with signed transactions when the signing address does
         * not equal the sender. The backend can use this to ensure that auth addr is equal
         * to the accounts auth addr.
         * @param closeRewards - (rc) rewards applied to close-remainder-to account.
         * @param closingAmount - (ca) closing amount for transaction.
         * @param confirmedRound - Round when the transaction was confirmed.
         * @param createdApplicationIndex - Specifies an application index (ID) if an application was created with this
         * transaction.
         * @param createdAssetIndex - Specifies an asset index (ID) if an asset was created with this transaction.
         * @param genesisHash - (gh) Hash of genesis block.
         * @param genesisId - (gen) genesis block ID.
         * @param globalStateDelta - (gd) Global state key/value changes for the application being executed by this
         * transaction.
         * @param group - (grp) Base64 encoded byte array of a sha512/256 digest. When present indicates
         * that this transaction is part of a transaction group and the value is the
         * sha512/256 hash of the transactions in that group.
         * @param heartbeatTransaction - Fields for a heartbeat transaction.
         * Definition:
         * data/transactions/heartbeat.go : HeartbeatTxnFields
         * @param id - Transaction ID
         * @param innerTxns - Inner transactions produced by application execution.
         * @param intraRoundOffset - Offset into the round where this transaction was confirmed.
         * @param keyregTransaction - Fields for a keyreg transaction.
         * Definition:
         * data/transactions/keyreg.go : KeyregTxnFields
         * @param lease - (lx) Base64 encoded 32-byte array. Lease enforces mutual exclusion of
         * transactions. If this field is nonzero, then once the transaction is confirmed,
         * it acquires the lease identified by the (Sender, Lease) pair of the transaction
         * until the LastValid round passes. While this transaction possesses the lease, no
         * other transaction specifying this lease can be confirmed.
         * @param localStateDelta - (ld) Local state key/value changes for the application being executed by this
         * transaction.
         * @param logs - (lg) Logs for the application being executed by this transaction.
         * @param note - (note) Free form data.
         * @param paymentTransaction - Fields for a payment transaction.
         * Definition:
         * data/transactions/payment.go : PaymentTxnFields
         * @param receiverRewards - (rr) rewards applied to receiver account.
         * @param rekeyTo - (rekey) when included in a valid transaction, the accounts auth addr will be
         * updated with this value and future signatures must be signed with the key
         * represented by this address.
         * @param roundTime - Time when the block this transaction is in was confirmed.
         * @param senderRewards - (rs) rewards applied to sender account.
         * @param signature - Validation signature associated with some data. Only one of the signatures
         * should be provided.
         * @param stateProofTransaction - Fields for a state proof transaction.
         * Definition:
         * data/transactions/stateproof.go : StateProofTxnFields
         * @param txType - (type) Indicates what type of transaction this is. Different types have
         * different fields.
         * Valid types, and where their fields are stored:
         * * (pay) payment-transaction
         * * (keyreg) keyreg-transaction
         * * (acfg) asset-config-transaction
         * * (axfer) asset-transfer-transaction
         * * (afrz) asset-freeze-transaction
         * * (appl) application-transaction
         * * (stpf) state-proof-transaction
         * * (hb) heartbeat-transaction
         */
        constructor({ fee, firstValid, lastValid, sender, applicationTransaction, assetConfigTransaction, assetFreezeTransaction, assetTransferTransaction, authAddr, closeRewards, closingAmount, confirmedRound, createdApplicationIndex, createdAssetIndex, genesisHash, genesisId, globalStateDelta, group, heartbeatTransaction, id, innerTxns, intraRoundOffset, keyregTransaction, lease, localStateDelta, logs, note, paymentTransaction, receiverRewards, rekeyTo, roundTime, senderRewards, signature, stateProofTransaction, txType }) {
          this.fee = ensureBigInt(fee);
          this.firstValid = ensureBigInt(firstValid);
          this.lastValid = ensureBigInt(lastValid);
          this.sender = sender;
          this.applicationTransaction = applicationTransaction;
          this.assetConfigTransaction = assetConfigTransaction;
          this.assetFreezeTransaction = assetFreezeTransaction;
          this.assetTransferTransaction = assetTransferTransaction;
          this.authAddr = typeof authAddr === "string" ? Address.fromString(authAddr) : authAddr;
          this.closeRewards = typeof closeRewards === "undefined" ? void 0 : ensureBigInt(closeRewards);
          this.closingAmount = typeof closingAmount === "undefined" ? void 0 : ensureBigInt(closingAmount);
          this.confirmedRound = typeof confirmedRound === "undefined" ? void 0 : ensureBigInt(confirmedRound);
          this.createdApplicationIndex = typeof createdApplicationIndex === "undefined" ? void 0 : ensureBigInt(createdApplicationIndex);
          this.createdAssetIndex = typeof createdAssetIndex === "undefined" ? void 0 : ensureBigInt(createdAssetIndex);
          this.genesisHash = typeof genesisHash === "string" ? base64ToBytes(genesisHash) : genesisHash;
          this.genesisId = genesisId;
          this.globalStateDelta = globalStateDelta;
          this.group = typeof group === "string" ? base64ToBytes(group) : group;
          this.heartbeatTransaction = heartbeatTransaction;
          this.id = id;
          this.innerTxns = innerTxns;
          this.intraRoundOffset = typeof intraRoundOffset === "undefined" ? void 0 : ensureSafeInteger(intraRoundOffset);
          this.keyregTransaction = keyregTransaction;
          this.lease = typeof lease === "string" ? base64ToBytes(lease) : lease;
          this.localStateDelta = localStateDelta;
          this.logs = logs;
          this.note = typeof note === "string" ? base64ToBytes(note) : note;
          this.paymentTransaction = paymentTransaction;
          this.receiverRewards = typeof receiverRewards === "undefined" ? void 0 : ensureBigInt(receiverRewards);
          this.rekeyTo = typeof rekeyTo === "string" ? Address.fromString(rekeyTo) : rekeyTo;
          this.roundTime = typeof roundTime === "undefined" ? void 0 : ensureSafeInteger(roundTime);
          this.senderRewards = typeof senderRewards === "undefined" ? void 0 : ensureBigInt(senderRewards);
          this.signature = signature;
          this.stateProofTransaction = stateProofTransaction;
          this.txType = txType;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _Transaction.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["fee", this.fee],
            ["first-valid", this.firstValid],
            ["last-valid", this.lastValid],
            ["sender", this.sender],
            [
              "application-transaction",
              typeof this.applicationTransaction !== "undefined" ? this.applicationTransaction.toEncodingData() : void 0
            ],
            [
              "asset-config-transaction",
              typeof this.assetConfigTransaction !== "undefined" ? this.assetConfigTransaction.toEncodingData() : void 0
            ],
            [
              "asset-freeze-transaction",
              typeof this.assetFreezeTransaction !== "undefined" ? this.assetFreezeTransaction.toEncodingData() : void 0
            ],
            [
              "asset-transfer-transaction",
              typeof this.assetTransferTransaction !== "undefined" ? this.assetTransferTransaction.toEncodingData() : void 0
            ],
            [
              "auth-addr",
              typeof this.authAddr !== "undefined" ? this.authAddr.toString() : void 0
            ],
            ["close-rewards", this.closeRewards],
            ["closing-amount", this.closingAmount],
            ["confirmed-round", this.confirmedRound],
            ["created-application-index", this.createdApplicationIndex],
            ["created-asset-index", this.createdAssetIndex],
            ["genesis-hash", this.genesisHash],
            ["genesis-id", this.genesisId],
            [
              "global-state-delta",
              typeof this.globalStateDelta !== "undefined" ? this.globalStateDelta.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["group", this.group],
            [
              "heartbeat-transaction",
              typeof this.heartbeatTransaction !== "undefined" ? this.heartbeatTransaction.toEncodingData() : void 0
            ],
            ["id", this.id],
            [
              "inner-txns",
              typeof this.innerTxns !== "undefined" ? this.innerTxns.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["intra-round-offset", this.intraRoundOffset],
            [
              "keyreg-transaction",
              typeof this.keyregTransaction !== "undefined" ? this.keyregTransaction.toEncodingData() : void 0
            ],
            ["lease", this.lease],
            [
              "local-state-delta",
              typeof this.localStateDelta !== "undefined" ? this.localStateDelta.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["logs", this.logs],
            ["note", this.note],
            [
              "payment-transaction",
              typeof this.paymentTransaction !== "undefined" ? this.paymentTransaction.toEncodingData() : void 0
            ],
            ["receiver-rewards", this.receiverRewards],
            [
              "rekey-to",
              typeof this.rekeyTo !== "undefined" ? this.rekeyTo.toString() : void 0
            ],
            ["round-time", this.roundTime],
            ["sender-rewards", this.senderRewards],
            [
              "signature",
              typeof this.signature !== "undefined" ? this.signature.toEncodingData() : void 0
            ],
            [
              "state-proof-transaction",
              typeof this.stateProofTransaction !== "undefined" ? this.stateProofTransaction.toEncodingData() : void 0
            ],
            ["tx-type", this.txType]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded Transaction: ${data}`);
          }
          return new _Transaction({
            fee: data.get("fee"),
            firstValid: data.get("first-valid"),
            lastValid: data.get("last-valid"),
            sender: data.get("sender"),
            applicationTransaction: typeof data.get("application-transaction") !== "undefined" ? TransactionApplication.fromEncodingData(data.get("application-transaction")) : void 0,
            assetConfigTransaction: typeof data.get("asset-config-transaction") !== "undefined" ? TransactionAssetConfig.fromEncodingData(data.get("asset-config-transaction")) : void 0,
            assetFreezeTransaction: typeof data.get("asset-freeze-transaction") !== "undefined" ? TransactionAssetFreeze.fromEncodingData(data.get("asset-freeze-transaction")) : void 0,
            assetTransferTransaction: typeof data.get("asset-transfer-transaction") !== "undefined" ? TransactionAssetTransfer.fromEncodingData(data.get("asset-transfer-transaction")) : void 0,
            authAddr: data.get("auth-addr"),
            closeRewards: data.get("close-rewards"),
            closingAmount: data.get("closing-amount"),
            confirmedRound: data.get("confirmed-round"),
            createdApplicationIndex: data.get("created-application-index"),
            createdAssetIndex: data.get("created-asset-index"),
            genesisHash: data.get("genesis-hash"),
            genesisId: data.get("genesis-id"),
            globalStateDelta: typeof data.get("global-state-delta") !== "undefined" ? data.get("global-state-delta").map((v3) => EvalDeltaKeyValue2.fromEncodingData(v3)) : void 0,
            group: data.get("group"),
            heartbeatTransaction: typeof data.get("heartbeat-transaction") !== "undefined" ? TransactionHeartbeat.fromEncodingData(data.get("heartbeat-transaction")) : void 0,
            id: data.get("id"),
            innerTxns: typeof data.get("inner-txns") !== "undefined" ? data.get("inner-txns").map((v3) => _Transaction.fromEncodingData(v3)) : void 0,
            intraRoundOffset: data.get("intra-round-offset"),
            keyregTransaction: typeof data.get("keyreg-transaction") !== "undefined" ? TransactionKeyreg.fromEncodingData(data.get("keyreg-transaction")) : void 0,
            lease: data.get("lease"),
            localStateDelta: typeof data.get("local-state-delta") !== "undefined" ? data.get("local-state-delta").map((v3) => AccountStateDelta2.fromEncodingData(v3)) : void 0,
            logs: data.get("logs"),
            note: data.get("note"),
            paymentTransaction: typeof data.get("payment-transaction") !== "undefined" ? TransactionPayment.fromEncodingData(data.get("payment-transaction")) : void 0,
            receiverRewards: data.get("receiver-rewards"),
            rekeyTo: data.get("rekey-to"),
            roundTime: data.get("round-time"),
            senderRewards: data.get("sender-rewards"),
            signature: typeof data.get("signature") !== "undefined" ? TransactionSignature.fromEncodingData(data.get("signature")) : void 0,
            stateProofTransaction: typeof data.get("state-proof-transaction") !== "undefined" ? TransactionStateProof.fromEncodingData(data.get("state-proof-transaction")) : void 0,
            txType: data.get("tx-type")
          });
        }
      };
      TransactionApplication = class _TransactionApplication {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "application-id",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "accounts",
              valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
              omitEmpty: true
            }, {
              key: "application-args",
              valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
              omitEmpty: true
            }, {
              key: "approval-program",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "clear-state-program",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "extra-program-pages",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "foreign-apps",
              valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
              omitEmpty: true
            }, {
              key: "foreign-assets",
              valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
              omitEmpty: true
            }, {
              key: "global-state-schema",
              valueSchema: new OptionalSchema(StateSchema2.encodingSchema),
              omitEmpty: true
            }, {
              key: "local-state-schema",
              valueSchema: new OptionalSchema(StateSchema2.encodingSchema),
              omitEmpty: true
            }, {
              key: "on-completion",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionApplication` object.
         * @param applicationId - (apid) ID of the application being configured or empty if creating.
         * @param accounts - (apat) List of accounts in addition to the sender that may be accessed from the
         * application's approval-program and clear-state-program.
         * @param applicationArgs - (apaa) transaction specific arguments accessed from the application's
         * approval-program and clear-state-program.
         * @param approvalProgram - (apap) Logic executed for every application transaction, except when
         * on-completion is set to "clear". It can read and write global state for the
         * application, as well as account-specific local state. Approval programs may
         * reject the transaction.
         * @param clearStateProgram - (apsu) Logic executed for application transactions with on-completion set to
         * "clear". It can read and write global state for the application, as well as
         * account-specific local state. Clear state programs cannot reject the
         * transaction.
         * @param extraProgramPages - (epp) specifies the additional app program len requested in pages.
         * @param foreignApps - (apfa) Lists the applications in addition to the application-id whose global
         * states may be accessed by this application's approval-program and
         * clear-state-program. The access is read-only.
         * @param foreignAssets - (apas) lists the assets whose parameters may be accessed by this application's
         * ApprovalProgram and ClearStateProgram. The access is read-only.
         * @param globalStateSchema - Represents a (apls) local-state or (apgs) global-state schema. These schemas
         * determine how much storage may be used in a local-state or global-state for an
         * application. The more space used, the larger minimum balance must be maintained
         * in the account holding the data.
         * @param localStateSchema - Represents a (apls) local-state or (apgs) global-state schema. These schemas
         * determine how much storage may be used in a local-state or global-state for an
         * application. The more space used, the larger minimum balance must be maintained
         * in the account holding the data.
         * @param onCompletion - (apan) defines the what additional actions occur with the transaction.
         * Valid types:
         * * noop
         * * optin
         * * closeout
         * * clear
         * * update
         * * update
         * * delete
         */
        constructor({ applicationId, accounts, applicationArgs, approvalProgram, clearStateProgram, extraProgramPages, foreignApps, foreignAssets, globalStateSchema, localStateSchema, onCompletion }) {
          this.applicationId = ensureBigInt(applicationId);
          this.accounts = typeof accounts !== "undefined" ? accounts.map((addr) => typeof addr === "string" ? Address.fromString(addr) : addr) : void 0;
          this.applicationArgs = applicationArgs;
          this.approvalProgram = typeof approvalProgram === "string" ? base64ToBytes(approvalProgram) : approvalProgram;
          this.clearStateProgram = typeof clearStateProgram === "string" ? base64ToBytes(clearStateProgram) : clearStateProgram;
          this.extraProgramPages = typeof extraProgramPages === "undefined" ? void 0 : ensureSafeInteger(extraProgramPages);
          this.foreignApps = typeof foreignApps === "undefined" ? void 0 : foreignApps.map(ensureBigInt);
          this.foreignAssets = typeof foreignAssets === "undefined" ? void 0 : foreignAssets.map(ensureBigInt);
          this.globalStateSchema = globalStateSchema;
          this.localStateSchema = localStateSchema;
          this.onCompletion = onCompletion;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionApplication.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["application-id", this.applicationId],
            [
              "accounts",
              typeof this.accounts !== "undefined" ? this.accounts.map((v3) => v3.toString()) : void 0
            ],
            ["application-args", this.applicationArgs],
            ["approval-program", this.approvalProgram],
            ["clear-state-program", this.clearStateProgram],
            ["extra-program-pages", this.extraProgramPages],
            ["foreign-apps", this.foreignApps],
            ["foreign-assets", this.foreignAssets],
            [
              "global-state-schema",
              typeof this.globalStateSchema !== "undefined" ? this.globalStateSchema.toEncodingData() : void 0
            ],
            [
              "local-state-schema",
              typeof this.localStateSchema !== "undefined" ? this.localStateSchema.toEncodingData() : void 0
            ],
            ["on-completion", this.onCompletion]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionApplication: ${data}`);
          }
          return new _TransactionApplication({
            applicationId: data.get("application-id"),
            accounts: data.get("accounts"),
            applicationArgs: data.get("application-args"),
            approvalProgram: data.get("approval-program"),
            clearStateProgram: data.get("clear-state-program"),
            extraProgramPages: data.get("extra-program-pages"),
            foreignApps: data.get("foreign-apps"),
            foreignAssets: data.get("foreign-assets"),
            globalStateSchema: typeof data.get("global-state-schema") !== "undefined" ? StateSchema2.fromEncodingData(data.get("global-state-schema")) : void 0,
            localStateSchema: typeof data.get("local-state-schema") !== "undefined" ? StateSchema2.fromEncodingData(data.get("local-state-schema")) : void 0,
            onCompletion: data.get("on-completion")
          });
        }
      };
      TransactionAssetConfig = class _TransactionAssetConfig {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "asset-id",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "params",
              valueSchema: new OptionalSchema(AssetParams3.encodingSchema),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionAssetConfig` object.
         * @param assetId - (xaid) ID of the asset being configured or empty if creating.
         * @param params - AssetParams specifies the parameters for an asset.
         * (apar) when part of an AssetConfig transaction.
         * Definition:
         * data/transactions/asset.go : AssetParams
         */
        constructor({ assetId, params }) {
          this.assetId = typeof assetId === "undefined" ? void 0 : ensureBigInt(assetId);
          this.params = params;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionAssetConfig.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["asset-id", this.assetId],
            [
              "params",
              typeof this.params !== "undefined" ? this.params.toEncodingData() : void 0
            ]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionAssetConfig: ${data}`);
          }
          return new _TransactionAssetConfig({
            assetId: data.get("asset-id"),
            params: typeof data.get("params") !== "undefined" ? AssetParams3.fromEncodingData(data.get("params")) : void 0
          });
        }
      };
      TransactionAssetFreeze = class _TransactionAssetFreeze {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
              key: "new-freeze-status",
              valueSchema: new BooleanSchema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionAssetFreeze` object.
         * @param address - (fadd) Address of the account whose asset is being frozen or thawed.
         * @param assetId - (faid) ID of the asset being frozen or thawed.
         * @param newFreezeStatus - (afrz) The new freeze status.
         */
        constructor({ address, assetId, newFreezeStatus }) {
          this.address = address;
          this.assetId = ensureBigInt(assetId);
          this.newFreezeStatus = newFreezeStatus;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionAssetFreeze.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["address", this.address],
            ["asset-id", this.assetId],
            ["new-freeze-status", this.newFreezeStatus]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionAssetFreeze: ${data}`);
          }
          return new _TransactionAssetFreeze({
            address: data.get("address"),
            assetId: data.get("asset-id"),
            newFreezeStatus: data.get("new-freeze-status")
          });
        }
      };
      TransactionAssetTransfer = class _TransactionAssetTransfer {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "receiver", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "close-amount",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "close-to",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            }, {
              key: "sender",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionAssetTransfer` object.
         * @param amount - (aamt) Amount of asset to transfer. A zero amount transferred to self allocates
         * that asset in the account's Assets map.
         * @param assetId - (xaid) ID of the asset being transferred.
         * @param receiver - (arcv) Recipient address of the transfer.
         * @param closeAmount - Number of assets transferred to the close-to account as part of the transaction.
         * @param closeTo - (aclose) Indicates that the asset should be removed from the account's Assets
         * map, and specifies where the remaining asset holdings should be transferred.
         * It's always valid to transfer remaining asset holdings to the creator account.
         * @param sender - (asnd) The effective sender during a clawback transactions. If this is not a
         * zero value, the real transaction sender must be the Clawback address from the
         * AssetParams.
         */
        constructor({ amount, assetId, receiver, closeAmount, closeTo, sender }) {
          this.amount = ensureBigInt(amount);
          this.assetId = ensureBigInt(assetId);
          this.receiver = receiver;
          this.closeAmount = typeof closeAmount === "undefined" ? void 0 : ensureBigInt(closeAmount);
          this.closeTo = closeTo;
          this.sender = sender;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionAssetTransfer.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["amount", this.amount],
            ["asset-id", this.assetId],
            ["receiver", this.receiver],
            ["close-amount", this.closeAmount],
            ["close-to", this.closeTo],
            ["sender", this.sender]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionAssetTransfer: ${data}`);
          }
          return new _TransactionAssetTransfer({
            amount: data.get("amount"),
            assetId: data.get("asset-id"),
            receiver: data.get("receiver"),
            closeAmount: data.get("close-amount"),
            closeTo: data.get("close-to"),
            sender: data.get("sender")
          });
        }
      };
      TransactionHeartbeat = class _TransactionHeartbeat {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "hb-address", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "hb-key-dilution",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "hb-proof",
              valueSchema: HbProofFields.encodingSchema,
              omitEmpty: true
            }, { key: "hb-seed", valueSchema: new ByteArraySchema(), omitEmpty: true }, {
              key: "hb-vote-id",
              valueSchema: new ByteArraySchema(),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionHeartbeat` object.
         * @param hbAddress - (hbad) HbAddress is the account this txn is proving onlineness for.
         * @param hbKeyDilution - (hbkd) HbKeyDilution must match HbAddress account's current KeyDilution.
         * @param hbProof - (hbprf) HbProof is a signature using HeartbeatAddress's partkey, thereby showing
         * it is online.
         * @param hbSeed - (hbsd) HbSeed must be the block seed for the this transaction's firstValid
         * block.
         * @param hbVoteId - (hbvid) HbVoteID must match the HbAddress account's current VoteID.
         */
        constructor({ hbAddress, hbKeyDilution, hbProof, hbSeed, hbVoteId }) {
          this.hbAddress = hbAddress;
          this.hbKeyDilution = ensureBigInt(hbKeyDilution);
          this.hbProof = hbProof;
          this.hbSeed = typeof hbSeed === "string" ? base64ToBytes(hbSeed) : hbSeed;
          this.hbVoteId = typeof hbVoteId === "string" ? base64ToBytes(hbVoteId) : hbVoteId;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionHeartbeat.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["hb-address", this.hbAddress],
            ["hb-key-dilution", this.hbKeyDilution],
            ["hb-proof", this.hbProof.toEncodingData()],
            ["hb-seed", this.hbSeed],
            ["hb-vote-id", this.hbVoteId]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionHeartbeat: ${data}`);
          }
          return new _TransactionHeartbeat({
            hbAddress: data.get("hb-address"),
            hbKeyDilution: data.get("hb-key-dilution"),
            hbProof: HbProofFields.fromEncodingData(data.get("hb-proof") ?? /* @__PURE__ */ new Map()),
            hbSeed: data.get("hb-seed"),
            hbVoteId: data.get("hb-vote-id")
          });
        }
      };
      TransactionKeyreg = class _TransactionKeyreg {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "non-participation",
              valueSchema: new OptionalSchema(new BooleanSchema()),
              omitEmpty: true
            }, {
              key: "selection-participation-key",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "state-proof-key",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "vote-first-valid",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "vote-key-dilution",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "vote-last-valid",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "vote-participation-key",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionKeyreg` object.
         * @param nonParticipation - (nonpart) Mark the account as participating or non-participating.
         * @param selectionParticipationKey - (selkey) Public key used with the Verified Random Function (VRF) result during
         * committee selection.
         * @param stateProofKey - (sprfkey) State proof key used in key registration transactions.
         * @param voteFirstValid - (votefst) First round this participation key is valid.
         * @param voteKeyDilution - (votekd) Number of subkeys in each batch of participation keys.
         * @param voteLastValid - (votelst) Last round this participation key is valid.
         * @param voteParticipationKey - (votekey) Participation public key used in key registration transactions.
         */
        constructor({ nonParticipation, selectionParticipationKey, stateProofKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey }) {
          this.nonParticipation = nonParticipation;
          this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? base64ToBytes(selectionParticipationKey) : selectionParticipationKey;
          this.stateProofKey = typeof stateProofKey === "string" ? base64ToBytes(stateProofKey) : stateProofKey;
          this.voteFirstValid = typeof voteFirstValid === "undefined" ? void 0 : ensureBigInt(voteFirstValid);
          this.voteKeyDilution = typeof voteKeyDilution === "undefined" ? void 0 : ensureBigInt(voteKeyDilution);
          this.voteLastValid = typeof voteLastValid === "undefined" ? void 0 : ensureBigInt(voteLastValid);
          this.voteParticipationKey = typeof voteParticipationKey === "string" ? base64ToBytes(voteParticipationKey) : voteParticipationKey;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionKeyreg.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["non-participation", this.nonParticipation],
            ["selection-participation-key", this.selectionParticipationKey],
            ["state-proof-key", this.stateProofKey],
            ["vote-first-valid", this.voteFirstValid],
            ["vote-key-dilution", this.voteKeyDilution],
            ["vote-last-valid", this.voteLastValid],
            ["vote-participation-key", this.voteParticipationKey]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionKeyreg: ${data}`);
          }
          return new _TransactionKeyreg({
            nonParticipation: data.get("non-participation"),
            selectionParticipationKey: data.get("selection-participation-key"),
            stateProofKey: data.get("state-proof-key"),
            voteFirstValid: data.get("vote-first-valid"),
            voteKeyDilution: data.get("vote-key-dilution"),
            voteLastValid: data.get("vote-last-valid"),
            voteParticipationKey: data.get("vote-participation-key")
          });
        }
      };
      TransactionPayment = class _TransactionPayment {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "receiver", valueSchema: new StringSchema(), omitEmpty: true }, {
              key: "close-amount",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "close-remainder-to",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionPayment` object.
         * @param amount - (amt) number of MicroAlgos intended to be transferred.
         * @param receiver - (rcv) receiver's address.
         * @param closeAmount - Number of MicroAlgos that were sent to the close-remainder-to address when
         * closing the sender account.
         * @param closeRemainderTo - (close) when set, indicates that the sending account should be closed and all
         * remaining funds be transferred to this address.
         */
        constructor({ amount, receiver, closeAmount, closeRemainderTo }) {
          this.amount = ensureBigInt(amount);
          this.receiver = receiver;
          this.closeAmount = typeof closeAmount === "undefined" ? void 0 : ensureBigInt(closeAmount);
          this.closeRemainderTo = closeRemainderTo;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionPayment.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["amount", this.amount],
            ["receiver", this.receiver],
            ["close-amount", this.closeAmount],
            ["close-remainder-to", this.closeRemainderTo]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionPayment: ${data}`);
          }
          return new _TransactionPayment({
            amount: data.get("amount"),
            receiver: data.get("receiver"),
            closeAmount: data.get("close-amount"),
            closeRemainderTo: data.get("close-remainder-to")
          });
        }
      };
      TransactionResponse = class _TransactionResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "transaction",
              valueSchema: Transaction2.encodingSchema,
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionResponse` object.
         * @param currentRound - Round at which the results were computed.
         * @param transaction - Contains all fields common to all transactions and serves as an envelope to all
         * transactions type. Represents both regular and inner transactions.
         * Definition:
         * data/transactions/signedtxn.go : SignedTxn
         * data/transactions/transaction.go : Transaction
         */
        constructor({ currentRound, transaction }) {
          this.currentRound = ensureBigInt(currentRound);
          this.transaction = transaction;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["current-round", this.currentRound],
            ["transaction", this.transaction.toEncodingData()]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionResponse: ${data}`);
          }
          return new _TransactionResponse({
            currentRound: data.get("current-round"),
            transaction: Transaction2.fromEncodingData(data.get("transaction") ?? /* @__PURE__ */ new Map())
          });
        }
      };
      TransactionSignature = class _TransactionSignature {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "logicsig",
              valueSchema: new OptionalSchema(TransactionSignatureLogicsig.encodingSchema),
              omitEmpty: true
            }, {
              key: "multisig",
              valueSchema: new OptionalSchema(TransactionSignatureMultisig.encodingSchema),
              omitEmpty: true
            }, {
              key: "sig",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionSignature` object.
         * @param logicsig - (lsig) Programatic transaction signature.
         * Definition:
         * data/transactions/logicsig.go
         * @param multisig - (msig) structure holding multiple subsignatures.
         * Definition:
         * crypto/multisig.go : MultisigSig
         * @param sig - (sig) Standard ed25519 signature.
         */
        constructor({ logicsig, multisig, sig }) {
          this.logicsig = logicsig;
          this.multisig = multisig;
          this.sig = typeof sig === "string" ? base64ToBytes(sig) : sig;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionSignature.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "logicsig",
              typeof this.logicsig !== "undefined" ? this.logicsig.toEncodingData() : void 0
            ],
            [
              "multisig",
              typeof this.multisig !== "undefined" ? this.multisig.toEncodingData() : void 0
            ],
            ["sig", this.sig]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionSignature: ${data}`);
          }
          return new _TransactionSignature({
            logicsig: typeof data.get("logicsig") !== "undefined" ? TransactionSignatureLogicsig.fromEncodingData(data.get("logicsig")) : void 0,
            multisig: typeof data.get("multisig") !== "undefined" ? TransactionSignatureMultisig.fromEncodingData(data.get("multisig")) : void 0,
            sig: data.get("sig")
          });
        }
      };
      TransactionSignatureLogicsig = class _TransactionSignatureLogicsig {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({ key: "logic", valueSchema: new ByteArraySchema(), omitEmpty: true }, {
              key: "args",
              valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
              omitEmpty: true
            }, {
              key: "multisig-signature",
              valueSchema: new OptionalSchema(TransactionSignatureMultisig.encodingSchema),
              omitEmpty: true
            }, {
              key: "signature",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionSignatureLogicsig` object.
         * @param logic - (l) Program signed by a signature or multi signature, or hashed to be the
         * address of ana ccount. Base64 encoded TEAL program.
         * @param args - (arg) Logic arguments, base64 encoded.
         * @param multisigSignature - (msig) structure holding multiple subsignatures.
         * Definition:
         * crypto/multisig.go : MultisigSig
         * @param signature - (sig) ed25519 signature.
         */
        constructor({ logic, args, multisigSignature, signature }) {
          this.logic = typeof logic === "string" ? base64ToBytes(logic) : logic;
          this.args = args;
          this.multisigSignature = multisigSignature;
          this.signature = typeof signature === "string" ? base64ToBytes(signature) : signature;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionSignatureLogicsig.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["logic", this.logic],
            ["args", this.args],
            [
              "multisig-signature",
              typeof this.multisigSignature !== "undefined" ? this.multisigSignature.toEncodingData() : void 0
            ],
            ["signature", this.signature]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionSignatureLogicsig: ${data}`);
          }
          return new _TransactionSignatureLogicsig({
            logic: data.get("logic"),
            args: data.get("args"),
            multisigSignature: typeof data.get("multisig-signature") !== "undefined" ? TransactionSignatureMultisig.fromEncodingData(data.get("multisig-signature")) : void 0,
            signature: data.get("signature")
          });
        }
      };
      TransactionSignatureMultisig = class _TransactionSignatureMultisig {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "subsignature",
              valueSchema: new OptionalSchema(new ArraySchema(TransactionSignatureMultisigSubsignature.encodingSchema)),
              omitEmpty: true
            }, {
              key: "threshold",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            }, {
              key: "version",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionSignatureMultisig` object.
         * @param subsignature - (subsig) holds pairs of public key and signatures.
         * @param threshold - (thr)
         * @param version - (v)
         */
        constructor({ subsignature, threshold, version }) {
          this.subsignature = subsignature;
          this.threshold = typeof threshold === "undefined" ? void 0 : ensureSafeInteger(threshold);
          this.version = typeof version === "undefined" ? void 0 : ensureSafeInteger(version);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionSignatureMultisig.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "subsignature",
              typeof this.subsignature !== "undefined" ? this.subsignature.map((v3) => v3.toEncodingData()) : void 0
            ],
            ["threshold", this.threshold],
            ["version", this.version]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionSignatureMultisig: ${data}`);
          }
          return new _TransactionSignatureMultisig({
            subsignature: typeof data.get("subsignature") !== "undefined" ? data.get("subsignature").map((v3) => TransactionSignatureMultisigSubsignature.fromEncodingData(v3)) : void 0,
            threshold: data.get("threshold"),
            version: data.get("version")
          });
        }
      };
      TransactionSignatureMultisigSubsignature = class _TransactionSignatureMultisigSubsignature {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "public-key",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            }, {
              key: "signature",
              valueSchema: new OptionalSchema(new ByteArraySchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionSignatureMultisigSubsignature` object.
         * @param publicKey - (pk)
         * @param signature - (s)
         */
        constructor({ publicKey, signature }) {
          this.publicKey = typeof publicKey === "string" ? base64ToBytes(publicKey) : publicKey;
          this.signature = typeof signature === "string" ? base64ToBytes(signature) : signature;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionSignatureMultisigSubsignature.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["public-key", this.publicKey],
            ["signature", this.signature]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionSignatureMultisigSubsignature: ${data}`);
          }
          return new _TransactionSignatureMultisigSubsignature({
            publicKey: data.get("public-key"),
            signature: data.get("signature")
          });
        }
      };
      TransactionStateProof = class _TransactionStateProof {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "message",
              valueSchema: new OptionalSchema(IndexerStateProofMessage.encodingSchema),
              omitEmpty: true
            }, {
              key: "state-proof",
              valueSchema: new OptionalSchema(StateProofFields.encodingSchema),
              omitEmpty: true
            }, {
              key: "state-proof-type",
              valueSchema: new OptionalSchema(new Uint64Schema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionStateProof` object.
         * @param message - (spmsg)
         * @param stateProof - (sp) represents a state proof.
         * Definition:
         * crypto/stateproof/structs.go : StateProof
         * @param stateProofType - (sptype) Type of the state proof. Integer representing an entry defined in
         * protocol/stateproof.go
         */
        constructor({ message, stateProof, stateProofType }) {
          this.message = message;
          this.stateProof = stateProof;
          this.stateProofType = typeof stateProofType === "undefined" ? void 0 : ensureSafeInteger(stateProofType);
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionStateProof.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            [
              "message",
              typeof this.message !== "undefined" ? this.message.toEncodingData() : void 0
            ],
            [
              "state-proof",
              typeof this.stateProof !== "undefined" ? this.stateProof.toEncodingData() : void 0
            ],
            ["state-proof-type", this.stateProofType]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionStateProof: ${data}`);
          }
          return new _TransactionStateProof({
            message: typeof data.get("message") !== "undefined" ? IndexerStateProofMessage.fromEncodingData(data.get("message")) : void 0,
            stateProof: typeof data.get("state-proof") !== "undefined" ? StateProofFields.fromEncodingData(data.get("state-proof")) : void 0,
            stateProofType: data.get("state-proof-type")
          });
        }
      };
      TransactionsResponse = class _TransactionsResponse {
        static get encodingSchema() {
          if (!this.encodingSchemaValue) {
            this.encodingSchemaValue = new NamedMapSchema([]);
            this.encodingSchemaValue.pushEntries({
              key: "current-round",
              valueSchema: new Uint64Schema(),
              omitEmpty: true
            }, {
              key: "transactions",
              valueSchema: new ArraySchema(Transaction2.encodingSchema),
              omitEmpty: true
            }, {
              key: "next-token",
              valueSchema: new OptionalSchema(new StringSchema()),
              omitEmpty: true
            });
          }
          return this.encodingSchemaValue;
        }
        /**
         * Creates a new `TransactionsResponse` object.
         * @param currentRound - Round at which the results were computed.
         * @param transactions -
         * @param nextToken - Used for pagination, when making another request provide this token with the
         * next parameter.
         */
        constructor({ currentRound, transactions, nextToken }) {
          this.currentRound = ensureBigInt(currentRound);
          this.transactions = transactions;
          this.nextToken = nextToken;
        }
        // eslint-disable-next-line class-methods-use-this
        getEncodingSchema() {
          return _TransactionsResponse.encodingSchema;
        }
        toEncodingData() {
          return /* @__PURE__ */ new Map([
            ["current-round", this.currentRound],
            ["transactions", this.transactions.map((v3) => v3.toEncodingData())],
            ["next-token", this.nextToken]
          ]);
        }
        static fromEncodingData(data) {
          if (!(data instanceof Map)) {
            throw new Error(`Invalid decoded TransactionsResponse: ${data}`);
          }
          return new _TransactionsResponse({
            currentRound: data.get("current-round"),
            transactions: (data.get("transactions") ?? []).map((v3) => Transaction2.fromEncodingData(v3)),
            nextToken: data.get("next-token")
          });
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/makeHealthCheck.js
  var MakeHealthCheck;
  var init_makeHealthCheck = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/makeHealthCheck.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      MakeHealthCheck = class extends JSONRequest {
        /**
         * @returns `/health`
         */
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/health";
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), HealthCheck2);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetBalances.js
  var LookupAssetBalances;
  var init_lookupAssetBalances = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetBalances.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      LookupAssetBalances = class extends JSONRequest {
        /**
         * Returns the list of accounts which hold the given asset and their balance.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
         * @param index - The asset ID to look up.
         */
        constructor(c2, index) {
          super(c2);
          this.index = BigInt(index);
        }
        /**
         * @returns `/v2/assets/${index}/balances`
         */
        path() {
          return `/v2/assets/${this.index}/balances`;
        }
        /**
         * Limit results for pagination.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const maxResults = 20;
         * const assetBalances = await indexerClient
         *        .lookupAssetBalances(assetId)
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit - maximum number of results to return.
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Filtered results should have an asset balance greater than this value.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const minBalance = 1000000;
         * const assetBalances = await indexerClient
         *        .lookupAssetBalances(assetId)
         *        .currencyGreaterThan(minBalance)
         *        .do();
         * ```
         * @param greater
         * @category query
         */
        currencyGreaterThan(greater) {
          this.query["currency-greater-than"] = greater.toString();
          return this;
        }
        /**
         * Filtered results should have an asset balance less than this value.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const maxBalance = 2000000;
         * const assetBalances = await indexerClient
         *        .lookupAssetBalances(assetId)
         *        .currencyLessThan(maxBalance)
         *        .do();
         * ```
         * @param lesser
         * @category query
         */
        currencyLessThan(lesser) {
          this.query["currency-less-than"] = lesser;
          return this;
        }
        /**
         * Specify the next page of results.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const maxResults = 20;
         *
         * const assetBalancesPage1 = await indexerClient
         *        .lookupAssetBalances(assetId)
         *        .limit(maxResults)
         *        .do();
         *
         * const assetBalancesPage2 = await indexerClient
         *        .lookupAssetBalances(assetId)
         *        .limit(maxResults)
         *        .nextToken(assetBalancesPage1["next-token"])
         *        .do();
         * ```
         * @param nextToken - provided by the previous results.
         * @category query
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
         *
         * #### Example 1
         * ```typescript
         * const assetId = 163650;
         * const assetBalances = await indexerClient
         *        .lookupAssetBalances(assetId)
         *        .includeAll(false)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const assetId = 163650;
         * const assetBalances = await indexerClient
         *        .lookupAssetBalances(assetId)
         *        .includeAll()
         *        .do();
         * ```
         *
         * @param value
         * @category query
         */
        includeAll(value = true) {
          this.query["include-all"] = value;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), AssetBalancesResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountTransactions.js
  function base64StringFunnel(data) {
    if (typeof data === "string") {
      return data;
    }
    return bytesToBase64(data);
  }
  var LookupAccountTransactions;
  var init_lookupAccountTransactions = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountTransactions.js"() {
      init_polyfills();
      init_binarydata();
      init_encoding3();
      init_jsonrequest();
      init_types4();
      LookupAccountTransactions = class extends JSONRequest {
        /**
         * Returns transactions relating to the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
         * @param account - The address of the account.
         */
        constructor(c2, account) {
          super(c2);
          this.account = account.toString();
        }
        /**
         * @returns `/v2/accounts/${account}/transactions`
         */
        path() {
          return `/v2/accounts/${this.account}/transactions`;
        }
        /**
         * Specifies a prefix which must be contained in the note field.
         *
         * #### Example
         * ```typescript
         * const notePrefixBase64Encoded = "Y3JlYXRl";
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .notePrefix(notePrefixBase64Encoded)
         *        .do();
         * ```
         *
         * @param prefix - base64 string or uint8array
         * @category query
         */
        notePrefix(prefix) {
          this.query["note-prefix"] = base64StringFunnel(prefix);
          return this;
        }
        /**
         * Type of transaction to filter with.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .txType("appl")
         *        .do();
         * ```
         *
         * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
         * @category query
         */
        txType(type) {
          this.query["tx-type"] = type;
          return this;
        }
        /**
         * Type of signature to filter with.
         * - sig: Standard
         * - msig: MultiSig
         * - lsig: LogicSig
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .sigType("msig")
         *        .do();
         * ```
         *
         * @param type - one of `sig`, `msig`, `lsig`
         * @category query
         */
        sigType(type) {
          this.query["sig-type"] = type;
          return this;
        }
        /**
         * Lookup the specific transaction by ID.
         *
         * #### Example
         * ```typescript
         * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .txid(txId)
         *        .do();
         * ```
         * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
         * @param txid
         * @category query
         */
        txid(txid) {
          this.query.txid = txid;
          return this;
        }
        /**
         * Include results for the specified round.
         *
         * #### Example
         * ```typescript
         * const targetBlock = 18309917;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .round(targetBlock)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        round(round) {
          this.query.round = round;
          return this;
        }
        /**
         * Include results at or after the specified min-round.
         *
         * #### Example
         * ```typescript
         * const minRound = 18309917;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .minRound(minRound)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        minRound(round) {
          this.query["min-round"] = round;
          return this;
        }
        /**
         * Include results at or before the specified max-round.
         *
         * #### Example
         * ```typescript
         * const maxRound = 18309917;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .maxRound(maxRound)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        maxRound(round) {
          this.query["max-round"] = round;
          return this;
        }
        /**
         * Asset ID to filter with.
         *
         * #### Example
         * ```typescript
         * const assetID = 163650;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .assetID(assetID)
         *        .do();
         * ```
         *
         * @param id
         * @category query
         */
        assetID(id) {
          this.query["asset-id"] = id;
          return this;
        }
        /**
         * Maximum number of results to return.
         *
         * #### Example
         * ```typescript
         * const maxResults = 25;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Include results before the given time.
         *
         * #### Example
         * ```typescript
         * const beforeTime = "2022-02-02T20:20:22.02Z";
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .beforeTime(beforeTime)
         *        .do();
         * ```
         *
         * @param before - rfc3339 string or Date object
         * @category query
         */
        beforeTime(before) {
          this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
          return this;
        }
        /**
         * Include results after the given time.
         *
         * #### Example
         * ```typescript
         * const afterTime = "2022-10-21T00:00:11.55Z";
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .afterTime(afterTime)
         *        .do();
         * ```
         *
         * @param after - rfc3339 string or Date object
         * @category query
         */
        afterTime(after) {
          this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
          return this;
        }
        /**
         * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
         *
         * #### Example 1
         * ```typescript
         * const minBalance = 300000;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .currencyGreaterThan(minBalance - 1)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const assetID = 163650;
         * const minBalance = 300000;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .assetID(assetID)
         *        .currencyGreaterThan(minBalance - 1)
         *        .do();
         * ```
         *
         * @param greater
         * @category query
         */
        currencyGreaterThan(greater) {
          this.query["currency-greater-than"] = greater.toString();
          return this;
        }
        /**
         * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
         *
         * #### Example 1
         * ```typescript
         * const maxBalance = 500000;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .currencyLessThan(maxBalance + 1)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const assetID = 163650;
         * const maxBalance = 500000;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .assetID(assetID)
         *        .currencyLessThan(maxBalance + 1)
         *        .do();
         * ```
         *
         * @param lesser
         * @category query
         */
        currencyLessThan(lesser) {
          this.query["currency-less-than"] = lesser;
          return this;
        }
        /**
         * The next page of results. Use the next token provided by the previous results.
         *
         * #### Example
         * ```typescript
         * const maxResults = 25;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         *
         * const accountTxnsPage1 = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .limit(maxResults)
         *        .do();
         *
         * const accountTxnsPage2 = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .limit(maxResults)
         *        .nextToken(accountTxnsPage1["next-token"])
         *        .do();
         * ```
         *
         * @param nextToken - provided by the previous results.
         * @category query
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Whether or not to include rekeying transactions.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient
         *        .lookupAccountTransactions(address)
         *        .rekeyTo(false)
         *        .do();
         * ```
         *
         * @param rekeyTo
         * @category query
         */
        rekeyTo(rekeyTo) {
          this.query["rekey-to"] = rekeyTo;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), TransactionsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetTransactions.js
  var LookupAssetTransactions;
  var init_lookupAssetTransactions = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetTransactions.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_lookupAccountTransactions();
      init_types4();
      LookupAssetTransactions = class extends JSONRequest {
        /**
         * Returns transactions relating to the given asset.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
         * @param index - The asset ID to look up.
         */
        constructor(c2, index) {
          super(c2);
          this.index = BigInt(index);
        }
        /**
         * @returns `/v2/assets/${index}/transactions`
         */
        path() {
          return `/v2/assets/${this.index}/transactions`;
        }
        /**
         * Specifies a prefix which must be contained in the note field.
         *
         * #### Example
         * ```typescript
         * const notePrefixBase64Encoded = "Y3JlYXRl";
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .notePrefix(notePrefixBase64Encoded)
         *        .do();
         * ```
         *
         * @param prefix - base64 string or uint8array
         * @category query
         */
        notePrefix(prefix) {
          this.query["note-prefix"] = base64StringFunnel(prefix);
          return this;
        }
        /**
         * Type of transaction to filter with.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .txType("axfer")
         *        .do();
         * ```
         *
         * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`
         * @category query
         */
        txType(type) {
          this.query["tx-type"] = type;
          return this;
        }
        /**
         * Type of signature to filter with.
         * - sig: Standard
         * - msig: MultiSig
         * - lsig: LogicSig
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .sigType("lsig")
         *        .do();
         * ```
         *
         * @param type - one of `sig`, `msig`, `lsig`
         * @category query
         */
        sigType(type) {
          this.query["sig-type"] = type;
          return this;
        }
        /**
         * Lookup the specific transaction by ID.
         *
         * #### Example
         * ```typescript
         * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .txid(txId)
         *        .do();
         * ```
         *
         * @param txid
         * @category query
         */
        txid(txid) {
          this.query.txid = txid;
          return this;
        }
        /**
         * Include results for the specified round.
         *
         * #### Example
         * ```typescript
         * const targetBlock = 18309917;
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .round(targetBlock)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        round(round) {
          this.query.round = round;
          return this;
        }
        /**
         * Include results at or after the specified min-round.
         *
         * #### Example
         * ```typescript
         * const minRound = 18309917;
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .minRound(minRound)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        minRound(round) {
          this.query["min-round"] = round;
          return this;
        }
        /**
         * Include results at or before the specified max-round.
         *
         * #### Example
         * ```typescript
         * const maxRound = 18309917;
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .maxRound(maxRound)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        maxRound(round) {
          this.query["max-round"] = round;
          return this;
        }
        /**
         * Maximum number of results to return.
         *
         * #### Example
         * ```typescript
         * const maxResults = 25;
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Include results before the given time.
         *
         * #### Example
         * ```typescript
         * const beforeTime = "2022-02-02T20:20:22.02Z";
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .beforeTime(beforeTime)
         *        .do();
         * ```
         *
         * @param before - rfc3339 string or Date object
         * @category query
         */
        beforeTime(before) {
          this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
          return this;
        }
        /**
         * Include results after the given time.
         *
         * #### Example
         * ```typescript
         * const afterTime = "2022-10-21T00:00:11.55Z";
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .afterTime(afterTime)
         *        .do();
         * ```
         *
         * @param after - rfc3339 string or Date object
         * @category query
         */
        afterTime(after) {
          this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
          return this;
        }
        /**
         * Filtered results should have an amount greater than this value, as int, representing asset units.
         *
         * #### Example
         * ```typescript
         * const minBalance = 300000;
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .currencyGreaterThan(minBalance - 1)
         *        .do();
         * ```
         *
         * @param greater
         * @category query
         */
        currencyGreaterThan(greater) {
          this.query["currency-greater-than"] = greater.toString();
          return this;
        }
        /**
         * Filtered results should have an amount less than this value, as int, representing asset units.
         *
         * #### Example
         * ```typescript
         * const maxBalance = 500000;
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .currencyLessThan(maxBalance + 1)
         *        .do();
         * ```
         *
         * @param lesser
         * @category query
         */
        currencyLessThan(lesser) {
          this.query["currency-less-than"] = lesser;
          return this;
        }
        /**
         * Combined with address, defines what address to filter on, as string.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const role = "sender";
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .address(address)
         *        .addressRole(role)
         *        .do();
         * ```
         *
         * @param role - one of `sender`, `receiver`, `freeze-target`
         * @category query
         */
        addressRole(role) {
          this.query["address-role"] = role;
          return this;
        }
        /**
         * Only include transactions with this address in one of the transaction fields.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .address(address)
         *        .do();
         * ```
         *
         * @param address
         * @category query
         */
        address(address) {
          this.query.address = address.toString();
          return this;
        }
        /**
         * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .excludeCloseTo(true)
         *        .do();
         * ```
         *
         * @param exclude
         * @category query
         */
        excludeCloseTo(exclude) {
          this.query["exclude-close-to"] = exclude;
          return this;
        }
        /**
         * The next page of results.
         *
         * #### Example
         * ```typescript
         * const maxResults = 25;
         * const assetId = 163650;
         *
         * const assetTxnsPage1 = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .limit(maxResults)
         *        .do();
         *
         * const assetTxnsPage2 = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .limit(maxResults)
         *        .nextToken(assetTxnsPage1["next-token"])
         *        .do();
         * ```
         *
         * @param nextToken - provided by the previous results.
         * @category query
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Whether or not to include rekeying transactions.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const assetTxns = await indexerClient
         *        .lookupAssetTransactions(assetId)
         *        .rekeyTo(false)
         *        .do();
         * ```
         *
         * @param rekeyTo
         * @category query
         */
        rekeyTo(rekeyTo) {
          this.query["rekey-to"] = rekeyTo;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), TransactionsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupBlock.js
  var LookupBlock;
  var init_lookupBlock = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupBlock.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      LookupBlock = class extends JSONRequest {
        /**
         * Returns the block for the passed round.
         *
         * #### Example
         * ```typescript
         * const targetBlock = 18309917;
         * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
         * @param round - The number of the round to look up.
         * @category GET
         */
        constructor(c2, round) {
          super(c2);
          this.round = BigInt(round);
        }
        /**
         * @returns `/v2/blocks/${round}`
         */
        path() {
          return `/v2/blocks/${this.round}`;
        }
        /**
         * Header only flag. When this is set to true, returned block does not contain the
         * transactions.
         */
        headerOnly(headerOnly) {
          this.query["header-only"] = headerOnly;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), Block3);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupTransactionByID.js
  var LookupTransactionByID;
  var init_lookupTransactionByID = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupTransactionByID.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      LookupTransactionByID = class extends JSONRequest {
        /**
         * Returns information about the given transaction.
         *
         * #### Example
         * ```typescript
         * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
         * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
         * @param txID - The ID of the transaction to look up.
         * @category GET
         */
        constructor(c2, txID) {
          super(c2);
          this.txID = txID;
        }
        /**
         * @returns `/v2/transactions/${txID}`
         */
        path() {
          return `/v2/transactions/${this.txID}`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), TransactionResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountByID.js
  var LookupAccountByID;
  var init_lookupAccountByID = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountByID.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      LookupAccountByID = class extends JSONRequest {
        /**
         * Returns information about the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountInfo = await indexerClient.lookupAccountByID(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
         * @param account - The address of the account to look up.
         * @category GET
         */
        constructor(c2, account) {
          super(c2);
          this.account = account.toString();
        }
        /**
         * @returns `/v2/accounts/${account}`
         */
        path() {
          return `/v2/accounts/${this.account}`;
        }
        /**
         * Specify round to filter with.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const targetBlock = 18309917;
         * const accountInfo = await indexerClient
         *        .lookupAccountByID(address)
         *        .round(targetBlock)
         *        .do();
         * ```
         * @param round
         */
        round(round) {
          this.query.round = round;
          return this;
        }
        /**
         * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
         *
         * #### Example 1
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountInfo = await indexerClient
         *        .lookupAccountByID(address)
         *        .includeAll(false)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountInfo = await indexerClient
         *        .lookupAccountByID(address)
         *        .includeAll()
         *        .do();
         * ```
         * @param value
         */
        includeAll(value = true) {
          this.query["include-all"] = value;
          return this;
        }
        /**
         * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
         *
         * #### Example 1
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountInfo = await indexerClient
         *        .lookupAccountByID(address)
         *        .exclude("all")
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountInfo = await indexerClient
         *        .lookupAccountByID(address)
         *        .exclude("assets,created-assets")
         *        .do();
         * ```
         * @remarks By default, it behaves as exclude=none
         * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
         * @category query
         */
        exclude(exclude) {
          this.query.exclude = exclude;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), AccountResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountAssets.js
  var LookupAccountAssets;
  var init_lookupAccountAssets = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountAssets.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      LookupAccountAssets = class extends JSONRequest {
        /**
         * Returns asset about the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
         * @param account - The address of the account to look up.
         * @category GET
         */
        constructor(c2, account) {
          super(c2);
          this.account = account.toString();
        }
        /**
         * @returns `/v2/accounts/${account}/assets`
         */
        path() {
          return `/v2/accounts/${this.account}/assets`;
        }
        /**
         * Add a limit for filter.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const maxResults = 20;
         * const accountAssets = await indexerClient
         *        .lookupAccountAssets(address)
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit - maximum number of results to return.
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Specify round to filter with.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const targetBlock = 18309917;
         * const accountAssets = await indexerClient
         *        .lookupAccountAssets(address)
         *        .round(targetBlock)
         *        .do();
         * ```
         * @param round
         * @category query
         */
        round(round) {
          this.query.round = round;
          return this;
        }
        /**
         * Specify the next page of results.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const maxResults = 20;
         *
         * const accountAssetsPage1 = await indexerClient
         *        .lookupAccountAssets(address)
         *        .limit(maxResults)
         *        .do();
         *
         * const accountAssetsPage2 = await indexerClient
         *        .lookupAccountAssets(address)
         *        .limit(maxResults)
         *        .next(accountAssetsPage1["next-token"])
         *        .do();
         * ```
         * @param nextToken - provided by the previous results.
         * @category query
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountAssets = await indexerClient
         *        .lookupAccountAssets(address)
         *        .includeAll(false)
         *        .do();
         * ```
         * @param value
         * @category query
         */
        includeAll(value = true) {
          this.query["include-all"] = value;
          return this;
        }
        /**
         * Specify an assetID to search for.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const assetAssets = await indexerClient
         *        .lookupAccountAssets(address)
         *        .assetId(assetId)
         *        .do();
         * ```
         * @param index - the assetID
         * @category query
         */
        assetId(index) {
          this.query["asset-id"] = index;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), AssetHoldingsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountCreatedAssets.js
  var LookupAccountCreatedAssets;
  var init_lookupAccountCreatedAssets = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountCreatedAssets.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      LookupAccountCreatedAssets = class extends JSONRequest {
        /**
         * Returns asset information created by the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
         * @param account - The address of the account to look up.
         * @category GET
         */
        constructor(c2, account) {
          super(c2);
          this.account = account.toString();
        }
        /**
         * @returns `/v2/accounts/${account}/created-assets`
         */
        path() {
          return `/v2/accounts/${this.account}/created-assets`;
        }
        /**
         * Add a limit for filter.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const maxResults = 20;
         * const accountAssets = await indexerClient
         *        .lookupAccountCreatedAssets(address)
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit - maximum number of results to return.
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Specify round to filter with.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const targetBlock = 18309917;
         * const accountAssets = await indexerClient
         *        .lookupAccountCreatedAssets(address)
         *        .round(targetBlock)
         *        .do();
         * ```
         * @param round
         * @category query
         */
        round(round) {
          this.query.round = round;
          return this;
        }
        /**
         * Specify the next page of results.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const maxResults = 20;
         *
         * const accountAssetsPage1 = await indexerClient
         *        .lookupAccountCreatedAssets(address)
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * const accountAssetsPage2 = await indexerClient
         *        .lookupAccountCreatedAssets(address)
         *        .limit(maxResults)
         *        .next(accountAssetsPage1["next-token"])
         *        .do();
         * ```
         * @param nextToken - provided by the previous results.
         * @category query
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountAssets = await indexerClient
         *        .lookupAccountCreatedAssets(address)
         *        .includeAll(false)
         *        .do();
         * ```
         * @param value
         * @category query
         */
        includeAll(value = true) {
          this.query["include-all"] = value;
          return this;
        }
        /**
         * Specify an assetID to search for.
         *
         * #### Example
         * ```typescript
         * const assetID = 163650;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const assetAssets = await indexerClient
         *        .lookupAccountCreatedAssets(address)
         *        .assetID(assetID)
         *        .do();
         * ```
         * @param index - the assetID
         * @category query
         */
        assetID(index) {
          this.query["asset-id"] = index;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), AssetsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountAppLocalStates.js
  var LookupAccountAppLocalStates;
  var init_lookupAccountAppLocalStates = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountAppLocalStates.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      LookupAccountAppLocalStates = class extends JSONRequest {
        /**
         * Returns application local state about the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
         * @param account - The address of the account to look up.
         * @category GET
         */
        constructor(c2, account) {
          super(c2);
          this.account = account.toString();
        }
        /**
         * @returns `/v2/accounts/${account}/apps-local-state`
         */
        path() {
          return `/v2/accounts/${this.account}/apps-local-state`;
        }
        /**
         * Add a limit for filter.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const maxResults = 20;
         * const accountAssets = await indexerClient
         *        .lookupAccountAppLocalStates(address)
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit - maximum number of results to return.
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Specify round to filter with.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const targetBlock = 18309917;
         * const accountAssets = await indexerClient
         *        .lookupAccountAppLocalStates(address)
         *        .round(targetBlock)
         *        .do();
         * ```
         * @param round
         * @category query
         */
        round(round) {
          this.query.round = round;
          return this;
        }
        /**
         * Specify the next page of results.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const maxResults = 20;
         *
         * const accountAssetsPage1 = await indexerClient
         *        .lookupAccountAppLocalStates(address)
         *        .limit(maxResults)
         *        .do();
         *
         * const accountAssetsPage2 = await indexerClient
         *        .lookupAccountAppLocalStates(address)
         *        .limit(maxResults)
         *        .next(accountAssetsPage1["next-token"])
         *        .do();
         * ```
         * @param nextToken - provided by the previous results.
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountAssets = await indexerClient
         *        .lookupAccountAppLocalStates(address)
         *        .includeAll(false)
         *        .do();
         * ```
         * @param value
         * @category query
         */
        includeAll(value = true) {
          this.query["include-all"] = value;
          return this;
        }
        /**
         * Specify an applicationID to search for.
         *
         * #### Example
         * ```typescript
         * const applicationID = 163650;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountApplications = await indexerClient
         *        .lookupAccountAppLocalStates(address)
         *        .applicationID(applicationID)
         *        .do();
         * ```
         * @param index - the applicationID
         * @category query
         */
        applicationID(index) {
          this.query["application-id"] = index;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), ApplicationLocalStatesResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountCreatedApplications.js
  var LookupAccountCreatedApplications;
  var init_lookupAccountCreatedApplications = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountCreatedApplications.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      LookupAccountCreatedApplications = class extends JSONRequest {
        /**
         * Returns application information created by the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
         * @param account - The address of the account to look up.
         * @category GET
         */
        constructor(c2, account) {
          super(c2);
          this.account = account.toString();
        }
        /**
         * @returns `/v2/accounts/${account}/created-applications`
         */
        path() {
          return `/v2/accounts/${this.account}/created-applications`;
        }
        /**
         * Add a limit for filter.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const maxResults = 20;
         * const accountAssets = await indexerClient
         *        .lookupAccountCreatedApplications(address)
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit - maximum number of results to return.
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Specify round to filter with.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const targetBlock = 18309917;
         * const accountAssets = await indexerClient
         *        .lookupAccountCreatedApplications(address)
         *        .round(targetBlock)
         *        .do();
         * ```
         * @param round
         * @category query
         */
        round(round) {
          this.query.round = round;
          return this;
        }
        /**
         * Specify the next page of results.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const maxResults = 20;
         *
         * const accountAssetsPage1 = await indexerClient
         *        .lookupAccountCreatedApplications(address)
         *        .limit(maxResults)
         *        .do();
         *
         * const accountAssetsPage2 = await indexerClient
         *        .lookupAccountCreatedApplications(address)
         *        .limit(maxResults)
         *        .next(accountAssetsPage1["next-token"])
         *        .do();
         * ```
         * @param nextToken - provided by the previous results.
         * @category query
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountAssets = await indexerClient
         *        .lookupAccountCreatedApplications(address)
         *        .includeAll(false)
         *        .do();
         * ```
         * @param value
         * @category query
         */
        includeAll(value = true) {
          this.query["include-all"] = value;
          return this;
        }
        /**
         * Specify an applicationID to search for.
         *
         * #### Example
         * ```typescript
         * const applicationID = 163650;
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountApplications = await indexerClient
         *        .lookupAccountAppLocalStates(address)
         *        .applicationID(applicationID)
         *        .do();
         * ```
         * @param index - the applicationID
         * @category query
         */
        applicationID(index) {
          this.query["application-id"] = index;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), ApplicationsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetByID.js
  var LookupAssetByID;
  var init_lookupAssetByID = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetByID.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      LookupAssetByID = class extends JSONRequest {
        /**
         * Returns asset information of the queried asset.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
         * @param index - The asset ID to look up.
         */
        constructor(c2, index) {
          super(c2);
          this.index = BigInt(index);
        }
        /**
         * @returns `/v2/assets/${index}`
         */
        path() {
          return `/v2/assets/${this.index}`;
        }
        /**
         * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
         *
         * #### Example 1
         * ```typescript
         * const assetId = 163650;
         * const assetInfo = await indexerClient
         *        .lookupAssetByID(assetId)
         *        .includeAll(false)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const assetId = 163650;
         * const assetInfo = await indexerClient
         *        .lookupAssetByID(assetId)
         *        .includeAll()
         *        .do();
         * ```
         *
         * @param value - default true when called without passing a value
         * @category query
         */
        includeAll(value = true) {
          this.query["include-all"] = value;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), AssetResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplications.js
  var LookupApplications;
  var init_lookupApplications = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplications.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      LookupApplications = class extends JSONRequest {
        /**
         * Returns information about the passed application.
         *
         * #### Example
         * ```typescript
         * const appId = 60553466;
         * const appInfo = await indexerClient.lookupApplications(appId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
         * @param index - The ID of the application to look up.
         * @category GET
         */
        constructor(c2, index) {
          super(c2);
          this.index = BigInt(index);
        }
        /**
         * @returns `/v2/applications/${index}`
         */
        path() {
          return `/v2/applications/${this.index}`;
        }
        /**
         * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
         *
         * #### Example 1
         * ```typescript
         * const appId = 60553466;
         * const appInfo = await indexerClient
         *        .lookupApplications(appId)
         *        .includeAll(false)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const appId = 60553466;
         * const appInfo = await indexerClient
         *        .lookupApplications(appId)
         *        .includeAll()
         *        .do();
         * ```
         *
         * @param value - default true when called without passing a value
         * @category query
         */
        includeAll(value = true) {
          this.query["include-all"] = value;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), ApplicationResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplicationLogs.js
  var LookupApplicationLogs;
  var init_lookupApplicationLogs = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplicationLogs.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      LookupApplicationLogs = class extends JSONRequest {
        /**
         * Returns log messages generated by the passed in application.
         *
         * #### Example
         * ```typescript
         * const appId = 60553466;
         * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
         * @param appID - The ID of the application which generated the logs.
         * @category GET
         */
        constructor(c2, appID) {
          super(c2);
          this.appID = BigInt(appID);
        }
        /**
         * @returns `/v2/applications/${appID}/logs`
         */
        path() {
          return `/v2/applications/${this.appID}/logs`;
        }
        /**
         * Limit results for pagination.
         *
         * #### Example
         * ```typescript
         * const maxResults = 20;
         * const appLogs = await indexerClient
         *        .lookupApplicationLogs(appId)
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit - maximum number of results to return.
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Include results at or after the specified min-round.
         *
         * #### Example
         * ```typescript
         * const minRound = 18309917;
         * const appLogs = await indexerClient
         *        .lookupApplicationLogs(appId)
         *        .minRound(minRound)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        minRound(round) {
          this.query["min-round"] = round;
          return this;
        }
        /**
         * Include results at or before the specified max-round.
         *
         * #### Example
         * ```typescript
         * const maxRound = 18309917;
         * const appLogs = await indexerClient
         *        .lookupApplicationLogs(appId)
         *        .maxRound(maxRound)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        maxRound(round) {
          this.query["max-round"] = round;
          return this;
        }
        /**
         * The next page of results.
         *
         * #### Example
         * ```typescript
         * const maxResults = 25;
         *
         * const appLogsPage1 = await indexerClient
         *        .lookupApplicationLogs(appId)
         *        .limit(maxResults)
         *        .do();
         *
         * const appLogsPage2 = await indexerClient
         *        .lookupApplicationLogs(appId)
         *        .limit(maxResults)
         *        .nextToken(appLogsPage1["next-token"])
         *        .do();
         * ```
         *
         * @param nextToken - provided by the previous results.
         * @category query
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Only include transactions with this sender address.
         *
         * #### Example
         * ```typescript
         * const sender = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const appLogs = await indexerClient
         *        .lookupApplicationLogs(appId)
         *        .sender(sender)
         *        .do();
         * ```
         *
         * @param senderAddress
         * @category query
         */
        sender(senderAddress) {
          this.query["sender-address"] = senderAddress;
          return this;
        }
        /**
         * Lookup the specific transaction by ID.
         *
         * #### Example
         * ```typescript
         * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
         * const appLogs = await indexerClient
         *        .lookupApplicationLogs(appId)
         *        .txid(txId)
         *        .do();
         * ```
         *
         * @param txid
         * @category query
         */
        txid(txid) {
          this.query.txid = txid;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), ApplicationLogsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplicationBoxByIDandName.js
  var LookupApplicationBoxByIDandName;
  var init_lookupApplicationBoxByIDandName = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplicationBoxByIDandName.js"() {
      init_polyfills();
      init_binarydata();
      init_encoding3();
      init_jsonrequest();
      init_types4();
      LookupApplicationBoxByIDandName = class extends JSONRequest {
        /**
         * Returns information about indexed application boxes.
         *
         * #### Example
         * ```typescript
         * const boxName = Buffer.from("foo");
         * const boxResponse = await indexerClient
         *        .LookupApplicationBoxByIDandName(1234, boxName)
         *        .do();
         * const boxValue = boxResponse.value;
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
         * @oaram index - application index.
         * @category GET
         */
        constructor(c2, index, boxName) {
          super(c2);
          this.index = BigInt(index);
          const encodedName = bytesToBase64(boxName);
          this.query.name = encodeURI(`b64:${encodedName}`);
        }
        /**
         * @returns `/v2/applications/${index}/box`
         */
        path() {
          return `/v2/applications/${this.index}/box`;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), Box2);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/searchAccounts.js
  var SearchAccounts;
  var init_searchAccounts = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/searchAccounts.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      SearchAccounts = class extends JSONRequest {
        /**
         * @returns `/v2/accounts`
         */
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/v2/accounts";
        }
        /**
         * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
         *
         * #### Example 1
         * ```typescript
         * const minBalance = 300000;
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .currencyGreaterThan(minBalance - 1)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const assetID = 163650;
         * const minBalance = 300000;
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .assetID(assetID)
         *        .currencyGreaterThan(minBalance - 1)
         *        .do();
         * ```
         * @remarks
         * If you are looking for accounts with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude accounts with a 0 amount.
         *
         * @param greater
         * @category query
         */
        currencyGreaterThan(greater) {
          this.query["currency-greater-than"] = greater.toString();
          return this;
        }
        /**
         * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
         *
         * #### Example 1
         * ```typescript
         * const maxBalance = 500000;
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .currencyLessThan(maxBalance + 1)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const assetID = 163650;
         * const maxBalance = 500000;
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .assetID(assetID)
         *        .currencyLessThan(maxBalance + 1)
         *        .do();
         * ```
         *
         * @param lesser
         * @category query
         */
        currencyLessThan(lesser) {
          this.query["currency-less-than"] = lesser;
          return this;
        }
        /**
         * Maximum number of results to return.
         *
         * #### Example
         * ```typescript
         * const maxResults = 25;
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Asset ID to filter with.
         *
         * #### Example
         * ```typescript
         * const assetID = 163650;
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .assetID(assetID)
         *        .do();
         * ```
         *
         * @param id
         * @category query
         */
        assetID(id) {
          this.query["asset-id"] = id;
          return this;
        }
        /**
         * The next page of results.
         *
         * #### Example
         * ```typescript
         * const maxResults = 25;
         *
         * const accountsPage1 = await indexerClient
         *        .searchAccounts()
         *        .limit(maxResults)
         *        .do();
         *
         * const accountsPage2 = await indexerClient
         *        .searchAccounts()
         *        .limit(maxResults)
         *        .nextToken(accountsPage1["next-token"])
         *        .do();
         * ```
         *
         * @param nextToken - provided by the previous results
         * @category query
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Include results for the specified round.
         *
         * #### Example
         * ```typescript
         * const targetBlock = 18309917;
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .round(targetBlock)
         *        .do();
         * ```
         * @remarks For performance reasons, this parameter may be disabled on some configurations.
         * @param round
         * @category query
         */
        round(round) {
          this.query.round = round;
          return this;
        }
        /**
         * Include accounts that use this spending key.
         *
         * #### Example
         * ```typescript
         * const authAddr = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .authAddr(authAddr)
         *        .do();
         * ```
         *
         * @param authAddr
         */
        authAddr(authAddr) {
          this.query["auth-addr"] = authAddr.toString();
          return this;
        }
        /**
         * Filter for this application.
         *
         * #### Example
         * ```typescript
         * const appId = 60553466;
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .applicationID(appId)
         *        .do();
         * ```
         *
         * @param applicationID
         * @category query
         */
        applicationID(applicationID) {
          this.query["application-id"] = applicationID;
          return this;
        }
        /**
         * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
         *
         * #### Example 1
         * ```typescript
         * const assetId = 163650;
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .includeAll(false)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const assetId = 163650;
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .includeAll()
         *        .do();
         * ```
         *
         * @param value - default true when called without passing a value
         * @category query
         */
        includeAll(value = true) {
          this.query["include-all"] = value;
          return this;
        }
        /**
         * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
         *
         * #### Example 1
         * ```typescript
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .exclude("all")
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const accounts = await indexerClient
         *        .searchAccounts()
         *        .exclude("assets,created-assets")
         *        .do();
         * ```
         * @remarks By default, it behaves as exclude=none
         * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
         * @category query
         */
        exclude(exclude) {
          this.query.exclude = exclude;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), AccountsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/searchForBlockHeaders.js
  var SearchForBlockHeaders;
  var init_searchForBlockHeaders = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/searchForBlockHeaders.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      SearchForBlockHeaders = class extends JSONRequest {
        /**
         * @returns `/v2/block-headers`
         */
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/v2/block-headers";
        }
        /**
         * Accounts marked as absent in the block header's participation updates.
         *
         * #### Example
         * ```typescript
         * const address1 = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const address2 = "4H5UNRBJ2Q6JENAXQ6HNTGKLKINP4J4VTQBEPK5F3I6RDICMZBPGNH6KD4";
         * const bhs = await indexerClient
         *        .searchForBlockHeaders()
         *        .absent([address1,address2])
         *        .do();
         * ```
         *
         * @param absent - a comma separated list of addresses
         * @category query
         */
        absent(absent) {
          this.query.absent = absent;
          return this;
        }
        /**
         * Include results after the given time.
         *
         * #### Example
         * ```typescript
         * const afterTime = "2022-10-21T00:00:11.55Z";
         * const bhs = await indexerClient
         *        .searchForBlockHeaders()
         *        .afterTime(afterTime)
         *        .do();
         * ```
         *
         * @param after - rfc3339 string or Date object
         * @category query
         */
        afterTime(after) {
          this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
          return this;
        }
        /**
         * Include results before the given time.
         *
         * #### Example
         * ```typescript
         * const beforeTime = "2022-02-02T20:20:22.02Z";
         * const bhs = await indexerClient
         *        .searchForBlockHeaders()
         *        .beforeTime(beforeTime)
         *        .do();
         * ```
         *
         * @param before - rfc3339 string or Date object
         * @category query
         */
        beforeTime(before) {
          this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
          return this;
        }
        /**
         * Accounts marked as expired in the block header's participation updates.
         *
         * #### Example
         * ```typescript
         * const address1 = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const address2 = "4H5UNRBJ2Q6JENAXQ6HNTGKLKINP4J4VTQBEPK5F3I6RDICMZBPGNH6KD4";
         * const bhs = await indexerClient
         *        .searchForBlockHeaders()
         *        .expired([address1,address2])
         *        .do();
         * ```
         *
         * @param expired - - a comma separated list of addresses
         * @category query
         */
        expired(expired) {
          this.query.expired = expired;
          return this;
        }
        /**
         * Maximum number of results to return.
         *
         * #### Example
         * ```typescript
         * const maxResults = 25;
         * const bhs = await indexerClient
         *        .searchForBlockHeaders()
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Include results at or before the specified max-round.
         *
         * #### Example
         * ```typescript
         * const maxRound = 18309917;
         * const bhs = await indexerClient
         *        .searchForBlockHeaders()
         *        .maxRound(maxRound)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        maxRound(round) {
          this.query["max-round"] = round;
          return this;
        }
        /**
         * Include results at or after the specified min-round.
         *
         * #### Example
         * ```typescript
         * const minRound = 18309917;
         * const bhs = await indexerClient
         *        .searchForBlockHeaders()
         *        .minRound(minRound)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        minRound(round) {
          this.query["min-round"] = round;
          return this;
        }
        /**
         * The next page of results.
         *
         * #### Example
         * ```typescript
         * const maxResults = 25;
         *
         * const bh1 = await indexerClient
         *        .searchForBlockHeaders()
         *        .limit(maxResults)
         *        .do();
         *
         * const bh2 = await indexerClient
         *        .searchForBlockHeaders()
         *        .limit(maxResults)
         *        .nextToken(bh1["next-token"])
         *        .do();
         * ```
         *
         * @param nextToken - provided by the previous results
         * @category query
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Accounts marked as proposer in the block header's participation updates.
         *
         * #### Example
         * ```typescript
         * const address1 = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const address2 = "4H5UNRBJ2Q6JENAXQ6HNTGKLKINP4J4VTQBEPK5F3I6RDICMZBPGNH6KD4";
         * const bhs = await indexerClient
         *        .searchForBlockHeaders()
         *        .proposers([address1,address2])
         *        .do();
         * ```
         *
         * @param proposers - a comma separated list of addresses
         * @category query
         */
        proposers(proposers) {
          this.query.proposers = proposers;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), BlockHeadersResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/searchForTransactions.js
  var SearchForTransactions;
  var init_searchForTransactions = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/searchForTransactions.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_lookupAccountTransactions();
      init_types4();
      SearchForTransactions = class extends JSONRequest {
        /**
         * @returns `/v2/transactions`
         */
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/v2/transactions";
        }
        /**
         * Specifies a prefix which must be contained in the note field.
         *
         * #### Example
         * ```typescript
         * const notePrefixBase64Encoded = "Y3JlYXRl";
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .notePrefix(notePrefixBase64Encoded)
         *        .do();
         * ```
         *
         * @param prefix - base64 string or uint8array
         * @category query
         */
        notePrefix(prefix) {
          this.query["note-prefix"] = base64StringFunnel(prefix);
          return this;
        }
        /**
         * Type of transaction to filter with.
         *
         * #### Example
         * ```typescript
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .txType("keyreg")
         *        .do();
         * ```
         *
         * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
         * @category query
         */
        txType(type) {
          this.query["tx-type"] = type;
          return this;
        }
        /**
         * Type of signature to filter with.
         * - sig: Standard
         * - msig: MultiSig
         * - lsig: LogicSig
         *
         * #### Example
         * ```typescript
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .sigType("sig")
         *        .do();
         * ```
         *
         * @param type - one of `sig`, `msig`, `lsig`
         * @category query
         */
        sigType(type) {
          this.query["sig-type"] = type;
          return this;
        }
        /**
         * Lookup the specific transaction by ID.
         *
         * #### Example
         * ```typescript
         * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .txid(txId)
         *        .do();
         * ```
         * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
         * @param txid
         * @category query
         */
        txid(txid) {
          this.query.txid = txid;
          return this;
        }
        /**
         * Include results for the specified round.
         *
         * #### Example
         * ```typescript
         * const targetBlock = 18309917;
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .round(targetBlock)
         *        .do();
         * ```
         * @remarks Alternatively, use `indexerClient.lookupBlock(targetBlock).do()`
         * @param round
         * @category query
         */
        round(round) {
          this.query.round = round;
          return this;
        }
        /**
         * Include results at or after the specified min-round.
         *
         * #### Example
         * ```typescript
         * const minRound = 18309917;
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .minRound(minRound)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        minRound(round) {
          this.query["min-round"] = round;
          return this;
        }
        /**
         * Include results at or before the specified max-round.
         *
         * #### Example
         * ```typescript
         * const maxRound = 18309917;
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .maxRound(maxRound)
         *        .do();
         * ```
         *
         * @param round
         * @category query
         */
        maxRound(round) {
          this.query["max-round"] = round;
          return this;
        }
        /**
         * Asset ID to filter with.
         *
         * #### Example
         * ```typescript
         * const assetID = 163650;
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .assetID(assetID)
         *        .do();
         * ```
         * @remarks Alternatively, use `indexerClient.lookupAssetTransactions(assetId).do()`
         * @param id
         * @category query
         */
        assetID(id) {
          this.query["asset-id"] = id;
          return this;
        }
        /**
         * Maximum number of results to return.
         *
         * #### Example
         * ```typescript
         * const maxResults = 25;
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Include results before the given time.
         *
         * #### Example
         * ```typescript
         * const beforeTime = "2022-02-02T20:20:22.02Z";
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .beforeTime(beforeTime)
         *        .do();
         * ```
         *
         * @param before - rfc3339 string or Date object
         * @category query
         */
        beforeTime(before) {
          this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
          return this;
        }
        /**
         * Include results after the given time.
         *
         * #### Example
         * ```typescript
         * const afterTime = "2022-10-21T00:00:11.55Z";
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .afterTime(afterTime)
         *        .do();
         * ```
         *
         * @param after - rfc3339 string or Date object
         * @category query
         */
        afterTime(after) {
          this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
          return this;
        }
        /**
         * Combined with address, defines what address to filter on, as string.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const role = "freeze-target";
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .address(address)
         *        .addressRole(role)
         *        .do();
         * ```
         *
         * @param role - one of `sender`, `receiver`, `freeze-target`
         * @category query
         */
        addressRole(role) {
          this.query["address-role"] = role;
          return this;
        }
        /**
         * Only include transactions with this address in one of the transaction fields.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .address(address)
         *        .do();
         * ```
         * @remarks Alternatively, use `indexerClient.lookupAccountTransactions(address).do()`
         * @param address
         * @category query
         */
        address(address) {
          this.query.address = address.toString();
          return this;
        }
        /**
         * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
         *
         * #### Example
         * ```typescript
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .excludeCloseTo(true)
         *        .do();
         * ```
         *
         * @param exclude
         * @category query
         */
        excludeCloseTo(exclude) {
          this.query["exclude-close-to"] = exclude;
          return this;
        }
        /**
         * The next page of results.
         *
         * #### Example
         * ```typescript
         * const maxResults = 25;
         *
         * const txnsPage1 = await indexerClient
         *        .searchForTransactions()
         *        .limit(maxResults)
         *        .do();
         *
         * const txnsPage2 = await indexerClient
         *        .searchForTransactions()
         *        .limit(maxResults)
         *        .nextToken(txnsPage1["next-token"])
         *        .do();
         * ```
         *
         * @param nextToken - provided by the previous results
         * @category query
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Whether or not to include rekeying transactions.
         *
         * #### Example
         * ```typescript
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .rekeyTo(false)
         *        .do();
         * ```
         *
         * @param rekeyTo
         * @category query
         */
        rekeyTo(rekeyTo) {
          this.query["rekey-to"] = rekeyTo;
          return this;
        }
        /**
         * Filter for this application.
         *
         * #### Example
         * ```typescript
         * const appId = 60553466;
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .applicationID(appId)
         *        .do();
         * ```
         *
         * @param applicationID
         * @category query
         */
        applicationID(applicationID) {
          this.query["application-id"] = applicationID;
          return this;
        }
        /**
         * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
         *
         * #### Example 1
         * ```typescript
         * const minBalance = 300000;
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .currencyGreaterThan(minBalance - 1)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const assetID = 163650;
         * const minBalance = 300000;
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .assetID(assetID)
         *        .currencyGreaterThan(minBalance - 1)
         *        .do();
         * ```
         *
         * @param greater
         * @category query
         */
        currencyGreaterThan(greater) {
          this.query["currency-greater-than"] = greater.toString();
          return this;
        }
        /**
         * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
         *
         * #### Example 1
         * ```typescript
         * const maxBalance = 500000;
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .currencyLessThan(maxBalance + 1)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const assetID = 163650;
         * const maxBalance = 500000;
         * const txns = await indexerClient
         *        .searchForTransactions()
         *        .assetID(assetID)
         *        .currencyLessThan(maxBalance + 1)
         *        .do();
         * ```
         *
         * @param lesser
         * @category query
         */
        currencyLessThan(lesser) {
          this.query["currency-less-than"] = lesser;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), TransactionsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/searchForAssets.js
  var SearchForAssets;
  var init_searchForAssets = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/searchForAssets.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      SearchForAssets = class extends JSONRequest {
        /**
         * @returns `/v2/assets`
         */
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/v2/assets";
        }
        /**
         * Limit results for pagination.
         *
         * #### Example
         * ```typescript
         * const maxResults = 20;
         * const assets = await indexerClient
         *        .searchForAssets()
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit - maximum number of results to return.
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Filter just assets with the given creator address.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const assets = await indexerClient
         *        .searchForAssets()
         *        .creator(address)
         *        .do();
         * ```
         *
         * @param creator
         * @category query
         */
        creator(creator) {
          this.query.creator = creator.toString();
          return this;
        }
        /**
         * Filter just assets with the given name.
         *
         * #### Example
         * ```typescript
         * const name = "Test Token";
         * const assets = await indexerClient
         *        .searchForAssets()
         *        .name(name)
         *        .do();
         * ```
         *
         * @param name
         * @category query
         */
        name(name) {
          this.query.name = name;
          return this;
        }
        /**
         * Filter just assets with the given unit.
         *
         * #### Example
         * ```typescript
         * const unit = "test";
         * const assets = await indexerClient
         *        .searchForAssets()
         *        .unit(unit)
         *        .do();
         * ```
         *
         * @param unit
         * @category query
         */
        unit(unit) {
          this.query.unit = unit;
          return this;
        }
        /**
         * Asset ID for filter, as int.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const assets = await indexerClient
         *        .searchForAssets()
         *        .index(assetId)
         *        .do();
         * ```
         * @remarks Alternatively, use `indexerClient.lookupAssetByID(assetId).do();`
         * @param index
         * @category query
         */
        index(index) {
          this.query["asset-id"] = index;
          return this;
        }
        /**
         * Specify the next page of results.
         *
         * #### Example
         * ```typescript
         * const maxResults = 20;
         *
         * const assetsPage1 = await indexerClient
         *        .searchForAssets()
         *        .limit(maxResults)
         *        .do();
         *
         * const assetsPage2 = await indexerClient
         *        .searchForAssets()
         *        .limit(maxResults)
         *        .nextToken(assetsPage1["next-token"])
         *        .do();
         * ```
         * @param nextToken - provided by the previous results.
         * @category query
         */
        nextToken(nextToken) {
          this.query.next = nextToken;
          return this;
        }
        /**
         * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
         *
         * #### Example 1
         * ```typescript
         * const assets = await indexerClient
         *        .searchForAssets()
         *        .includeAll(false)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const assets = await indexerClient
         *        .searchForAssets()
         *        .includeAll()
         *        .do();
         * ```
         *
         * @param value - default true when called without passing a value
         * @category query
         */
        includeAll(value = true) {
          this.query["include-all"] = value;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), AssetsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/searchForApplications.js
  var SearchForApplications;
  var init_searchForApplications = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/searchForApplications.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      SearchForApplications = class extends JSONRequest {
        /**
         * @returns `/v2/applications`
         */
        // eslint-disable-next-line class-methods-use-this
        path() {
          return "/v2/applications";
        }
        /**
         * Application ID for filter, as int
         *
         * #### Example
         * ```typescript
         * const appId = 60553466;
         * const apps = await indexerClient
         *        .searchForApplications()
         *        .index(appId)
         *        .do();
         * ```
         * @remarks Alternatively, use `indexerClient.lookupApplications(appId).do()`
         * @param index
         * @category query
         */
        index(index) {
          this.query["application-id"] = index;
          return this;
        }
        /**
         * Creator for filter, as string
         *
         * #### Example
         * ```typescript
         * const creator = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const apps = await indexerClient
         *        .searchForApplications()
         *        .creator(creator)
         *        .do();
         * ```
         * @param creator
         * @category query
         */
        creator(creator) {
          this.query.creator = creator.toString();
          return this;
        }
        /**
         * Specify the next page of results.
         *
         * #### Example
         * ```typescript
         * const maxResults = 20;
         *
         * const appsPage1 = await indexerClient
         *        .searchForApplications()
         *        .limit(maxResults)
         *        .do();
         *
         * const appsPage2 = await indexerClient
         *        .searchForApplications()
         *        .limit(maxResults)
         *        .nextToken(appsPage1["next-token"])
         *        .do();
         * ```
         * @param nextToken - provided by the previous results.
         * @category query
         */
        nextToken(next) {
          this.query.next = next;
          return this;
        }
        /**
         * Limit results for pagination.
         *
         * #### Example
         * ```typescript
         * const maxResults = 20;
         * const apps = await indexerClient
         *        .searchForApplications()
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit - maximum number of results to return.
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        /**
         * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
         *
         * #### Example 1
         * ```typescript
         * const apps = await indexerClient
         *        .searchForApplications()
         *        .includeAll(false)
         *        .do();
         * ```
         *
         * #### Example 2
         * ```typescript
         * const apps = await indexerClient
         *        .searchForApplications()
         *        .includeAll()
         *        .do();
         * ```
         *
         * @param value - default true when called without passing a value
         * @category query
         */
        includeAll(value = true) {
          this.query["include-all"] = value;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), ApplicationsResponse);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/searchForApplicationBoxes.js
  var SearchForApplicationBoxes;
  var init_searchForApplicationBoxes = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/searchForApplicationBoxes.js"() {
      init_polyfills();
      init_jsonrequest();
      init_encoding3();
      init_types4();
      SearchForApplicationBoxes = class extends JSONRequest {
        /**
         * Returns information about indexed application boxes.
         *
         * #### Example
         * ```typescript
         * const maxResults = 20;
         * const appID = 1234;
         *
         * const responsePage1 = await indexerClient
         *        .searchForApplicationBoxes(appID)
         *        .limit(maxResults)
         *        .do();
         * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
         *
         * const responsePage2 = await indexerClient
         *        .searchForApplicationBoxes(appID)
         *        .limit(maxResults)
         *        .nextToken(responsePage1.nextToken)
         *        .do();
         * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
         * @oaram index - application index.
         * @category GET
         */
        constructor(c2, index) {
          super(c2);
          this.index = BigInt(index);
        }
        /**
         * @returns `/v2/applications/${index}/boxes`
         */
        path() {
          return `/v2/applications/${this.index}/boxes`;
        }
        /**
         * Specify the next page of results.
         *
         * #### Example
         * ```typescript
         * const maxResults = 20;
         * const appID = 1234;
         *
         * const responsePage1 = await indexerClient
         *        .searchForApplicationBoxes(appID)
         *        .limit(maxResults)
         *        .do();
         * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
         *
         * const responsePage2 = await indexerClient
         *        .searchForApplicationBoxes(appID)
         *        .limit(maxResults)
         *        .nextToken(responsePage1.nextToken)
         *        .do();
         * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
         * ```
         * @param nextToken - provided by the previous results.
         * @category query
         */
        nextToken(next) {
          this.query.next = next;
          return this;
        }
        /**
         * Limit results for pagination.
         *
         * #### Example
         * ```typescript
         * const maxResults = 20;
         * const boxesResponse = await indexerClient
         *        .searchForApplicationBoxes(1234)
         *        .limit(maxResults)
         *        .do();
         * ```
         *
         * @param limit - maximum number of results to return.
         * @category query
         */
        limit(limit) {
          this.query.limit = limit;
          return this;
        }
        // eslint-disable-next-line class-methods-use-this
        prepare(response) {
          return decodeJSON(response.getJSONText(), BoxesResponse2);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/client/v2/indexer/indexer.js
  var IndexerClient;
  var init_indexer = __esm({
    "node_modules/algosdk/dist/esm/client/v2/indexer/indexer.js"() {
      init_polyfills();
      init_serviceClient();
      init_makeHealthCheck();
      init_lookupAssetBalances();
      init_lookupAssetTransactions();
      init_lookupAccountTransactions();
      init_lookupBlock();
      init_lookupTransactionByID();
      init_lookupAccountByID();
      init_lookupAccountAssets();
      init_lookupAccountCreatedAssets();
      init_lookupAccountAppLocalStates();
      init_lookupAccountCreatedApplications();
      init_lookupAssetByID();
      init_lookupApplications();
      init_lookupApplicationLogs();
      init_lookupApplicationBoxByIDandName();
      init_searchAccounts();
      init_searchForBlockHeaders();
      init_searchForTransactions();
      init_searchForAssets();
      init_searchForApplications();
      init_searchForApplicationBoxes();
      IndexerClient = class extends ServiceClient {
        /**
         * Create an IndexerClient from
         * * either a token, baseServer, port, and optional headers
         * * or a base client server for interoperability with external dApp wallets
         *
         * #### Example
         * ```typescript
         * const token  = "";
         * const server = "http://localhost";
         * const port   = 8980;
         * const indexerClient = new algosdk.Indexer(token, server, port);
         * ```
         * @remarks
         * The above configuration is for a sandbox private network.
         * For applications on production, you are encouraged to run your own node with indexer, or use an Algorand REST API provider with a dedicated API key.
         *
         * @param tokenOrBaseClient - The API token for the Indexer API
         * @param baseServer - REST endpoint
         * @param port - Port number if specifically configured by the server
         * @param headers - Optional headers
         */
        constructor(tokenOrBaseClient, baseServer = "http://127.0.0.1", port = 8080, headers = {}) {
          super("X-Indexer-API-Token", tokenOrBaseClient, baseServer, port, headers);
        }
        /**
         * Returns the health object for the service.
         * Returns 200 if healthy.
         *
         * #### Example
         * ```typescript
         * const health = await indexerClient.makeHealthCheck().do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-health)
         * @category GET
         */
        makeHealthCheck() {
          return new MakeHealthCheck(this.c);
        }
        /**
         * Returns the list of accounts who hold the given asset and their balance.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
         * @param index - The asset ID to look up.
         * @category GET
         */
        lookupAssetBalances(index) {
          return new LookupAssetBalances(this.c, index);
        }
        /**
         * Returns transactions relating to the given asset.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
         * @param index - The asset ID to look up.
         * @category GET
         */
        lookupAssetTransactions(index) {
          return new LookupAssetTransactions(this.c, index);
        }
        /**
         * Returns transactions relating to the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
         * @param account - The address of the account.
         * @category GET
         */
        lookupAccountTransactions(account) {
          return new LookupAccountTransactions(this.c, account);
        }
        /**
         * Returns the block for the passed round.
         *
         * #### Example
         * ```typescript
         * const targetBlock = 18309917;
         * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
         * @param round - The number of the round to look up.
         * @category GET
         */
        lookupBlock(round) {
          return new LookupBlock(this.c, round);
        }
        /**
         * Returns information about the given transaction.
         *
         * #### Example
         * ```typescript
         * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
         * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
         * @param txID - The ID of the transaction to look up.
         * @category GET
         */
        lookupTransactionByID(txID) {
          return new LookupTransactionByID(this.c, txID);
        }
        /**
         * Returns information about the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountInfo = await indexerClient.lookupAccountByID(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
         * @param account - The address of the account to look up.
         * @category GET
         */
        lookupAccountByID(account) {
          return new LookupAccountByID(this.c, account);
        }
        /**
         * Returns asset about the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
         * @param account - The address of the account to look up.
         * @category GET
         */
        lookupAccountAssets(account) {
          return new LookupAccountAssets(this.c, account);
        }
        /**
         * Returns asset information created by the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
         * @param account - The address of the account to look up.
         * @category GET
         */
        lookupAccountCreatedAssets(account) {
          return new LookupAccountCreatedAssets(this.c, account);
        }
        /**
         * Returns application local state about the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
         * @param account - The address of the account to look up.
         * @category GET
         */
        lookupAccountAppLocalStates(account) {
          return new LookupAccountAppLocalStates(this.c, account);
        }
        /**
         * Returns application information created by the given account.
         *
         * #### Example
         * ```typescript
         * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
         * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
         * @param account - The address of the account to look up.
         * @category GET
         */
        lookupAccountCreatedApplications(account) {
          return new LookupAccountCreatedApplications(this.c, account);
        }
        /**
         * Returns information about the passed asset.
         *
         * #### Example
         * ```typescript
         * const assetId = 163650;
         * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
         * @param index - The ID of the asset ot look up.
         * @category GET
         */
        lookupAssetByID(index) {
          return new LookupAssetByID(this.c, index);
        }
        /**
         * Returns information about the passed application.
         *
         * #### Example
         * ```typescript
         * const appId = 60553466;
         * const appInfo = await indexerClient.lookupApplications(appId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
         * @param index - The ID of the application to look up.
         * @category GET
         */
        lookupApplications(index) {
          return new LookupApplications(this.c, index);
        }
        /**
         * Returns log messages generated by the passed in application.
         *
         * #### Example
         * ```typescript
         * const appId = 60553466;
         * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
         * @param appID - The ID of the application which generated the logs.
         * @category GET
         */
        lookupApplicationLogs(appID) {
          return new LookupApplicationLogs(this.c, appID);
        }
        /**
         * Returns information about indexed accounts.
         *
         * #### Example
         * ```typescript
         * const accounts = await indexerClient.searchAccounts().do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accounts)
         * @category GET
         */
        searchAccounts() {
          return new SearchAccounts(this.c);
        }
        /**
         * Returns information about indexed block headers.
         *
         * #### Example
         * ```typescript
         * const bhs = await indexerClient.searchForBlockHeaders().do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2block-headers)
         * @category GET
         */
        searchForBlockHeaders() {
          return new SearchForBlockHeaders(this.c);
        }
        /**
         * Returns information about indexed transactions.
         *
         * #### Example
         * ```typescript
         * const txns = await indexerClient.searchForTransactions().do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactions)
         * @category GET
         */
        searchForTransactions() {
          return new SearchForTransactions(this.c);
        }
        /**
         * Returns information about indexed assets.
         *
         * #### Example
         * ```typescript
         * const assets = await indexerClient.searchForAssets().do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assets)
         * @category GET
         */
        searchForAssets() {
          return new SearchForAssets(this.c);
        }
        /**
         * Returns information about indexed applications.
         *
         * #### Example
         * ```typescript
         * const apps = await indexerClient.searchForApplications().do();
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applications)
         * @category GET
         */
        searchForApplications() {
          return new SearchForApplications(this.c);
        }
        /**
         * Returns information about indexed application boxes.
         *
         * #### Example
         * ```typescript
         * const maxResults = 20;
         * const appID = 1234;
         *
         * const responsePage1 = await indexerClient
         *        .searchForApplicationBoxes(appID)
         *        .limit(maxResults)
         *        .do();
         * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
         *
         * const responsePage2 = await indexerClient
         *        .searchForApplicationBoxes(appID)
         *        .limit(maxResults)
         *        .nextToken(responsePage1.nextToken)
         *        .do();
         * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
         * @param appID - The ID of the application with boxes.
         * @category GET
         */
        searchForApplicationBoxes(appID) {
          return new SearchForApplicationBoxes(this.c, appID);
        }
        /**
         * Returns information about the application box given its name.
         *
         * #### Example
         * ```typescript
         * const boxName = Buffer.from("foo");
         * const boxResponse = await indexerClient
         *        .LookupApplicationBoxByIDandName(1234, boxName)
         *        .do();
         * const boxValue = boxResponse.value;
         * ```
         *
         * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
         * @param appID - The ID of the application with boxes.
         * @category GET
         */
        lookupApplicationBoxByIDandName(appID, boxName) {
          return new LookupApplicationBoxByIDandName(this.c, appID, boxName);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/wait.js
  async function waitForConfirmation(client, txid, waitRounds) {
    const status = await client.status().do();
    if (typeof status === "undefined") {
      throw new Error("Unable to get node status");
    }
    const startRound = status.lastRound + BigInt(1);
    const stopRound = startRound + BigInt(waitRounds);
    let currentRound = startRound;
    while (currentRound < stopRound) {
      let poolError = false;
      try {
        const pendingInfo = await client.pendingTransactionInformation(txid).do();
        if (pendingInfo.confirmedRound) {
          return pendingInfo;
        }
        if (pendingInfo.poolError) {
          poolError = true;
          throw new Error(`Transaction Rejected: ${pendingInfo.poolError}`);
        }
      } catch (err) {
        if (poolError) {
          throw err;
        }
      }
      await client.statusAfterBlock(currentRound).do();
      currentRound += BigInt(1);
    }
    throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);
  }
  var init_wait = __esm({
    "node_modules/algosdk/dist/esm/wait.js"() {
      init_polyfills();
    }
  });

  // node_modules/algosdk/dist/esm/encoding/bigint.js
  function bigIntToBytes(bi, size) {
    let hex = bi.toString(16);
    if (hex.length !== size * 2) {
      hex = hex.padStart(size * 2, "0");
    }
    const byteArray = new Uint8Array(hex.length / 2);
    for (let i2 = 0, j3 = 0; i2 < hex.length / 2; i2++, j3 += 2) {
      byteArray[i2] = parseInt(hex.slice(j3, j3 + 2), 16);
    }
    return byteArray;
  }
  function bytesToBigInt(bytes) {
    let res = BigInt(0);
    const buf = new DataView(bytes.buffer, bytes.byteOffset);
    for (let i2 = 0; i2 < bytes.length; i2++) {
      res = BigInt(Number(buf.getUint8(i2))) + res * BigInt(256);
    }
    return res;
  }
  var init_bigint = __esm({
    "node_modules/algosdk/dist/esm/encoding/bigint.js"() {
      init_polyfills();
    }
  });

  // node_modules/algosdk/dist/esm/account.js
  function generateAccount() {
    const keys = keyPair();
    const addr = new Address(keys.publicKey);
    return { addr, sk: keys.secretKey };
  }
  var init_account = __esm({
    "node_modules/algosdk/dist/esm/account.js"() {
      init_polyfills();
      init_naclWrappers();
      init_address();
    }
  });

  // node_modules/algosdk/dist/esm/mnemonic/wordlists/english.js
  var english, english_default;
  var init_english = __esm({
    "node_modules/algosdk/dist/esm/mnemonic/wordlists/english.js"() {
      init_polyfills();
      english = [
        "abandon",
        "ability",
        "able",
        "about",
        "above",
        "absent",
        "absorb",
        "abstract",
        "absurd",
        "abuse",
        "access",
        "accident",
        "account",
        "accuse",
        "achieve",
        "acid",
        "acoustic",
        "acquire",
        "across",
        "act",
        "action",
        "actor",
        "actress",
        "actual",
        "adapt",
        "add",
        "addict",
        "address",
        "adjust",
        "admit",
        "adult",
        "advance",
        "advice",
        "aerobic",
        "affair",
        "afford",
        "afraid",
        "again",
        "age",
        "agent",
        "agree",
        "ahead",
        "aim",
        "air",
        "airport",
        "aisle",
        "alarm",
        "album",
        "alcohol",
        "alert",
        "alien",
        "all",
        "alley",
        "allow",
        "almost",
        "alone",
        "alpha",
        "already",
        "also",
        "alter",
        "always",
        "amateur",
        "amazing",
        "among",
        "amount",
        "amused",
        "analyst",
        "anchor",
        "ancient",
        "anger",
        "angle",
        "angry",
        "animal",
        "ankle",
        "announce",
        "annual",
        "another",
        "answer",
        "antenna",
        "antique",
        "anxiety",
        "any",
        "apart",
        "apology",
        "appear",
        "apple",
        "approve",
        "april",
        "arch",
        "arctic",
        "area",
        "arena",
        "argue",
        "arm",
        "armed",
        "armor",
        "army",
        "around",
        "arrange",
        "arrest",
        "arrive",
        "arrow",
        "art",
        "artefact",
        "artist",
        "artwork",
        "ask",
        "aspect",
        "assault",
        "asset",
        "assist",
        "assume",
        "asthma",
        "athlete",
        "atom",
        "attack",
        "attend",
        "attitude",
        "attract",
        "auction",
        "audit",
        "august",
        "aunt",
        "author",
        "auto",
        "autumn",
        "average",
        "avocado",
        "avoid",
        "awake",
        "aware",
        "away",
        "awesome",
        "awful",
        "awkward",
        "axis",
        "baby",
        "bachelor",
        "bacon",
        "badge",
        "bag",
        "balance",
        "balcony",
        "ball",
        "bamboo",
        "banana",
        "banner",
        "bar",
        "barely",
        "bargain",
        "barrel",
        "base",
        "basic",
        "basket",
        "battle",
        "beach",
        "bean",
        "beauty",
        "because",
        "become",
        "beef",
        "before",
        "begin",
        "behave",
        "behind",
        "believe",
        "below",
        "belt",
        "bench",
        "benefit",
        "best",
        "betray",
        "better",
        "between",
        "beyond",
        "bicycle",
        "bid",
        "bike",
        "bind",
        "biology",
        "bird",
        "birth",
        "bitter",
        "black",
        "blade",
        "blame",
        "blanket",
        "blast",
        "bleak",
        "bless",
        "blind",
        "blood",
        "blossom",
        "blouse",
        "blue",
        "blur",
        "blush",
        "board",
        "boat",
        "body",
        "boil",
        "bomb",
        "bone",
        "bonus",
        "book",
        "boost",
        "border",
        "boring",
        "borrow",
        "boss",
        "bottom",
        "bounce",
        "box",
        "boy",
        "bracket",
        "brain",
        "brand",
        "brass",
        "brave",
        "bread",
        "breeze",
        "brick",
        "bridge",
        "brief",
        "bright",
        "bring",
        "brisk",
        "broccoli",
        "broken",
        "bronze",
        "broom",
        "brother",
        "brown",
        "brush",
        "bubble",
        "buddy",
        "budget",
        "buffalo",
        "build",
        "bulb",
        "bulk",
        "bullet",
        "bundle",
        "bunker",
        "burden",
        "burger",
        "burst",
        "bus",
        "business",
        "busy",
        "butter",
        "buyer",
        "buzz",
        "cabbage",
        "cabin",
        "cable",
        "cactus",
        "cage",
        "cake",
        "call",
        "calm",
        "camera",
        "camp",
        "can",
        "canal",
        "cancel",
        "candy",
        "cannon",
        "canoe",
        "canvas",
        "canyon",
        "capable",
        "capital",
        "captain",
        "car",
        "carbon",
        "card",
        "cargo",
        "carpet",
        "carry",
        "cart",
        "case",
        "cash",
        "casino",
        "castle",
        "casual",
        "cat",
        "catalog",
        "catch",
        "category",
        "cattle",
        "caught",
        "cause",
        "caution",
        "cave",
        "ceiling",
        "celery",
        "cement",
        "census",
        "century",
        "cereal",
        "certain",
        "chair",
        "chalk",
        "champion",
        "change",
        "chaos",
        "chapter",
        "charge",
        "chase",
        "chat",
        "cheap",
        "check",
        "cheese",
        "chef",
        "cherry",
        "chest",
        "chicken",
        "chief",
        "child",
        "chimney",
        "choice",
        "choose",
        "chronic",
        "chuckle",
        "chunk",
        "churn",
        "cigar",
        "cinnamon",
        "circle",
        "citizen",
        "city",
        "civil",
        "claim",
        "clap",
        "clarify",
        "claw",
        "clay",
        "clean",
        "clerk",
        "clever",
        "click",
        "client",
        "cliff",
        "climb",
        "clinic",
        "clip",
        "clock",
        "clog",
        "close",
        "cloth",
        "cloud",
        "clown",
        "club",
        "clump",
        "cluster",
        "clutch",
        "coach",
        "coast",
        "coconut",
        "code",
        "coffee",
        "coil",
        "coin",
        "collect",
        "color",
        "column",
        "combine",
        "come",
        "comfort",
        "comic",
        "common",
        "company",
        "concert",
        "conduct",
        "confirm",
        "congress",
        "connect",
        "consider",
        "control",
        "convince",
        "cook",
        "cool",
        "copper",
        "copy",
        "coral",
        "core",
        "corn",
        "correct",
        "cost",
        "cotton",
        "couch",
        "country",
        "couple",
        "course",
        "cousin",
        "cover",
        "coyote",
        "crack",
        "cradle",
        "craft",
        "cram",
        "crane",
        "crash",
        "crater",
        "crawl",
        "crazy",
        "cream",
        "credit",
        "creek",
        "crew",
        "cricket",
        "crime",
        "crisp",
        "critic",
        "crop",
        "cross",
        "crouch",
        "crowd",
        "crucial",
        "cruel",
        "cruise",
        "crumble",
        "crunch",
        "crush",
        "cry",
        "crystal",
        "cube",
        "culture",
        "cup",
        "cupboard",
        "curious",
        "current",
        "curtain",
        "curve",
        "cushion",
        "custom",
        "cute",
        "cycle",
        "dad",
        "damage",
        "damp",
        "dance",
        "danger",
        "daring",
        "dash",
        "daughter",
        "dawn",
        "day",
        "deal",
        "debate",
        "debris",
        "decade",
        "december",
        "decide",
        "decline",
        "decorate",
        "decrease",
        "deer",
        "defense",
        "define",
        "defy",
        "degree",
        "delay",
        "deliver",
        "demand",
        "demise",
        "denial",
        "dentist",
        "deny",
        "depart",
        "depend",
        "deposit",
        "depth",
        "deputy",
        "derive",
        "describe",
        "desert",
        "design",
        "desk",
        "despair",
        "destroy",
        "detail",
        "detect",
        "develop",
        "device",
        "devote",
        "diagram",
        "dial",
        "diamond",
        "diary",
        "dice",
        "diesel",
        "diet",
        "differ",
        "digital",
        "dignity",
        "dilemma",
        "dinner",
        "dinosaur",
        "direct",
        "dirt",
        "disagree",
        "discover",
        "disease",
        "dish",
        "dismiss",
        "disorder",
        "display",
        "distance",
        "divert",
        "divide",
        "divorce",
        "dizzy",
        "doctor",
        "document",
        "dog",
        "doll",
        "dolphin",
        "domain",
        "donate",
        "donkey",
        "donor",
        "door",
        "dose",
        "double",
        "dove",
        "draft",
        "dragon",
        "drama",
        "drastic",
        "draw",
        "dream",
        "dress",
        "drift",
        "drill",
        "drink",
        "drip",
        "drive",
        "drop",
        "drum",
        "dry",
        "duck",
        "dumb",
        "dune",
        "during",
        "dust",
        "dutch",
        "duty",
        "dwarf",
        "dynamic",
        "eager",
        "eagle",
        "early",
        "earn",
        "earth",
        "easily",
        "east",
        "easy",
        "echo",
        "ecology",
        "economy",
        "edge",
        "edit",
        "educate",
        "effort",
        "egg",
        "eight",
        "either",
        "elbow",
        "elder",
        "electric",
        "elegant",
        "element",
        "elephant",
        "elevator",
        "elite",
        "else",
        "embark",
        "embody",
        "embrace",
        "emerge",
        "emotion",
        "employ",
        "empower",
        "empty",
        "enable",
        "enact",
        "end",
        "endless",
        "endorse",
        "enemy",
        "energy",
        "enforce",
        "engage",
        "engine",
        "enhance",
        "enjoy",
        "enlist",
        "enough",
        "enrich",
        "enroll",
        "ensure",
        "enter",
        "entire",
        "entry",
        "envelope",
        "episode",
        "equal",
        "equip",
        "era",
        "erase",
        "erode",
        "erosion",
        "error",
        "erupt",
        "escape",
        "essay",
        "essence",
        "estate",
        "eternal",
        "ethics",
        "evidence",
        "evil",
        "evoke",
        "evolve",
        "exact",
        "example",
        "excess",
        "exchange",
        "excite",
        "exclude",
        "excuse",
        "execute",
        "exercise",
        "exhaust",
        "exhibit",
        "exile",
        "exist",
        "exit",
        "exotic",
        "expand",
        "expect",
        "expire",
        "explain",
        "expose",
        "express",
        "extend",
        "extra",
        "eye",
        "eyebrow",
        "fabric",
        "face",
        "faculty",
        "fade",
        "faint",
        "faith",
        "fall",
        "false",
        "fame",
        "family",
        "famous",
        "fan",
        "fancy",
        "fantasy",
        "farm",
        "fashion",
        "fat",
        "fatal",
        "father",
        "fatigue",
        "fault",
        "favorite",
        "feature",
        "february",
        "federal",
        "fee",
        "feed",
        "feel",
        "female",
        "fence",
        "festival",
        "fetch",
        "fever",
        "few",
        "fiber",
        "fiction",
        "field",
        "figure",
        "file",
        "film",
        "filter",
        "final",
        "find",
        "fine",
        "finger",
        "finish",
        "fire",
        "firm",
        "first",
        "fiscal",
        "fish",
        "fit",
        "fitness",
        "fix",
        "flag",
        "flame",
        "flash",
        "flat",
        "flavor",
        "flee",
        "flight",
        "flip",
        "float",
        "flock",
        "floor",
        "flower",
        "fluid",
        "flush",
        "fly",
        "foam",
        "focus",
        "fog",
        "foil",
        "fold",
        "follow",
        "food",
        "foot",
        "force",
        "forest",
        "forget",
        "fork",
        "fortune",
        "forum",
        "forward",
        "fossil",
        "foster",
        "found",
        "fox",
        "fragile",
        "frame",
        "frequent",
        "fresh",
        "friend",
        "fringe",
        "frog",
        "front",
        "frost",
        "frown",
        "frozen",
        "fruit",
        "fuel",
        "fun",
        "funny",
        "furnace",
        "fury",
        "future",
        "gadget",
        "gain",
        "galaxy",
        "gallery",
        "game",
        "gap",
        "garage",
        "garbage",
        "garden",
        "garlic",
        "garment",
        "gas",
        "gasp",
        "gate",
        "gather",
        "gauge",
        "gaze",
        "general",
        "genius",
        "genre",
        "gentle",
        "genuine",
        "gesture",
        "ghost",
        "giant",
        "gift",
        "giggle",
        "ginger",
        "giraffe",
        "girl",
        "give",
        "glad",
        "glance",
        "glare",
        "glass",
        "glide",
        "glimpse",
        "globe",
        "gloom",
        "glory",
        "glove",
        "glow",
        "glue",
        "goat",
        "goddess",
        "gold",
        "good",
        "goose",
        "gorilla",
        "gospel",
        "gossip",
        "govern",
        "gown",
        "grab",
        "grace",
        "grain",
        "grant",
        "grape",
        "grass",
        "gravity",
        "great",
        "green",
        "grid",
        "grief",
        "grit",
        "grocery",
        "group",
        "grow",
        "grunt",
        "guard",
        "guess",
        "guide",
        "guilt",
        "guitar",
        "gun",
        "gym",
        "habit",
        "hair",
        "half",
        "hammer",
        "hamster",
        "hand",
        "happy",
        "harbor",
        "hard",
        "harsh",
        "harvest",
        "hat",
        "have",
        "hawk",
        "hazard",
        "head",
        "health",
        "heart",
        "heavy",
        "hedgehog",
        "height",
        "hello",
        "helmet",
        "help",
        "hen",
        "hero",
        "hidden",
        "high",
        "hill",
        "hint",
        "hip",
        "hire",
        "history",
        "hobby",
        "hockey",
        "hold",
        "hole",
        "holiday",
        "hollow",
        "home",
        "honey",
        "hood",
        "hope",
        "horn",
        "horror",
        "horse",
        "hospital",
        "host",
        "hotel",
        "hour",
        "hover",
        "hub",
        "huge",
        "human",
        "humble",
        "humor",
        "hundred",
        "hungry",
        "hunt",
        "hurdle",
        "hurry",
        "hurt",
        "husband",
        "hybrid",
        "ice",
        "icon",
        "idea",
        "identify",
        "idle",
        "ignore",
        "ill",
        "illegal",
        "illness",
        "image",
        "imitate",
        "immense",
        "immune",
        "impact",
        "impose",
        "improve",
        "impulse",
        "inch",
        "include",
        "income",
        "increase",
        "index",
        "indicate",
        "indoor",
        "industry",
        "infant",
        "inflict",
        "inform",
        "inhale",
        "inherit",
        "initial",
        "inject",
        "injury",
        "inmate",
        "inner",
        "innocent",
        "input",
        "inquiry",
        "insane",
        "insect",
        "inside",
        "inspire",
        "install",
        "intact",
        "interest",
        "into",
        "invest",
        "invite",
        "involve",
        "iron",
        "island",
        "isolate",
        "issue",
        "item",
        "ivory",
        "jacket",
        "jaguar",
        "jar",
        "jazz",
        "jealous",
        "jeans",
        "jelly",
        "jewel",
        "job",
        "join",
        "joke",
        "journey",
        "joy",
        "judge",
        "juice",
        "jump",
        "jungle",
        "junior",
        "junk",
        "just",
        "kangaroo",
        "keen",
        "keep",
        "ketchup",
        "key",
        "kick",
        "kid",
        "kidney",
        "kind",
        "kingdom",
        "kiss",
        "kit",
        "kitchen",
        "kite",
        "kitten",
        "kiwi",
        "knee",
        "knife",
        "knock",
        "know",
        "lab",
        "label",
        "labor",
        "ladder",
        "lady",
        "lake",
        "lamp",
        "language",
        "laptop",
        "large",
        "later",
        "latin",
        "laugh",
        "laundry",
        "lava",
        "law",
        "lawn",
        "lawsuit",
        "layer",
        "lazy",
        "leader",
        "leaf",
        "learn",
        "leave",
        "lecture",
        "left",
        "leg",
        "legal",
        "legend",
        "leisure",
        "lemon",
        "lend",
        "length",
        "lens",
        "leopard",
        "lesson",
        "letter",
        "level",
        "liar",
        "liberty",
        "library",
        "license",
        "life",
        "lift",
        "light",
        "like",
        "limb",
        "limit",
        "link",
        "lion",
        "liquid",
        "list",
        "little",
        "live",
        "lizard",
        "load",
        "loan",
        "lobster",
        "local",
        "lock",
        "logic",
        "lonely",
        "long",
        "loop",
        "lottery",
        "loud",
        "lounge",
        "love",
        "loyal",
        "lucky",
        "luggage",
        "lumber",
        "lunar",
        "lunch",
        "luxury",
        "lyrics",
        "machine",
        "mad",
        "magic",
        "magnet",
        "maid",
        "mail",
        "main",
        "major",
        "make",
        "mammal",
        "man",
        "manage",
        "mandate",
        "mango",
        "mansion",
        "manual",
        "maple",
        "marble",
        "march",
        "margin",
        "marine",
        "market",
        "marriage",
        "mask",
        "mass",
        "master",
        "match",
        "material",
        "math",
        "matrix",
        "matter",
        "maximum",
        "maze",
        "meadow",
        "mean",
        "measure",
        "meat",
        "mechanic",
        "medal",
        "media",
        "melody",
        "melt",
        "member",
        "memory",
        "mention",
        "menu",
        "mercy",
        "merge",
        "merit",
        "merry",
        "mesh",
        "message",
        "metal",
        "method",
        "middle",
        "midnight",
        "milk",
        "million",
        "mimic",
        "mind",
        "minimum",
        "minor",
        "minute",
        "miracle",
        "mirror",
        "misery",
        "miss",
        "mistake",
        "mix",
        "mixed",
        "mixture",
        "mobile",
        "model",
        "modify",
        "mom",
        "moment",
        "monitor",
        "monkey",
        "monster",
        "month",
        "moon",
        "moral",
        "more",
        "morning",
        "mosquito",
        "mother",
        "motion",
        "motor",
        "mountain",
        "mouse",
        "move",
        "movie",
        "much",
        "muffin",
        "mule",
        "multiply",
        "muscle",
        "museum",
        "mushroom",
        "music",
        "must",
        "mutual",
        "myself",
        "mystery",
        "myth",
        "naive",
        "name",
        "napkin",
        "narrow",
        "nasty",
        "nation",
        "nature",
        "near",
        "neck",
        "need",
        "negative",
        "neglect",
        "neither",
        "nephew",
        "nerve",
        "nest",
        "net",
        "network",
        "neutral",
        "never",
        "news",
        "next",
        "nice",
        "night",
        "noble",
        "noise",
        "nominee",
        "noodle",
        "normal",
        "north",
        "nose",
        "notable",
        "note",
        "nothing",
        "notice",
        "novel",
        "now",
        "nuclear",
        "number",
        "nurse",
        "nut",
        "oak",
        "obey",
        "object",
        "oblige",
        "obscure",
        "observe",
        "obtain",
        "obvious",
        "occur",
        "ocean",
        "october",
        "odor",
        "off",
        "offer",
        "office",
        "often",
        "oil",
        "okay",
        "old",
        "olive",
        "olympic",
        "omit",
        "once",
        "one",
        "onion",
        "online",
        "only",
        "open",
        "opera",
        "opinion",
        "oppose",
        "option",
        "orange",
        "orbit",
        "orchard",
        "order",
        "ordinary",
        "organ",
        "orient",
        "original",
        "orphan",
        "ostrich",
        "other",
        "outdoor",
        "outer",
        "output",
        "outside",
        "oval",
        "oven",
        "over",
        "own",
        "owner",
        "oxygen",
        "oyster",
        "ozone",
        "pact",
        "paddle",
        "page",
        "pair",
        "palace",
        "palm",
        "panda",
        "panel",
        "panic",
        "panther",
        "paper",
        "parade",
        "parent",
        "park",
        "parrot",
        "party",
        "pass",
        "patch",
        "path",
        "patient",
        "patrol",
        "pattern",
        "pause",
        "pave",
        "payment",
        "peace",
        "peanut",
        "pear",
        "peasant",
        "pelican",
        "pen",
        "penalty",
        "pencil",
        "people",
        "pepper",
        "perfect",
        "permit",
        "person",
        "pet",
        "phone",
        "photo",
        "phrase",
        "physical",
        "piano",
        "picnic",
        "picture",
        "piece",
        "pig",
        "pigeon",
        "pill",
        "pilot",
        "pink",
        "pioneer",
        "pipe",
        "pistol",
        "pitch",
        "pizza",
        "place",
        "planet",
        "plastic",
        "plate",
        "play",
        "please",
        "pledge",
        "pluck",
        "plug",
        "plunge",
        "poem",
        "poet",
        "point",
        "polar",
        "pole",
        "police",
        "pond",
        "pony",
        "pool",
        "popular",
        "portion",
        "position",
        "possible",
        "post",
        "potato",
        "pottery",
        "poverty",
        "powder",
        "power",
        "practice",
        "praise",
        "predict",
        "prefer",
        "prepare",
        "present",
        "pretty",
        "prevent",
        "price",
        "pride",
        "primary",
        "print",
        "priority",
        "prison",
        "private",
        "prize",
        "problem",
        "process",
        "produce",
        "profit",
        "program",
        "project",
        "promote",
        "proof",
        "property",
        "prosper",
        "protect",
        "proud",
        "provide",
        "public",
        "pudding",
        "pull",
        "pulp",
        "pulse",
        "pumpkin",
        "punch",
        "pupil",
        "puppy",
        "purchase",
        "purity",
        "purpose",
        "purse",
        "push",
        "put",
        "puzzle",
        "pyramid",
        "quality",
        "quantum",
        "quarter",
        "question",
        "quick",
        "quit",
        "quiz",
        "quote",
        "rabbit",
        "raccoon",
        "race",
        "rack",
        "radar",
        "radio",
        "rail",
        "rain",
        "raise",
        "rally",
        "ramp",
        "ranch",
        "random",
        "range",
        "rapid",
        "rare",
        "rate",
        "rather",
        "raven",
        "raw",
        "razor",
        "ready",
        "real",
        "reason",
        "rebel",
        "rebuild",
        "recall",
        "receive",
        "recipe",
        "record",
        "recycle",
        "reduce",
        "reflect",
        "reform",
        "refuse",
        "region",
        "regret",
        "regular",
        "reject",
        "relax",
        "release",
        "relief",
        "rely",
        "remain",
        "remember",
        "remind",
        "remove",
        "render",
        "renew",
        "rent",
        "reopen",
        "repair",
        "repeat",
        "replace",
        "report",
        "require",
        "rescue",
        "resemble",
        "resist",
        "resource",
        "response",
        "result",
        "retire",
        "retreat",
        "return",
        "reunion",
        "reveal",
        "review",
        "reward",
        "rhythm",
        "rib",
        "ribbon",
        "rice",
        "rich",
        "ride",
        "ridge",
        "rifle",
        "right",
        "rigid",
        "ring",
        "riot",
        "ripple",
        "risk",
        "ritual",
        "rival",
        "river",
        "road",
        "roast",
        "robot",
        "robust",
        "rocket",
        "romance",
        "roof",
        "rookie",
        "room",
        "rose",
        "rotate",
        "rough",
        "round",
        "route",
        "royal",
        "rubber",
        "rude",
        "rug",
        "rule",
        "run",
        "runway",
        "rural",
        "sad",
        "saddle",
        "sadness",
        "safe",
        "sail",
        "salad",
        "salmon",
        "salon",
        "salt",
        "salute",
        "same",
        "sample",
        "sand",
        "satisfy",
        "satoshi",
        "sauce",
        "sausage",
        "save",
        "say",
        "scale",
        "scan",
        "scare",
        "scatter",
        "scene",
        "scheme",
        "school",
        "science",
        "scissors",
        "scorpion",
        "scout",
        "scrap",
        "screen",
        "script",
        "scrub",
        "sea",
        "search",
        "season",
        "seat",
        "second",
        "secret",
        "section",
        "security",
        "seed",
        "seek",
        "segment",
        "select",
        "sell",
        "seminar",
        "senior",
        "sense",
        "sentence",
        "series",
        "service",
        "session",
        "settle",
        "setup",
        "seven",
        "shadow",
        "shaft",
        "shallow",
        "share",
        "shed",
        "shell",
        "sheriff",
        "shield",
        "shift",
        "shine",
        "ship",
        "shiver",
        "shock",
        "shoe",
        "shoot",
        "shop",
        "short",
        "shoulder",
        "shove",
        "shrimp",
        "shrug",
        "shuffle",
        "shy",
        "sibling",
        "sick",
        "side",
        "siege",
        "sight",
        "sign",
        "silent",
        "silk",
        "silly",
        "silver",
        "similar",
        "simple",
        "since",
        "sing",
        "siren",
        "sister",
        "situate",
        "six",
        "size",
        "skate",
        "sketch",
        "ski",
        "skill",
        "skin",
        "skirt",
        "skull",
        "slab",
        "slam",
        "sleep",
        "slender",
        "slice",
        "slide",
        "slight",
        "slim",
        "slogan",
        "slot",
        "slow",
        "slush",
        "small",
        "smart",
        "smile",
        "smoke",
        "smooth",
        "snack",
        "snake",
        "snap",
        "sniff",
        "snow",
        "soap",
        "soccer",
        "social",
        "sock",
        "soda",
        "soft",
        "solar",
        "soldier",
        "solid",
        "solution",
        "solve",
        "someone",
        "song",
        "soon",
        "sorry",
        "sort",
        "soul",
        "sound",
        "soup",
        "source",
        "south",
        "space",
        "spare",
        "spatial",
        "spawn",
        "speak",
        "special",
        "speed",
        "spell",
        "spend",
        "sphere",
        "spice",
        "spider",
        "spike",
        "spin",
        "spirit",
        "split",
        "spoil",
        "sponsor",
        "spoon",
        "sport",
        "spot",
        "spray",
        "spread",
        "spring",
        "spy",
        "square",
        "squeeze",
        "squirrel",
        "stable",
        "stadium",
        "staff",
        "stage",
        "stairs",
        "stamp",
        "stand",
        "start",
        "state",
        "stay",
        "steak",
        "steel",
        "stem",
        "step",
        "stereo",
        "stick",
        "still",
        "sting",
        "stock",
        "stomach",
        "stone",
        "stool",
        "story",
        "stove",
        "strategy",
        "street",
        "strike",
        "strong",
        "struggle",
        "student",
        "stuff",
        "stumble",
        "style",
        "subject",
        "submit",
        "subway",
        "success",
        "such",
        "sudden",
        "suffer",
        "sugar",
        "suggest",
        "suit",
        "summer",
        "sun",
        "sunny",
        "sunset",
        "super",
        "supply",
        "supreme",
        "sure",
        "surface",
        "surge",
        "surprise",
        "surround",
        "survey",
        "suspect",
        "sustain",
        "swallow",
        "swamp",
        "swap",
        "swarm",
        "swear",
        "sweet",
        "swift",
        "swim",
        "swing",
        "switch",
        "sword",
        "symbol",
        "symptom",
        "syrup",
        "system",
        "table",
        "tackle",
        "tag",
        "tail",
        "talent",
        "talk",
        "tank",
        "tape",
        "target",
        "task",
        "taste",
        "tattoo",
        "taxi",
        "teach",
        "team",
        "tell",
        "ten",
        "tenant",
        "tennis",
        "tent",
        "term",
        "test",
        "text",
        "thank",
        "that",
        "theme",
        "then",
        "theory",
        "there",
        "they",
        "thing",
        "this",
        "thought",
        "three",
        "thrive",
        "throw",
        "thumb",
        "thunder",
        "ticket",
        "tide",
        "tiger",
        "tilt",
        "timber",
        "time",
        "tiny",
        "tip",
        "tired",
        "tissue",
        "title",
        "toast",
        "tobacco",
        "today",
        "toddler",
        "toe",
        "together",
        "toilet",
        "token",
        "tomato",
        "tomorrow",
        "tone",
        "tongue",
        "tonight",
        "tool",
        "tooth",
        "top",
        "topic",
        "topple",
        "torch",
        "tornado",
        "tortoise",
        "toss",
        "total",
        "tourist",
        "toward",
        "tower",
        "town",
        "toy",
        "track",
        "trade",
        "traffic",
        "tragic",
        "train",
        "transfer",
        "trap",
        "trash",
        "travel",
        "tray",
        "treat",
        "tree",
        "trend",
        "trial",
        "tribe",
        "trick",
        "trigger",
        "trim",
        "trip",
        "trophy",
        "trouble",
        "truck",
        "true",
        "truly",
        "trumpet",
        "trust",
        "truth",
        "try",
        "tube",
        "tuition",
        "tumble",
        "tuna",
        "tunnel",
        "turkey",
        "turn",
        "turtle",
        "twelve",
        "twenty",
        "twice",
        "twin",
        "twist",
        "two",
        "type",
        "typical",
        "ugly",
        "umbrella",
        "unable",
        "unaware",
        "uncle",
        "uncover",
        "under",
        "undo",
        "unfair",
        "unfold",
        "unhappy",
        "uniform",
        "unique",
        "unit",
        "universe",
        "unknown",
        "unlock",
        "until",
        "unusual",
        "unveil",
        "update",
        "upgrade",
        "uphold",
        "upon",
        "upper",
        "upset",
        "urban",
        "urge",
        "usage",
        "use",
        "used",
        "useful",
        "useless",
        "usual",
        "utility",
        "vacant",
        "vacuum",
        "vague",
        "valid",
        "valley",
        "valve",
        "van",
        "vanish",
        "vapor",
        "various",
        "vast",
        "vault",
        "vehicle",
        "velvet",
        "vendor",
        "venture",
        "venue",
        "verb",
        "verify",
        "version",
        "very",
        "vessel",
        "veteran",
        "viable",
        "vibrant",
        "vicious",
        "victory",
        "video",
        "view",
        "village",
        "vintage",
        "violin",
        "virtual",
        "virus",
        "visa",
        "visit",
        "visual",
        "vital",
        "vivid",
        "vocal",
        "voice",
        "void",
        "volcano",
        "volume",
        "vote",
        "voyage",
        "wage",
        "wagon",
        "wait",
        "walk",
        "wall",
        "walnut",
        "want",
        "warfare",
        "warm",
        "warrior",
        "wash",
        "wasp",
        "waste",
        "water",
        "wave",
        "way",
        "wealth",
        "weapon",
        "wear",
        "weasel",
        "weather",
        "web",
        "wedding",
        "weekend",
        "weird",
        "welcome",
        "west",
        "wet",
        "whale",
        "what",
        "wheat",
        "wheel",
        "when",
        "where",
        "whip",
        "whisper",
        "wide",
        "width",
        "wife",
        "wild",
        "will",
        "win",
        "window",
        "wine",
        "wing",
        "wink",
        "winner",
        "winter",
        "wire",
        "wisdom",
        "wise",
        "wish",
        "witness",
        "wolf",
        "woman",
        "wonder",
        "wood",
        "wool",
        "word",
        "work",
        "world",
        "worry",
        "worth",
        "wrap",
        "wreck",
        "wrestle",
        "wrist",
        "write",
        "wrong",
        "yard",
        "year",
        "yellow",
        "you",
        "young",
        "youth",
        "zebra",
        "zero",
        "zone",
        "zoo"
      ];
      english_default = english;
    }
  });

  // node_modules/algosdk/dist/esm/mnemonic/mnemonic.js
  function toUint11Array(buffer8) {
    const buffer11 = [];
    let acc = 0;
    let accBits = 0;
    function add(octet) {
      acc |= octet << accBits;
      accBits += 8;
      if (accBits >= 11) {
        buffer11.push(acc & 2047);
        acc >>= 11;
        accBits -= 11;
      }
    }
    function flush() {
      if (accBits) {
        buffer11.push(acc);
      }
    }
    buffer8.forEach(add);
    flush();
    return buffer11;
  }
  function applyWords(nums) {
    return nums.map((n3) => english_default[n3]);
  }
  function computeChecksum(seed) {
    const hashBuffer = genericHash(seed);
    const uint11Hash = toUint11Array(hashBuffer);
    const words = applyWords(uint11Hash);
    return words[0];
  }
  function mnemonicFromSeed(seed) {
    if (seed.length !== SEED_BTYES_LENGTH) {
      throw new RangeError(`Seed length must be ${SEED_BTYES_LENGTH}`);
    }
    const uint11Array = toUint11Array(seed);
    const words = applyWords(uint11Array);
    const checksumWord = computeChecksum(seed);
    return `${words.join(" ")} ${checksumWord}`;
  }
  function toUint8Array(buffer11) {
    const buffer8 = [];
    let acc = 0;
    let accBits = 0;
    function add(ui11) {
      acc |= ui11 << accBits;
      accBits += 11;
      while (accBits >= 8) {
        buffer8.push(acc & 255);
        acc >>= 8;
        accBits -= 8;
      }
    }
    function flush() {
      if (accBits) {
        buffer8.push(acc);
      }
    }
    buffer11.forEach(add);
    flush();
    return new Uint8Array(buffer8);
  }
  function seedFromMnemonic(mnemonic) {
    const words = mnemonic.split(" ");
    const key = words.slice(0, 24);
    for (const w3 of key) {
      if (english_default.indexOf(w3) === -1)
        throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);
    }
    const checksum = words[words.length - 1];
    const uint11Array = key.map((word) => english_default.indexOf(word));
    let uint8Array = toUint8Array(uint11Array);
    if (uint8Array.length !== 33)
      throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
    if (uint8Array[uint8Array.length - 1] !== 0)
      throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
    uint8Array = uint8Array.slice(0, uint8Array.length - 1);
    const cs = computeChecksum(uint8Array);
    if (cs === checksum)
      return uint8Array;
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  }
  function mnemonicToSecretKey(mn) {
    const seed = seedFromMnemonic(mn);
    const keys = keyPairFromSeed(seed);
    const addr = new Address(keys.publicKey);
    return { addr, sk: keys.secretKey };
  }
  function secretKeyToMnemonic(sk) {
    const seed = sk.slice(0, SEED_BTYES_LENGTH);
    return mnemonicFromSeed(seed);
  }
  function mnemonicToMasterDerivationKey(mn) {
    return seedFromMnemonic(mn);
  }
  function masterDerivationKeyToMnemonic(mdk) {
    return mnemonicFromSeed(mdk);
  }
  var FAIL_TO_DECODE_MNEMONIC_ERROR_MSG, NOT_IN_WORDS_LIST_ERROR_MSG;
  var init_mnemonic = __esm({
    "node_modules/algosdk/dist/esm/mnemonic/mnemonic.js"() {
      init_polyfills();
      init_english();
      init_naclWrappers();
      init_address();
      FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = "failed to decode mnemonic";
      NOT_IN_WORDS_LIST_ERROR_MSG = "the mnemonic contains a word that is not in the wordlist";
    }
  });

  // node_modules/algosdk/dist/esm/group.js
  function txGroupPreimage(txnHashes) {
    if (txnHashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {
      throw new Error(`${txnHashes.length} transactions grouped together but max group size is ${ALGORAND_MAX_TX_GROUP_SIZE}`);
    }
    if (txnHashes.length === 0) {
      throw new Error("Cannot compute group ID of zero transactions");
    }
    const bytes = msgpackRawEncode({
      txlist: txnHashes
    });
    return concatArrays2(TX_GROUP_TAG, bytes);
  }
  function computeGroupID(txns) {
    const hashes = [];
    for (const txn of txns) {
      hashes.push(txn.rawTxID());
    }
    const toBeHashed = txGroupPreimage(hashes);
    const gid = genericHash(toBeHashed);
    return Uint8Array.from(gid);
  }
  function assignGroupID(txns) {
    const gid = computeGroupID(txns);
    for (const txn of txns) {
      txn.group = gid;
    }
    return txns;
  }
  var ALGORAND_MAX_TX_GROUP_SIZE, TX_GROUP_TAG;
  var init_group = __esm({
    "node_modules/algosdk/dist/esm/group.js"() {
      init_polyfills();
      init_naclWrappers();
      init_encoding3();
      init_utils();
      ALGORAND_MAX_TX_GROUP_SIZE = 16;
      TX_GROUP_TAG = new TextEncoder().encode("TG");
    }
  });

  // node_modules/algosdk/dist/esm/signing.js
  function signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {
    if (!lsig.verify(lsigAddress.publicKey)) {
      throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
    }
    let sgnr;
    if (!bytesEqual(lsigAddress.publicKey, txn.sender.publicKey)) {
      sgnr = lsigAddress;
    }
    const signedTxn = new SignedTransaction({
      lsig,
      txn,
      sgnr
    });
    return {
      txID: txn.txID(),
      blob: encodeMsgpack(signedTxn)
    };
  }
  function signLogicSigTransactionObject(txn, lsigObject) {
    let lsig;
    let lsigAddress;
    if (lsigObject instanceof LogicSigAccount) {
      lsig = lsigObject.lsig;
      lsigAddress = lsigObject.address();
    } else {
      lsig = lsigObject;
      if (lsig.sig) {
        lsigAddress = new Address(txn.sender.publicKey);
      } else if (lsig.msig) {
        const msigMetadata = {
          version: lsig.msig.v,
          threshold: lsig.msig.thr,
          pks: lsig.msig.subsig.map((subsig) => subsig.pk)
        };
        lsigAddress = addressFromMultisigPreImg(msigMetadata);
      } else {
        lsigAddress = lsig.address();
      }
    }
    return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);
  }
  function signLogicSigTransaction(txn, lsigObject) {
    return signLogicSigTransactionObject(txn, lsigObject);
  }
  var init_signing = __esm({
    "node_modules/algosdk/dist/esm/signing.js"() {
      init_polyfills();
      init_naclWrappers();
      init_address();
      init_encoding3();
      init_signedTransaction();
      init_logicsig();
      init_multisig();
    }
  });

  // node_modules/algosdk/dist/esm/multisigSigning.js
  function createMultisigTransaction(txn, { version, threshold, addrs }) {
    const pks = pksFromAddresses(addrs);
    const subsigs = pks.map((pk) => ({ pk }));
    const msig = {
      v: version,
      thr: threshold,
      subsig: subsigs
    };
    const msigAddr = addressFromMultisigPreImg({
      version,
      threshold,
      pks
    });
    let sgnr;
    if (!txn.sender.equals(msigAddr)) {
      sgnr = msigAddr;
    }
    const signedTxn = new SignedTransaction({
      txn,
      msig,
      sgnr
    });
    return encodeMsgpack(signedTxn);
  }
  function createMultisigTransactionWithSignature(txn, { rawSig, myPk }, { version, threshold, pks }) {
    const encodedMsig = createMultisigTransaction(txn, {
      version,
      threshold,
      addrs: pks.map((pk) => new Address(pk))
    });
    const signedTxn = decodeMsgpack(encodedMsig, SignedTransaction);
    let keyExist = false;
    signedTxn.msig.subsig.forEach((subsig, i2) => {
      if (bytesEqual(subsig.pk, myPk)) {
        keyExist = true;
        signedTxn.msig.subsig[i2].s = rawSig;
      }
    });
    if (!keyExist) {
      throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);
    }
    return encodeMsgpack(signedTxn);
  }
  function partialSignTxn(transaction, { version, threshold, pks }, sk) {
    const myPk = keyPairFromSecretKey(sk).publicKey;
    return createMultisigTransactionWithSignature(transaction, { rawSig: transaction.rawSignTxn(sk), myPk }, { version, threshold, pks });
  }
  function partialSignWithMultisigSignature(transaction, metadata, signerAddr, signature) {
    if (!isValidSignatureLength(signature.length)) {
      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);
    }
    const signerAddressObj = typeof signerAddr === "string" ? Address.fromString(signerAddr) : signerAddr;
    return createMultisigTransactionWithSignature(transaction, {
      rawSig: signature,
      myPk: signerAddressObj.publicKey
    }, metadata);
  }
  function mergeMultisigTransactions(multisigTxnBlobs) {
    if (multisigTxnBlobs.length < 2) {
      throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);
    }
    const refSigTx = decodeMsgpack(multisigTxnBlobs[0], SignedTransaction);
    if (!refSigTx.msig) {
      throw new Error("Invalid multisig transaction, multisig structure missing at index 0");
    }
    const refTxID = refSigTx.txn.txID();
    const refAuthAddr = refSigTx.sgnr ? refSigTx.sgnr.toString() : void 0;
    const refPreImage = {
      version: refSigTx.msig.v,
      threshold: refSigTx.msig.thr,
      pks: refSigTx.msig.subsig.map((subsig) => subsig.pk)
    };
    const refMsigAddr = addressFromMultisigPreImg(refPreImage);
    const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));
    for (let i2 = 1; i2 < multisigTxnBlobs.length; i2++) {
      const unisig = decodeMsgpack(multisigTxnBlobs[i2], SignedTransaction);
      if (!unisig.msig) {
        throw new Error(`Invalid multisig transaction, multisig structure missing at index ${i2}`);
      }
      if (unisig.txn.txID() !== refTxID) {
        throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);
      }
      const authAddr = unisig.sgnr ? unisig.sgnr.toString() : void 0;
      if (refAuthAddr !== authAddr) {
        throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);
      }
      if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {
        throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
      }
      const preimg = {
        version: unisig.msig.v,
        threshold: unisig.msig.thr,
        pks: unisig.msig.subsig.map((subsig) => subsig.pk)
      };
      const msgigAddr = addressFromMultisigPreImg(preimg);
      if (!refMsigAddr.equals(msgigAddr)) {
        throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
      }
      unisig.msig.subsig.forEach((uniSubsig, index) => {
        if (!uniSubsig.s)
          return;
        const current = newSubsigs[index];
        if (current.s && !arrayEqual(uniSubsig.s, current.s)) {
          throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);
        }
        current.s = uniSubsig.s;
      });
    }
    const msig = {
      v: refSigTx.msig.v,
      thr: refSigTx.msig.thr,
      subsig: newSubsigs
    };
    const refSgnr = typeof refAuthAddr !== "undefined" ? refSigTx.sgnr : void 0;
    const signedTxn = new SignedTransaction({
      msig,
      txn: refSigTx.txn,
      sgnr: refSgnr
    });
    return encodeMsgpack(signedTxn);
  }
  function signMultisigTransaction(txn, { version, threshold, addrs }, sk) {
    const pks = pksFromAddresses(addrs);
    const blob = partialSignTxn(txn, { version, threshold, pks }, sk);
    return {
      txID: txn.txID(),
      blob
    };
  }
  function appendSignMultisigTransaction(multisigTxnBlob, { version, threshold, addrs }, sk) {
    const pks = pksFromAddresses(addrs);
    const multisigTxObj = decodeMsgpack(multisigTxnBlob, SignedTransaction);
    const partialSignedBlob = partialSignTxn(multisigTxObj.txn, { version, threshold, pks }, sk);
    return {
      txID: multisigTxObj.txn.txID(),
      blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
    };
  }
  function appendSignRawMultisigSignature(multisigTxnBlob, { version, threshold, addrs }, signerAddr, signature) {
    const pks = pksFromAddresses(addrs);
    const multisigTxObj = decodeMsgpack(multisigTxnBlob, SignedTransaction);
    const partialSignedBlob = partialSignWithMultisigSignature(multisigTxObj.txn, { version, threshold, pks }, signerAddr, signature);
    return {
      txID: multisigTxObj.txn.txID(),
      blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
    };
  }
  var MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG, MULTISIG_MERGE_MISMATCH_ERROR_MSG, MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG, MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG, MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG, MULTISIG_SIGNATURE_LENGTH_ERROR_MSG, MULTISIG_KEY_NOT_EXIST_ERROR_MSG;
  var init_multisigSigning = __esm({
    "node_modules/algosdk/dist/esm/multisigSigning.js"() {
      init_polyfills();
      init_naclWrappers();
      init_address();
      init_encoding3();
      init_utils();
      init_signedTransaction();
      init_multisig();
      MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = "Not enough multisig transactions to merge. Need at least two";
      MULTISIG_MERGE_MISMATCH_ERROR_MSG = "Cannot merge txs. txIDs differ";
      MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = "Cannot merge txs. Auth addrs differ";
      MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = "Cannot merge txs. Multisig preimages differ";
      MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = "Cannot merge txs. subsigs are mismatched.";
      MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = "Cannot add multisig signature. Signature is not of the correct length.";
      MULTISIG_KEY_NOT_EXIST_ERROR_MSG = "Key does not exist";
    }
  });

  // node_modules/vlq/src/index.js
  function decode2(string) {
    let result = [];
    let shift = 0;
    let value = 0;
    for (let i2 = 0; i2 < string.length; i2 += 1) {
      let integer = char_to_integer[string[i2]];
      if (integer === void 0) {
        throw new Error("Invalid character (" + string[i2] + ")");
      }
      const has_continuation_bit = integer & 32;
      integer &= 31;
      value += integer << shift;
      if (has_continuation_bit) {
        shift += 5;
      } else {
        const should_negate = value & 1;
        value >>>= 1;
        if (should_negate) {
          result.push(value === 0 ? -2147483648 : -value);
        } else {
          result.push(value);
        }
        value = shift = 0;
      }
    }
    return result;
  }
  var char_to_integer, integer_to_char;
  var init_src = __esm({
    "node_modules/vlq/src/index.js"() {
      init_polyfills();
      char_to_integer = {};
      integer_to_char = {};
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(char, i2) {
        char_to_integer[char] = i2;
        integer_to_char[i2] = char;
      });
    }
  });

  // node_modules/algosdk/dist/esm/logic/sourcemap.js
  var ProgramSourceMap;
  var init_sourcemap = __esm({
    "node_modules/algosdk/dist/esm/logic/sourcemap.js"() {
      init_polyfills();
      init_src();
      ProgramSourceMap = class {
        constructor({ version, sources, names, mappings }) {
          this.version = version;
          this.sources = sources;
          this.names = names;
          this.mappings = mappings;
          if (this.version !== 3)
            throw new Error(`Only version 3 is supported, got ${this.version}`);
          if (this.mappings === void 0)
            throw new Error("mapping undefined, cannot build source map without `mapping`");
          const pcList = this.mappings.split(";").map(decode2);
          this.pcToLocation = /* @__PURE__ */ new Map();
          this.sourceAndLineToPc = /* @__PURE__ */ new Map();
          const lastLocation = {
            line: 0,
            column: 0,
            sourceIndex: 0,
            nameIndex: 0
          };
          for (const [pc, data] of pcList.entries()) {
            if (data.length < 4)
              continue;
            const nameDelta = data.length > 4 ? data[4] : void 0;
            const [, sourceDelta, lineDelta, columnDelta] = data;
            lastLocation.sourceIndex += sourceDelta;
            lastLocation.line += lineDelta;
            lastLocation.column += columnDelta;
            if (typeof nameDelta !== "undefined") {
              lastLocation.nameIndex += nameDelta;
            }
            const sourceAndLineKey = `${lastLocation.sourceIndex}:${lastLocation.line}`;
            let pcsForSourceAndLine = this.sourceAndLineToPc.get(sourceAndLineKey);
            if (pcsForSourceAndLine === void 0) {
              pcsForSourceAndLine = [];
              this.sourceAndLineToPc.set(sourceAndLineKey, pcsForSourceAndLine);
            }
            const pcInLine = {
              pc,
              column: lastLocation.column
            };
            const pcLocation = {
              line: lastLocation.line,
              column: lastLocation.column,
              sourceIndex: lastLocation.sourceIndex
            };
            if (typeof nameDelta !== "undefined") {
              pcInLine.nameIndex = lastLocation.nameIndex;
              pcLocation.nameIndex = lastLocation.nameIndex;
            }
            pcsForSourceAndLine.push(pcInLine);
            this.pcToLocation.set(pc, pcLocation);
          }
        }
        getPcs() {
          return Array.from(this.pcToLocation.keys());
        }
        getLocationForPc(pc) {
          return this.pcToLocation.get(pc);
        }
        getPcsOnSourceLine(sourceIndex, line) {
          const pcs = this.sourceAndLineToPc.get(`${sourceIndex}:${line}`);
          if (pcs === void 0)
            return [];
          return pcs;
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/dryrun.js
  async function createDryrun({ client, txns, protocolVersion, latestTimestamp, round, sources }) {
    const appInfos = [];
    const acctInfos = [];
    const apps = [];
    const assets = [];
    const accts = [];
    for (const t of txns) {
      if (t.txn.type === TransactionType.appl) {
        accts.push(t.txn.sender.toString());
        accts.push(...t.txn.applicationCall.accounts.map((a2) => a2.toString()));
        apps.push(...t.txn.applicationCall.foreignApps);
        accts.push(...t.txn.applicationCall.foreignApps.map(getApplicationAddress).map((a2) => a2.toString()));
        assets.push(...t.txn.applicationCall.foreignAssets);
        if (t.txn.applicationCall.appIndex === BigInt(0)) {
          appInfos.push(new Application({
            id: defaultAppId,
            params: new ApplicationParams({
              creator: t.txn.sender.toString(),
              approvalProgram: t.txn.applicationCall.approvalProgram,
              clearStateProgram: t.txn.applicationCall.clearProgram,
              localStateSchema: new ApplicationStateSchema({
                numUint: t.txn.applicationCall.numLocalInts,
                numByteSlice: t.txn.applicationCall.numLocalByteSlices
              }),
              globalStateSchema: new ApplicationStateSchema({
                numUint: t.txn.applicationCall.numGlobalInts,
                numByteSlice: t.txn.applicationCall.numGlobalByteSlices
              })
            })
          }));
        } else {
          const { appIndex } = t.txn.applicationCall;
          apps.push(appIndex);
          accts.push(getApplicationAddress(appIndex).toString());
        }
      }
    }
    const assetPromises = [];
    for (const assetId of new Set(assets)) {
      assetPromises.push(client.getAssetByID(assetId).do().then((assetInfo) => {
        accts.push(assetInfo.params.creator);
      }));
    }
    await Promise.all(assetPromises);
    const appPromises = [];
    for (const appId of new Set(apps)) {
      appPromises.push(client.getApplicationByID(appId).do().then((appInfo) => {
        appInfos.push(appInfo);
        accts.push(appInfo.params.creator.toString());
      }));
    }
    await Promise.all(appPromises);
    const acctPromises = [];
    for (const acct of new Set(accts)) {
      acctPromises.push(client.accountInformation(acct).do().then((acctInfo) => {
        acctInfos.push(acctInfo);
      }));
    }
    await Promise.all(acctPromises);
    return new DryrunRequest({
      txns: txns.slice(),
      accounts: acctInfos,
      apps: appInfos,
      latestTimestamp: latestTimestamp ?? 0,
      round: round ?? 0,
      protocolVersion: protocolVersion ?? "",
      sources: sources ?? []
    });
  }
  function truncate(str, maxValueWidth) {
    if (str.length > maxValueWidth && maxValueWidth > 0) {
      return `${str.slice(0, maxValueWidth)}...`;
    }
    return str;
  }
  function scratchToString(prevScratch, currScratch) {
    if (currScratch.length === 0)
      return "";
    let newScratchIdx = null;
    for (let idx = 0; idx < currScratch.length; idx++) {
      if (idx > prevScratch.length) {
        newScratchIdx = idx;
        continue;
      }
      if (stringifyJSON(prevScratch[idx]) !== stringifyJSON(currScratch[idx])) {
        newScratchIdx = idx;
      }
    }
    if (newScratchIdx == null)
      return "";
    const newScratch = currScratch[newScratchIdx];
    if (newScratch.bytes.length > 0) {
      return `${newScratchIdx} = 0x${bytesToHex(newScratch.bytes)}`;
    }
    return `${newScratchIdx} = ${newScratch.uint.toString()}`;
  }
  function stackToString(stack, reverse) {
    const svs = reverse ? stack.reverse() : stack;
    return `[${svs.map((sv) => {
      switch (sv.type) {
        case 1:
          return `0x${bytesToHex(sv.bytes)}`;
        case 2:
          return sv.uint.toString();
        default:
          return "";
      }
    }).join(", ")}]`;
  }
  function dryrunTrace(trace, disassembly, spc) {
    const maxWidth = spc.maxValueWidth || defaultMaxWidth;
    const lines = [["pc#", "ln#", "source", "scratch", "stack"]];
    for (let idx = 0; idx < trace.length; idx++) {
      const { line, error, pc, scratch, stack } = trace[idx];
      const currScratch = scratch !== void 0 ? scratch : [];
      const prevScratch = idx > 0 && trace[idx - 1].scratch !== void 0 ? trace[idx - 1].scratch : [];
      const src = !error ? disassembly[line] : `!! ${error} !!`;
      lines.push([
        pc.toString().padEnd(3, " "),
        line.toString().padEnd(3, " "),
        truncate(src, maxWidth),
        truncate(scratchToString(prevScratch, currScratch), maxWidth),
        truncate(stackToString(stack, spc.topOfStackFirst), maxWidth)
      ]);
    }
    const maxLengths = lines.reduce((prev, curr) => {
      const newVal = new Array(lines[0].length).fill(0);
      for (let idx = 0; idx < prev.length; idx++) {
        newVal[idx] = curr[idx].length > prev[idx] ? curr[idx].length : prev[idx];
      }
      return newVal;
    }, new Array(lines[0].length).fill(0));
    return `${lines.map((line) => line.map((v3, idx) => v3.padEnd(maxLengths[idx] + 1, " ")).join("|").trim()).join("\n")}
`;
  }
  function dryrunTxnResultAppTrace(result, spc) {
    if (!result.appCallTrace || !result.disassembly)
      return "";
    let conf = spc;
    if (spc !== void 0)
      conf = spc;
    else {
      conf = {
        maxValueWidth: defaultMaxWidth,
        topOfStackFirst: false
      };
    }
    return dryrunTrace(result.appCallTrace, result.disassembly, conf);
  }
  function dryrunTxnResultLogicSigTrace(result, spc) {
    if (!result.logicSigTrace || !result.logicSigDisassembly)
      return "";
    let conf;
    if (spc !== void 0)
      conf = spc;
    else {
      conf = {
        maxValueWidth: defaultMaxWidth,
        topOfStackFirst: true
      };
    }
    return dryrunTrace(result.logicSigTrace, result.logicSigDisassembly, conf);
  }
  var defaultAppId, defaultMaxWidth;
  var init_dryrun2 = __esm({
    "node_modules/algosdk/dist/esm/dryrun.js"() {
      init_polyfills();
      init_types3();
      init_address();
      init_binarydata();
      init_transactions();
      init_utils();
      defaultAppId = 1380011588;
      defaultMaxWidth = 30;
    }
  });

  // node_modules/algosdk/dist/esm/makeTxn.js
  function makePaymentTxnWithSuggestedParamsFromObject({ sender, receiver, amount, closeRemainderTo, suggestedParams, note, lease, rekeyTo }) {
    return new Transaction({
      type: TransactionType.pay,
      sender,
      note,
      lease,
      rekeyTo,
      suggestedParams,
      paymentParams: {
        receiver,
        amount,
        closeRemainderTo
      }
    });
  }
  function makeKeyRegistrationTxnWithSuggestedParamsFromObject({ sender, voteKey, selectionKey, stateProofKey, voteFirst, voteLast, voteKeyDilution, nonParticipation, suggestedParams, note, lease, rekeyTo }) {
    return new Transaction({
      type: TransactionType.keyreg,
      sender,
      note,
      lease,
      rekeyTo,
      suggestedParams,
      keyregParams: {
        voteKey,
        selectionKey,
        stateProofKey,
        voteFirst,
        voteLast,
        voteKeyDilution,
        nonParticipation
      }
    });
  }
  function makeBaseAssetConfigTxn({ sender, assetIndex, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, note, lease, rekeyTo, suggestedParams }) {
    return new Transaction({
      type: TransactionType.acfg,
      sender,
      note,
      lease,
      rekeyTo,
      suggestedParams,
      assetConfigParams: {
        assetIndex,
        total,
        decimals,
        defaultFrozen,
        manager,
        reserve,
        freeze,
        clawback,
        unitName,
        assetName,
        assetURL,
        assetMetadataHash
      }
    });
  }
  function makeAssetCreateTxnWithSuggestedParamsFromObject({ sender, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, note, lease, rekeyTo, suggestedParams }) {
    return makeBaseAssetConfigTxn({
      sender,
      total,
      decimals,
      defaultFrozen,
      manager,
      reserve,
      freeze,
      clawback,
      unitName,
      assetName,
      assetURL,
      assetMetadataHash,
      note,
      lease,
      rekeyTo,
      suggestedParams
    });
  }
  function makeAssetConfigTxnWithSuggestedParamsFromObject({ sender, assetIndex, manager, reserve, freeze, clawback, strictEmptyAddressChecking, note, lease, rekeyTo, suggestedParams }) {
    if (!assetIndex) {
      throw Error("assetIndex must be provided");
    }
    const strictChecking = strictEmptyAddressChecking ?? true;
    if (strictChecking && (manager == null || reserve == null || freeze == null || clawback == null)) {
      throw Error("strictEmptyAddressChecking is enabled, but an address is empty. If this is intentional, set strictEmptyAddressChecking to false.");
    }
    return makeBaseAssetConfigTxn({
      sender,
      assetIndex,
      manager,
      reserve,
      freeze,
      clawback,
      note,
      lease,
      rekeyTo,
      suggestedParams
    });
  }
  function makeAssetDestroyTxnWithSuggestedParamsFromObject({ sender, assetIndex, note, lease, rekeyTo, suggestedParams }) {
    if (!assetIndex) {
      throw Error("assetIndex must be provided");
    }
    return makeBaseAssetConfigTxn({
      sender,
      assetIndex,
      note,
      lease,
      rekeyTo,
      suggestedParams
    });
  }
  function makeAssetFreezeTxnWithSuggestedParamsFromObject({ sender, assetIndex, freezeTarget, frozen, suggestedParams, note, lease, rekeyTo }) {
    return new Transaction({
      type: TransactionType.afrz,
      sender,
      note,
      lease,
      rekeyTo,
      suggestedParams,
      assetFreezeParams: {
        assetIndex,
        freezeTarget,
        frozen
      }
    });
  }
  function makeAssetTransferTxnWithSuggestedParamsFromObject({ sender, receiver, amount, closeRemainderTo, assetSender, note, assetIndex, suggestedParams, rekeyTo, lease }) {
    if (!assetIndex) {
      throw Error("assetIndex must be provided");
    }
    return new Transaction({
      type: TransactionType.axfer,
      sender,
      note,
      lease,
      rekeyTo,
      suggestedParams,
      assetTransferParams: {
        assetIndex,
        receiver,
        amount,
        assetSender,
        closeRemainderTo
      }
    });
  }
  function makeApplicationCallTxnFromObject({ sender, appIndex, onComplete, appArgs, accounts, foreignApps, foreignAssets, boxes, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, extraPages, note, lease, rekeyTo, suggestedParams }) {
    if (onComplete == null) {
      throw Error("onComplete must be provided");
    }
    return new Transaction({
      type: TransactionType.appl,
      sender,
      note,
      lease,
      rekeyTo,
      suggestedParams,
      appCallParams: {
        appIndex,
        onComplete,
        appArgs,
        accounts,
        foreignAssets,
        foreignApps,
        boxes,
        approvalProgram,
        clearProgram,
        numLocalInts,
        numLocalByteSlices,
        numGlobalInts,
        numGlobalByteSlices,
        extraPages
      }
    });
  }
  function makeApplicationCreateTxnFromObject({ sender, onComplete, appArgs, accounts, foreignApps, foreignAssets, boxes, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, extraPages, note, lease, rekeyTo, suggestedParams }) {
    if (!approvalProgram || !clearProgram) {
      throw Error("approvalProgram and clearProgram must be provided");
    }
    if (onComplete == null) {
      throw Error("onComplete must be provided");
    }
    return makeApplicationCallTxnFromObject({
      sender,
      appIndex: 0,
      onComplete,
      appArgs,
      accounts,
      foreignApps,
      foreignAssets,
      boxes,
      approvalProgram,
      clearProgram,
      numLocalInts,
      numLocalByteSlices,
      numGlobalInts,
      numGlobalByteSlices,
      extraPages,
      note,
      lease,
      rekeyTo,
      suggestedParams
    });
  }
  function makeApplicationUpdateTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, approvalProgram, clearProgram, note, lease, rekeyTo, suggestedParams }) {
    if (!appIndex) {
      throw Error("appIndex must be provided");
    }
    if (!approvalProgram || !clearProgram) {
      throw Error("approvalProgram and clearProgram must be provided");
    }
    return makeApplicationCallTxnFromObject({
      sender,
      appIndex,
      onComplete: OnApplicationComplete.UpdateApplicationOC,
      appArgs,
      accounts,
      foreignApps,
      foreignAssets,
      boxes,
      approvalProgram,
      clearProgram,
      note,
      lease,
      rekeyTo,
      suggestedParams
    });
  }
  function makeApplicationDeleteTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, note, lease, rekeyTo, suggestedParams }) {
    if (!appIndex) {
      throw Error("appIndex must be provided");
    }
    return makeApplicationCallTxnFromObject({
      sender,
      appIndex,
      onComplete: OnApplicationComplete.DeleteApplicationOC,
      appArgs,
      accounts,
      foreignApps,
      foreignAssets,
      boxes,
      note,
      lease,
      rekeyTo,
      suggestedParams
    });
  }
  function makeApplicationOptInTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, note, lease, rekeyTo, suggestedParams }) {
    if (!appIndex) {
      throw Error("appIndex must be provided");
    }
    return makeApplicationCallTxnFromObject({
      sender,
      appIndex,
      onComplete: OnApplicationComplete.OptInOC,
      appArgs,
      accounts,
      foreignApps,
      foreignAssets,
      boxes,
      note,
      lease,
      rekeyTo,
      suggestedParams
    });
  }
  function makeApplicationCloseOutTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, note, lease, rekeyTo, suggestedParams }) {
    if (!appIndex) {
      throw Error("appIndex must be provided");
    }
    return makeApplicationCallTxnFromObject({
      sender,
      appIndex,
      onComplete: OnApplicationComplete.CloseOutOC,
      appArgs,
      accounts,
      foreignApps,
      foreignAssets,
      boxes,
      note,
      lease,
      rekeyTo,
      suggestedParams
    });
  }
  function makeApplicationClearStateTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, note, lease, rekeyTo, suggestedParams }) {
    if (!appIndex) {
      throw Error("appIndex must be provided");
    }
    return makeApplicationCallTxnFromObject({
      sender,
      appIndex,
      onComplete: OnApplicationComplete.ClearStateOC,
      appArgs,
      accounts,
      foreignApps,
      foreignAssets,
      boxes,
      note,
      lease,
      rekeyTo,
      suggestedParams
    });
  }
  function makeApplicationNoOpTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, note, lease, rekeyTo, suggestedParams }) {
    if (!appIndex) {
      throw Error("appIndex must be provided");
    }
    return makeApplicationCallTxnFromObject({
      sender,
      appIndex,
      onComplete: OnApplicationComplete.NoOpOC,
      appArgs,
      accounts,
      foreignApps,
      foreignAssets,
      boxes,
      note,
      lease,
      rekeyTo,
      suggestedParams
    });
  }
  var init_makeTxn = __esm({
    "node_modules/algosdk/dist/esm/makeTxn.js"() {
      init_polyfills();
      init_transaction();
      init_base();
    }
  });

  // node_modules/algosdk/dist/esm/signer.js
  function makeBasicAccountTransactionSigner(account) {
    return (txnGroup, indexesToSign) => {
      const signed = [];
      for (const index of indexesToSign) {
        signed.push(txnGroup[index].signTxn(account.sk));
      }
      return Promise.resolve(signed);
    };
  }
  function makeLogicSigAccountTransactionSigner(account) {
    return (txnGroup, indexesToSign) => {
      const signed = [];
      for (const index of indexesToSign) {
        const { blob } = signLogicSigTransactionObject(txnGroup[index], account);
        signed.push(blob);
      }
      return Promise.resolve(signed);
    };
  }
  function makeMultiSigAccountTransactionSigner(msig, sks) {
    return (txnGroup, indexesToSign) => {
      const signed = [];
      for (const index of indexesToSign) {
        const txn = txnGroup[index];
        const partialSigs = [];
        for (const sk of sks) {
          const { blob } = signMultisigTransaction(txn, msig, sk);
          partialSigs.push(blob);
        }
        if (partialSigs.length > 1) {
          signed.push(mergeMultisigTransactions(partialSigs));
        } else {
          signed.push(partialSigs[0]);
        }
      }
      return Promise.resolve(signed);
    };
  }
  function makeEmptyTransactionSigner() {
    return (txnGroup, indexesToSign) => {
      const unsigned = [];
      for (const index of indexesToSign) {
        unsigned.push(encodeUnsignedSimulateTransaction(txnGroup[index]));
      }
      return Promise.resolve(unsigned);
    };
  }
  function isTransactionWithSigner(value) {
    return typeof value === "object" && Object.keys(value).length === 2 && typeof value.txn === "object" && typeof value.signer === "function";
  }
  var init_signer = __esm({
    "node_modules/algosdk/dist/esm/signer.js"() {
      init_polyfills();
      init_signedTransaction();
      init_signing();
      init_multisigSigning();
    }
  });

  // node_modules/algosdk/dist/esm/abi/abi_type.js
  function compressMultipleBool(valueList) {
    let res = 0;
    if (valueList.length > 8) {
      throw new Error("value list passed in should be no greater than length 8");
    }
    for (let i2 = 0; i2 < valueList.length; i2++) {
      const boolVal = valueList[i2];
      if (typeof boolVal !== "boolean") {
        throw new Error("non-boolean values cannot be compressed into a byte");
      }
      if (boolVal) {
        res |= 1 << 7 - i2;
      }
    }
    return res;
  }
  function findBoolLR(typeList, index, delta) {
    let until = 0;
    while (true) {
      const curr = index + delta * until;
      if (typeList[curr].constructor === ABIBoolType) {
        if (curr !== typeList.length - 1 && delta === 1) {
          until += 1;
        } else if (curr > 0 && delta === -1) {
          until += 1;
        } else {
          break;
        }
      } else {
        until -= 1;
        break;
      }
    }
    return until;
  }
  var MAX_LEN, ADDR_BYTE_SIZE, SINGLE_BYTE_SIZE, SINGLE_BOOL_SIZE, LENGTH_ENCODE_BYTE_SIZE, staticArrayRegexp, ufixedRegexp, ABIType, ABIUintType, ABIUfixedType, ABIAddressType, ABIBoolType, ABIByteType, ABIStringType, ABIArrayStaticType, ABIArrayDynamicType, ABITupleType;
  var init_abi_type = __esm({
    "node_modules/algosdk/dist/esm/abi/abi_type.js"() {
      init_polyfills();
      init_address();
      init_bigint();
      init_utils();
      MAX_LEN = 2 ** 16 - 1;
      ADDR_BYTE_SIZE = 32;
      SINGLE_BYTE_SIZE = 1;
      SINGLE_BOOL_SIZE = 1;
      LENGTH_ENCODE_BYTE_SIZE = 2;
      staticArrayRegexp = /^([a-z\d[\](),]+)\[(0|[1-9][\d]*)]$/;
      ufixedRegexp = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/;
      ABIType = class _ABIType {
        // De-serializes the ABI type from a string using the ABI specs
        static from(str) {
          if (str.endsWith("[]")) {
            const arrayArgType = _ABIType.from(str.slice(0, str.length - 2));
            return new ABIArrayDynamicType(arrayArgType);
          }
          if (str.endsWith("]")) {
            const stringMatches = str.match(staticArrayRegexp);
            if (!stringMatches || stringMatches.length !== 3) {
              throw new Error(`malformed static array string: ${str}`);
            }
            const arrayLengthStr = stringMatches[2];
            const arrayLength = parseInt(arrayLengthStr, 10);
            if (arrayLength > MAX_LEN) {
              throw new Error(`array length exceeds limit ${MAX_LEN}`);
            }
            const arrayType = _ABIType.from(stringMatches[1]);
            return new ABIArrayStaticType(arrayType, arrayLength);
          }
          if (str.startsWith("uint")) {
            const digitsOnly = (s2) => [...s2].every((c2) => "0123456789".includes(c2));
            const typeSizeStr = str.slice(4, str.length);
            if (!digitsOnly(typeSizeStr)) {
              throw new Error(`malformed uint string: ${typeSizeStr}`);
            }
            const typeSize = parseInt(typeSizeStr, 10);
            if (typeSize > MAX_LEN) {
              throw new Error(`malformed uint string: ${typeSize}`);
            }
            return new ABIUintType(typeSize);
          }
          if (str === "byte") {
            return new ABIByteType();
          }
          if (str.startsWith("ufixed")) {
            const stringMatches = str.match(ufixedRegexp);
            if (!stringMatches || stringMatches.length !== 3) {
              throw new Error(`malformed ufixed type: ${str}`);
            }
            const ufixedSize = parseInt(stringMatches[1], 10);
            const ufixedPrecision = parseInt(stringMatches[2], 10);
            return new ABIUfixedType(ufixedSize, ufixedPrecision);
          }
          if (str === "bool") {
            return new ABIBoolType();
          }
          if (str === "address") {
            return new ABIAddressType();
          }
          if (str === "string") {
            return new ABIStringType();
          }
          if (str.length >= 2 && str[0] === "(" && str[str.length - 1] === ")") {
            const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));
            const tupleTypes = [];
            for (let i2 = 0; i2 < tupleContent.length; i2++) {
              const ti = _ABIType.from(tupleContent[i2]);
              tupleTypes.push(ti);
            }
            return new ABITupleType(tupleTypes);
          }
          throw new Error(`cannot convert a string ${str} to an ABI type`);
        }
      };
      ABIUintType = class _ABIUintType extends ABIType {
        constructor(size) {
          super();
          if (size % 8 !== 0 || size < 8 || size > 512) {
            throw new Error(`unsupported uint type bitSize: ${size}`);
          }
          this.bitSize = size;
        }
        toString() {
          return `uint${this.bitSize}`;
        }
        equals(other) {
          return other instanceof _ABIUintType && this.bitSize === other.bitSize;
        }
        isDynamic() {
          return false;
        }
        byteLen() {
          return this.bitSize / 8;
        }
        encode(value) {
          if (typeof value !== "bigint" && typeof value !== "number") {
            throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);
          }
          if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
            throw new Error(`${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
          }
          if (typeof value === "number" && !Number.isSafeInteger(value)) {
            throw new Error(`${value} should be converted into a BigInt before it is encoded`);
          }
          return bigIntToBytes(value, this.bitSize / 8);
        }
        decode(byteString) {
          if (byteString.length !== this.bitSize / 8) {
            throw new Error(`byte string must correspond to a uint${this.bitSize}`);
          }
          return bytesToBigInt(byteString);
        }
      };
      ABIUfixedType = class _ABIUfixedType extends ABIType {
        constructor(size, denominator) {
          super();
          if (size % 8 !== 0 || size < 8 || size > 512) {
            throw new Error(`unsupported ufixed type bitSize: ${size}`);
          }
          if (denominator > 160 || denominator < 1) {
            throw new Error(`unsupported ufixed type precision: ${denominator}`);
          }
          this.bitSize = size;
          this.precision = denominator;
        }
        toString() {
          return `ufixed${this.bitSize}x${this.precision}`;
        }
        equals(other) {
          return other instanceof _ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;
        }
        isDynamic() {
          return false;
        }
        byteLen() {
          return this.bitSize / 8;
        }
        encode(value) {
          if (typeof value !== "bigint" && typeof value !== "number") {
            throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
          }
          if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
            throw new Error(`${value} is not a non-negative int or too big to fit in size ${this.toString()}`);
          }
          if (typeof value === "number" && !Number.isSafeInteger(value)) {
            throw new Error(`${value} should be converted into a BigInt before it is encoded`);
          }
          return bigIntToBytes(value, this.bitSize / 8);
        }
        decode(byteString) {
          if (byteString.length !== this.bitSize / 8) {
            throw new Error(`byte string must correspond to a ${this.toString()}`);
          }
          return bytesToBigInt(byteString);
        }
      };
      ABIAddressType = class _ABIAddressType extends ABIType {
        toString() {
          return "address";
        }
        equals(other) {
          return other instanceof _ABIAddressType;
        }
        isDynamic() {
          return false;
        }
        byteLen() {
          return ADDR_BYTE_SIZE;
        }
        encode(value) {
          if (typeof value === "string") {
            const decodedAddress = decodeAddress(value);
            return decodedAddress.publicKey;
          }
          if (value instanceof Address) {
            return value.publicKey;
          }
          if (value instanceof Uint8Array) {
            if (value.byteLength !== 32) {
              throw new Error(`byte string must be 32 bytes long for an address`);
            }
            return value;
          }
          throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
        }
        decode(byteString) {
          if (byteString.byteLength !== 32) {
            throw new Error(`byte string must be 32 bytes long for an address`);
          }
          return encodeAddress(byteString);
        }
      };
      ABIBoolType = class _ABIBoolType extends ABIType {
        toString() {
          return "bool";
        }
        equals(other) {
          return other instanceof _ABIBoolType;
        }
        isDynamic() {
          return false;
        }
        byteLen() {
          return SINGLE_BOOL_SIZE;
        }
        encode(value) {
          if (typeof value !== "boolean") {
            throw new Error(`Cannot encode value as bool: ${value}`);
          }
          if (value) {
            return new Uint8Array([128]);
          }
          return new Uint8Array([0]);
        }
        decode(byteString) {
          if (byteString.byteLength !== 1) {
            throw new Error(`bool string must be 1 byte long`);
          }
          const value = byteString[0];
          if (value === 128) {
            return true;
          }
          if (value === 0) {
            return false;
          }
          throw new Error(`boolean could not be decoded from the byte string`);
        }
      };
      ABIByteType = class _ABIByteType extends ABIType {
        toString() {
          return "byte";
        }
        equals(other) {
          return other instanceof _ABIByteType;
        }
        isDynamic() {
          return false;
        }
        byteLen() {
          return SINGLE_BYTE_SIZE;
        }
        encode(value) {
          if (typeof value !== "number" && typeof value !== "bigint") {
            throw new Error(`Cannot encode value as byte: ${value}`);
          }
          if (typeof value === "bigint") {
            value = Number(value);
          }
          if (value < 0 || value > 255) {
            throw new Error(`${value} cannot be encoded into a byte`);
          }
          return new Uint8Array([value]);
        }
        decode(byteString) {
          if (byteString.byteLength !== 1) {
            throw new Error(`byte string must be 1 byte long`);
          }
          return byteString[0];
        }
      };
      ABIStringType = class _ABIStringType extends ABIType {
        toString() {
          return "string";
        }
        equals(other) {
          return other instanceof _ABIStringType;
        }
        isDynamic() {
          return true;
        }
        byteLen() {
          throw new Error(`${this.toString()} is a dynamic type`);
        }
        encode(value) {
          if (typeof value !== "string" && !(value instanceof Uint8Array)) {
            throw new Error(`Cannot encode value as string: ${value}`);
          }
          let encodedBytes;
          if (typeof value === "string") {
            encodedBytes = new TextEncoder().encode(value);
          } else {
            encodedBytes = value;
          }
          const encodedLength = bigIntToBytes(encodedBytes.length, LENGTH_ENCODE_BYTE_SIZE);
          const mergedBytes = new Uint8Array(encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE);
          mergedBytes.set(encodedLength);
          mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);
          return mergedBytes;
        }
        decode(byteString) {
          if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {
            throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`);
          }
          const view = new DataView(byteString.buffer, byteString.byteOffset, LENGTH_ENCODE_BYTE_SIZE);
          const byteLength = view.getUint16(0);
          const byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);
          if (byteLength !== byteValue.length) {
            throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`);
          }
          return new TextDecoder("utf-8").decode(byteValue);
        }
      };
      ABIArrayStaticType = class _ABIArrayStaticType extends ABIType {
        constructor(argType, arrayLength) {
          super();
          if (arrayLength < 0) {
            throw new Error(`static array must have a non negative length: ${arrayLength}`);
          }
          this.childType = argType;
          this.staticLength = arrayLength;
        }
        toString() {
          return `${this.childType.toString()}[${this.staticLength}]`;
        }
        equals(other) {
          return other instanceof _ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);
        }
        isDynamic() {
          return this.childType.isDynamic();
        }
        byteLen() {
          if (this.childType.constructor === ABIBoolType) {
            return Math.ceil(this.staticLength / 8);
          }
          return this.staticLength * this.childType.byteLen();
        }
        encode(value) {
          if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
            throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
          }
          if (value.length !== this.staticLength) {
            throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`);
          }
          const convertedTuple = this.toABITupleType();
          return convertedTuple.encode(value);
        }
        decode(byteString) {
          const convertedTuple = this.toABITupleType();
          return convertedTuple.decode(byteString);
        }
        toABITupleType() {
          return new ABITupleType(Array(this.staticLength).fill(this.childType));
        }
      };
      ABIArrayDynamicType = class _ABIArrayDynamicType extends ABIType {
        constructor(argType) {
          super();
          this.childType = argType;
        }
        toString() {
          return `${this.childType.toString()}[]`;
        }
        equals(other) {
          return other instanceof _ABIArrayDynamicType && this.childType.equals(other.childType);
        }
        isDynamic() {
          return true;
        }
        byteLen() {
          throw new Error(`${this.toString()} is a dynamic type`);
        }
        encode(value) {
          if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
            throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
          }
          const convertedTuple = this.toABITupleType(value.length);
          const encodedTuple = convertedTuple.encode(value);
          const encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);
          const mergedBytes = concatArrays2(encodedLength, encodedTuple);
          return mergedBytes;
        }
        decode(byteString) {
          const view = new DataView(byteString.buffer, 0, LENGTH_ENCODE_BYTE_SIZE);
          const byteLength = view.getUint16(0);
          const convertedTuple = this.toABITupleType(byteLength);
          return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));
        }
        toABITupleType(length) {
          return new ABITupleType(Array(length).fill(this.childType));
        }
      };
      ABITupleType = class _ABITupleType extends ABIType {
        constructor(argTypes) {
          super();
          if (argTypes.length >= MAX_LEN) {
            throw new Error("tuple type child type number larger than maximum uint16 error");
          }
          this.childTypes = argTypes;
        }
        toString() {
          const typeStrings = [];
          for (let i2 = 0; i2 < this.childTypes.length; i2++) {
            typeStrings[i2] = this.childTypes[i2].toString();
          }
          return `(${typeStrings.join(",")})`;
        }
        equals(other) {
          return other instanceof _ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index) => child.equals(other.childTypes[index]));
        }
        isDynamic() {
          const isDynamic = (child) => child.isDynamic();
          return this.childTypes.some(isDynamic);
        }
        byteLen() {
          let size = 0;
          for (let i2 = 0; i2 < this.childTypes.length; i2++) {
            if (this.childTypes[i2].constructor === ABIBoolType) {
              const after = findBoolLR(this.childTypes, i2, 1);
              const boolNum = after + 1;
              i2 += after;
              size += Math.trunc((boolNum + 7) / 8);
            } else {
              const childByteSize = this.childTypes[i2].byteLen();
              size += childByteSize;
            }
          }
          return size;
        }
        encode(value) {
          if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
            throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
          }
          const values = Array.from(value);
          if (value.length > MAX_LEN) {
            throw new Error("length of tuple array should not exceed a uint16");
          }
          const tupleTypes = this.childTypes;
          const heads = [];
          const tails = [];
          const isDynamicIndex = /* @__PURE__ */ new Map();
          let i2 = 0;
          while (i2 < tupleTypes.length) {
            const tupleType = tupleTypes[i2];
            if (tupleType.isDynamic()) {
              isDynamicIndex.set(heads.length, true);
              heads.push(new Uint8Array([0, 0]));
              tails.push(tupleType.encode(values[i2]));
            } else {
              if (tupleType.constructor === ABIBoolType) {
                const before = findBoolLR(tupleTypes, i2, -1);
                let after = findBoolLR(tupleTypes, i2, 1);
                if (before % 8 !== 0) {
                  throw new Error("expected before index should have number of bool mod 8 equal 0");
                }
                after = Math.min(7, after);
                const compressedInt = compressMultipleBool(values.slice(i2, i2 + after + 1));
                heads.push(bigIntToBytes(compressedInt, 1));
                i2 += after;
              } else {
                const encodedTupleValue = tupleType.encode(values[i2]);
                heads.push(encodedTupleValue);
              }
              isDynamicIndex.set(i2, false);
              tails.push(new Uint8Array());
            }
            i2 += 1;
          }
          let headLength = 0;
          for (const headElement of heads) {
            headLength += headElement.length;
          }
          let tailLength = 0;
          for (let j3 = 0; j3 < heads.length; j3++) {
            if (isDynamicIndex.get(j3)) {
              const headValue = headLength + tailLength;
              if (headValue > MAX_LEN) {
                throw new Error(`byte length of ${headValue} should not exceed a uint16`);
              }
              heads[j3] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);
            }
            tailLength += tails[j3].length;
          }
          return concatArrays2(...heads, ...tails);
        }
        decode(byteString) {
          const tupleTypes = this.childTypes;
          const dynamicSegments = [];
          const valuePartition = [];
          let i2 = 0;
          let iterIndex = 0;
          const view = new DataView(byteString.buffer);
          while (i2 < tupleTypes.length) {
            const tupleType = tupleTypes[i2];
            if (tupleType.isDynamic()) {
              if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {
                throw new Error("dynamic type in tuple is too short to be decoded");
              }
              const dynamicIndex = view.getUint16(iterIndex);
              if (dynamicSegments.length > 0) {
                dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;
                if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {
                  throw new Error("dynamic index segment miscalculation: left is greater than right index");
                }
              }
              const seg = {
                left: dynamicIndex,
                right: -1
              };
              dynamicSegments.push(seg);
              valuePartition.push(null);
              iterIndex += LENGTH_ENCODE_BYTE_SIZE;
            } else {
              if (tupleType.constructor === ABIBoolType) {
                const before = findBoolLR(this.childTypes, i2, -1);
                let after = findBoolLR(this.childTypes, i2, 1);
                if (before % 8 !== 0) {
                  throw new Error("expected before bool number mod 8 === 0");
                }
                after = Math.min(7, after);
                for (let boolIndex = 0; boolIndex <= after; boolIndex++) {
                  const boolMask = 128 >> boolIndex;
                  if ((byteString[iterIndex] & boolMask) > 0) {
                    valuePartition.push(new Uint8Array([128]));
                  } else {
                    valuePartition.push(new Uint8Array([0]));
                  }
                }
                i2 += after;
                iterIndex += 1;
              } else {
                const currLen = tupleType.byteLen();
                valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));
                iterIndex += currLen;
              }
            }
            if (i2 !== tupleTypes.length - 1 && iterIndex >= byteString.length) {
              throw new Error("input byte not enough to decode");
            }
            i2 += 1;
          }
          if (dynamicSegments.length > 0) {
            dynamicSegments[dynamicSegments.length - 1].right = byteString.length;
            iterIndex = byteString.length;
          }
          if (iterIndex < byteString.length) {
            throw new Error("input byte not fully consumed");
          }
          for (let j3 = 0; j3 < dynamicSegments.length; j3++) {
            const seg = dynamicSegments[j3];
            if (seg.left > seg.right) {
              throw new Error("dynamic segment should display a [l, r] space with l <= r");
            }
            if (j3 !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j3 + 1].left) {
              throw new Error("dynamic segment should be consecutive");
            }
          }
          let segIndex = 0;
          for (let j3 = 0; j3 < tupleTypes.length; j3++) {
            if (tupleTypes[j3].isDynamic()) {
              valuePartition[j3] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);
              segIndex += 1;
            }
          }
          const returnValues = [];
          for (let j3 = 0; j3 < tupleTypes.length; j3++) {
            const valueTi = tupleTypes[j3].decode(valuePartition[j3]);
            returnValues.push(valueTi);
          }
          return returnValues;
        }
        static parseTupleContent(str) {
          if (str.length === 0) {
            return [];
          }
          if (str.endsWith(",") || str.startsWith(",")) {
            throw new Error("tuple string should not start with comma");
          }
          if (str.includes(",,")) {
            throw new Error("tuple string should not have consecutive commas");
          }
          const tupleStrings = [];
          let depth = 0;
          let word = "";
          for (const char of str) {
            word += char;
            if (char === "(") {
              depth += 1;
            } else if (char === ")") {
              depth -= 1;
            } else if (char === ",") {
              if (depth === 0) {
                tupleStrings.push(word.slice(0, word.length - 1));
                word = "";
              }
            }
          }
          if (word.length !== 0) {
            tupleStrings.push(word);
          }
          if (depth !== 0) {
            throw new Error("tuple string has mismatched parentheses");
          }
          return tupleStrings;
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/abi/transaction.js
  function abiTypeIsTransaction(type) {
    return type === ABITransactionType.any || type === ABITransactionType.pay || type === ABITransactionType.keyreg || type === ABITransactionType.acfg || type === ABITransactionType.axfer || type === ABITransactionType.afrz || type === ABITransactionType.appl;
  }
  function abiCheckTransactionType(type, txn) {
    if (type === ABITransactionType.any) {
      return true;
    }
    return txn.type ? txn.type.toString() === type.toString() : false;
  }
  var ABITransactionType;
  var init_transaction2 = __esm({
    "node_modules/algosdk/dist/esm/abi/transaction.js"() {
      init_polyfills();
      (function(ABITransactionType2) {
        ABITransactionType2["any"] = "txn";
        ABITransactionType2["pay"] = "pay";
        ABITransactionType2["keyreg"] = "keyreg";
        ABITransactionType2["acfg"] = "acfg";
        ABITransactionType2["axfer"] = "axfer";
        ABITransactionType2["afrz"] = "afrz";
        ABITransactionType2["appl"] = "appl";
      })(ABITransactionType || (ABITransactionType = {}));
    }
  });

  // node_modules/algosdk/dist/esm/abi/reference.js
  function abiTypeIsReference(type) {
    return type === ABIReferenceType.account || type === ABIReferenceType.application || type === ABIReferenceType.asset;
  }
  var ABIReferenceType;
  var init_reference = __esm({
    "node_modules/algosdk/dist/esm/abi/reference.js"() {
      init_polyfills();
      (function(ABIReferenceType2) {
        ABIReferenceType2["account"] = "account";
        ABIReferenceType2["application"] = "application";
        ABIReferenceType2["asset"] = "asset";
      })(ABIReferenceType || (ABIReferenceType = {}));
    }
  });

  // node_modules/algosdk/dist/esm/abi/method.js
  function parseMethodSignature(signature) {
    const argsStart = signature.indexOf("(");
    if (argsStart === -1) {
      throw new Error(`Invalid method signature: ${signature}`);
    }
    let argsEnd = -1;
    let depth = 0;
    for (let i2 = argsStart; i2 < signature.length; i2++) {
      const char = signature[i2];
      if (char === "(") {
        depth += 1;
      } else if (char === ")") {
        if (depth === 0) {
          break;
        }
        depth -= 1;
        if (depth === 0) {
          argsEnd = i2;
          break;
        }
      }
    }
    if (argsEnd === -1) {
      throw new Error(`Invalid method signature: ${signature}`);
    }
    return {
      name: signature.slice(0, argsStart),
      args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),
      returns: signature.slice(argsEnd + 1)
    };
  }
  function getMethodByName(methods, name) {
    if (methods === null || !Array.isArray(methods) || !methods.every((item) => item instanceof ABIMethod))
      throw new Error("Methods list provided is null or not the correct type");
    const filteredMethods = methods.filter((m3) => m3.name === name);
    if (filteredMethods.length > 1)
      throw new Error(`found ${filteredMethods.length} methods with the same name ${filteredMethods.map((m3) => m3.getSignature()).join(",")}`);
    if (filteredMethods.length === 0)
      throw new Error(`found 0 methods with the name ${name}`);
    return filteredMethods[0];
  }
  var ABIMethod;
  var init_method = __esm({
    "node_modules/algosdk/dist/esm/abi/method.js"() {
      init_polyfills();
      init_naclWrappers();
      init_abi_type();
      init_transaction2();
      init_reference();
      ABIMethod = class _ABIMethod {
        constructor(params) {
          if (typeof params.name !== "string" || typeof params.returns !== "object" || !Array.isArray(params.args)) {
            throw new Error("Invalid ABIMethod parameters");
          }
          this.name = params.name;
          this.description = params.desc;
          this.args = params.args.map(({ type, name, desc }) => {
            if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {
              return {
                type,
                name,
                description: desc
              };
            }
            return {
              type: ABIType.from(type),
              name,
              description: desc
            };
          });
          this.returns = {
            type: params.returns.type === "void" ? params.returns.type : ABIType.from(params.returns.type),
            description: params.returns.desc
          };
          this.events = params.events;
          this.readonly = params.readonly;
        }
        getSignature() {
          const args = this.args.map((arg) => arg.type.toString()).join(",");
          const returns = this.returns.type.toString();
          return `${this.name}(${args})${returns}`;
        }
        getSelector() {
          const hash = genericHash(this.getSignature());
          return new Uint8Array(hash.slice(0, 4));
        }
        txnCount() {
          let count = 1;
          for (const arg of this.args) {
            if (typeof arg.type === "string" && abiTypeIsTransaction(arg.type)) {
              count += 1;
            }
          }
          return count;
        }
        toJSON() {
          return {
            name: this.name,
            desc: this.description,
            args: this.args.map(({ type, name, description }) => ({
              type: type.toString(),
              name,
              desc: description
            })),
            returns: {
              type: this.returns.type.toString(),
              desc: this.returns.description
            },
            events: this.events,
            readonly: this.readonly
          };
        }
        static fromSignature(signature) {
          const { name, args, returns } = parseMethodSignature(signature);
          return new _ABIMethod({
            name,
            args: args.map((arg) => ({ type: arg })),
            returns: { type: returns }
          });
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/abi/contract.js
  var ABIContract;
  var init_contract = __esm({
    "node_modules/algosdk/dist/esm/abi/contract.js"() {
      init_polyfills();
      init_method();
      ABIContract = class {
        constructor(params) {
          if (typeof params.name !== "string" || !Array.isArray(params.methods) || params.networks && typeof params.networks !== "object") {
            throw new Error("Invalid ABIContract parameters");
          }
          this.name = params.name;
          this.description = params.desc;
          this.networks = params.networks ? { ...params.networks } : {};
          this.methods = params.methods.map((method) => new ABIMethod(method));
          this.events = params.events;
        }
        toJSON() {
          return {
            name: this.name,
            desc: this.description,
            networks: this.networks,
            methods: this.methods.map((method) => method.toJSON()),
            events: this.events
          };
        }
        getMethodByName(name) {
          return getMethodByName(this.methods, name);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/abi/interface.js
  var ABIInterface;
  var init_interface = __esm({
    "node_modules/algosdk/dist/esm/abi/interface.js"() {
      init_polyfills();
      init_method();
      ABIInterface = class {
        constructor(params) {
          if (typeof params.name !== "string" || !Array.isArray(params.methods)) {
            throw new Error("Invalid ABIInterface parameters");
          }
          this.name = params.name;
          this.description = params.desc;
          this.methods = params.methods.map((method) => new ABIMethod(method));
        }
        toJSON() {
          return {
            name: this.name,
            desc: this.description,
            methods: this.methods.map((method) => method.toJSON())
          };
        }
        getMethodByName(name) {
          return getMethodByName(this.methods, name);
        }
      };
    }
  });

  // node_modules/algosdk/dist/esm/abi/index.js
  var init_abi = __esm({
    "node_modules/algosdk/dist/esm/abi/index.js"() {
      init_polyfills();
      init_abi_type();
      init_contract();
      init_interface();
      init_method();
      init_transaction2();
      init_reference();
    }
  });

  // node_modules/algosdk/dist/esm/composer.js
  function populateForeignArray(valueToAdd, array, zeroValue) {
    if (zeroValue != null && valueToAdd === zeroValue) {
      return 0;
    }
    const offset = zeroValue == null ? 0 : 1;
    for (let i2 = 0; i2 < array.length; i2++) {
      if (valueToAdd === array[i2]) {
        return i2 + offset;
      }
    }
    array.push(valueToAdd);
    return array.length - 1 + offset;
  }
  var RETURN_PREFIX, MAX_APP_ARGS, AtomicTransactionComposerStatus, AtomicTransactionComposer;
  var init_composer = __esm({
    "node_modules/algosdk/dist/esm/composer.js"() {
      init_polyfills();
      init_abi();
      init_types3();
      init_encoding3();
      init_group();
      init_makeTxn();
      init_signer();
      init_transaction();
      init_signedTransaction();
      init_base();
      init_utils();
      init_wait();
      RETURN_PREFIX = new Uint8Array([21, 31, 124, 117]);
      MAX_APP_ARGS = 16;
      (function(AtomicTransactionComposerStatus2) {
        AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILDING"] = 0] = "BUILDING";
        AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILT"] = 1] = "BUILT";
        AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SIGNED"] = 2] = "SIGNED";
        AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SUBMITTED"] = 3] = "SUBMITTED";
        AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["COMMITTED"] = 4] = "COMMITTED";
      })(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));
      AtomicTransactionComposer = class _AtomicTransactionComposer {
        constructor() {
          this.status = AtomicTransactionComposerStatus.BUILDING;
          this.transactions = [];
          this.methodCalls = /* @__PURE__ */ new Map();
          this.signedTxns = [];
          this.txIDs = [];
        }
        /**
         * Get the status of this composer's transaction group.
         */
        getStatus() {
          return this.status;
        }
        /**
         * Get the number of transactions currently in this atomic group.
         */
        count() {
          return this.transactions.length;
        }
        /**
         * Create a new composer with the same underlying transactions. The new composer's status will be
         * BUILDING, so additional transactions may be added to it.
         */
        clone() {
          const theClone = new _AtomicTransactionComposer();
          theClone.transactions = this.transactions.map(({ txn, signer }) => {
            const txnMap = txn.toEncodingData();
            txnMap.delete("grp");
            return {
              // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)
              txn: Transaction.fromEncodingData(txnMap),
              signer
            };
          });
          theClone.methodCalls = new Map(this.methodCalls);
          return theClone;
        }
        /**
         * Add a transaction to this atomic group.
         *
         * An error will be thrown if the transaction has a nonzero group ID, the composer's status is
         * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.
         */
        addTransaction(txnAndSigner) {
          if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
            throw new Error("Cannot add transactions when composer status is not BUILDING");
          }
          if (this.transactions.length === _AtomicTransactionComposer.MAX_GROUP_SIZE) {
            throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${_AtomicTransactionComposer.MAX_GROUP_SIZE}`);
          }
          if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v3) => v3 !== 0)) {
            throw new Error("Cannot add a transaction with nonzero group ID");
          }
          this.transactions.push(txnAndSigner);
        }
        /**
         * Add a smart contract method call to this atomic group.
         *
         * An error will be thrown if the composer's status is not BUILDING, if adding this transaction
         * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid
         * for the given method.
         */
        addMethodCall({ appID, method, methodArgs, sender, suggestedParams, onComplete, approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages, appAccounts, appForeignApps, appForeignAssets, boxes, note, lease, rekeyTo, signer }) {
          if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
            throw new Error("Cannot add transactions when composer status is not BUILDING");
          }
          if (this.transactions.length + method.txnCount() > _AtomicTransactionComposer.MAX_GROUP_SIZE) {
            throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${_AtomicTransactionComposer.MAX_GROUP_SIZE}`);
          }
          if (BigInt(appID) === BigInt(0)) {
            if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {
              throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
            }
          } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {
            if (approvalProgram == null || clearProgram == null) {
              throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
            }
            if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
              throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
            }
          } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
            throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
          }
          if (methodArgs == null) {
            methodArgs = [];
          }
          if (methodArgs.length !== method.args.length) {
            throw new Error(`Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`);
          }
          let basicArgTypes = [];
          let basicArgValues = [];
          const txnArgs = [];
          const refArgTypes = [];
          const refArgValues = [];
          const refArgIndexToBasicArgIndex = /* @__PURE__ */ new Map();
          const boxReferences = !boxes ? [] : boxes;
          for (let i2 = 0; i2 < methodArgs.length; i2++) {
            let argType = method.args[i2].type;
            const argValue = methodArgs[i2];
            if (abiTypeIsTransaction(argType)) {
              if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {
                throw new Error(`Expected ${argType} TransactionWithSigner for argument at index ${i2}`);
              }
              if (argValue.txn.group && argValue.txn.group.some((v3) => v3 !== 0)) {
                throw new Error("Cannot add a transaction with nonzero group ID");
              }
              txnArgs.push(argValue);
              continue;
            }
            if (isTransactionWithSigner(argValue)) {
              throw new Error(`Expected non-transaction value for argument at index ${i2}`);
            }
            if (abiTypeIsReference(argType)) {
              refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);
              refArgTypes.push(argType);
              refArgValues.push(argValue);
              argType = new ABIUintType(8);
            }
            if (typeof argType === "string") {
              throw new Error(`Unknown ABI type: ${argType}`);
            }
            basicArgTypes.push(argType);
            basicArgValues.push(argValue);
          }
          const resolvedRefIndexes = [];
          const foreignAccounts = appAccounts == null ? [] : appAccounts.map((addr) => addr.toString());
          const foreignApps = appForeignApps == null ? [] : appForeignApps.map(ensureUint64);
          const foreignAssets = appForeignAssets == null ? [] : appForeignAssets.map(ensureUint64);
          for (let i2 = 0; i2 < refArgTypes.length; i2++) {
            const refType = refArgTypes[i2];
            const refValue = refArgValues[i2];
            let resolved = 0;
            switch (refType) {
              case ABIReferenceType.account: {
                const addressType = new ABIAddressType();
                const address = addressType.decode(addressType.encode(refValue));
                resolved = populateForeignArray(address, foreignAccounts, sender.toString());
                break;
              }
              case ABIReferenceType.application: {
                const uint64Type = new ABIUintType(64);
                const refAppID = uint64Type.decode(uint64Type.encode(refValue));
                if (refAppID > Number.MAX_SAFE_INTEGER) {
                  throw new Error(`Expected safe integer for application value, got ${refAppID}`);
                }
                resolved = populateForeignArray(refAppID, foreignApps, ensureUint64(appID));
                break;
              }
              case ABIReferenceType.asset: {
                const uint64Type = new ABIUintType(64);
                const refAssetID = uint64Type.decode(uint64Type.encode(refValue));
                if (refAssetID > Number.MAX_SAFE_INTEGER) {
                  throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);
                }
                resolved = populateForeignArray(refAssetID, foreignAssets);
                break;
              }
              default:
                throw new Error(`Unknown reference type: ${refType}`);
            }
            resolvedRefIndexes.push(resolved);
          }
          for (let i2 = 0; i2 < resolvedRefIndexes.length; i2++) {
            const basicArgIndex = refArgIndexToBasicArgIndex.get(i2);
            basicArgValues[basicArgIndex] = resolvedRefIndexes[i2];
          }
          if (basicArgTypes.length > MAX_APP_ARGS - 1) {
            const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);
            const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);
            basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);
            basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);
            basicArgTypes.push(new ABITupleType(lastArgTupleTypes));
            basicArgValues.push(lastArgTupleValues);
          }
          const appArgsEncoded = [method.getSelector()];
          for (let i2 = 0; i2 < basicArgTypes.length; i2++) {
            appArgsEncoded.push(basicArgTypes[i2].encode(basicArgValues[i2]));
          }
          const appCall = {
            txn: makeApplicationCallTxnFromObject({
              sender,
              appIndex: appID,
              appArgs: appArgsEncoded,
              accounts: foreignAccounts,
              foreignApps,
              foreignAssets,
              boxes: boxReferences,
              onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,
              approvalProgram,
              clearProgram,
              numGlobalInts,
              numGlobalByteSlices,
              numLocalInts,
              numLocalByteSlices,
              extraPages,
              lease,
              note,
              rekeyTo,
              suggestedParams
            }),
            signer
          };
          this.transactions.push(...txnArgs, appCall);
          this.methodCalls.set(this.transactions.length - 1, method);
        }
        /**
         * Finalize the transaction group and returned the finalized transactions.
         *
         * The composer's status will be at least BUILT after executing this method.
         */
        buildGroup() {
          if (this.status === AtomicTransactionComposerStatus.BUILDING) {
            if (this.transactions.length === 0) {
              throw new Error("Cannot build a group with 0 transactions");
            }
            if (this.transactions.length > 1) {
              assignGroupID(this.transactions.map((txnWithSigner) => txnWithSigner.txn));
            }
            this.status = AtomicTransactionComposerStatus.BUILT;
          }
          return this.transactions;
        }
        /**
         * Obtain signatures for each transaction in this group. If signatures have already been obtained,
         * this method will return cached versions of the signatures.
         *
         * The composer's status will be at least SIGNED after executing this method.
         *
         * An error will be thrown if signing any of the transactions fails.
         *
         * @returns A promise that resolves to an array of signed transactions.
         */
        async gatherSignatures() {
          if (this.status >= AtomicTransactionComposerStatus.SIGNED) {
            return this.signedTxns;
          }
          const txnsWithSigners = this.buildGroup();
          const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);
          const indexesPerSigner = /* @__PURE__ */ new Map();
          for (let i2 = 0; i2 < txnsWithSigners.length; i2++) {
            const { signer } = txnsWithSigners[i2];
            if (!indexesPerSigner.has(signer)) {
              indexesPerSigner.set(signer, []);
            }
            indexesPerSigner.get(signer).push(i2);
          }
          const orderedSigners = Array.from(indexesPerSigner);
          const batchedSigs = await Promise.all(orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes)));
          const signedTxns = txnsWithSigners.map(() => null);
          for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {
            const indexes = orderedSigners[signerIndex][1];
            const sigs = batchedSigs[signerIndex];
            for (let i2 = 0; i2 < indexes.length; i2++) {
              signedTxns[indexes[i2]] = sigs[i2];
            }
          }
          function fullyPopulated(a2) {
            return a2.every((v3) => v3 != null);
          }
          if (!fullyPopulated(signedTxns)) {
            throw new Error(`Missing signatures. Got ${signedTxns}`);
          }
          const txIDs = signedTxns.map((stxn, index) => {
            try {
              return decodeMsgpack(stxn, SignedTransaction).txn.txID();
            } catch (err) {
              throw new Error(`Cannot decode signed transaction at index ${index}. ${err}`);
            }
          });
          this.signedTxns = signedTxns;
          this.txIDs = txIDs;
          this.status = AtomicTransactionComposerStatus.SIGNED;
          return signedTxns;
        }
        /**
         * Send the transaction group to the network, but don't wait for it to be committed to a block. An
         * error will be thrown if submission fails.
         *
         * The composer's status must be SUBMITTED or lower before calling this method. If submission is
         * successful, this composer's status will update to SUBMITTED.
         *
         * Note: a group can only be submitted again if it fails.
         *
         * @param client - An Algodv2 client
         *
         * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.
         */
        async submit(client) {
          if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
            throw new Error("Transaction group cannot be resubmitted");
          }
          const stxns = await this.gatherSignatures();
          await client.sendRawTransaction(stxns).do();
          this.status = AtomicTransactionComposerStatus.SUBMITTED;
          return this.txIDs;
        }
        /**
         * Simulates the transaction group in the network.
         *
         * The composer will try to sign any transactions in the group, then simulate
         * the results.
         * Simulating the group will not change the composer's status.
         *
         * @param client - An Algodv2 client
         * @param request - SimulateRequest with options in simulation.
         *   If provided, the request's transaction group will be overrwritten by the composer's group,
         *   only simulation related options will be used.
         *
         * @returns A promise that, upon success, resolves to an object containing an
         *   array of results containing one element for each method call transaction
         *   in this group (ABIResult[]) and the SimulateResponse object.
         */
        async simulate(client, request) {
          if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
            throw new Error("Simulated Transaction group has already been submitted to the network");
          }
          const stxns = await this.gatherSignatures();
          const txnObjects = stxns.map((stxn) => decodeMsgpack(stxn, SignedTransaction));
          const currentRequest = request == null ? new SimulateRequest({ txnGroups: [] }) : request;
          currentRequest.txnGroups = [
            new SimulateRequestTransactionGroup({
              txns: txnObjects
            })
          ];
          const simulateResponse = await client.simulateTransactions(currentRequest).do();
          const methodResults = [];
          for (const [txnIndex, method] of this.methodCalls) {
            const txID = this.txIDs[txnIndex];
            const pendingInfo = simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;
            const methodResult = {
              txID,
              rawReturnValue: new Uint8Array(),
              method
            };
            methodResults.push(_AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo));
          }
          return { methodResults, simulateResponse };
        }
        /**
         * Send the transaction group to the network and wait until it's committed to a block. An error
         * will be thrown if submission or execution fails.
         *
         * The composer's status must be SUBMITTED or lower before calling this method, since execution is
         * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.
         * If the execution is also successful, this composer's status will update to COMMITTED.
         *
         * Note: a group can only be submitted again if it fails.
         *
         * @param client - An Algodv2 client
         * @param waitRounds - The maximum number of rounds to wait for transaction confirmation
         *
         * @returns A promise that, upon success, resolves to an object containing the confirmed round for
         *   this transaction, the txIDs of the submitted transactions, and an array of results containing
         *   one element for each method call transaction in this group.
         */
        async execute(client, waitRounds) {
          if (this.status === AtomicTransactionComposerStatus.COMMITTED) {
            throw new Error("Transaction group has already been executed successfully");
          }
          const txIDs = await this.submit(client);
          this.status = AtomicTransactionComposerStatus.SUBMITTED;
          const firstMethodCallIndex = this.transactions.findIndex((_3, index) => this.methodCalls.has(index));
          const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;
          const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);
          this.status = AtomicTransactionComposerStatus.COMMITTED;
          const confirmedRound = confirmedTxnInfo.confirmedRound;
          const methodResults = [];
          for (const [txnIndex, method] of this.methodCalls) {
            const txID = txIDs[txnIndex];
            let methodResult = {
              txID,
              rawReturnValue: new Uint8Array(),
              method
            };
            try {
              const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo : (
                // eslint-disable-next-line no-await-in-loop
                await client.pendingTransactionInformation(txID).do()
              );
              methodResult = _AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo);
            } catch (err) {
              methodResult.decodeError = err;
            }
            methodResults.push(methodResult);
          }
          return {
            confirmedRound,
            txIDs,
            methodResults
          };
        }
        /**
         * Parses a single ABI Method transaction log into a ABI result object.
         *
         * @param method
         * @param methodResult
         * @param pendingInfo
         * @returns An ABIResult object
         */
        static parseMethodResponse(method, methodResult, pendingInfo) {
          const returnedResult = methodResult;
          try {
            returnedResult.txInfo = pendingInfo;
            if (method.returns.type !== "void") {
              const logs = pendingInfo.logs || [];
              if (logs.length === 0) {
                throw new Error(`App call transaction did not log a return value ${stringifyJSON(pendingInfo)}`);
              }
              const lastLog = logs[logs.length - 1];
              if (lastLog.byteLength < 4 || !arrayEqual(lastLog.slice(0, 4), RETURN_PREFIX)) {
                throw new Error(`App call transaction did not log a ABI return value ${stringifyJSON(pendingInfo)}`);
              }
              returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));
              returnedResult.returnValue = method.returns.type.decode(methodResult.rawReturnValue);
            }
          } catch (err) {
            returnedResult.decodeError = err;
          }
          return returnedResult;
        }
      };
      AtomicTransactionComposer.MAX_GROUP_SIZE = 16;
    }
  });

  // node_modules/algosdk/dist/esm/main.js
  var main_exports = {};
  __export(main_exports, {
    ABIAddressType: () => ABIAddressType,
    ABIArrayDynamicType: () => ABIArrayDynamicType,
    ABIArrayStaticType: () => ABIArrayStaticType,
    ABIBoolType: () => ABIBoolType,
    ABIByteType: () => ABIByteType,
    ABIContract: () => ABIContract,
    ABIInterface: () => ABIInterface,
    ABIMethod: () => ABIMethod,
    ABIReferenceType: () => ABIReferenceType,
    ABIStringType: () => ABIStringType,
    ABITransactionType: () => ABITransactionType,
    ABITupleType: () => ABITupleType,
    ABIType: () => ABIType,
    ABIUfixedType: () => ABIUfixedType,
    ABIUintType: () => ABIUintType,
    ADDR_BYTE_SIZE: () => ADDR_BYTE_SIZE,
    ALGORAND_ZERO_ADDRESS_STRING: () => ALGORAND_ZERO_ADDRESS_STRING,
    AccountBaseData: () => AccountBaseData,
    AccountData: () => AccountData,
    AccountDeltas: () => AccountDeltas,
    AccountTotals: () => AccountTotals,
    Address: () => Address,
    AlgoCount: () => AlgoCount,
    Algodv2: () => AlgodClient,
    AppLocalState: () => AppLocalState,
    AppLocalStateDelta: () => AppLocalStateDelta,
    AppParams: () => AppParams,
    AppParamsDelta: () => AppParamsDelta,
    AppResourceRecord: () => AppResourceRecord,
    ApplyData: () => ApplyData,
    AssetHolding: () => AssetHolding,
    AssetHoldingDelta: () => AssetHoldingDelta,
    AssetParams: () => AssetParams,
    AssetParamsDelta: () => AssetParamsDelta,
    AssetResourceRecord: () => AssetResourceRecord,
    AtomicTransactionComposer: () => AtomicTransactionComposer,
    AtomicTransactionComposerStatus: () => AtomicTransactionComposerStatus,
    BalanceRecord: () => BalanceRecord,
    Block: () => Block,
    BlockHeader: () => BlockHeader,
    ENCODED_MULTISIG_SCHEMA: () => ENCODED_MULTISIG_SCHEMA,
    ENCODED_SUBSIG_SCHEMA: () => ENCODED_SUBSIG_SCHEMA,
    ERROR_INVALID_MICROALGOS: () => ERROR_INVALID_MICROALGOS,
    ERROR_MULTISIG_BAD_SENDER: () => ERROR_MULTISIG_BAD_SENDER,
    EvalDelta: () => EvalDelta,
    FalconSignatureStruct: () => FalconSignatureStruct,
    FalconVerifier: () => FalconVerifier,
    HashFactory: () => HashFactory,
    INVALID_MICROALGOS_ERROR_MSG: () => INVALID_MICROALGOS_ERROR_MSG,
    IncludedTransactions: () => IncludedTransactions,
    Indexer: () => IndexerClient,
    IntDecoding: () => intDecoding_default,
    Kmd: () => KmdClient,
    KvValueDelta: () => KvValueDelta,
    LENGTH_ENCODE_BYTE_SIZE: () => LENGTH_ENCODE_BYTE_SIZE,
    LedgerStateDelta: () => LedgerStateDelta,
    LogicSig: () => LogicSig,
    LogicSigAccount: () => LogicSigAccount,
    MAX_LEN: () => MAX_LEN,
    MULTISIG_BAD_SENDER_ERROR_MSG: () => MULTISIG_BAD_SENDER_ERROR_MSG,
    MerkleArrayProof: () => MerkleArrayProof,
    MerkleSignatureVerifier: () => MerkleSignatureVerifier,
    ModifiedCreatable: () => ModifiedCreatable,
    OnApplicationComplete: () => OnApplicationComplete,
    Participant: () => Participant,
    ParticipationUpdates: () => ParticipationUpdates,
    ProgramSourceMap: () => ProgramSourceMap,
    Reveal: () => Reveal,
    RewardState: () => RewardState,
    SINGLE_BOOL_SIZE: () => SINGLE_BOOL_SIZE,
    SINGLE_BYTE_SIZE: () => SINGLE_BYTE_SIZE,
    SignedTransaction: () => SignedTransaction,
    SignedTxnInBlock: () => SignedTxnInBlock,
    SignedTxnWithAD: () => SignedTxnWithAD,
    SigslotCommit: () => SigslotCommit,
    StateProof: () => StateProof,
    StateProofMessage: () => StateProofMessage,
    StateProofTrackingData: () => StateProofTrackingData,
    StateSchema: () => StateSchema,
    TealValue: () => TealValue,
    Transaction: () => Transaction,
    TransactionType: () => TransactionType,
    TxnCommitments: () => TxnCommitments,
    UntypedValue: () => UntypedValue,
    UpgradeState: () => UpgradeState,
    UpgradeVote: () => UpgradeVote,
    ValueDelta: () => ValueDelta,
    VotingData: () => VotingData,
    abiCheckTransactionType: () => abiCheckTransactionType,
    abiTypeIsReference: () => abiTypeIsReference,
    abiTypeIsTransaction: () => abiTypeIsTransaction,
    algosToMicroalgos: () => algosToMicroalgos,
    appendSignMultisigTransaction: () => appendSignMultisigTransaction,
    appendSignRawMultisigSignature: () => appendSignRawMultisigSignature,
    assignGroupID: () => assignGroupID,
    base64ToBytes: () => base64ToBytes,
    bigIntToBytes: () => bigIntToBytes,
    bytesToBase64: () => bytesToBase64,
    bytesToBigInt: () => bytesToBigInt,
    bytesToHex: () => bytesToHex,
    bytesToString: () => bytesToString,
    coerceToBytes: () => coerceToBytes,
    computeGroupID: () => computeGroupID,
    createDryrun: () => createDryrun,
    createMultisigTransaction: () => createMultisigTransaction,
    decodeAddress: () => decodeAddress,
    decodeJSON: () => decodeJSON,
    decodeMsgpack: () => decodeMsgpack,
    decodeObj: () => decodeObj,
    decodeSignedTransaction: () => decodeSignedTransaction,
    decodeUint64: () => decodeUint64,
    decodeUnsignedTransaction: () => decodeUnsignedTransaction,
    dryrunTxnResultAppTrace: () => dryrunTxnResultAppTrace,
    dryrunTxnResultLogicSigTrace: () => dryrunTxnResultLogicSigTrace,
    encodeAddress: () => encodeAddress,
    encodeJSON: () => encodeJSON,
    encodeMsgpack: () => encodeMsgpack,
    encodeObj: () => encodeObj,
    encodeUint64: () => encodeUint64,
    encodeUnsignedSimulateTransaction: () => encodeUnsignedSimulateTransaction,
    encodeUnsignedTransaction: () => encodeUnsignedTransaction,
    encodedMultiSigFromEncodingData: () => encodedMultiSigFromEncodingData,
    encodedMultiSigToEncodingData: () => encodedMultiSigToEncodingData,
    encodedSubsigFromEncodingData: () => encodedSubsigFromEncodingData,
    encodedSubsigToEncodingData: () => encodedSubsigToEncodingData,
    generateAccount: () => generateAccount,
    getApplicationAddress: () => getApplicationAddress,
    getMethodByName: () => getMethodByName,
    hexToBytes: () => hexToBytes,
    indexerModels: () => types_exports2,
    isOnApplicationComplete: () => isOnApplicationComplete,
    isTransactionType: () => isTransactionType,
    isTransactionWithSigner: () => isTransactionWithSigner,
    isValidAddress: () => isValidAddress2,
    logicSigFromByte: () => logicSigFromByte,
    makeApplicationCallTxnFromObject: () => makeApplicationCallTxnFromObject,
    makeApplicationClearStateTxnFromObject: () => makeApplicationClearStateTxnFromObject,
    makeApplicationCloseOutTxnFromObject: () => makeApplicationCloseOutTxnFromObject,
    makeApplicationCreateTxnFromObject: () => makeApplicationCreateTxnFromObject,
    makeApplicationDeleteTxnFromObject: () => makeApplicationDeleteTxnFromObject,
    makeApplicationNoOpTxnFromObject: () => makeApplicationNoOpTxnFromObject,
    makeApplicationOptInTxnFromObject: () => makeApplicationOptInTxnFromObject,
    makeApplicationUpdateTxnFromObject: () => makeApplicationUpdateTxnFromObject,
    makeAssetConfigTxnWithSuggestedParamsFromObject: () => makeAssetConfigTxnWithSuggestedParamsFromObject,
    makeAssetCreateTxnWithSuggestedParamsFromObject: () => makeAssetCreateTxnWithSuggestedParamsFromObject,
    makeAssetDestroyTxnWithSuggestedParamsFromObject: () => makeAssetDestroyTxnWithSuggestedParamsFromObject,
    makeAssetFreezeTxnWithSuggestedParamsFromObject: () => makeAssetFreezeTxnWithSuggestedParamsFromObject,
    makeAssetTransferTxnWithSuggestedParamsFromObject: () => makeAssetTransferTxnWithSuggestedParamsFromObject,
    makeBaseAssetConfigTxn: () => makeBaseAssetConfigTxn,
    makeBasicAccountTransactionSigner: () => makeBasicAccountTransactionSigner,
    makeEmptyTransactionSigner: () => makeEmptyTransactionSigner,
    makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => makeKeyRegistrationTxnWithSuggestedParamsFromObject,
    makeLogicSigAccountTransactionSigner: () => makeLogicSigAccountTransactionSigner,
    makeMultiSigAccountTransactionSigner: () => makeMultiSigAccountTransactionSigner,
    makePaymentTxnWithSuggestedParamsFromObject: () => makePaymentTxnWithSuggestedParamsFromObject,
    masterDerivationKeyToMnemonic: () => masterDerivationKeyToMnemonic,
    mergeMultisigTransactions: () => mergeMultisigTransactions,
    microalgosToAlgos: () => microalgosToAlgos,
    mnemonicFromSeed: () => mnemonicFromSeed,
    mnemonicToMasterDerivationKey: () => mnemonicToMasterDerivationKey,
    mnemonicToSecretKey: () => mnemonicToSecretKey,
    modelsv2: () => types_exports,
    msgpackRawDecode: () => msgpackRawDecode,
    msgpackRawDecodeAsMap: () => msgpackRawDecodeAsMap,
    msgpackRawEncode: () => msgpackRawEncode,
    multisigAddress: () => multisigAddress,
    parseJSON: () => parseJSON,
    secretKeyToMnemonic: () => secretKeyToMnemonic,
    seedFromMnemonic: () => seedFromMnemonic,
    signBytes: () => signBytes,
    signLogicSigTransaction: () => signLogicSigTransaction,
    signLogicSigTransactionObject: () => signLogicSigTransactionObject,
    signMultisigTransaction: () => signMultisigTransaction,
    signTransaction: () => signTransaction,
    stringifyJSON: () => stringifyJSON,
    tealSign: () => tealSign,
    tealSignFromProgram: () => tealSignFromProgram,
    verifyBytes: () => verifyBytes,
    verifyMultisig: () => verifyMultisig,
    verifyTealSign: () => verifyTealSign,
    waitForConfirmation: () => waitForConfirmation
  });
  function signTransaction(txn, sk) {
    return {
      txID: txn.txID(),
      blob: txn.signTxn(sk)
    };
  }
  function signBytes(bytes, sk) {
    const toBeSigned = concatArrays2(SIGN_BYTES_PREFIX, bytes);
    const sig = sign(toBeSigned, sk);
    return sig;
  }
  function verifyBytes(bytes, signature, addr) {
    const toBeVerified = concatArrays2(SIGN_BYTES_PREFIX, bytes);
    const addrObj = typeof addr === "string" ? Address.fromString(addr) : addr;
    return verify(toBeVerified, signature, addrObj.publicKey);
  }
  var SIGN_BYTES_PREFIX, MULTISIG_BAD_SENDER_ERROR_MSG, ERROR_MULTISIG_BAD_SENDER, ERROR_INVALID_MICROALGOS;
  var init_main = __esm({
    "node_modules/algosdk/dist/esm/main.js"() {
      init_polyfills();
      init_naclWrappers();
      init_address();
      init_convert();
      init_utils();
      init_algod();
      init_kmd();
      init_intDecoding();
      init_indexer();
      init_wait();
      init_encoding3();
      init_address();
      init_bigint();
      init_binarydata();
      init_uint64();
      init_utils();
      init_account();
      init_block();
      init_statedelta();
      init_stateproof();
      init_untypedmodel();
      init_types3();
      init_types4();
      init_mnemonic();
      init_convert();
      init_group();
      init_signedTransaction();
      init_signing();
      init_logicsig();
      init_multisig();
      init_multisigSigning();
      init_sourcemap();
      init_dryrun2();
      init_makeTxn();
      init_transaction();
      init_signer();
      init_composer();
      init_transactions();
      init_abi();
      SIGN_BYTES_PREFIX = Uint8Array.from([77, 88]);
      MULTISIG_BAD_SENDER_ERROR_MSG = "The transaction sender address and multisig preimage do not match.";
      ERROR_MULTISIG_BAD_SENDER = new Error(MULTISIG_BAD_SENDER_ERROR_MSG);
      ERROR_INVALID_MICROALGOS = new Error(INVALID_MICROALGOS_ERROR_MSG);
    }
  });

  // node_modules/algosdk/dist/esm/index.js
  var esm_default4;
  var init_esm10 = __esm({
    "node_modules/algosdk/dist/esm/index.js"() {
      init_polyfills();
      init_main();
      init_main();
      esm_default4 = main_exports;
    }
  });

  // node_modules/bowser/es5.js
  var require_es5 = __commonJS({
    "node_modules/bowser/es5.js"(exports, module) {
      init_polyfills();
      !function(e2, t) {
        "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.bowser = t() : e2.bowser = t();
      }(exports, function() {
        return function(e2) {
          var t = {};
          function r3(n3) {
            if (t[n3]) return t[n3].exports;
            var i2 = t[n3] = { i: n3, l: false, exports: {} };
            return e2[n3].call(i2.exports, i2, i2.exports, r3), i2.l = true, i2.exports;
          }
          return r3.m = e2, r3.c = t, r3.d = function(e3, t2, n3) {
            r3.o(e3, t2) || Object.defineProperty(e3, t2, { enumerable: true, get: n3 });
          }, r3.r = function(e3) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
          }, r3.t = function(e3, t2) {
            if (1 & t2 && (e3 = r3(e3)), 8 & t2) return e3;
            if (4 & t2 && "object" == typeof e3 && e3 && e3.__esModule) return e3;
            var n3 = /* @__PURE__ */ Object.create(null);
            if (r3.r(n3), Object.defineProperty(n3, "default", { enumerable: true, value: e3 }), 2 & t2 && "string" != typeof e3) for (var i2 in e3) r3.d(n3, i2, function(t3) {
              return e3[t3];
            }.bind(null, i2));
            return n3;
          }, r3.n = function(e3) {
            var t2 = e3 && e3.__esModule ? function() {
              return e3.default;
            } : function() {
              return e3;
            };
            return r3.d(t2, "a", t2), t2;
          }, r3.o = function(e3, t2) {
            return Object.prototype.hasOwnProperty.call(e3, t2);
          }, r3.p = "", r3(r3.s = 90);
        }({ 17: function(e2, t, r3) {
          "use strict";
          t.__esModule = true, t.default = void 0;
          var n3 = r3(18), i2 = function() {
            function e3() {
            }
            return e3.getFirstMatch = function(e4, t2) {
              var r4 = t2.match(e4);
              return r4 && r4.length > 0 && r4[1] || "";
            }, e3.getSecondMatch = function(e4, t2) {
              var r4 = t2.match(e4);
              return r4 && r4.length > 1 && r4[2] || "";
            }, e3.matchAndReturnConst = function(e4, t2, r4) {
              if (e4.test(t2)) return r4;
            }, e3.getWindowsVersionName = function(e4) {
              switch (e4) {
                case "NT":
                  return "NT";
                case "XP":
                  return "XP";
                case "NT 5.0":
                  return "2000";
                case "NT 5.1":
                  return "XP";
                case "NT 5.2":
                  return "2003";
                case "NT 6.0":
                  return "Vista";
                case "NT 6.1":
                  return "7";
                case "NT 6.2":
                  return "8";
                case "NT 6.3":
                  return "8.1";
                case "NT 10.0":
                  return "10";
                default:
                  return;
              }
            }, e3.getMacOSVersionName = function(e4) {
              var t2 = e4.split(".").splice(0, 2).map(function(e5) {
                return parseInt(e5, 10) || 0;
              });
              if (t2.push(0), 10 === t2[0]) switch (t2[1]) {
                case 5:
                  return "Leopard";
                case 6:
                  return "Snow Leopard";
                case 7:
                  return "Lion";
                case 8:
                  return "Mountain Lion";
                case 9:
                  return "Mavericks";
                case 10:
                  return "Yosemite";
                case 11:
                  return "El Capitan";
                case 12:
                  return "Sierra";
                case 13:
                  return "High Sierra";
                case 14:
                  return "Mojave";
                case 15:
                  return "Catalina";
                default:
                  return;
              }
            }, e3.getAndroidVersionName = function(e4) {
              var t2 = e4.split(".").splice(0, 2).map(function(e5) {
                return parseInt(e5, 10) || 0;
              });
              if (t2.push(0), !(1 === t2[0] && t2[1] < 5)) return 1 === t2[0] && t2[1] < 6 ? "Cupcake" : 1 === t2[0] && t2[1] >= 6 ? "Donut" : 2 === t2[0] && t2[1] < 2 ? "Eclair" : 2 === t2[0] && 2 === t2[1] ? "Froyo" : 2 === t2[0] && t2[1] > 2 ? "Gingerbread" : 3 === t2[0] ? "Honeycomb" : 4 === t2[0] && t2[1] < 1 ? "Ice Cream Sandwich" : 4 === t2[0] && t2[1] < 4 ? "Jelly Bean" : 4 === t2[0] && t2[1] >= 4 ? "KitKat" : 5 === t2[0] ? "Lollipop" : 6 === t2[0] ? "Marshmallow" : 7 === t2[0] ? "Nougat" : 8 === t2[0] ? "Oreo" : 9 === t2[0] ? "Pie" : void 0;
            }, e3.getVersionPrecision = function(e4) {
              return e4.split(".").length;
            }, e3.compareVersions = function(t2, r4, n4) {
              void 0 === n4 && (n4 = false);
              var i3 = e3.getVersionPrecision(t2), s2 = e3.getVersionPrecision(r4), a2 = Math.max(i3, s2), o3 = 0, u3 = e3.map([t2, r4], function(t3) {
                var r5 = a2 - e3.getVersionPrecision(t3), n5 = t3 + new Array(r5 + 1).join(".0");
                return e3.map(n5.split("."), function(e4) {
                  return new Array(20 - e4.length).join("0") + e4;
                }).reverse();
              });
              for (n4 && (o3 = a2 - Math.min(i3, s2)), a2 -= 1; a2 >= o3; ) {
                if (u3[0][a2] > u3[1][a2]) return 1;
                if (u3[0][a2] === u3[1][a2]) {
                  if (a2 === o3) return 0;
                  a2 -= 1;
                } else if (u3[0][a2] < u3[1][a2]) return -1;
              }
            }, e3.map = function(e4, t2) {
              var r4, n4 = [];
              if (Array.prototype.map) return Array.prototype.map.call(e4, t2);
              for (r4 = 0; r4 < e4.length; r4 += 1) n4.push(t2(e4[r4]));
              return n4;
            }, e3.find = function(e4, t2) {
              var r4, n4;
              if (Array.prototype.find) return Array.prototype.find.call(e4, t2);
              for (r4 = 0, n4 = e4.length; r4 < n4; r4 += 1) {
                var i3 = e4[r4];
                if (t2(i3, r4)) return i3;
              }
            }, e3.assign = function(e4) {
              for (var t2, r4, n4 = e4, i3 = arguments.length, s2 = new Array(i3 > 1 ? i3 - 1 : 0), a2 = 1; a2 < i3; a2++) s2[a2 - 1] = arguments[a2];
              if (Object.assign) return Object.assign.apply(Object, [e4].concat(s2));
              var o3 = function() {
                var e5 = s2[t2];
                "object" == typeof e5 && null !== e5 && Object.keys(e5).forEach(function(t3) {
                  n4[t3] = e5[t3];
                });
              };
              for (t2 = 0, r4 = s2.length; t2 < r4; t2 += 1) o3();
              return e4;
            }, e3.getBrowserAlias = function(e4) {
              return n3.BROWSER_ALIASES_MAP[e4];
            }, e3.getBrowserTypeByAlias = function(e4) {
              return n3.BROWSER_MAP[e4] || "";
            }, e3;
          }();
          t.default = i2, e2.exports = t.default;
        }, 18: function(e2, t, r3) {
          "use strict";
          t.__esModule = true, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0;
          t.BROWSER_ALIASES_MAP = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
          t.BROWSER_MAP = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
          t.PLATFORMS_MAP = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" };
          t.OS_MAP = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
          t.ENGINE_MAP = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
        }, 90: function(e2, t, r3) {
          "use strict";
          t.__esModule = true, t.default = void 0;
          var n3, i2 = (n3 = r3(91)) && n3.__esModule ? n3 : { default: n3 }, s2 = r3(18);
          function a2(e3, t2) {
            for (var r4 = 0; r4 < t2.length; r4++) {
              var n4 = t2[r4];
              n4.enumerable = n4.enumerable || false, n4.configurable = true, "value" in n4 && (n4.writable = true), Object.defineProperty(e3, n4.key, n4);
            }
          }
          var o3 = function() {
            function e3() {
            }
            var t2, r4, n4;
            return e3.getParser = function(e4, t3) {
              if (void 0 === t3 && (t3 = false), "string" != typeof e4) throw new Error("UserAgent should be a string");
              return new i2.default(e4, t3);
            }, e3.parse = function(e4) {
              return new i2.default(e4).getResult();
            }, t2 = e3, n4 = [{ key: "BROWSER_MAP", get: function() {
              return s2.BROWSER_MAP;
            } }, { key: "ENGINE_MAP", get: function() {
              return s2.ENGINE_MAP;
            } }, { key: "OS_MAP", get: function() {
              return s2.OS_MAP;
            } }, { key: "PLATFORMS_MAP", get: function() {
              return s2.PLATFORMS_MAP;
            } }], (r4 = null) && a2(t2.prototype, r4), n4 && a2(t2, n4), e3;
          }();
          t.default = o3, e2.exports = t.default;
        }, 91: function(e2, t, r3) {
          "use strict";
          t.__esModule = true, t.default = void 0;
          var n3 = u3(r3(92)), i2 = u3(r3(93)), s2 = u3(r3(94)), a2 = u3(r3(95)), o3 = u3(r3(17));
          function u3(e3) {
            return e3 && e3.__esModule ? e3 : { default: e3 };
          }
          var d2 = function() {
            function e3(e4, t3) {
              if (void 0 === t3 && (t3 = false), null == e4 || "" === e4) throw new Error("UserAgent parameter can't be empty");
              this._ua = e4, this.parsedResult = {}, true !== t3 && this.parse();
            }
            var t2 = e3.prototype;
            return t2.getUA = function() {
              return this._ua;
            }, t2.test = function(e4) {
              return e4.test(this._ua);
            }, t2.parseBrowser = function() {
              var e4 = this;
              this.parsedResult.browser = {};
              var t3 = o3.default.find(n3.default, function(t4) {
                if ("function" == typeof t4.test) return t4.test(e4);
                if (t4.test instanceof Array) return t4.test.some(function(t5) {
                  return e4.test(t5);
                });
                throw new Error("Browser's test function is not valid");
              });
              return t3 && (this.parsedResult.browser = t3.describe(this.getUA())), this.parsedResult.browser;
            }, t2.getBrowser = function() {
              return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
            }, t2.getBrowserName = function(e4) {
              return e4 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
            }, t2.getBrowserVersion = function() {
              return this.getBrowser().version;
            }, t2.getOS = function() {
              return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
            }, t2.parseOS = function() {
              var e4 = this;
              this.parsedResult.os = {};
              var t3 = o3.default.find(i2.default, function(t4) {
                if ("function" == typeof t4.test) return t4.test(e4);
                if (t4.test instanceof Array) return t4.test.some(function(t5) {
                  return e4.test(t5);
                });
                throw new Error("Browser's test function is not valid");
              });
              return t3 && (this.parsedResult.os = t3.describe(this.getUA())), this.parsedResult.os;
            }, t2.getOSName = function(e4) {
              var t3 = this.getOS().name;
              return e4 ? String(t3).toLowerCase() || "" : t3 || "";
            }, t2.getOSVersion = function() {
              return this.getOS().version;
            }, t2.getPlatform = function() {
              return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
            }, t2.getPlatformType = function(e4) {
              void 0 === e4 && (e4 = false);
              var t3 = this.getPlatform().type;
              return e4 ? String(t3).toLowerCase() || "" : t3 || "";
            }, t2.parsePlatform = function() {
              var e4 = this;
              this.parsedResult.platform = {};
              var t3 = o3.default.find(s2.default, function(t4) {
                if ("function" == typeof t4.test) return t4.test(e4);
                if (t4.test instanceof Array) return t4.test.some(function(t5) {
                  return e4.test(t5);
                });
                throw new Error("Browser's test function is not valid");
              });
              return t3 && (this.parsedResult.platform = t3.describe(this.getUA())), this.parsedResult.platform;
            }, t2.getEngine = function() {
              return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
            }, t2.getEngineName = function(e4) {
              return e4 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
            }, t2.parseEngine = function() {
              var e4 = this;
              this.parsedResult.engine = {};
              var t3 = o3.default.find(a2.default, function(t4) {
                if ("function" == typeof t4.test) return t4.test(e4);
                if (t4.test instanceof Array) return t4.test.some(function(t5) {
                  return e4.test(t5);
                });
                throw new Error("Browser's test function is not valid");
              });
              return t3 && (this.parsedResult.engine = t3.describe(this.getUA())), this.parsedResult.engine;
            }, t2.parse = function() {
              return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
            }, t2.getResult = function() {
              return o3.default.assign({}, this.parsedResult);
            }, t2.satisfies = function(e4) {
              var t3 = this, r4 = {}, n4 = 0, i3 = {}, s3 = 0;
              if (Object.keys(e4).forEach(function(t4) {
                var a4 = e4[t4];
                "string" == typeof a4 ? (i3[t4] = a4, s3 += 1) : "object" == typeof a4 && (r4[t4] = a4, n4 += 1);
              }), n4 > 0) {
                var a3 = Object.keys(r4), u4 = o3.default.find(a3, function(e5) {
                  return t3.isOS(e5);
                });
                if (u4) {
                  var d3 = this.satisfies(r4[u4]);
                  if (void 0 !== d3) return d3;
                }
                var c2 = o3.default.find(a3, function(e5) {
                  return t3.isPlatform(e5);
                });
                if (c2) {
                  var f3 = this.satisfies(r4[c2]);
                  if (void 0 !== f3) return f3;
                }
              }
              if (s3 > 0) {
                var l2 = Object.keys(i3), h3 = o3.default.find(l2, function(e5) {
                  return t3.isBrowser(e5, true);
                });
                if (void 0 !== h3) return this.compareVersion(i3[h3]);
              }
            }, t2.isBrowser = function(e4, t3) {
              void 0 === t3 && (t3 = false);
              var r4 = this.getBrowserName().toLowerCase(), n4 = e4.toLowerCase(), i3 = o3.default.getBrowserTypeByAlias(n4);
              return t3 && i3 && (n4 = i3.toLowerCase()), n4 === r4;
            }, t2.compareVersion = function(e4) {
              var t3 = [0], r4 = e4, n4 = false, i3 = this.getBrowserVersion();
              if ("string" == typeof i3) return ">" === e4[0] || "<" === e4[0] ? (r4 = e4.substr(1), "=" === e4[1] ? (n4 = true, r4 = e4.substr(2)) : t3 = [], ">" === e4[0] ? t3.push(1) : t3.push(-1)) : "=" === e4[0] ? r4 = e4.substr(1) : "~" === e4[0] && (n4 = true, r4 = e4.substr(1)), t3.indexOf(o3.default.compareVersions(i3, r4, n4)) > -1;
            }, t2.isOS = function(e4) {
              return this.getOSName(true) === String(e4).toLowerCase();
            }, t2.isPlatform = function(e4) {
              return this.getPlatformType(true) === String(e4).toLowerCase();
            }, t2.isEngine = function(e4) {
              return this.getEngineName(true) === String(e4).toLowerCase();
            }, t2.is = function(e4, t3) {
              return void 0 === t3 && (t3 = false), this.isBrowser(e4, t3) || this.isOS(e4) || this.isPlatform(e4);
            }, t2.some = function(e4) {
              var t3 = this;
              return void 0 === e4 && (e4 = []), e4.some(function(e5) {
                return t3.is(e5);
              });
            }, e3;
          }();
          t.default = d2, e2.exports = t.default;
        }, 92: function(e2, t, r3) {
          "use strict";
          t.__esModule = true, t.default = void 0;
          var n3, i2 = (n3 = r3(17)) && n3.__esModule ? n3 : { default: n3 };
          var s2 = /version\/(\d+(\.?_?\d+)+)/i, a2 = [{ test: [/googlebot/i], describe: function(e3) {
            var t2 = { name: "Googlebot" }, r4 = i2.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/opera/i], describe: function(e3) {
            var t2 = { name: "Opera" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/opr\/|opios/i], describe: function(e3) {
            var t2 = { name: "Opera" }, r4 = i2.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/SamsungBrowser/i], describe: function(e3) {
            var t2 = { name: "Samsung Internet for Android" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/Whale/i], describe: function(e3) {
            var t2 = { name: "NAVER Whale Browser" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/MZBrowser/i], describe: function(e3) {
            var t2 = { name: "MZ Browser" }, r4 = i2.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/focus/i], describe: function(e3) {
            var t2 = { name: "Focus" }, r4 = i2.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/swing/i], describe: function(e3) {
            var t2 = { name: "Swing" }, r4 = i2.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/coast/i], describe: function(e3) {
            var t2 = { name: "Opera Coast" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe: function(e3) {
            var t2 = { name: "Opera Touch" }, r4 = i2.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/yabrowser/i], describe: function(e3) {
            var t2 = { name: "Yandex Browser" }, r4 = i2.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/ucbrowser/i], describe: function(e3) {
            var t2 = { name: "UC Browser" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/Maxthon|mxios/i], describe: function(e3) {
            var t2 = { name: "Maxthon" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/epiphany/i], describe: function(e3) {
            var t2 = { name: "Epiphany" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/puffin/i], describe: function(e3) {
            var t2 = { name: "Puffin" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/sleipnir/i], describe: function(e3) {
            var t2 = { name: "Sleipnir" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/k-meleon/i], describe: function(e3) {
            var t2 = { name: "K-Meleon" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/micromessenger/i], describe: function(e3) {
            var t2 = { name: "WeChat" }, r4 = i2.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/qqbrowser/i], describe: function(e3) {
            var t2 = { name: /qqbrowserlite/i.test(e3) ? "QQ Browser Lite" : "QQ Browser" }, r4 = i2.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/msie|trident/i], describe: function(e3) {
            var t2 = { name: "Internet Explorer" }, r4 = i2.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/\sedg\//i], describe: function(e3) {
            var t2 = { name: "Microsoft Edge" }, r4 = i2.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/edg([ea]|ios)/i], describe: function(e3) {
            var t2 = { name: "Microsoft Edge" }, r4 = i2.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/vivaldi/i], describe: function(e3) {
            var t2 = { name: "Vivaldi" }, r4 = i2.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/seamonkey/i], describe: function(e3) {
            var t2 = { name: "SeaMonkey" }, r4 = i2.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/sailfish/i], describe: function(e3) {
            var t2 = { name: "Sailfish" }, r4 = i2.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/silk/i], describe: function(e3) {
            var t2 = { name: "Amazon Silk" }, r4 = i2.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/phantom/i], describe: function(e3) {
            var t2 = { name: "PhantomJS" }, r4 = i2.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/slimerjs/i], describe: function(e3) {
            var t2 = { name: "SlimerJS" }, r4 = i2.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e3) {
            var t2 = { name: "BlackBerry" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/(web|hpw)[o0]s/i], describe: function(e3) {
            var t2 = { name: "WebOS Browser" }, r4 = i2.default.getFirstMatch(s2, e3) || i2.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/bada/i], describe: function(e3) {
            var t2 = { name: "Bada" }, r4 = i2.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/tizen/i], describe: function(e3) {
            var t2 = { name: "Tizen" }, r4 = i2.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/qupzilla/i], describe: function(e3) {
            var t2 = { name: "QupZilla" }, r4 = i2.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/firefox|iceweasel|fxios/i], describe: function(e3) {
            var t2 = { name: "Firefox" }, r4 = i2.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/electron/i], describe: function(e3) {
            var t2 = { name: "Electron" }, r4 = i2.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/MiuiBrowser/i], describe: function(e3) {
            var t2 = { name: "Miui" }, r4 = i2.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/chromium/i], describe: function(e3) {
            var t2 = { name: "Chromium" }, r4 = i2.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e3) || i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/chrome|crios|crmo/i], describe: function(e3) {
            var t2 = { name: "Chrome" }, r4 = i2.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/GSA/i], describe: function(e3) {
            var t2 = { name: "Google Search" }, r4 = i2.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: function(e3) {
            var t2 = !e3.test(/like android/i), r4 = e3.test(/android/i);
            return t2 && r4;
          }, describe: function(e3) {
            var t2 = { name: "Android Browser" }, r4 = i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/playstation 4/i], describe: function(e3) {
            var t2 = { name: "PlayStation 4" }, r4 = i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/safari|applewebkit/i], describe: function(e3) {
            var t2 = { name: "Safari" }, r4 = i2.default.getFirstMatch(s2, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/.*/i], describe: function(e3) {
            var t2 = -1 !== e3.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
            return { name: i2.default.getFirstMatch(t2, e3), version: i2.default.getSecondMatch(t2, e3) };
          } }];
          t.default = a2, e2.exports = t.default;
        }, 93: function(e2, t, r3) {
          "use strict";
          t.__esModule = true, t.default = void 0;
          var n3, i2 = (n3 = r3(17)) && n3.__esModule ? n3 : { default: n3 }, s2 = r3(18);
          var a2 = [{ test: [/Roku\/DVP/], describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e3);
            return { name: s2.OS_MAP.Roku, version: t2 };
          } }, { test: [/windows phone/i], describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e3);
            return { name: s2.OS_MAP.WindowsPhone, version: t2 };
          } }, { test: [/windows /i], describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e3), r4 = i2.default.getWindowsVersionName(t2);
            return { name: s2.OS_MAP.Windows, version: t2, versionName: r4 };
          } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function(e3) {
            var t2 = { name: s2.OS_MAP.iOS }, r4 = i2.default.getSecondMatch(/(Version\/)(\d[\d.]+)/, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/macintosh/i], describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e3).replace(/[_\s]/g, "."), r4 = i2.default.getMacOSVersionName(t2), n4 = { name: s2.OS_MAP.MacOS, version: t2 };
            return r4 && (n4.versionName = r4), n4;
          } }, { test: [/(ipod|iphone|ipad)/i], describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e3).replace(/[_\s]/g, ".");
            return { name: s2.OS_MAP.iOS, version: t2 };
          } }, { test: function(e3) {
            var t2 = !e3.test(/like android/i), r4 = e3.test(/android/i);
            return t2 && r4;
          }, describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e3), r4 = i2.default.getAndroidVersionName(t2), n4 = { name: s2.OS_MAP.Android, version: t2 };
            return r4 && (n4.versionName = r4), n4;
          } }, { test: [/(web|hpw)[o0]s/i], describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e3), r4 = { name: s2.OS_MAP.WebOS };
            return t2 && t2.length && (r4.version = t2), r4;
          } }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e3) || i2.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e3) || i2.default.getFirstMatch(/\bbb(\d+)/i, e3);
            return { name: s2.OS_MAP.BlackBerry, version: t2 };
          } }, { test: [/bada/i], describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e3);
            return { name: s2.OS_MAP.Bada, version: t2 };
          } }, { test: [/tizen/i], describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e3);
            return { name: s2.OS_MAP.Tizen, version: t2 };
          } }, { test: [/linux/i], describe: function() {
            return { name: s2.OS_MAP.Linux };
          } }, { test: [/CrOS/], describe: function() {
            return { name: s2.OS_MAP.ChromeOS };
          } }, { test: [/PlayStation 4/], describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e3);
            return { name: s2.OS_MAP.PlayStation4, version: t2 };
          } }];
          t.default = a2, e2.exports = t.default;
        }, 94: function(e2, t, r3) {
          "use strict";
          t.__esModule = true, t.default = void 0;
          var n3, i2 = (n3 = r3(17)) && n3.__esModule ? n3 : { default: n3 }, s2 = r3(18);
          var a2 = [{ test: [/googlebot/i], describe: function() {
            return { type: "bot", vendor: "Google" };
          } }, { test: [/huawei/i], describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/(can-l01)/i, e3) && "Nova", r4 = { type: s2.PLATFORMS_MAP.mobile, vendor: "Huawei" };
            return t2 && (r4.model = t2), r4;
          } }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: function() {
            return { type: s2.PLATFORMS_MAP.tablet, vendor: "Nexus" };
          } }, { test: [/ipad/i], describe: function() {
            return { type: s2.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
          } }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: function() {
            return { type: s2.PLATFORMS_MAP.tablet, vendor: "Apple", model: "iPad" };
          } }, { test: [/kftt build/i], describe: function() {
            return { type: s2.PLATFORMS_MAP.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" };
          } }, { test: [/silk/i], describe: function() {
            return { type: s2.PLATFORMS_MAP.tablet, vendor: "Amazon" };
          } }, { test: [/tablet(?! pc)/i], describe: function() {
            return { type: s2.PLATFORMS_MAP.tablet };
          } }, { test: function(e3) {
            var t2 = e3.test(/ipod|iphone/i), r4 = e3.test(/like (ipod|iphone)/i);
            return t2 && !r4;
          }, describe: function(e3) {
            var t2 = i2.default.getFirstMatch(/(ipod|iphone)/i, e3);
            return { type: s2.PLATFORMS_MAP.mobile, vendor: "Apple", model: t2 };
          } }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: function() {
            return { type: s2.PLATFORMS_MAP.mobile, vendor: "Nexus" };
          } }, { test: [/[^-]mobi/i], describe: function() {
            return { type: s2.PLATFORMS_MAP.mobile };
          } }, { test: function(e3) {
            return "blackberry" === e3.getBrowserName(true);
          }, describe: function() {
            return { type: s2.PLATFORMS_MAP.mobile, vendor: "BlackBerry" };
          } }, { test: function(e3) {
            return "bada" === e3.getBrowserName(true);
          }, describe: function() {
            return { type: s2.PLATFORMS_MAP.mobile };
          } }, { test: function(e3) {
            return "windows phone" === e3.getBrowserName();
          }, describe: function() {
            return { type: s2.PLATFORMS_MAP.mobile, vendor: "Microsoft" };
          } }, { test: function(e3) {
            var t2 = Number(String(e3.getOSVersion()).split(".")[0]);
            return "android" === e3.getOSName(true) && t2 >= 3;
          }, describe: function() {
            return { type: s2.PLATFORMS_MAP.tablet };
          } }, { test: function(e3) {
            return "android" === e3.getOSName(true);
          }, describe: function() {
            return { type: s2.PLATFORMS_MAP.mobile };
          } }, { test: function(e3) {
            return "macos" === e3.getOSName(true);
          }, describe: function() {
            return { type: s2.PLATFORMS_MAP.desktop, vendor: "Apple" };
          } }, { test: function(e3) {
            return "windows" === e3.getOSName(true);
          }, describe: function() {
            return { type: s2.PLATFORMS_MAP.desktop };
          } }, { test: function(e3) {
            return "linux" === e3.getOSName(true);
          }, describe: function() {
            return { type: s2.PLATFORMS_MAP.desktop };
          } }, { test: function(e3) {
            return "playstation 4" === e3.getOSName(true);
          }, describe: function() {
            return { type: s2.PLATFORMS_MAP.tv };
          } }, { test: function(e3) {
            return "roku" === e3.getOSName(true);
          }, describe: function() {
            return { type: s2.PLATFORMS_MAP.tv };
          } }];
          t.default = a2, e2.exports = t.default;
        }, 95: function(e2, t, r3) {
          "use strict";
          t.__esModule = true, t.default = void 0;
          var n3, i2 = (n3 = r3(17)) && n3.__esModule ? n3 : { default: n3 }, s2 = r3(18);
          var a2 = [{ test: function(e3) {
            return "microsoft edge" === e3.getBrowserName(true);
          }, describe: function(e3) {
            if (/\sedg\//i.test(e3)) return { name: s2.ENGINE_MAP.Blink };
            var t2 = i2.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e3);
            return { name: s2.ENGINE_MAP.EdgeHTML, version: t2 };
          } }, { test: [/trident/i], describe: function(e3) {
            var t2 = { name: s2.ENGINE_MAP.Trident }, r4 = i2.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: function(e3) {
            return e3.test(/presto/i);
          }, describe: function(e3) {
            var t2 = { name: s2.ENGINE_MAP.Presto }, r4 = i2.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: function(e3) {
            var t2 = e3.test(/gecko/i), r4 = e3.test(/like gecko/i);
            return t2 && !r4;
          }, describe: function(e3) {
            var t2 = { name: s2.ENGINE_MAP.Gecko }, r4 = i2.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }, { test: [/(apple)?webkit\/537\.36/i], describe: function() {
            return { name: s2.ENGINE_MAP.Blink };
          } }, { test: [/(apple)?webkit/i], describe: function(e3) {
            var t2 = { name: s2.ENGINE_MAP.WebKit }, r4 = i2.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e3);
            return r4 && (t2.version = r4), t2;
          } }];
          t.default = a2, e2.exports = t.default;
        } });
      });
    }
  });

  // node_modules/qr-code-styling/lib/qr-code-styling.js
  var require_qr_code_styling = __commonJS({
    "node_modules/qr-code-styling/lib/qr-code-styling.js"(exports, module) {
      init_polyfills();
      !function(t, e2) {
        "object" == typeof exports && "object" == typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define([], e2) : "object" == typeof exports ? exports.QRCodeStyling = e2() : t.QRCodeStyling = e2();
      }(self, function() {
        return (() => {
          var t = { 192: (t2, e3) => {
            var r4, n3, o3 = function() {
              var t3 = function(t4, e5) {
                var r6 = t4, n5 = a2[e5], o5 = null, i3 = 0, u4 = null, v4 = [], w4 = {}, m3 = function(t5, e6) {
                  o5 = function(t6) {
                    for (var e7 = new Array(t6), r7 = 0; r7 < t6; r7 += 1) {
                      e7[r7] = new Array(t6);
                      for (var n6 = 0; n6 < t6; n6 += 1) e7[r7][n6] = null;
                    }
                    return e7;
                  }(i3 = 4 * r6 + 17), b3(0, 0), b3(i3 - 7, 0), b3(0, i3 - 7), x3(), _3(), M3(t5, e6), r6 >= 7 && S3(t5), null == u4 && (u4 = A3(r6, n5, v4)), C3(u4, e6);
                }, b3 = function(t5, e6) {
                  for (var r7 = -1; r7 <= 7; r7 += 1) if (!(t5 + r7 <= -1 || i3 <= t5 + r7)) for (var n6 = -1; n6 <= 7; n6 += 1) e6 + n6 <= -1 || i3 <= e6 + n6 || (o5[t5 + r7][e6 + n6] = 0 <= r7 && r7 <= 6 && (0 == n6 || 6 == n6) || 0 <= n6 && n6 <= 6 && (0 == r7 || 6 == r7) || 2 <= r7 && r7 <= 4 && 2 <= n6 && n6 <= 4);
                }, _3 = function() {
                  for (var t5 = 8; t5 < i3 - 8; t5 += 1) null == o5[t5][6] && (o5[t5][6] = t5 % 2 == 0);
                  for (var e6 = 8; e6 < i3 - 8; e6 += 1) null == o5[6][e6] && (o5[6][e6] = e6 % 2 == 0);
                }, x3 = function() {
                  for (var t5 = s2.getPatternPosition(r6), e6 = 0; e6 < t5.length; e6 += 1) for (var n6 = 0; n6 < t5.length; n6 += 1) {
                    var i4 = t5[e6], a3 = t5[n6];
                    if (null == o5[i4][a3]) for (var u5 = -2; u5 <= 2; u5 += 1) for (var h4 = -2; h4 <= 2; h4 += 1) o5[i4 + u5][a3 + h4] = -2 == u5 || 2 == u5 || -2 == h4 || 2 == h4 || 0 == u5 && 0 == h4;
                  }
                }, S3 = function(t5) {
                  for (var e6 = s2.getBCHTypeNumber(r6), n6 = 0; n6 < 18; n6 += 1) {
                    var a3 = !t5 && 1 == (e6 >> n6 & 1);
                    o5[Math.floor(n6 / 3)][n6 % 3 + i3 - 8 - 3] = a3;
                  }
                  for (n6 = 0; n6 < 18; n6 += 1) a3 = !t5 && 1 == (e6 >> n6 & 1), o5[n6 % 3 + i3 - 8 - 3][Math.floor(n6 / 3)] = a3;
                }, M3 = function(t5, e6) {
                  for (var r7 = n5 << 3 | e6, a3 = s2.getBCHTypeInfo(r7), u5 = 0; u5 < 15; u5 += 1) {
                    var h4 = !t5 && 1 == (a3 >> u5 & 1);
                    u5 < 6 ? o5[u5][8] = h4 : u5 < 8 ? o5[u5 + 1][8] = h4 : o5[i3 - 15 + u5][8] = h4;
                  }
                  for (u5 = 0; u5 < 15; u5 += 1) h4 = !t5 && 1 == (a3 >> u5 & 1), u5 < 8 ? o5[8][i3 - u5 - 1] = h4 : u5 < 9 ? o5[8][15 - u5 - 1 + 1] = h4 : o5[8][15 - u5 - 1] = h4;
                  o5[i3 - 8][8] = !t5;
                }, C3 = function(t5, e6) {
                  for (var r7 = -1, n6 = i3 - 1, a3 = 7, u5 = 0, h4 = s2.getMaskFunction(e6), c3 = i3 - 1; c3 > 0; c3 -= 2) for (6 == c3 && (c3 -= 1); ; ) {
                    for (var l3 = 0; l3 < 2; l3 += 1) if (null == o5[n6][c3 - l3]) {
                      var d3 = false;
                      u5 < t5.length && (d3 = 1 == (t5[u5] >>> a3 & 1)), h4(n6, c3 - l3) && (d3 = !d3), o5[n6][c3 - l3] = d3, -1 == (a3 -= 1) && (u5 += 1, a3 = 7);
                    }
                    if ((n6 += r7) < 0 || i3 <= n6) {
                      n6 -= r7, r7 = -r7;
                      break;
                    }
                  }
                }, A3 = function(t5, e6, r7) {
                  for (var n6 = c2.getRSBlocks(t5, e6), o6 = l2(), i4 = 0; i4 < r7.length; i4 += 1) {
                    var a3 = r7[i4];
                    o6.put(a3.getMode(), 4), o6.put(a3.getLength(), s2.getLengthInBits(a3.getMode(), t5)), a3.write(o6);
                  }
                  var u5 = 0;
                  for (i4 = 0; i4 < n6.length; i4 += 1) u5 += n6[i4].dataCount;
                  if (o6.getLengthInBits() > 8 * u5) throw "code length overflow. (" + o6.getLengthInBits() + ">" + 8 * u5 + ")";
                  for (o6.getLengthInBits() + 4 <= 8 * u5 && o6.put(0, 4); o6.getLengthInBits() % 8 != 0; ) o6.putBit(false);
                  for (; !(o6.getLengthInBits() >= 8 * u5 || (o6.put(236, 8), o6.getLengthInBits() >= 8 * u5)); ) o6.put(17, 8);
                  return function(t6, e7) {
                    for (var r8 = 0, n7 = 0, o7 = 0, i5 = new Array(e7.length), a4 = new Array(e7.length), u6 = 0; u6 < e7.length; u6 += 1) {
                      var c3 = e7[u6].dataCount, l3 = e7[u6].totalCount - c3;
                      n7 = Math.max(n7, c3), o7 = Math.max(o7, l3), i5[u6] = new Array(c3);
                      for (var d3 = 0; d3 < i5[u6].length; d3 += 1) i5[u6][d3] = 255 & t6.getBuffer()[d3 + r8];
                      r8 += c3;
                      var f4 = s2.getErrorCorrectPolynomial(l3), g4 = h3(i5[u6], f4.getLength() - 1).mod(f4);
                      for (a4[u6] = new Array(f4.getLength() - 1), d3 = 0; d3 < a4[u6].length; d3 += 1) {
                        var p3 = d3 + g4.getLength() - a4[u6].length;
                        a4[u6][d3] = p3 >= 0 ? g4.getAt(p3) : 0;
                      }
                    }
                    var v5 = 0;
                    for (d3 = 0; d3 < e7.length; d3 += 1) v5 += e7[d3].totalCount;
                    var w5 = new Array(v5), y4 = 0;
                    for (d3 = 0; d3 < n7; d3 += 1) for (u6 = 0; u6 < e7.length; u6 += 1) d3 < i5[u6].length && (w5[y4] = i5[u6][d3], y4 += 1);
                    for (d3 = 0; d3 < o7; d3 += 1) for (u6 = 0; u6 < e7.length; u6 += 1) d3 < a4[u6].length && (w5[y4] = a4[u6][d3], y4 += 1);
                    return w5;
                  }(o6, n6);
                };
                w4.addData = function(t5, e6) {
                  var r7 = null;
                  switch (e6 = e6 || "Byte") {
                    case "Numeric":
                      r7 = d2(t5);
                      break;
                    case "Alphanumeric":
                      r7 = f3(t5);
                      break;
                    case "Byte":
                      r7 = g3(t5);
                      break;
                    case "Kanji":
                      r7 = p2(t5);
                      break;
                    default:
                      throw "mode:" + e6;
                  }
                  v4.push(r7), u4 = null;
                }, w4.isDark = function(t5, e6) {
                  if (t5 < 0 || i3 <= t5 || e6 < 0 || i3 <= e6) throw t5 + "," + e6;
                  return o5[t5][e6];
                }, w4.getModuleCount = function() {
                  return i3;
                }, w4.make = function() {
                  if (r6 < 1) {
                    for (var t5 = 1; t5 < 40; t5++) {
                      for (var e6 = c2.getRSBlocks(t5, n5), o6 = l2(), i4 = 0; i4 < v4.length; i4++) {
                        var a3 = v4[i4];
                        o6.put(a3.getMode(), 4), o6.put(a3.getLength(), s2.getLengthInBits(a3.getMode(), t5)), a3.write(o6);
                      }
                      var u5 = 0;
                      for (i4 = 0; i4 < e6.length; i4++) u5 += e6[i4].dataCount;
                      if (o6.getLengthInBits() <= 8 * u5) break;
                    }
                    r6 = t5;
                  }
                  m3(false, function() {
                    for (var t6 = 0, e7 = 0, r7 = 0; r7 < 8; r7 += 1) {
                      m3(true, r7);
                      var n6 = s2.getLostPoint(w4);
                      (0 == r7 || t6 > n6) && (t6 = n6, e7 = r7);
                    }
                    return e7;
                  }());
                }, w4.createTableTag = function(t5, e6) {
                  t5 = t5 || 2;
                  var r7 = "";
                  r7 += '<table style="', r7 += " border-width: 0px; border-style: none;", r7 += " border-collapse: collapse;", r7 += " padding: 0px; margin: " + (e6 = void 0 === e6 ? 4 * t5 : e6) + "px;", r7 += '">', r7 += "<tbody>";
                  for (var n6 = 0; n6 < w4.getModuleCount(); n6 += 1) {
                    r7 += "<tr>";
                    for (var o6 = 0; o6 < w4.getModuleCount(); o6 += 1) r7 += '<td style="', r7 += " border-width: 0px; border-style: none;", r7 += " border-collapse: collapse;", r7 += " padding: 0px; margin: 0px;", r7 += " width: " + t5 + "px;", r7 += " height: " + t5 + "px;", r7 += " background-color: ", r7 += w4.isDark(n6, o6) ? "#000000" : "#ffffff", r7 += ";", r7 += '"/>';
                    r7 += "</tr>";
                  }
                  return (r7 += "</tbody>") + "</table>";
                }, w4.createSvgTag = function(t5, e6, r7, n6) {
                  var o6 = {};
                  "object" == typeof arguments[0] && (t5 = (o6 = arguments[0]).cellSize, e6 = o6.margin, r7 = o6.alt, n6 = o6.title), t5 = t5 || 2, e6 = void 0 === e6 ? 4 * t5 : e6, (r7 = "string" == typeof r7 ? { text: r7 } : r7 || {}).text = r7.text || null, r7.id = r7.text ? r7.id || "qrcode-description" : null, (n6 = "string" == typeof n6 ? { text: n6 } : n6 || {}).text = n6.text || null, n6.id = n6.text ? n6.id || "qrcode-title" : null;
                  var i4, a3, s3, u5, h4 = w4.getModuleCount() * t5 + 2 * e6, c3 = "";
                  for (u5 = "l" + t5 + ",0 0," + t5 + " -" + t5 + ",0 0,-" + t5 + "z ", c3 += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', c3 += o6.scalable ? "" : ' width="' + h4 + 'px" height="' + h4 + 'px"', c3 += ' viewBox="0 0 ' + h4 + " " + h4 + '" ', c3 += ' preserveAspectRatio="xMinYMin meet"', c3 += n6.text || r7.text ? ' role="img" aria-labelledby="' + k3([n6.id, r7.id].join(" ").trim()) + '"' : "", c3 += ">", c3 += n6.text ? '<title id="' + k3(n6.id) + '">' + k3(n6.text) + "</title>" : "", c3 += r7.text ? '<description id="' + k3(r7.id) + '">' + k3(r7.text) + "</description>" : "", c3 += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', c3 += '<path d="', a3 = 0; a3 < w4.getModuleCount(); a3 += 1) for (s3 = a3 * t5 + e6, i4 = 0; i4 < w4.getModuleCount(); i4 += 1) w4.isDark(a3, i4) && (c3 += "M" + (i4 * t5 + e6) + "," + s3 + u5);
                  return (c3 += '" stroke="transparent" fill="black"/>') + "</svg>";
                }, w4.createDataURL = function(t5, e6) {
                  t5 = t5 || 2, e6 = void 0 === e6 ? 4 * t5 : e6;
                  var r7 = w4.getModuleCount() * t5 + 2 * e6, n6 = e6, o6 = r7 - e6;
                  return y3(r7, r7, function(e7, r8) {
                    if (n6 <= e7 && e7 < o6 && n6 <= r8 && r8 < o6) {
                      var i4 = Math.floor((e7 - n6) / t5), a3 = Math.floor((r8 - n6) / t5);
                      return w4.isDark(a3, i4) ? 0 : 1;
                    }
                    return 1;
                  });
                }, w4.createImgTag = function(t5, e6, r7) {
                  t5 = t5 || 2, e6 = void 0 === e6 ? 4 * t5 : e6;
                  var n6 = w4.getModuleCount() * t5 + 2 * e6, o6 = "";
                  return o6 += "<img", o6 += ' src="', o6 += w4.createDataURL(t5, e6), o6 += '"', o6 += ' width="', o6 += n6, o6 += '"', o6 += ' height="', o6 += n6, o6 += '"', r7 && (o6 += ' alt="', o6 += k3(r7), o6 += '"'), o6 + "/>";
                };
                var k3 = function(t5) {
                  for (var e6 = "", r7 = 0; r7 < t5.length; r7 += 1) {
                    var n6 = t5.charAt(r7);
                    switch (n6) {
                      case "<":
                        e6 += "&lt;";
                        break;
                      case ">":
                        e6 += "&gt;";
                        break;
                      case "&":
                        e6 += "&amp;";
                        break;
                      case '"':
                        e6 += "&quot;";
                        break;
                      default:
                        e6 += n6;
                    }
                  }
                  return e6;
                };
                return w4.createASCII = function(t5, e6) {
                  if ((t5 = t5 || 1) < 2) return function(t6) {
                    t6 = void 0 === t6 ? 2 : t6;
                    var e7, r8, n7, o7, i5, a4 = 1 * w4.getModuleCount() + 2 * t6, s4 = t6, u6 = a4 - t6, h5 = { "\u2588\u2588": "\u2588", "\u2588 ": "\u2580", " \u2588": "\u2584", "  ": " " }, c4 = { "\u2588\u2588": "\u2580", "\u2588 ": "\u2580", " \u2588": " ", "  ": " " }, l4 = "";
                    for (e7 = 0; e7 < a4; e7 += 2) {
                      for (n7 = Math.floor((e7 - s4) / 1), o7 = Math.floor((e7 + 1 - s4) / 1), r8 = 0; r8 < a4; r8 += 1) i5 = "\u2588", s4 <= r8 && r8 < u6 && s4 <= e7 && e7 < u6 && w4.isDark(n7, Math.floor((r8 - s4) / 1)) && (i5 = " "), s4 <= r8 && r8 < u6 && s4 <= e7 + 1 && e7 + 1 < u6 && w4.isDark(o7, Math.floor((r8 - s4) / 1)) ? i5 += " " : i5 += "\u2588", l4 += t6 < 1 && e7 + 1 >= u6 ? c4[i5] : h5[i5];
                      l4 += "\n";
                    }
                    return a4 % 2 && t6 > 0 ? l4.substring(0, l4.length - a4 - 1) + Array(a4 + 1).join("\u2580") : l4.substring(0, l4.length - 1);
                  }(e6);
                  t5 -= 1, e6 = void 0 === e6 ? 2 * t5 : e6;
                  var r7, n6, o6, i4, a3 = w4.getModuleCount() * t5 + 2 * e6, s3 = e6, u5 = a3 - e6, h4 = Array(t5 + 1).join("\u2588\u2588"), c3 = Array(t5 + 1).join("  "), l3 = "", d3 = "";
                  for (r7 = 0; r7 < a3; r7 += 1) {
                    for (o6 = Math.floor((r7 - s3) / t5), d3 = "", n6 = 0; n6 < a3; n6 += 1) i4 = 1, s3 <= n6 && n6 < u5 && s3 <= r7 && r7 < u5 && w4.isDark(o6, Math.floor((n6 - s3) / t5)) && (i4 = 0), d3 += i4 ? h4 : c3;
                    for (o6 = 0; o6 < t5; o6 += 1) l3 += d3 + "\n";
                  }
                  return l3.substring(0, l3.length - 1);
                }, w4.renderTo2dContext = function(t5, e6) {
                  e6 = e6 || 2;
                  for (var r7 = w4.getModuleCount(), n6 = 0; n6 < r7; n6++) for (var o6 = 0; o6 < r7; o6++) t5.fillStyle = w4.isDark(n6, o6) ? "black" : "white", t5.fillRect(n6 * e6, o6 * e6, e6, e6);
                }, w4;
              };
              t3.stringToBytes = (t3.stringToBytesFuncs = { default: function(t4) {
                for (var e5 = [], r6 = 0; r6 < t4.length; r6 += 1) {
                  var n5 = t4.charCodeAt(r6);
                  e5.push(255 & n5);
                }
                return e5;
              } }).default, t3.createStringToBytes = function(t4, e5) {
                var r6 = function() {
                  for (var r7 = w3(t4), n6 = function() {
                    var t5 = r7.read();
                    if (-1 == t5) throw "eof";
                    return t5;
                  }, o5 = 0, i3 = {}; ; ) {
                    var a3 = r7.read();
                    if (-1 == a3) break;
                    var s3 = n6(), u4 = n6() << 8 | n6();
                    i3[String.fromCharCode(a3 << 8 | s3)] = u4, o5 += 1;
                  }
                  if (o5 != e5) throw o5 + " != " + e5;
                  return i3;
                }(), n5 = "?".charCodeAt(0);
                return function(t5) {
                  for (var e6 = [], o5 = 0; o5 < t5.length; o5 += 1) {
                    var i3 = t5.charCodeAt(o5);
                    if (i3 < 128) e6.push(i3);
                    else {
                      var a3 = r6[t5.charAt(o5)];
                      "number" == typeof a3 ? (255 & a3) == a3 ? e6.push(a3) : (e6.push(a3 >>> 8), e6.push(255 & a3)) : e6.push(n5);
                    }
                  }
                  return e6;
                };
              };
              var e4, r5, n4, o4, i2, a2 = { L: 1, M: 0, Q: 3, H: 2 }, s2 = (e4 = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], r5 = 1335, n4 = 7973, i2 = function(t4) {
                for (var e5 = 0; 0 != t4; ) e5 += 1, t4 >>>= 1;
                return e5;
              }, (o4 = {}).getBCHTypeInfo = function(t4) {
                for (var e5 = t4 << 10; i2(e5) - i2(r5) >= 0; ) e5 ^= r5 << i2(e5) - i2(r5);
                return 21522 ^ (t4 << 10 | e5);
              }, o4.getBCHTypeNumber = function(t4) {
                for (var e5 = t4 << 12; i2(e5) - i2(n4) >= 0; ) e5 ^= n4 << i2(e5) - i2(n4);
                return t4 << 12 | e5;
              }, o4.getPatternPosition = function(t4) {
                return e4[t4 - 1];
              }, o4.getMaskFunction = function(t4) {
                switch (t4) {
                  case 0:
                    return function(t5, e5) {
                      return (t5 + e5) % 2 == 0;
                    };
                  case 1:
                    return function(t5, e5) {
                      return t5 % 2 == 0;
                    };
                  case 2:
                    return function(t5, e5) {
                      return e5 % 3 == 0;
                    };
                  case 3:
                    return function(t5, e5) {
                      return (t5 + e5) % 3 == 0;
                    };
                  case 4:
                    return function(t5, e5) {
                      return (Math.floor(t5 / 2) + Math.floor(e5 / 3)) % 2 == 0;
                    };
                  case 5:
                    return function(t5, e5) {
                      return t5 * e5 % 2 + t5 * e5 % 3 == 0;
                    };
                  case 6:
                    return function(t5, e5) {
                      return (t5 * e5 % 2 + t5 * e5 % 3) % 2 == 0;
                    };
                  case 7:
                    return function(t5, e5) {
                      return (t5 * e5 % 3 + (t5 + e5) % 2) % 2 == 0;
                    };
                  default:
                    throw "bad maskPattern:" + t4;
                }
              }, o4.getErrorCorrectPolynomial = function(t4) {
                for (var e5 = h3([1], 0), r6 = 0; r6 < t4; r6 += 1) e5 = e5.multiply(h3([1, u3.gexp(r6)], 0));
                return e5;
              }, o4.getLengthInBits = function(t4, e5) {
                if (1 <= e5 && e5 < 10) switch (t4) {
                  case 1:
                    return 10;
                  case 2:
                    return 9;
                  case 4:
                  case 8:
                    return 8;
                  default:
                    throw "mode:" + t4;
                }
                else if (e5 < 27) switch (t4) {
                  case 1:
                    return 12;
                  case 2:
                    return 11;
                  case 4:
                    return 16;
                  case 8:
                    return 10;
                  default:
                    throw "mode:" + t4;
                }
                else {
                  if (!(e5 < 41)) throw "type:" + e5;
                  switch (t4) {
                    case 1:
                      return 14;
                    case 2:
                      return 13;
                    case 4:
                      return 16;
                    case 8:
                      return 12;
                    default:
                      throw "mode:" + t4;
                  }
                }
              }, o4.getLostPoint = function(t4) {
                for (var e5 = t4.getModuleCount(), r6 = 0, n5 = 0; n5 < e5; n5 += 1) for (var o5 = 0; o5 < e5; o5 += 1) {
                  for (var i3 = 0, a3 = t4.isDark(n5, o5), s3 = -1; s3 <= 1; s3 += 1) if (!(n5 + s3 < 0 || e5 <= n5 + s3)) for (var u4 = -1; u4 <= 1; u4 += 1) o5 + u4 < 0 || e5 <= o5 + u4 || 0 == s3 && 0 == u4 || a3 == t4.isDark(n5 + s3, o5 + u4) && (i3 += 1);
                  i3 > 5 && (r6 += 3 + i3 - 5);
                }
                for (n5 = 0; n5 < e5 - 1; n5 += 1) for (o5 = 0; o5 < e5 - 1; o5 += 1) {
                  var h4 = 0;
                  t4.isDark(n5, o5) && (h4 += 1), t4.isDark(n5 + 1, o5) && (h4 += 1), t4.isDark(n5, o5 + 1) && (h4 += 1), t4.isDark(n5 + 1, o5 + 1) && (h4 += 1), 0 != h4 && 4 != h4 || (r6 += 3);
                }
                for (n5 = 0; n5 < e5; n5 += 1) for (o5 = 0; o5 < e5 - 6; o5 += 1) t4.isDark(n5, o5) && !t4.isDark(n5, o5 + 1) && t4.isDark(n5, o5 + 2) && t4.isDark(n5, o5 + 3) && t4.isDark(n5, o5 + 4) && !t4.isDark(n5, o5 + 5) && t4.isDark(n5, o5 + 6) && (r6 += 40);
                for (o5 = 0; o5 < e5; o5 += 1) for (n5 = 0; n5 < e5 - 6; n5 += 1) t4.isDark(n5, o5) && !t4.isDark(n5 + 1, o5) && t4.isDark(n5 + 2, o5) && t4.isDark(n5 + 3, o5) && t4.isDark(n5 + 4, o5) && !t4.isDark(n5 + 5, o5) && t4.isDark(n5 + 6, o5) && (r6 += 40);
                var c3 = 0;
                for (o5 = 0; o5 < e5; o5 += 1) for (n5 = 0; n5 < e5; n5 += 1) t4.isDark(n5, o5) && (c3 += 1);
                return r6 + Math.abs(100 * c3 / e5 / e5 - 50) / 5 * 10;
              }, o4), u3 = function() {
                for (var t4 = new Array(256), e5 = new Array(256), r6 = 0; r6 < 8; r6 += 1) t4[r6] = 1 << r6;
                for (r6 = 8; r6 < 256; r6 += 1) t4[r6] = t4[r6 - 4] ^ t4[r6 - 5] ^ t4[r6 - 6] ^ t4[r6 - 8];
                for (r6 = 0; r6 < 255; r6 += 1) e5[t4[r6]] = r6;
                return { glog: function(t5) {
                  if (t5 < 1) throw "glog(" + t5 + ")";
                  return e5[t5];
                }, gexp: function(e6) {
                  for (; e6 < 0; ) e6 += 255;
                  for (; e6 >= 256; ) e6 -= 255;
                  return t4[e6];
                } };
              }();
              function h3(t4, e5) {
                if (void 0 === t4.length) throw t4.length + "/" + e5;
                var r6 = function() {
                  for (var r7 = 0; r7 < t4.length && 0 == t4[r7]; ) r7 += 1;
                  for (var n6 = new Array(t4.length - r7 + e5), o5 = 0; o5 < t4.length - r7; o5 += 1) n6[o5] = t4[o5 + r7];
                  return n6;
                }(), n5 = { getAt: function(t5) {
                  return r6[t5];
                }, getLength: function() {
                  return r6.length;
                }, multiply: function(t5) {
                  for (var e6 = new Array(n5.getLength() + t5.getLength() - 1), r7 = 0; r7 < n5.getLength(); r7 += 1) for (var o5 = 0; o5 < t5.getLength(); o5 += 1) e6[r7 + o5] ^= u3.gexp(u3.glog(n5.getAt(r7)) + u3.glog(t5.getAt(o5)));
                  return h3(e6, 0);
                }, mod: function(t5) {
                  if (n5.getLength() - t5.getLength() < 0) return n5;
                  for (var e6 = u3.glog(n5.getAt(0)) - u3.glog(t5.getAt(0)), r7 = new Array(n5.getLength()), o5 = 0; o5 < n5.getLength(); o5 += 1) r7[o5] = n5.getAt(o5);
                  for (o5 = 0; o5 < t5.getLength(); o5 += 1) r7[o5] ^= u3.gexp(u3.glog(t5.getAt(o5)) + e6);
                  return h3(r7, 0).mod(t5);
                } };
                return n5;
              }
              var c2 = /* @__PURE__ */ function() {
                var t4 = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], e5 = function(t5, e6) {
                  var r7 = {};
                  return r7.totalCount = t5, r7.dataCount = e6, r7;
                }, r6 = { getRSBlocks: function(r7, n5) {
                  var o5 = function(e6, r8) {
                    switch (r8) {
                      case a2.L:
                        return t4[4 * (e6 - 1) + 0];
                      case a2.M:
                        return t4[4 * (e6 - 1) + 1];
                      case a2.Q:
                        return t4[4 * (e6 - 1) + 2];
                      case a2.H:
                        return t4[4 * (e6 - 1) + 3];
                      default:
                        return;
                    }
                  }(r7, n5);
                  if (void 0 === o5) throw "bad rs block @ typeNumber:" + r7 + "/errorCorrectionLevel:" + n5;
                  for (var i3 = o5.length / 3, s3 = [], u4 = 0; u4 < i3; u4 += 1) for (var h4 = o5[3 * u4 + 0], c3 = o5[3 * u4 + 1], l3 = o5[3 * u4 + 2], d3 = 0; d3 < h4; d3 += 1) s3.push(e5(c3, l3));
                  return s3;
                } };
                return r6;
              }(), l2 = function() {
                var t4 = [], e5 = 0, r6 = { getBuffer: function() {
                  return t4;
                }, getAt: function(e6) {
                  var r7 = Math.floor(e6 / 8);
                  return 1 == (t4[r7] >>> 7 - e6 % 8 & 1);
                }, put: function(t5, e6) {
                  for (var n5 = 0; n5 < e6; n5 += 1) r6.putBit(1 == (t5 >>> e6 - n5 - 1 & 1));
                }, getLengthInBits: function() {
                  return e5;
                }, putBit: function(r7) {
                  var n5 = Math.floor(e5 / 8);
                  t4.length <= n5 && t4.push(0), r7 && (t4[n5] |= 128 >>> e5 % 8), e5 += 1;
                } };
                return r6;
              }, d2 = function(t4) {
                var e5 = t4, r6 = { getMode: function() {
                  return 1;
                }, getLength: function(t5) {
                  return e5.length;
                }, write: function(t5) {
                  for (var r7 = e5, o6 = 0; o6 + 2 < r7.length; ) t5.put(n5(r7.substring(o6, o6 + 3)), 10), o6 += 3;
                  o6 < r7.length && (r7.length - o6 == 1 ? t5.put(n5(r7.substring(o6, o6 + 1)), 4) : r7.length - o6 == 2 && t5.put(n5(r7.substring(o6, o6 + 2)), 7));
                } }, n5 = function(t5) {
                  for (var e6 = 0, r7 = 0; r7 < t5.length; r7 += 1) e6 = 10 * e6 + o5(t5.charAt(r7));
                  return e6;
                }, o5 = function(t5) {
                  if ("0" <= t5 && t5 <= "9") return t5.charCodeAt(0) - "0".charCodeAt(0);
                  throw "illegal char :" + t5;
                };
                return r6;
              }, f3 = function(t4) {
                var e5 = t4, r6 = { getMode: function() {
                  return 2;
                }, getLength: function(t5) {
                  return e5.length;
                }, write: function(t5) {
                  for (var r7 = e5, o5 = 0; o5 + 1 < r7.length; ) t5.put(45 * n5(r7.charAt(o5)) + n5(r7.charAt(o5 + 1)), 11), o5 += 2;
                  o5 < r7.length && t5.put(n5(r7.charAt(o5)), 6);
                } }, n5 = function(t5) {
                  if ("0" <= t5 && t5 <= "9") return t5.charCodeAt(0) - "0".charCodeAt(0);
                  if ("A" <= t5 && t5 <= "Z") return t5.charCodeAt(0) - "A".charCodeAt(0) + 10;
                  switch (t5) {
                    case " ":
                      return 36;
                    case "$":
                      return 37;
                    case "%":
                      return 38;
                    case "*":
                      return 39;
                    case "+":
                      return 40;
                    case "-":
                      return 41;
                    case ".":
                      return 42;
                    case "/":
                      return 43;
                    case ":":
                      return 44;
                    default:
                      throw "illegal char :" + t5;
                  }
                };
                return r6;
              }, g3 = function(e5) {
                var r6 = t3.stringToBytes(e5);
                return { getMode: function() {
                  return 4;
                }, getLength: function(t4) {
                  return r6.length;
                }, write: function(t4) {
                  for (var e6 = 0; e6 < r6.length; e6 += 1) t4.put(r6[e6], 8);
                } };
              }, p2 = function(e5) {
                var r6 = t3.stringToBytesFuncs.SJIS;
                if (!r6) throw "sjis not supported.";
                !function(t4, e6) {
                  var n6 = r6("\u53CB");
                  if (2 != n6.length || 38726 != (n6[0] << 8 | n6[1])) throw "sjis not supported.";
                }();
                var n5 = r6(e5);
                return { getMode: function() {
                  return 8;
                }, getLength: function(t4) {
                  return ~~(n5.length / 2);
                }, write: function(t4) {
                  for (var e6 = n5, r7 = 0; r7 + 1 < e6.length; ) {
                    var o5 = (255 & e6[r7]) << 8 | 255 & e6[r7 + 1];
                    if (33088 <= o5 && o5 <= 40956) o5 -= 33088;
                    else {
                      if (!(57408 <= o5 && o5 <= 60351)) throw "illegal char at " + (r7 + 1) + "/" + o5;
                      o5 -= 49472;
                    }
                    o5 = 192 * (o5 >>> 8 & 255) + (255 & o5), t4.put(o5, 13), r7 += 2;
                  }
                  if (r7 < e6.length) throw "illegal char at " + (r7 + 1);
                } };
              }, v3 = function() {
                var t4 = [], e5 = { writeByte: function(e6) {
                  t4.push(255 & e6);
                }, writeShort: function(t5) {
                  e5.writeByte(t5), e5.writeByte(t5 >>> 8);
                }, writeBytes: function(t5, r6, n5) {
                  r6 = r6 || 0, n5 = n5 || t5.length;
                  for (var o5 = 0; o5 < n5; o5 += 1) e5.writeByte(t5[o5 + r6]);
                }, writeString: function(t5) {
                  for (var r6 = 0; r6 < t5.length; r6 += 1) e5.writeByte(t5.charCodeAt(r6));
                }, toByteArray: function() {
                  return t4;
                }, toString: function() {
                  var e6 = "";
                  e6 += "[";
                  for (var r6 = 0; r6 < t4.length; r6 += 1) r6 > 0 && (e6 += ","), e6 += t4[r6];
                  return e6 + "]";
                } };
                return e5;
              }, w3 = function(t4) {
                var e5 = t4, r6 = 0, n5 = 0, o5 = 0, i3 = { read: function() {
                  for (; o5 < 8; ) {
                    if (r6 >= e5.length) {
                      if (0 == o5) return -1;
                      throw "unexpected end of file./" + o5;
                    }
                    var t5 = e5.charAt(r6);
                    if (r6 += 1, "=" == t5) return o5 = 0, -1;
                    t5.match(/^\s$/) || (n5 = n5 << 6 | a3(t5.charCodeAt(0)), o5 += 6);
                  }
                  var i4 = n5 >>> o5 - 8 & 255;
                  return o5 -= 8, i4;
                } }, a3 = function(t5) {
                  if (65 <= t5 && t5 <= 90) return t5 - 65;
                  if (97 <= t5 && t5 <= 122) return t5 - 97 + 26;
                  if (48 <= t5 && t5 <= 57) return t5 - 48 + 52;
                  if (43 == t5) return 62;
                  if (47 == t5) return 63;
                  throw "c:" + t5;
                };
                return i3;
              }, y3 = function(t4, e5, r6) {
                for (var n5 = function(t5, e6) {
                  var r7 = t5, n6 = e6, o6 = new Array(t5 * e6), i4 = { setPixel: function(t6, e7, n7) {
                    o6[e7 * r7 + t6] = n7;
                  }, write: function(t6) {
                    t6.writeString("GIF87a"), t6.writeShort(r7), t6.writeShort(n6), t6.writeByte(128), t6.writeByte(0), t6.writeByte(0), t6.writeByte(0), t6.writeByte(0), t6.writeByte(0), t6.writeByte(255), t6.writeByte(255), t6.writeByte(255), t6.writeString(","), t6.writeShort(0), t6.writeShort(0), t6.writeShort(r7), t6.writeShort(n6), t6.writeByte(0);
                    var e7 = a4(2);
                    t6.writeByte(2);
                    for (var o7 = 0; e7.length - o7 > 255; ) t6.writeByte(255), t6.writeBytes(e7, o7, 255), o7 += 255;
                    t6.writeByte(e7.length - o7), t6.writeBytes(e7, o7, e7.length - o7), t6.writeByte(0), t6.writeString(";");
                  } }, a4 = function(t6) {
                    for (var e7 = 1 << t6, r8 = 1 + (1 << t6), n7 = t6 + 1, i5 = s4(), a5 = 0; a5 < e7; a5 += 1) i5.add(String.fromCharCode(a5));
                    i5.add(String.fromCharCode(e7)), i5.add(String.fromCharCode(r8));
                    var u5, h5, c3, l3 = v3(), d3 = (u5 = l3, h5 = 0, c3 = 0, { write: function(t7, e8) {
                      if (t7 >>> e8 != 0) throw "length over";
                      for (; h5 + e8 >= 8; ) u5.writeByte(255 & (t7 << h5 | c3)), e8 -= 8 - h5, t7 >>>= 8 - h5, c3 = 0, h5 = 0;
                      c3 |= t7 << h5, h5 += e8;
                    }, flush: function() {
                      h5 > 0 && u5.writeByte(c3);
                    } });
                    d3.write(e7, n7);
                    var f4 = 0, g4 = String.fromCharCode(o6[f4]);
                    for (f4 += 1; f4 < o6.length; ) {
                      var p3 = String.fromCharCode(o6[f4]);
                      f4 += 1, i5.contains(g4 + p3) ? g4 += p3 : (d3.write(i5.indexOf(g4), n7), i5.size() < 4095 && (i5.size() == 1 << n7 && (n7 += 1), i5.add(g4 + p3)), g4 = p3);
                    }
                    return d3.write(i5.indexOf(g4), n7), d3.write(r8, n7), d3.flush(), l3.toByteArray();
                  }, s4 = function() {
                    var t6 = {}, e7 = 0, r8 = { add: function(n7) {
                      if (r8.contains(n7)) throw "dup key:" + n7;
                      t6[n7] = e7, e7 += 1;
                    }, size: function() {
                      return e7;
                    }, indexOf: function(e8) {
                      return t6[e8];
                    }, contains: function(e8) {
                      return void 0 !== t6[e8];
                    } };
                    return r8;
                  };
                  return i4;
                }(t4, e5), o5 = 0; o5 < e5; o5 += 1) for (var i3 = 0; i3 < t4; i3 += 1) n5.setPixel(i3, o5, r6(i3, o5));
                var a3 = v3();
                n5.write(a3);
                for (var s3 = function() {
                  var t5 = 0, e6 = 0, r7 = 0, n6 = "", o6 = {}, i4 = function(t6) {
                    n6 += String.fromCharCode(a4(63 & t6));
                  }, a4 = function(t6) {
                    if (t6 < 0) ;
                    else {
                      if (t6 < 26) return 65 + t6;
                      if (t6 < 52) return t6 - 26 + 97;
                      if (t6 < 62) return t6 - 52 + 48;
                      if (62 == t6) return 43;
                      if (63 == t6) return 47;
                    }
                    throw "n:" + t6;
                  };
                  return o6.writeByte = function(n7) {
                    for (t5 = t5 << 8 | 255 & n7, e6 += 8, r7 += 1; e6 >= 6; ) i4(t5 >>> e6 - 6), e6 -= 6;
                  }, o6.flush = function() {
                    if (e6 > 0 && (i4(t5 << 6 - e6), t5 = 0, e6 = 0), r7 % 3 != 0) for (var o7 = 3 - r7 % 3, a5 = 0; a5 < o7; a5 += 1) n6 += "=";
                  }, o6.toString = function() {
                    return n6;
                  }, o6;
                }(), u4 = a3.toByteArray(), h4 = 0; h4 < u4.length; h4 += 1) s3.writeByte(u4[h4]);
                return s3.flush(), "data:image/gif;base64," + s3;
              };
              return t3;
            }();
            o3.stringToBytesFuncs["UTF-8"] = function(t3) {
              return function(t4) {
                for (var e4 = [], r5 = 0; r5 < t4.length; r5++) {
                  var n4 = t4.charCodeAt(r5);
                  n4 < 128 ? e4.push(n4) : n4 < 2048 ? e4.push(192 | n4 >> 6, 128 | 63 & n4) : n4 < 55296 || n4 >= 57344 ? e4.push(224 | n4 >> 12, 128 | n4 >> 6 & 63, 128 | 63 & n4) : (r5++, n4 = 65536 + ((1023 & n4) << 10 | 1023 & t4.charCodeAt(r5)), e4.push(240 | n4 >> 18, 128 | n4 >> 12 & 63, 128 | n4 >> 6 & 63, 128 | 63 & n4));
                }
                return e4;
              }(t3);
            }, void 0 === (n3 = "function" == typeof (r4 = function() {
              return o3;
            }) ? r4.apply(e3, []) : r4) || (t2.exports = n3);
          }, 676: (t2, e3, r4) => {
            "use strict";
            r4.d(e3, { default: () => q3 });
            var n3 = function() {
              return (n3 = Object.assign || function(t3) {
                for (var e4, r5 = 1, n4 = arguments.length; r5 < n4; r5++) for (var o4 in e4 = arguments[r5]) Object.prototype.hasOwnProperty.call(e4, o4) && (t3[o4] = e4[o4]);
                return t3;
              }).apply(this, arguments);
            }, o3 = function() {
              for (var t3 = 0, e4 = 0, r5 = arguments.length; e4 < r5; e4++) t3 += arguments[e4].length;
              var n4 = Array(t3), o4 = 0;
              for (e4 = 0; e4 < r5; e4++) for (var i3 = arguments[e4], a3 = 0, s3 = i3.length; a3 < s3; a3++, o4++) n4[o4] = i3[a3];
              return n4;
            }, i2 = function(t3) {
              return !!t3 && "object" == typeof t3 && !Array.isArray(t3);
            };
            function a2(t3) {
              for (var e4 = [], r5 = 1; r5 < arguments.length; r5++) e4[r5 - 1] = arguments[r5];
              if (!e4.length) return t3;
              var s3 = e4.shift();
              return void 0 !== s3 && i2(t3) && i2(s3) ? (t3 = n3({}, t3), Object.keys(s3).forEach(function(e5) {
                var r6 = t3[e5], n4 = s3[e5];
                Array.isArray(r6) && Array.isArray(n4) ? t3[e5] = n4 : i2(r6) && i2(n4) ? t3[e5] = a2(Object.assign({}, r6), n4) : t3[e5] = n4;
              }), a2.apply(void 0, o3([t3], e4))) : t3;
            }
            function s2(t3, e4) {
              var r5 = document.createElement("a");
              r5.download = e4, r5.href = t3, document.body.appendChild(r5), r5.click(), document.body.removeChild(r5);
            }
            function u3(t3) {
              return e4 = this, r5 = void 0, o4 = function() {
                return function(t4, e5) {
                  var r6, n5, o5, i3, a3 = { label: 0, sent: function() {
                    if (1 & o5[0]) throw o5[1];
                    return o5[1];
                  }, trys: [], ops: [] };
                  return i3 = { next: s3(0), throw: s3(1), return: s3(2) }, "function" == typeof Symbol && (i3[Symbol.iterator] = function() {
                    return this;
                  }), i3;
                  function s3(i4) {
                    return function(s4) {
                      return function(i5) {
                        if (r6) throw new TypeError("Generator is already executing.");
                        for (; a3; ) try {
                          if (r6 = 1, n5 && (o5 = 2 & i5[0] ? n5.return : i5[0] ? n5.throw || ((o5 = n5.return) && o5.call(n5), 0) : n5.next) && !(o5 = o5.call(n5, i5[1])).done) return o5;
                          switch (n5 = 0, o5 && (i5 = [2 & i5[0], o5.value]), i5[0]) {
                            case 0:
                            case 1:
                              o5 = i5;
                              break;
                            case 4:
                              return a3.label++, { value: i5[1], done: false };
                            case 5:
                              a3.label++, n5 = i5[1], i5 = [0];
                              continue;
                            case 7:
                              i5 = a3.ops.pop(), a3.trys.pop();
                              continue;
                            default:
                              if (!((o5 = (o5 = a3.trys).length > 0 && o5[o5.length - 1]) || 6 !== i5[0] && 2 !== i5[0])) {
                                a3 = 0;
                                continue;
                              }
                              if (3 === i5[0] && (!o5 || i5[1] > o5[0] && i5[1] < o5[3])) {
                                a3.label = i5[1];
                                break;
                              }
                              if (6 === i5[0] && a3.label < o5[1]) {
                                a3.label = o5[1], o5 = i5;
                                break;
                              }
                              if (o5 && a3.label < o5[2]) {
                                a3.label = o5[2], a3.ops.push(i5);
                                break;
                              }
                              o5[2] && a3.ops.pop(), a3.trys.pop();
                              continue;
                          }
                          i5 = e5.call(t4, a3);
                        } catch (t5) {
                          i5 = [6, t5], n5 = 0;
                        } finally {
                          r6 = o5 = 0;
                        }
                        if (5 & i5[0]) throw i5[1];
                        return { value: i5[0] ? i5[1] : void 0, done: true };
                      }([i4, s4]);
                    };
                  }
                }(this, function(e5) {
                  return [2, new Promise(function(e6) {
                    var r6 = new XMLHttpRequest();
                    r6.onload = function() {
                      var t4 = new FileReader();
                      t4.onloadend = function() {
                        e6(t4.result);
                      }, t4.readAsDataURL(r6.response);
                    }, r6.open("GET", t3), r6.responseType = "blob", r6.send();
                  })];
                });
              }, new ((n4 = void 0) || (n4 = Promise))(function(t4, i3) {
                function a3(t5) {
                  try {
                    u4(o4.next(t5));
                  } catch (t6) {
                    i3(t6);
                  }
                }
                function s3(t5) {
                  try {
                    u4(o4.throw(t5));
                  } catch (t6) {
                    i3(t6);
                  }
                }
                function u4(e5) {
                  var r6;
                  e5.done ? t4(e5.value) : (r6 = e5.value, r6 instanceof n4 ? r6 : new n4(function(t5) {
                    t5(r6);
                  })).then(a3, s3);
                }
                u4((o4 = o4.apply(e4, r5 || [])).next());
              });
              var e4, r5, n4, o4;
            }
            const h3 = { L: 0.07, M: 0.15, Q: 0.25, H: 0.3 };
            var c2 = function() {
              return (c2 = Object.assign || function(t3) {
                for (var e4, r5 = 1, n4 = arguments.length; r5 < n4; r5++) for (var o4 in e4 = arguments[r5]) Object.prototype.hasOwnProperty.call(e4, o4) && (t3[o4] = e4[o4]);
                return t3;
              }).apply(this, arguments);
            };
            const l2 = function() {
              function t3(t4) {
                var e4 = t4.svg, r5 = t4.type;
                this._svg = e4, this._type = r5;
              }
              return t3.prototype.draw = function(t4, e4, r5, n4) {
                var o4;
                switch (this._type) {
                  case "dots":
                    o4 = this._drawDot;
                    break;
                  case "classy":
                    o4 = this._drawClassy;
                    break;
                  case "classy-rounded":
                    o4 = this._drawClassyRounded;
                    break;
                  case "rounded":
                    o4 = this._drawRounded;
                    break;
                  case "extra-rounded":
                    o4 = this._drawExtraRounded;
                    break;
                  case "square":
                  default:
                    o4 = this._drawSquare;
                }
                o4.call(this, { x: t4, y: e4, size: r5, getNeighbor: n4 });
              }, t3.prototype._rotateFigure = function(t4) {
                var e4, r5 = t4.x, n4 = t4.y, o4 = t4.size, i3 = t4.rotation, a3 = void 0 === i3 ? 0 : i3, s3 = r5 + o4 / 2, u4 = n4 + o4 / 2;
                (0, t4.draw)(), null === (e4 = this._element) || void 0 === e4 || e4.setAttribute("transform", "rotate(" + 180 * a3 / Math.PI + "," + s3 + "," + u4 + ")");
              }, t3.prototype._basicDot = function(t4) {
                var e4 = this, r5 = t4.size, n4 = t4.x, o4 = t4.y;
                this._rotateFigure(c2(c2({}, t4), { draw: function() {
                  e4._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"), e4._element.setAttribute("cx", String(n4 + r5 / 2)), e4._element.setAttribute("cy", String(o4 + r5 / 2)), e4._element.setAttribute("r", String(r5 / 2));
                } }));
              }, t3.prototype._basicSquare = function(t4) {
                var e4 = this, r5 = t4.size, n4 = t4.x, o4 = t4.y;
                this._rotateFigure(c2(c2({}, t4), { draw: function() {
                  e4._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"), e4._element.setAttribute("x", String(n4)), e4._element.setAttribute("y", String(o4)), e4._element.setAttribute("width", String(r5)), e4._element.setAttribute("height", String(r5));
                } }));
              }, t3.prototype._basicSideRounded = function(t4) {
                var e4 = this, r5 = t4.size, n4 = t4.x, o4 = t4.y;
                this._rotateFigure(c2(c2({}, t4), { draw: function() {
                  e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("d", "M " + n4 + " " + o4 + "v " + r5 + "h " + r5 / 2 + "a " + r5 / 2 + " " + r5 / 2 + ", 0, 0, 0, 0 " + -r5);
                } }));
              }, t3.prototype._basicCornerRounded = function(t4) {
                var e4 = this, r5 = t4.size, n4 = t4.x, o4 = t4.y;
                this._rotateFigure(c2(c2({}, t4), { draw: function() {
                  e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("d", "M " + n4 + " " + o4 + "v " + r5 + "h " + r5 + "v " + -r5 / 2 + "a " + r5 / 2 + " " + r5 / 2 + ", 0, 0, 0, " + -r5 / 2 + " " + -r5 / 2);
                } }));
              }, t3.prototype._basicCornerExtraRounded = function(t4) {
                var e4 = this, r5 = t4.size, n4 = t4.x, o4 = t4.y;
                this._rotateFigure(c2(c2({}, t4), { draw: function() {
                  e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("d", "M " + n4 + " " + o4 + "v " + r5 + "h " + r5 + "a " + r5 + " " + r5 + ", 0, 0, 0, " + -r5 + " " + -r5);
                } }));
              }, t3.prototype._basicCornersRounded = function(t4) {
                var e4 = this, r5 = t4.size, n4 = t4.x, o4 = t4.y;
                this._rotateFigure(c2(c2({}, t4), { draw: function() {
                  e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("d", "M " + n4 + " " + o4 + "v " + r5 / 2 + "a " + r5 / 2 + " " + r5 / 2 + ", 0, 0, 0, " + r5 / 2 + " " + r5 / 2 + "h " + r5 / 2 + "v " + -r5 / 2 + "a " + r5 / 2 + " " + r5 / 2 + ", 0, 0, 0, " + -r5 / 2 + " " + -r5 / 2);
                } }));
              }, t3.prototype._drawDot = function(t4) {
                var e4 = t4.x, r5 = t4.y, n4 = t4.size;
                this._basicDot({ x: e4, y: r5, size: n4, rotation: 0 });
              }, t3.prototype._drawSquare = function(t4) {
                var e4 = t4.x, r5 = t4.y, n4 = t4.size;
                this._basicSquare({ x: e4, y: r5, size: n4, rotation: 0 });
              }, t3.prototype._drawRounded = function(t4) {
                var e4 = t4.x, r5 = t4.y, n4 = t4.size, o4 = t4.getNeighbor, i3 = o4 ? +o4(-1, 0) : 0, a3 = o4 ? +o4(1, 0) : 0, s3 = o4 ? +o4(0, -1) : 0, u4 = o4 ? +o4(0, 1) : 0, h4 = i3 + a3 + s3 + u4;
                if (0 !== h4) if (h4 > 2 || i3 && a3 || s3 && u4) this._basicSquare({ x: e4, y: r5, size: n4, rotation: 0 });
                else {
                  if (2 === h4) {
                    var c3 = 0;
                    return i3 && s3 ? c3 = Math.PI / 2 : s3 && a3 ? c3 = Math.PI : a3 && u4 && (c3 = -Math.PI / 2), void this._basicCornerRounded({ x: e4, y: r5, size: n4, rotation: c3 });
                  }
                  if (1 === h4) return c3 = 0, s3 ? c3 = Math.PI / 2 : a3 ? c3 = Math.PI : u4 && (c3 = -Math.PI / 2), void this._basicSideRounded({ x: e4, y: r5, size: n4, rotation: c3 });
                }
                else this._basicDot({ x: e4, y: r5, size: n4, rotation: 0 });
              }, t3.prototype._drawExtraRounded = function(t4) {
                var e4 = t4.x, r5 = t4.y, n4 = t4.size, o4 = t4.getNeighbor, i3 = o4 ? +o4(-1, 0) : 0, a3 = o4 ? +o4(1, 0) : 0, s3 = o4 ? +o4(0, -1) : 0, u4 = o4 ? +o4(0, 1) : 0, h4 = i3 + a3 + s3 + u4;
                if (0 !== h4) if (h4 > 2 || i3 && a3 || s3 && u4) this._basicSquare({ x: e4, y: r5, size: n4, rotation: 0 });
                else {
                  if (2 === h4) {
                    var c3 = 0;
                    return i3 && s3 ? c3 = Math.PI / 2 : s3 && a3 ? c3 = Math.PI : a3 && u4 && (c3 = -Math.PI / 2), void this._basicCornerExtraRounded({ x: e4, y: r5, size: n4, rotation: c3 });
                  }
                  if (1 === h4) return c3 = 0, s3 ? c3 = Math.PI / 2 : a3 ? c3 = Math.PI : u4 && (c3 = -Math.PI / 2), void this._basicSideRounded({ x: e4, y: r5, size: n4, rotation: c3 });
                }
                else this._basicDot({ x: e4, y: r5, size: n4, rotation: 0 });
              }, t3.prototype._drawClassy = function(t4) {
                var e4 = t4.x, r5 = t4.y, n4 = t4.size, o4 = t4.getNeighbor, i3 = o4 ? +o4(-1, 0) : 0, a3 = o4 ? +o4(1, 0) : 0, s3 = o4 ? +o4(0, -1) : 0, u4 = o4 ? +o4(0, 1) : 0;
                0 !== i3 + a3 + s3 + u4 ? i3 || s3 ? a3 || u4 ? this._basicSquare({ x: e4, y: r5, size: n4, rotation: 0 }) : this._basicCornerRounded({ x: e4, y: r5, size: n4, rotation: Math.PI / 2 }) : this._basicCornerRounded({ x: e4, y: r5, size: n4, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: e4, y: r5, size: n4, rotation: Math.PI / 2 });
              }, t3.prototype._drawClassyRounded = function(t4) {
                var e4 = t4.x, r5 = t4.y, n4 = t4.size, o4 = t4.getNeighbor, i3 = o4 ? +o4(-1, 0) : 0, a3 = o4 ? +o4(1, 0) : 0, s3 = o4 ? +o4(0, -1) : 0, u4 = o4 ? +o4(0, 1) : 0;
                0 !== i3 + a3 + s3 + u4 ? i3 || s3 ? a3 || u4 ? this._basicSquare({ x: e4, y: r5, size: n4, rotation: 0 }) : this._basicCornerExtraRounded({ x: e4, y: r5, size: n4, rotation: Math.PI / 2 }) : this._basicCornerExtraRounded({ x: e4, y: r5, size: n4, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: e4, y: r5, size: n4, rotation: Math.PI / 2 });
              }, t3;
            }();
            var d2 = function() {
              return (d2 = Object.assign || function(t3) {
                for (var e4, r5 = 1, n4 = arguments.length; r5 < n4; r5++) for (var o4 in e4 = arguments[r5]) Object.prototype.hasOwnProperty.call(e4, o4) && (t3[o4] = e4[o4]);
                return t3;
              }).apply(this, arguments);
            };
            const f3 = function() {
              function t3(t4) {
                var e4 = t4.svg, r5 = t4.type;
                this._svg = e4, this._type = r5;
              }
              return t3.prototype.draw = function(t4, e4, r5, n4) {
                var o4;
                switch (this._type) {
                  case "square":
                    o4 = this._drawSquare;
                    break;
                  case "extra-rounded":
                    o4 = this._drawExtraRounded;
                    break;
                  case "dot":
                  default:
                    o4 = this._drawDot;
                }
                o4.call(this, { x: t4, y: e4, size: r5, rotation: n4 });
              }, t3.prototype._rotateFigure = function(t4) {
                var e4, r5 = t4.x, n4 = t4.y, o4 = t4.size, i3 = t4.rotation, a3 = void 0 === i3 ? 0 : i3, s3 = r5 + o4 / 2, u4 = n4 + o4 / 2;
                (0, t4.draw)(), null === (e4 = this._element) || void 0 === e4 || e4.setAttribute("transform", "rotate(" + 180 * a3 / Math.PI + "," + s3 + "," + u4 + ")");
              }, t3.prototype._basicDot = function(t4) {
                var e4 = this, r5 = t4.size, n4 = t4.x, o4 = t4.y, i3 = r5 / 7;
                this._rotateFigure(d2(d2({}, t4), { draw: function() {
                  e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("clip-rule", "evenodd"), e4._element.setAttribute("d", "M " + (n4 + r5 / 2) + " " + o4 + "a " + r5 / 2 + " " + r5 / 2 + " 0 1 0 0.1 0zm 0 " + i3 + "a " + (r5 / 2 - i3) + " " + (r5 / 2 - i3) + " 0 1 1 -0.1 0Z");
                } }));
              }, t3.prototype._basicSquare = function(t4) {
                var e4 = this, r5 = t4.size, n4 = t4.x, o4 = t4.y, i3 = r5 / 7;
                this._rotateFigure(d2(d2({}, t4), { draw: function() {
                  e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("clip-rule", "evenodd"), e4._element.setAttribute("d", "M " + n4 + " " + o4 + "v " + r5 + "h " + r5 + "v " + -r5 + "zM " + (n4 + i3) + " " + (o4 + i3) + "h " + (r5 - 2 * i3) + "v " + (r5 - 2 * i3) + "h " + (2 * i3 - r5) + "z");
                } }));
              }, t3.prototype._basicExtraRounded = function(t4) {
                var e4 = this, r5 = t4.size, n4 = t4.x, o4 = t4.y, i3 = r5 / 7;
                this._rotateFigure(d2(d2({}, t4), { draw: function() {
                  e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("clip-rule", "evenodd"), e4._element.setAttribute("d", "M " + n4 + " " + (o4 + 2.5 * i3) + "v " + 2 * i3 + "a " + 2.5 * i3 + " " + 2.5 * i3 + ", 0, 0, 0, " + 2.5 * i3 + " " + 2.5 * i3 + "h " + 2 * i3 + "a " + 2.5 * i3 + " " + 2.5 * i3 + ", 0, 0, 0, " + 2.5 * i3 + " " + 2.5 * -i3 + "v " + -2 * i3 + "a " + 2.5 * i3 + " " + 2.5 * i3 + ", 0, 0, 0, " + 2.5 * -i3 + " " + 2.5 * -i3 + "h " + -2 * i3 + "a " + 2.5 * i3 + " " + 2.5 * i3 + ", 0, 0, 0, " + 2.5 * -i3 + " " + 2.5 * i3 + "M " + (n4 + 2.5 * i3) + " " + (o4 + i3) + "h " + 2 * i3 + "a " + 1.5 * i3 + " " + 1.5 * i3 + ", 0, 0, 1, " + 1.5 * i3 + " " + 1.5 * i3 + "v " + 2 * i3 + "a " + 1.5 * i3 + " " + 1.5 * i3 + ", 0, 0, 1, " + 1.5 * -i3 + " " + 1.5 * i3 + "h " + -2 * i3 + "a " + 1.5 * i3 + " " + 1.5 * i3 + ", 0, 0, 1, " + 1.5 * -i3 + " " + 1.5 * -i3 + "v " + -2 * i3 + "a " + 1.5 * i3 + " " + 1.5 * i3 + ", 0, 0, 1, " + 1.5 * i3 + " " + 1.5 * -i3);
                } }));
              }, t3.prototype._drawDot = function(t4) {
                var e4 = t4.x, r5 = t4.y, n4 = t4.size, o4 = t4.rotation;
                this._basicDot({ x: e4, y: r5, size: n4, rotation: o4 });
              }, t3.prototype._drawSquare = function(t4) {
                var e4 = t4.x, r5 = t4.y, n4 = t4.size, o4 = t4.rotation;
                this._basicSquare({ x: e4, y: r5, size: n4, rotation: o4 });
              }, t3.prototype._drawExtraRounded = function(t4) {
                var e4 = t4.x, r5 = t4.y, n4 = t4.size, o4 = t4.rotation;
                this._basicExtraRounded({ x: e4, y: r5, size: n4, rotation: o4 });
              }, t3;
            }();
            var g3 = function() {
              return (g3 = Object.assign || function(t3) {
                for (var e4, r5 = 1, n4 = arguments.length; r5 < n4; r5++) for (var o4 in e4 = arguments[r5]) Object.prototype.hasOwnProperty.call(e4, o4) && (t3[o4] = e4[o4]);
                return t3;
              }).apply(this, arguments);
            };
            const p2 = function() {
              function t3(t4) {
                var e4 = t4.svg, r5 = t4.type;
                this._svg = e4, this._type = r5;
              }
              return t3.prototype.draw = function(t4, e4, r5, n4) {
                var o4;
                switch (this._type) {
                  case "square":
                    o4 = this._drawSquare;
                    break;
                  case "dot":
                  default:
                    o4 = this._drawDot;
                }
                o4.call(this, { x: t4, y: e4, size: r5, rotation: n4 });
              }, t3.prototype._rotateFigure = function(t4) {
                var e4, r5 = t4.x, n4 = t4.y, o4 = t4.size, i3 = t4.rotation, a3 = void 0 === i3 ? 0 : i3, s3 = r5 + o4 / 2, u4 = n4 + o4 / 2;
                (0, t4.draw)(), null === (e4 = this._element) || void 0 === e4 || e4.setAttribute("transform", "rotate(" + 180 * a3 / Math.PI + "," + s3 + "," + u4 + ")");
              }, t3.prototype._basicDot = function(t4) {
                var e4 = this, r5 = t4.size, n4 = t4.x, o4 = t4.y;
                this._rotateFigure(g3(g3({}, t4), { draw: function() {
                  e4._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"), e4._element.setAttribute("cx", String(n4 + r5 / 2)), e4._element.setAttribute("cy", String(o4 + r5 / 2)), e4._element.setAttribute("r", String(r5 / 2));
                } }));
              }, t3.prototype._basicSquare = function(t4) {
                var e4 = this, r5 = t4.size, n4 = t4.x, o4 = t4.y;
                this._rotateFigure(g3(g3({}, t4), { draw: function() {
                  e4._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"), e4._element.setAttribute("x", String(n4)), e4._element.setAttribute("y", String(o4)), e4._element.setAttribute("width", String(r5)), e4._element.setAttribute("height", String(r5));
                } }));
              }, t3.prototype._drawDot = function(t4) {
                var e4 = t4.x, r5 = t4.y, n4 = t4.size, o4 = t4.rotation;
                this._basicDot({ x: e4, y: r5, size: n4, rotation: o4 });
              }, t3.prototype._drawSquare = function(t4) {
                var e4 = t4.x, r5 = t4.y, n4 = t4.size, o4 = t4.rotation;
                this._basicSquare({ x: e4, y: r5, size: n4, rotation: o4 });
              }, t3;
            }(), v3 = "circle";
            var w3 = function(t3, e4, r5, n4) {
              return new (r5 || (r5 = Promise))(function(o4, i3) {
                function a3(t4) {
                  try {
                    u4(n4.next(t4));
                  } catch (t5) {
                    i3(t5);
                  }
                }
                function s3(t4) {
                  try {
                    u4(n4.throw(t4));
                  } catch (t5) {
                    i3(t5);
                  }
                }
                function u4(t4) {
                  var e5;
                  t4.done ? o4(t4.value) : (e5 = t4.value, e5 instanceof r5 ? e5 : new r5(function(t5) {
                    t5(e5);
                  })).then(a3, s3);
                }
                u4((n4 = n4.apply(t3, e4 || [])).next());
              });
            }, y3 = function(t3, e4) {
              var r5, n4, o4, i3, a3 = { label: 0, sent: function() {
                if (1 & o4[0]) throw o4[1];
                return o4[1];
              }, trys: [], ops: [] };
              return i3 = { next: s3(0), throw: s3(1), return: s3(2) }, "function" == typeof Symbol && (i3[Symbol.iterator] = function() {
                return this;
              }), i3;
              function s3(i4) {
                return function(s4) {
                  return function(i5) {
                    if (r5) throw new TypeError("Generator is already executing.");
                    for (; a3; ) try {
                      if (r5 = 1, n4 && (o4 = 2 & i5[0] ? n4.return : i5[0] ? n4.throw || ((o4 = n4.return) && o4.call(n4), 0) : n4.next) && !(o4 = o4.call(n4, i5[1])).done) return o4;
                      switch (n4 = 0, o4 && (i5 = [2 & i5[0], o4.value]), i5[0]) {
                        case 0:
                        case 1:
                          o4 = i5;
                          break;
                        case 4:
                          return a3.label++, { value: i5[1], done: false };
                        case 5:
                          a3.label++, n4 = i5[1], i5 = [0];
                          continue;
                        case 7:
                          i5 = a3.ops.pop(), a3.trys.pop();
                          continue;
                        default:
                          if (!((o4 = (o4 = a3.trys).length > 0 && o4[o4.length - 1]) || 6 !== i5[0] && 2 !== i5[0])) {
                            a3 = 0;
                            continue;
                          }
                          if (3 === i5[0] && (!o4 || i5[1] > o4[0] && i5[1] < o4[3])) {
                            a3.label = i5[1];
                            break;
                          }
                          if (6 === i5[0] && a3.label < o4[1]) {
                            a3.label = o4[1], o4 = i5;
                            break;
                          }
                          if (o4 && a3.label < o4[2]) {
                            a3.label = o4[2], a3.ops.push(i5);
                            break;
                          }
                          o4[2] && a3.ops.pop(), a3.trys.pop();
                          continue;
                      }
                      i5 = e4.call(t3, a3);
                    } catch (t4) {
                      i5 = [6, t4], n4 = 0;
                    } finally {
                      r5 = o4 = 0;
                    }
                    if (5 & i5[0]) throw i5[1];
                    return { value: i5[0] ? i5[1] : void 0, done: true };
                  }([i4, s4]);
                };
              }
            }, m3 = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]], b3 = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
            const _3 = function() {
              function t3(t4) {
                this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(t4.width)), this._element.setAttribute("height", String(t4.height)), this._defs = document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._options = t4;
              }
              return Object.defineProperty(t3.prototype, "width", { get: function() {
                return this._options.width;
              }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "height", { get: function() {
                return this._options.height;
              }, enumerable: false, configurable: true }), t3.prototype.getElement = function() {
                return this._element;
              }, t3.prototype.drawQR = function(t4) {
                return w3(this, void 0, void 0, function() {
                  var e4, r5, n4, o4, i3, a3, s3, u4, c3, l3, d3 = this;
                  return y3(this, function(f4) {
                    switch (f4.label) {
                      case 0:
                        return e4 = t4.getModuleCount(), r5 = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, n4 = this._options.shape === v3 ? r5 / Math.sqrt(2) : r5, o4 = Math.floor(n4 / e4), i3 = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 }, this._qr = t4, this._options.image ? [4, this.loadImage()] : [3, 2];
                      case 1:
                        if (f4.sent(), !this._image) return [2];
                        a3 = this._options, s3 = a3.imageOptions, u4 = a3.qrOptions, c3 = s3.imageSize * h3[u4.errorCorrectionLevel], l3 = Math.floor(c3 * e4 * e4), i3 = function(t5) {
                          var e5 = t5.originalHeight, r6 = t5.originalWidth, n5 = t5.maxHiddenDots, o5 = t5.maxHiddenAxisDots, i4 = t5.dotSize, a4 = { x: 0, y: 0 }, s4 = { x: 0, y: 0 };
                          if (e5 <= 0 || r6 <= 0 || n5 <= 0 || i4 <= 0) return { height: 0, width: 0, hideYDots: 0, hideXDots: 0 };
                          var u5 = e5 / r6;
                          return a4.x = Math.floor(Math.sqrt(n5 / u5)), a4.x <= 0 && (a4.x = 1), o5 && o5 < a4.x && (a4.x = o5), a4.x % 2 == 0 && a4.x--, s4.x = a4.x * i4, a4.y = 1 + 2 * Math.ceil((a4.x * u5 - 1) / 2), s4.y = Math.round(s4.x * u5), (a4.y * a4.x > n5 || o5 && o5 < a4.y) && (o5 && o5 < a4.y ? (a4.y = o5, a4.y % 2 == 0 && a4.x--) : a4.y -= 2, s4.y = a4.y * i4, a4.x = 1 + 2 * Math.ceil((a4.y / u5 - 1) / 2), s4.x = Math.round(s4.y / u5)), { height: s4.y, width: s4.x, hideYDots: a4.y, hideXDots: a4.x };
                        }({ originalWidth: this._image.width, originalHeight: this._image.height, maxHiddenDots: l3, maxHiddenAxisDots: e4 - 14, dotSize: o4 }), f4.label = 2;
                      case 2:
                        return this.drawBackground(), this.drawDots(function(t5, r6) {
                          var n5, o5, a4, s4, u5, h4;
                          return !(d3._options.imageOptions.hideBackgroundDots && t5 >= (e4 - i3.hideXDots) / 2 && t5 < (e4 + i3.hideXDots) / 2 && r6 >= (e4 - i3.hideYDots) / 2 && r6 < (e4 + i3.hideYDots) / 2 || (null === (n5 = m3[t5]) || void 0 === n5 ? void 0 : n5[r6]) || (null === (o5 = m3[t5 - e4 + 7]) || void 0 === o5 ? void 0 : o5[r6]) || (null === (a4 = m3[t5]) || void 0 === a4 ? void 0 : a4[r6 - e4 + 7]) || (null === (s4 = b3[t5]) || void 0 === s4 ? void 0 : s4[r6]) || (null === (u5 = b3[t5 - e4 + 7]) || void 0 === u5 ? void 0 : u5[r6]) || (null === (h4 = b3[t5]) || void 0 === h4 ? void 0 : h4[r6 - e4 + 7]));
                        }), this.drawCorners(), this._options.image ? [4, this.drawImage({ width: i3.width, height: i3.height, count: e4, dotSize: o4 })] : [3, 4];
                      case 3:
                        f4.sent(), f4.label = 4;
                      case 4:
                        return [2];
                    }
                  });
                });
              }, t3.prototype.drawBackground = function() {
                var t4, e4, r5, n4 = this._element, o4 = this._options;
                if (n4) {
                  var i3 = null === (t4 = o4.backgroundOptions) || void 0 === t4 ? void 0 : t4.gradient, a3 = null === (e4 = o4.backgroundOptions) || void 0 === e4 ? void 0 : e4.color;
                  if ((i3 || a3) && this._createColor({ options: i3, color: a3, additionalRotation: 0, x: 0, y: 0, height: o4.height, width: o4.width, name: "background-color" }), null === (r5 = o4.backgroundOptions) || void 0 === r5 ? void 0 : r5.round) {
                    var s3 = Math.min(o4.width, o4.height), u4 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                    this._backgroundClipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._backgroundClipPath.setAttribute("id", "clip-path-background-color"), this._defs.appendChild(this._backgroundClipPath), u4.setAttribute("x", String((o4.width - s3) / 2)), u4.setAttribute("y", String((o4.height - s3) / 2)), u4.setAttribute("width", String(s3)), u4.setAttribute("height", String(s3)), u4.setAttribute("rx", String(s3 / 2 * o4.backgroundOptions.round)), this._backgroundClipPath.appendChild(u4);
                  }
                }
              }, t3.prototype.drawDots = function(t4) {
                var e4, r5, n4 = this;
                if (!this._qr) throw "QR code is not defined";
                var o4 = this._options, i3 = this._qr.getModuleCount();
                if (i3 > o4.width || i3 > o4.height) throw "The canvas is too small.";
                var a3 = Math.min(o4.width, o4.height) - 2 * o4.margin, s3 = o4.shape === v3 ? a3 / Math.sqrt(2) : a3, u4 = Math.floor(s3 / i3), h4 = Math.floor((o4.width - i3 * u4) / 2), c3 = Math.floor((o4.height - i3 * u4) / 2), d3 = new l2({ svg: this._element, type: o4.dotsOptions.type });
                this._dotsClipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", "clip-path-dot-color"), this._defs.appendChild(this._dotsClipPath), this._createColor({ options: null === (e4 = o4.dotsOptions) || void 0 === e4 ? void 0 : e4.gradient, color: o4.dotsOptions.color, additionalRotation: 0, x: 0, y: 0, height: o4.height, width: o4.width, name: "dot-color" });
                for (var f4 = function(e5) {
                  for (var o5 = function(o6) {
                    return t4 && !t4(e5, o6) ? "continue" : (null === (r5 = g4._qr) || void 0 === r5 ? void 0 : r5.isDark(e5, o6)) ? (d3.draw(h4 + e5 * u4, c3 + o6 * u4, u4, function(r6, a5) {
                      return !(e5 + r6 < 0 || o6 + a5 < 0 || e5 + r6 >= i3 || o6 + a5 >= i3) && !(t4 && !t4(e5 + r6, o6 + a5)) && !!n4._qr && n4._qr.isDark(e5 + r6, o6 + a5);
                    }), void (d3._element && g4._dotsClipPath && g4._dotsClipPath.appendChild(d3._element))) : "continue";
                  }, a4 = 0; a4 < i3; a4++) o5(a4);
                }, g4 = this, p3 = 0; p3 < i3; p3++) f4(p3);
                if (o4.shape === v3) {
                  var w4 = Math.floor((a3 / u4 - i3) / 2), y4 = i3 + 2 * w4, m4 = h4 - w4 * u4, b4 = c3 - w4 * u4, _4 = [], x4 = Math.floor(y4 / 2);
                  for (p3 = 0; p3 < y4; p3++) {
                    _4[p3] = [];
                    for (var S4 = 0; S4 < y4; S4++) p3 >= w4 - 1 && p3 <= y4 - w4 && S4 >= w4 - 1 && S4 <= y4 - w4 || Math.sqrt((p3 - x4) * (p3 - x4) + (S4 - x4) * (S4 - x4)) > x4 ? _4[p3][S4] = 0 : _4[p3][S4] = this._qr.isDark(S4 - 2 * w4 < 0 ? S4 : S4 >= i3 ? S4 - 2 * w4 : S4 - w4, p3 - 2 * w4 < 0 ? p3 : p3 >= i3 ? p3 - 2 * w4 : p3 - w4) ? 1 : 0;
                  }
                  var M4 = function(t5) {
                    for (var e5 = function(e6) {
                      if (!_4[t5][e6]) return "continue";
                      d3.draw(m4 + t5 * u4, b4 + e6 * u4, u4, function(r7, n5) {
                        var o5;
                        return !!(null === (o5 = _4[t5 + r7]) || void 0 === o5 ? void 0 : o5[e6 + n5]);
                      }), d3._element && C4._dotsClipPath && C4._dotsClipPath.appendChild(d3._element);
                    }, r6 = 0; r6 < y4; r6++) e5(r6);
                  }, C4 = this;
                  for (p3 = 0; p3 < y4; p3++) M4(p3);
                }
              }, t3.prototype.drawCorners = function() {
                var t4 = this;
                if (!this._qr) throw "QR code is not defined";
                var e4 = this._element, r5 = this._options;
                if (!e4) throw "Element code is not defined";
                var n4 = this._qr.getModuleCount(), o4 = Math.min(r5.width, r5.height) - 2 * r5.margin, i3 = r5.shape === v3 ? o4 / Math.sqrt(2) : o4, a3 = Math.floor(i3 / n4), s3 = 7 * a3, u4 = 3 * a3, h4 = Math.floor((r5.width - n4 * a3) / 2), c3 = Math.floor((r5.height - n4 * a3) / 2);
                [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach(function(e5) {
                  var o5, i4, d3, g4, v4, w4, y4, _4, x4, S4, M4, C4, A4 = e5[0], k4 = e5[1], O4 = e5[2], D4 = h4 + A4 * a3 * (n4 - 7), P4 = c3 + k4 * a3 * (n4 - 7), z4 = t4._dotsClipPath, B4 = t4._dotsClipPath;
                  if (((null === (o5 = r5.cornersSquareOptions) || void 0 === o5 ? void 0 : o5.gradient) || (null === (i4 = r5.cornersSquareOptions) || void 0 === i4 ? void 0 : i4.color)) && ((z4 = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-square-color-" + A4 + "-" + k4), t4._defs.appendChild(z4), t4._cornersSquareClipPath = t4._cornersDotClipPath = B4 = z4, t4._createColor({ options: null === (d3 = r5.cornersSquareOptions) || void 0 === d3 ? void 0 : d3.gradient, color: null === (g4 = r5.cornersSquareOptions) || void 0 === g4 ? void 0 : g4.color, additionalRotation: O4, x: D4, y: P4, height: s3, width: s3, name: "corners-square-color-" + A4 + "-" + k4 })), null === (v4 = r5.cornersSquareOptions) || void 0 === v4 ? void 0 : v4.type) {
                    var q4 = new f3({ svg: t4._element, type: r5.cornersSquareOptions.type });
                    q4.draw(D4, P4, s3, O4), q4._element && z4 && z4.appendChild(q4._element);
                  } else for (var I3 = new l2({ svg: t4._element, type: r5.dotsOptions.type }), E3 = function(t5) {
                    for (var e6 = function(e7) {
                      if (!(null === (w4 = m3[t5]) || void 0 === w4 ? void 0 : w4[e7])) return "continue";
                      I3.draw(D4 + t5 * a3, P4 + e7 * a3, a3, function(r7, n5) {
                        var o6;
                        return !!(null === (o6 = m3[t5 + r7]) || void 0 === o6 ? void 0 : o6[e7 + n5]);
                      }), I3._element && z4 && z4.appendChild(I3._element);
                    }, r6 = 0; r6 < m3[t5].length; r6++) e6(r6);
                  }, L3 = 0; L3 < m3.length; L3++) E3(L3);
                  if (((null === (y4 = r5.cornersDotOptions) || void 0 === y4 ? void 0 : y4.gradient) || (null === (_4 = r5.cornersDotOptions) || void 0 === _4 ? void 0 : _4.color)) && ((B4 = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-dot-color-" + A4 + "-" + k4), t4._defs.appendChild(B4), t4._cornersDotClipPath = B4, t4._createColor({ options: null === (x4 = r5.cornersDotOptions) || void 0 === x4 ? void 0 : x4.gradient, color: null === (S4 = r5.cornersDotOptions) || void 0 === S4 ? void 0 : S4.color, additionalRotation: O4, x: D4 + 2 * a3, y: P4 + 2 * a3, height: u4, width: u4, name: "corners-dot-color-" + A4 + "-" + k4 })), null === (M4 = r5.cornersDotOptions) || void 0 === M4 ? void 0 : M4.type) {
                    var R3 = new p2({ svg: t4._element, type: r5.cornersDotOptions.type });
                    R3.draw(D4 + 2 * a3, P4 + 2 * a3, u4, O4), R3._element && B4 && B4.appendChild(R3._element);
                  } else {
                    I3 = new l2({ svg: t4._element, type: r5.dotsOptions.type });
                    var N3 = function(t5) {
                      for (var e6 = function(e7) {
                        if (!(null === (C4 = b3[t5]) || void 0 === C4 ? void 0 : C4[e7])) return "continue";
                        I3.draw(D4 + t5 * a3, P4 + e7 * a3, a3, function(r7, n5) {
                          var o6;
                          return !!(null === (o6 = b3[t5 + r7]) || void 0 === o6 ? void 0 : o6[e7 + n5]);
                        }), I3._element && B4 && B4.appendChild(I3._element);
                      }, r6 = 0; r6 < b3[t5].length; r6++) e6(r6);
                    };
                    for (L3 = 0; L3 < b3.length; L3++) N3(L3);
                  }
                });
              }, t3.prototype.loadImage = function() {
                var t4 = this;
                return new Promise(function(e4, r5) {
                  var n4 = t4._options, o4 = new Image();
                  if (!n4.image) return r5("Image is not defined");
                  "string" == typeof n4.imageOptions.crossOrigin && (o4.crossOrigin = n4.imageOptions.crossOrigin), t4._image = o4, o4.onload = function() {
                    e4();
                  }, o4.src = n4.image;
                });
              }, t3.prototype.drawImage = function(t4) {
                var e4 = t4.width, r5 = t4.height, n4 = t4.count, o4 = t4.dotSize;
                return w3(this, void 0, void 0, function() {
                  var t5, i3, a3, s3, h4, c3, l3, d3, f4;
                  return y3(this, function(g4) {
                    switch (g4.label) {
                      case 0:
                        return t5 = this._options, i3 = Math.floor((t5.width - n4 * o4) / 2), a3 = Math.floor((t5.height - n4 * o4) / 2), s3 = i3 + t5.imageOptions.margin + (n4 * o4 - e4) / 2, h4 = a3 + t5.imageOptions.margin + (n4 * o4 - r5) / 2, c3 = e4 - 2 * t5.imageOptions.margin, l3 = r5 - 2 * t5.imageOptions.margin, (d3 = document.createElementNS("http://www.w3.org/2000/svg", "image")).setAttribute("x", String(s3)), d3.setAttribute("y", String(h4)), d3.setAttribute("width", c3 + "px"), d3.setAttribute("height", l3 + "px"), [4, u3(t5.image || "")];
                      case 1:
                        return f4 = g4.sent(), d3.setAttribute("href", f4 || ""), this._element.appendChild(d3), [2];
                    }
                  });
                });
              }, t3.prototype._createColor = function(t4) {
                var e4 = t4.options, r5 = t4.color, n4 = t4.additionalRotation, o4 = t4.x, i3 = t4.y, a3 = t4.height, s3 = t4.width, u4 = t4.name, h4 = s3 > a3 ? s3 : a3, c3 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                if (c3.setAttribute("x", String(o4)), c3.setAttribute("y", String(i3)), c3.setAttribute("height", String(a3)), c3.setAttribute("width", String(s3)), c3.setAttribute("clip-path", "url('#clip-path-" + u4 + "')"), e4) {
                  var l3;
                  if ("radial" === e4.type) (l3 = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient")).setAttribute("id", u4), l3.setAttribute("gradientUnits", "userSpaceOnUse"), l3.setAttribute("fx", String(o4 + s3 / 2)), l3.setAttribute("fy", String(i3 + a3 / 2)), l3.setAttribute("cx", String(o4 + s3 / 2)), l3.setAttribute("cy", String(i3 + a3 / 2)), l3.setAttribute("r", String(h4 / 2));
                  else {
                    var d3 = ((e4.rotation || 0) + n4) % (2 * Math.PI), f4 = (d3 + 2 * Math.PI) % (2 * Math.PI), g4 = o4 + s3 / 2, p3 = i3 + a3 / 2, v4 = o4 + s3 / 2, w4 = i3 + a3 / 2;
                    f4 >= 0 && f4 <= 0.25 * Math.PI || f4 > 1.75 * Math.PI && f4 <= 2 * Math.PI ? (g4 -= s3 / 2, p3 -= a3 / 2 * Math.tan(d3), v4 += s3 / 2, w4 += a3 / 2 * Math.tan(d3)) : f4 > 0.25 * Math.PI && f4 <= 0.75 * Math.PI ? (p3 -= a3 / 2, g4 -= s3 / 2 / Math.tan(d3), w4 += a3 / 2, v4 += s3 / 2 / Math.tan(d3)) : f4 > 0.75 * Math.PI && f4 <= 1.25 * Math.PI ? (g4 += s3 / 2, p3 += a3 / 2 * Math.tan(d3), v4 -= s3 / 2, w4 -= a3 / 2 * Math.tan(d3)) : f4 > 1.25 * Math.PI && f4 <= 1.75 * Math.PI && (p3 += a3 / 2, g4 += s3 / 2 / Math.tan(d3), w4 -= a3 / 2, v4 -= s3 / 2 / Math.tan(d3)), (l3 = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient")).setAttribute("id", u4), l3.setAttribute("gradientUnits", "userSpaceOnUse"), l3.setAttribute("x1", String(Math.round(g4))), l3.setAttribute("y1", String(Math.round(p3))), l3.setAttribute("x2", String(Math.round(v4))), l3.setAttribute("y2", String(Math.round(w4)));
                  }
                  e4.colorStops.forEach(function(t5) {
                    var e5 = t5.offset, r6 = t5.color, n5 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
                    n5.setAttribute("offset", 100 * e5 + "%"), n5.setAttribute("stop-color", r6), l3.appendChild(n5);
                  }), c3.setAttribute("fill", "url('#" + u4 + "')"), this._defs.appendChild(l3);
                } else r5 && c3.setAttribute("fill", r5);
                this._element.appendChild(c3);
              }, t3;
            }(), x3 = "canvas";
            for (var S3 = {}, M3 = 0; M3 <= 40; M3++) S3[M3] = M3;
            const C3 = { type: x3, shape: "square", width: 300, height: 300, data: "", margin: 0, qrOptions: { typeNumber: S3[0], mode: void 0, errorCorrectionLevel: "Q" }, imageOptions: { hideBackgroundDots: true, imageSize: 0.4, crossOrigin: void 0, margin: 0 }, dotsOptions: { type: "square", color: "#000" }, backgroundOptions: { round: 0, color: "#fff" } };
            var A3 = function() {
              return (A3 = Object.assign || function(t3) {
                for (var e4, r5 = 1, n4 = arguments.length; r5 < n4; r5++) for (var o4 in e4 = arguments[r5]) Object.prototype.hasOwnProperty.call(e4, o4) && (t3[o4] = e4[o4]);
                return t3;
              }).apply(this, arguments);
            };
            function k3(t3) {
              var e4 = A3({}, t3);
              if (!e4.colorStops || !e4.colorStops.length) throw "Field 'colorStops' is required in gradient";
              return e4.rotation ? e4.rotation = Number(e4.rotation) : e4.rotation = 0, e4.colorStops = e4.colorStops.map(function(t4) {
                return A3(A3({}, t4), { offset: Number(t4.offset) });
              }), e4;
            }
            function O3(t3) {
              var e4 = A3({}, t3);
              return e4.width = Number(e4.width), e4.height = Number(e4.height), e4.margin = Number(e4.margin), e4.imageOptions = A3(A3({}, e4.imageOptions), { hideBackgroundDots: Boolean(e4.imageOptions.hideBackgroundDots), imageSize: Number(e4.imageOptions.imageSize), margin: Number(e4.imageOptions.margin) }), e4.margin > Math.min(e4.width, e4.height) && (e4.margin = Math.min(e4.width, e4.height)), e4.dotsOptions = A3({}, e4.dotsOptions), e4.dotsOptions.gradient && (e4.dotsOptions.gradient = k3(e4.dotsOptions.gradient)), e4.cornersSquareOptions && (e4.cornersSquareOptions = A3({}, e4.cornersSquareOptions), e4.cornersSquareOptions.gradient && (e4.cornersSquareOptions.gradient = k3(e4.cornersSquareOptions.gradient))), e4.cornersDotOptions && (e4.cornersDotOptions = A3({}, e4.cornersDotOptions), e4.cornersDotOptions.gradient && (e4.cornersDotOptions.gradient = k3(e4.cornersDotOptions.gradient))), e4.backgroundOptions && (e4.backgroundOptions = A3({}, e4.backgroundOptions), e4.backgroundOptions.gradient && (e4.backgroundOptions.gradient = k3(e4.backgroundOptions.gradient))), e4;
            }
            var D3 = r4(192), P3 = r4.n(D3), z3 = function(t3, e4, r5, n4) {
              return new (r5 || (r5 = Promise))(function(o4, i3) {
                function a3(t4) {
                  try {
                    u4(n4.next(t4));
                  } catch (t5) {
                    i3(t5);
                  }
                }
                function s3(t4) {
                  try {
                    u4(n4.throw(t4));
                  } catch (t5) {
                    i3(t5);
                  }
                }
                function u4(t4) {
                  var e5;
                  t4.done ? o4(t4.value) : (e5 = t4.value, e5 instanceof r5 ? e5 : new r5(function(t5) {
                    t5(e5);
                  })).then(a3, s3);
                }
                u4((n4 = n4.apply(t3, e4 || [])).next());
              });
            }, B3 = function(t3, e4) {
              var r5, n4, o4, i3, a3 = { label: 0, sent: function() {
                if (1 & o4[0]) throw o4[1];
                return o4[1];
              }, trys: [], ops: [] };
              return i3 = { next: s3(0), throw: s3(1), return: s3(2) }, "function" == typeof Symbol && (i3[Symbol.iterator] = function() {
                return this;
              }), i3;
              function s3(i4) {
                return function(s4) {
                  return function(i5) {
                    if (r5) throw new TypeError("Generator is already executing.");
                    for (; a3; ) try {
                      if (r5 = 1, n4 && (o4 = 2 & i5[0] ? n4.return : i5[0] ? n4.throw || ((o4 = n4.return) && o4.call(n4), 0) : n4.next) && !(o4 = o4.call(n4, i5[1])).done) return o4;
                      switch (n4 = 0, o4 && (i5 = [2 & i5[0], o4.value]), i5[0]) {
                        case 0:
                        case 1:
                          o4 = i5;
                          break;
                        case 4:
                          return a3.label++, { value: i5[1], done: false };
                        case 5:
                          a3.label++, n4 = i5[1], i5 = [0];
                          continue;
                        case 7:
                          i5 = a3.ops.pop(), a3.trys.pop();
                          continue;
                        default:
                          if (!((o4 = (o4 = a3.trys).length > 0 && o4[o4.length - 1]) || 6 !== i5[0] && 2 !== i5[0])) {
                            a3 = 0;
                            continue;
                          }
                          if (3 === i5[0] && (!o4 || i5[1] > o4[0] && i5[1] < o4[3])) {
                            a3.label = i5[1];
                            break;
                          }
                          if (6 === i5[0] && a3.label < o4[1]) {
                            a3.label = o4[1], o4 = i5;
                            break;
                          }
                          if (o4 && a3.label < o4[2]) {
                            a3.label = o4[2], a3.ops.push(i5);
                            break;
                          }
                          o4[2] && a3.ops.pop(), a3.trys.pop();
                          continue;
                      }
                      i5 = e4.call(t3, a3);
                    } catch (t4) {
                      i5 = [6, t4], n4 = 0;
                    } finally {
                      r5 = o4 = 0;
                    }
                    if (5 & i5[0]) throw i5[1];
                    return { value: i5[0] ? i5[1] : void 0, done: true };
                  }([i4, s4]);
                };
              }
            };
            const q3 = function() {
              function t3(t4) {
                this._options = t4 ? O3(a2(C3, t4)) : C3, this.update();
              }
              return t3._clearContainer = function(t4) {
                t4 && (t4.innerHTML = "");
              }, t3.prototype._setupSvg = function() {
                var t4 = this;
                if (this._qr) {
                  var e4 = new _3(this._options);
                  this._svg = e4.getElement(), this._svgDrawingPromise = e4.drawQR(this._qr).then(function() {
                    var r5;
                    t4._svg && (null === (r5 = t4._extension) || void 0 === r5 || r5.call(t4, e4.getElement(), t4._options));
                  });
                }
              }, t3.prototype._setupCanvas = function() {
                var t4, e4 = this;
                this._qr && (this._canvas = document.createElement("canvas"), this._canvas.width = this._options.width, this._canvas.height = this._options.height, this._setupSvg(), this._canvasDrawingPromise = null === (t4 = this._svgDrawingPromise) || void 0 === t4 ? void 0 : t4.then(function() {
                  if (e4._svg) {
                    var t5 = e4._svg, r5 = new XMLSerializer().serializeToString(t5), n4 = "data:image/svg+xml;base64," + btoa(r5), o4 = new Image();
                    return new Promise(function(t6) {
                      o4.onload = function() {
                        var r6, n5;
                        null === (n5 = null === (r6 = e4._canvas) || void 0 === r6 ? void 0 : r6.getContext("2d")) || void 0 === n5 || n5.drawImage(o4, 0, 0), t6();
                      }, o4.src = n4;
                    });
                  }
                }));
              }, t3.prototype._getElement = function(t4) {
                return void 0 === t4 && (t4 = "png"), z3(this, void 0, void 0, function() {
                  return B3(this, function(e4) {
                    switch (e4.label) {
                      case 0:
                        if (!this._qr) throw "QR code is empty";
                        return "svg" !== t4.toLowerCase() ? [3, 2] : (this._svg && this._svgDrawingPromise || this._setupSvg(), [4, this._svgDrawingPromise]);
                      case 1:
                        return e4.sent(), [2, this._svg];
                      case 2:
                        return this._canvas && this._canvasDrawingPromise || this._setupCanvas(), [4, this._canvasDrawingPromise];
                      case 3:
                        return e4.sent(), [2, this._canvas];
                    }
                  });
                });
              }, t3.prototype.update = function(e4) {
                t3._clearContainer(this._container), this._options = e4 ? O3(a2(this._options, e4)) : this._options, this._options.data && (this._qr = P3()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || function(t4) {
                  switch (true) {
                    case /^[0-9]*$/.test(t4):
                      return "Numeric";
                    case /^[0-9A-Z $%*+\-./:]*$/.test(t4):
                      return "Alphanumeric";
                    default:
                      return "Byte";
                  }
                }(this._options.data)), this._qr.make(), this._options.type === x3 ? this._setupCanvas() : this._setupSvg(), this.append(this._container));
              }, t3.prototype.append = function(t4) {
                if (t4) {
                  if ("function" != typeof t4.appendChild) throw "Container should be a single DOM node";
                  this._options.type === x3 ? this._canvas && t4.appendChild(this._canvas) : this._svg && t4.appendChild(this._svg), this._container = t4;
                }
              }, t3.prototype.applyExtension = function(t4) {
                if (!t4) throw "Extension function should be defined.";
                this._extension = t4, this.update();
              }, t3.prototype.deleteExtension = function() {
                this._extension = void 0, this.update();
              }, t3.prototype.getRawData = function(t4) {
                return void 0 === t4 && (t4 = "png"), z3(this, void 0, void 0, function() {
                  var e4, r5, n4;
                  return B3(this, function(o4) {
                    switch (o4.label) {
                      case 0:
                        if (!this._qr) throw "QR code is empty";
                        return [4, this._getElement(t4)];
                      case 1:
                        return (e4 = o4.sent()) ? "svg" === t4.toLowerCase() ? (r5 = new XMLSerializer(), n4 = r5.serializeToString(e4), [2, new Blob(['<?xml version="1.0" standalone="no"?>\r\n' + n4], { type: "image/svg+xml" })]) : [2, new Promise(function(r6) {
                          return e4.toBlob(r6, "image/" + t4, 1);
                        })] : [2, null];
                    }
                  });
                });
              }, t3.prototype.download = function(t4) {
                return z3(this, void 0, void 0, function() {
                  var e4, r5, n4, o4, i3;
                  return B3(this, function(a3) {
                    switch (a3.label) {
                      case 0:
                        if (!this._qr) throw "QR code is empty";
                        return e4 = "png", r5 = "qr", "string" == typeof t4 ? (e4 = t4, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : "object" == typeof t4 && null !== t4 && (t4.name && (r5 = t4.name), t4.extension && (e4 = t4.extension)), [4, this._getElement(e4)];
                      case 1:
                        return (n4 = a3.sent()) ? ("svg" === e4.toLowerCase() ? (o4 = new XMLSerializer(), i3 = '<?xml version="1.0" standalone="no"?>\r\n' + (i3 = o4.serializeToString(n4)), s2("data:image/svg+xml;charset=utf-8," + encodeURIComponent(i3), r5 + ".svg")) : s2(n4.toDataURL("image/" + e4), r5 + "." + e4), [2]) : [2];
                    }
                  });
                });
              }, t3;
            }();
          } }, e2 = {};
          function r3(n3) {
            if (e2[n3]) return e2[n3].exports;
            var o3 = e2[n3] = { exports: {} };
            return t[n3](o3, o3.exports, r3), o3.exports;
          }
          return r3.n = (t2) => {
            var e3 = t2 && t2.__esModule ? () => t2.default : () => t2;
            return r3.d(e3, { a: e3 }), e3;
          }, r3.d = (t2, e3) => {
            for (var n3 in e3) r3.o(e3, n3) && !r3.o(t2, n3) && Object.defineProperty(t2, n3, { enumerable: true, get: e3[n3] });
          }, r3.o = (t2, e3) => Object.prototype.hasOwnProperty.call(t2, e3), r3(676);
        })().default;
      });
    }
  });

  // node_modules/@evanhahn/lottie-web-light/index.js
  var require_lottie_web_light = __commonJS({
    "node_modules/@evanhahn/lottie-web-light/index.js"(exports, module) {
      init_polyfills();
      typeof navigator !== "undefined" && function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define(function() {
            return factory(root);
          });
        } else if (typeof module === "object" && module.exports) {
          module.exports = factory(root);
        } else {
          root.lottie = factory(root);
          root.bodymovin = root.lottie;
        }
      }(window || {}, function(window2) {
        "use strict";
        var svgNS = "http://www.w3.org/2000/svg";
        var locationHref = "";
        var initialDefaultFrame = -999999;
        var _useWebWorker = false;
        var subframeEnabled = true;
        var idPrefix = "";
        var expressionsPlugin;
        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        var cachedColors = {};
        var bmRnd;
        var bmPow = Math.pow;
        var bmSqrt = Math.sqrt;
        var bmFloor = Math.floor;
        var bmMax = Math.max;
        var bmMin = Math.min;
        var BMMath = {};
        (function() {
          var propertyNames = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
          var i2;
          var len = propertyNames.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            BMMath[propertyNames[i2]] = Math[propertyNames[i2]];
          }
        })();
        function ProjectInterface() {
          return {};
        }
        BMMath.random = Math.random;
        BMMath.abs = function(val) {
          var tOfVal = typeof val;
          if (tOfVal === "object" && val.length) {
            var absArr = createSizedArray(val.length);
            var i2;
            var len = val.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              absArr[i2] = Math.abs(val[i2]);
            }
            return absArr;
          }
          return Math.abs(val);
        };
        var defaultCurveSegments = 150;
        var degToRads = Math.PI / 180;
        var roundCorner = 0.5519;
        function roundValues(flag) {
          if (flag) {
            bmRnd = Math.round;
          } else {
            bmRnd = function(val) {
              return val;
            };
          }
        }
        roundValues(false);
        function styleDiv(element) {
          element.style.position = "absolute";
          element.style.top = 0;
          element.style.left = 0;
          element.style.display = "block";
          element.style.transformOrigin = "0 0";
          element.style.webkitTransformOrigin = "0 0";
          element.style.backfaceVisibility = "visible";
          element.style.webkitBackfaceVisibility = "visible";
          element.style.transformStyle = "preserve-3d";
          element.style.webkitTransformStyle = "preserve-3d";
          element.style.mozTransformStyle = "preserve-3d";
        }
        function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {
          this.type = type;
          this.currentTime = currentTime;
          this.totalTime = totalTime;
          this.direction = frameMultiplier < 0 ? -1 : 1;
        }
        function BMCompleteEvent(type, frameMultiplier) {
          this.type = type;
          this.direction = frameMultiplier < 0 ? -1 : 1;
        }
        function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {
          this.type = type;
          this.currentLoop = currentLoop;
          this.totalLoops = totalLoops;
          this.direction = frameMultiplier < 0 ? -1 : 1;
        }
        function BMSegmentStartEvent(type, firstFrame, totalFrames) {
          this.type = type;
          this.firstFrame = firstFrame;
          this.totalFrames = totalFrames;
        }
        function BMDestroyEvent(type, target) {
          this.type = type;
          this.target = target;
        }
        function BMRenderFrameErrorEvent(nativeError, currentTime) {
          this.type = "renderFrameError";
          this.nativeError = nativeError;
          this.currentTime = currentTime;
        }
        function BMConfigErrorEvent(nativeError) {
          this.type = "configError";
          this.nativeError = nativeError;
        }
        function BMAnimationConfigErrorEvent(type, nativeError) {
          this.type = type;
          this.nativeError = nativeError;
        }
        var createElementID = /* @__PURE__ */ function() {
          var _count = 0;
          return function createID() {
            _count += 1;
            return idPrefix + "__lottie_element_" + _count;
          };
        }();
        function HSVtoRGB(h3, s2, v3) {
          var r3;
          var g3;
          var b3;
          var i2;
          var f3;
          var p2;
          var q3;
          var t;
          i2 = Math.floor(h3 * 6);
          f3 = h3 * 6 - i2;
          p2 = v3 * (1 - s2);
          q3 = v3 * (1 - f3 * s2);
          t = v3 * (1 - (1 - f3) * s2);
          switch (i2 % 6) {
            case 0:
              r3 = v3;
              g3 = t;
              b3 = p2;
              break;
            case 1:
              r3 = q3;
              g3 = v3;
              b3 = p2;
              break;
            case 2:
              r3 = p2;
              g3 = v3;
              b3 = t;
              break;
            case 3:
              r3 = p2;
              g3 = q3;
              b3 = v3;
              break;
            case 4:
              r3 = t;
              g3 = p2;
              b3 = v3;
              break;
            case 5:
              r3 = v3;
              g3 = p2;
              b3 = q3;
              break;
            default:
              break;
          }
          return [
            r3,
            g3,
            b3
          ];
        }
        function RGBtoHSV(r3, g3, b3) {
          var max = Math.max(r3, g3, b3);
          var min = Math.min(r3, g3, b3);
          var d2 = max - min;
          var h3;
          var s2 = max === 0 ? 0 : d2 / max;
          var v3 = max / 255;
          switch (max) {
            case min:
              h3 = 0;
              break;
            case r3:
              h3 = g3 - b3 + d2 * (g3 < b3 ? 6 : 0);
              h3 /= 6 * d2;
              break;
            case g3:
              h3 = b3 - r3 + d2 * 2;
              h3 /= 6 * d2;
              break;
            case b3:
              h3 = r3 - g3 + d2 * 4;
              h3 /= 6 * d2;
              break;
            default:
              break;
          }
          return [
            h3,
            s2,
            v3
          ];
        }
        function addSaturationToRGB(color, offset) {
          var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
          hsv[1] += offset;
          if (hsv[1] > 1) {
            hsv[1] = 1;
          } else if (hsv[1] <= 0) {
            hsv[1] = 0;
          }
          return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
        }
        function addBrightnessToRGB(color, offset) {
          var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
          hsv[2] += offset;
          if (hsv[2] > 1) {
            hsv[2] = 1;
          } else if (hsv[2] < 0) {
            hsv[2] = 0;
          }
          return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
        }
        function addHueToRGB(color, offset) {
          var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);
          hsv[0] += offset / 360;
          if (hsv[0] > 1) {
            hsv[0] -= 1;
          } else if (hsv[0] < 0) {
            hsv[0] += 1;
          }
          return HSVtoRGB(hsv[0], hsv[1], hsv[2]);
        }
        var rgbToHex = function() {
          var colorMap = [];
          var i2;
          var hex;
          for (i2 = 0; i2 < 256; i2 += 1) {
            hex = i2.toString(16);
            colorMap[i2] = hex.length === 1 ? "0" + hex : hex;
          }
          return function(r3, g3, b3) {
            if (r3 < 0) {
              r3 = 0;
            }
            if (g3 < 0) {
              g3 = 0;
            }
            if (b3 < 0) {
              b3 = 0;
            }
            return "#" + colorMap[r3] + colorMap[g3] + colorMap[b3];
          };
        }();
        function BaseEvent() {
        }
        BaseEvent.prototype = {
          triggerEvent: function(eventName, args) {
            if (this._cbs[eventName]) {
              var callbacks = this._cbs[eventName];
              for (var i2 = 0; i2 < callbacks.length; i2 += 1) {
                callbacks[i2](args);
              }
            }
          },
          addEventListener: function(eventName, callback) {
            if (!this._cbs[eventName]) {
              this._cbs[eventName] = [];
            }
            this._cbs[eventName].push(callback);
            return function() {
              this.removeEventListener(eventName, callback);
            }.bind(this);
          },
          removeEventListener: function(eventName, callback) {
            if (!callback) {
              this._cbs[eventName] = null;
            } else if (this._cbs[eventName]) {
              var i2 = 0;
              var len = this._cbs[eventName].length;
              while (i2 < len) {
                if (this._cbs[eventName][i2] === callback) {
                  this._cbs[eventName].splice(i2, 1);
                  i2 -= 1;
                  len -= 1;
                }
                i2 += 1;
              }
              if (!this._cbs[eventName].length) {
                this._cbs[eventName] = null;
              }
            }
          }
        };
        var createTypedArray = function() {
          function createRegularArray(type, len) {
            var i2 = 0;
            var arr = [];
            var value;
            switch (type) {
              case "int16":
              case "uint8c":
                value = 1;
                break;
              default:
                value = 1.1;
                break;
            }
            for (i2 = 0; i2 < len; i2 += 1) {
              arr.push(value);
            }
            return arr;
          }
          function createTypedArrayFactory(type, len) {
            if (type === "float32") {
              return new Float32Array(len);
            }
            if (type === "int16") {
              return new Int16Array(len);
            }
            if (type === "uint8c") {
              return new Uint8ClampedArray(len);
            }
            return createRegularArray(type, len);
          }
          if (typeof Uint8ClampedArray === "function" && typeof Float32Array === "function") {
            return createTypedArrayFactory;
          }
          return createRegularArray;
        }();
        function createSizedArray(len) {
          return Array.apply(null, { length: len });
        }
        function createNS(type) {
          return document.createElementNS(svgNS, type);
        }
        function createTag(type) {
          return document.createElement(type);
        }
        function DynamicPropertyContainer() {
        }
        DynamicPropertyContainer.prototype = {
          addDynamicProperty: function(prop) {
            if (this.dynamicProperties.indexOf(prop) === -1) {
              this.dynamicProperties.push(prop);
              this.container.addDynamicProperty(this);
              this._isAnimated = true;
            }
          },
          iterateDynamicProperties: function() {
            this._mdf = false;
            var i2;
            var len = this.dynamicProperties.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.dynamicProperties[i2].getValue();
              if (this.dynamicProperties[i2]._mdf) {
                this._mdf = true;
              }
            }
          },
          initDynamicPropertyContainer: function(container) {
            this.container = container;
            this.dynamicProperties = [];
            this._mdf = false;
            this._isAnimated = false;
          }
        };
        var getBlendMode = /* @__PURE__ */ function() {
          var blendModeEnums = {
            0: "source-over",
            1: "multiply",
            2: "screen",
            3: "overlay",
            4: "darken",
            5: "lighten",
            6: "color-dodge",
            7: "color-burn",
            8: "hard-light",
            9: "soft-light",
            10: "difference",
            11: "exclusion",
            12: "hue",
            13: "saturation",
            14: "color",
            15: "luminosity"
          };
          return function(mode) {
            return blendModeEnums[mode] || "";
          };
        }();
        var lineCapEnum = {
          1: "butt",
          2: "round",
          3: "square"
        };
        var lineJoinEnum = {
          1: "miter",
          2: "round",
          3: "bevel"
        };
        var Matrix = /* @__PURE__ */ function() {
          var _cos = Math.cos;
          var _sin = Math.sin;
          var _tan = Math.tan;
          var _rnd = Math.round;
          function reset() {
            this.props[0] = 1;
            this.props[1] = 0;
            this.props[2] = 0;
            this.props[3] = 0;
            this.props[4] = 0;
            this.props[5] = 1;
            this.props[6] = 0;
            this.props[7] = 0;
            this.props[8] = 0;
            this.props[9] = 0;
            this.props[10] = 1;
            this.props[11] = 0;
            this.props[12] = 0;
            this.props[13] = 0;
            this.props[14] = 0;
            this.props[15] = 1;
            return this;
          }
          function rotate(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          }
          function rotateX(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);
          }
          function rotateY(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);
          }
          function rotateZ(angle) {
            if (angle === 0) {
              return this;
            }
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          }
          function shear(sx, sy) {
            return this._t(1, sy, sx, 1, 0, 0);
          }
          function skew(ax, ay) {
            return this.shear(_tan(ax), _tan(ay));
          }
          function skewFromAxis(ax, angle) {
            var mCos = _cos(angle);
            var mSin = _sin(angle);
            return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
          }
          function scale(sx, sy, sz) {
            if (!sz && sz !== 0) {
              sz = 1;
            }
            if (sx === 1 && sy === 1 && sz === 1) {
              return this;
            }
            return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
          }
          function setTransform(a2, b3, c2, d2, e2, f3, g3, h3, i2, j3, k3, l2, m3, n3, o3, p2) {
            this.props[0] = a2;
            this.props[1] = b3;
            this.props[2] = c2;
            this.props[3] = d2;
            this.props[4] = e2;
            this.props[5] = f3;
            this.props[6] = g3;
            this.props[7] = h3;
            this.props[8] = i2;
            this.props[9] = j3;
            this.props[10] = k3;
            this.props[11] = l2;
            this.props[12] = m3;
            this.props[13] = n3;
            this.props[14] = o3;
            this.props[15] = p2;
            return this;
          }
          function translate(tx, ty, tz) {
            tz = tz || 0;
            if (tx !== 0 || ty !== 0 || tz !== 0) {
              return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
            }
            return this;
          }
          function transform(a2, b22, c2, d2, e2, f22, g22, h22, i2, j22, k22, l2, m22, n22, o22, p2) {
            var _p = this.props;
            if (a2 === 1 && b22 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f22 === 1 && g22 === 0 && h22 === 0 && i2 === 0 && j22 === 0 && k22 === 1 && l2 === 0) {
              _p[12] = _p[12] * a2 + _p[15] * m22;
              _p[13] = _p[13] * f22 + _p[15] * n22;
              _p[14] = _p[14] * k22 + _p[15] * o22;
              _p[15] *= p2;
              this._identityCalculated = false;
              return this;
            }
            var a1 = _p[0];
            var b1 = _p[1];
            var c1 = _p[2];
            var d1 = _p[3];
            var e1 = _p[4];
            var f1 = _p[5];
            var g1 = _p[6];
            var h1 = _p[7];
            var i1 = _p[8];
            var j1 = _p[9];
            var k1 = _p[10];
            var l1 = _p[11];
            var m1 = _p[12];
            var n1 = _p[13];
            var o1 = _p[14];
            var p1 = _p[15];
            _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m22;
            _p[1] = a1 * b22 + b1 * f22 + c1 * j22 + d1 * n22;
            _p[2] = a1 * c2 + b1 * g22 + c1 * k22 + d1 * o22;
            _p[3] = a1 * d2 + b1 * h22 + c1 * l2 + d1 * p2;
            _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m22;
            _p[5] = e1 * b22 + f1 * f22 + g1 * j22 + h1 * n22;
            _p[6] = e1 * c2 + f1 * g22 + g1 * k22 + h1 * o22;
            _p[7] = e1 * d2 + f1 * h22 + g1 * l2 + h1 * p2;
            _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m22;
            _p[9] = i1 * b22 + j1 * f22 + k1 * j22 + l1 * n22;
            _p[10] = i1 * c2 + j1 * g22 + k1 * k22 + l1 * o22;
            _p[11] = i1 * d2 + j1 * h22 + k1 * l2 + l1 * p2;
            _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m22;
            _p[13] = m1 * b22 + n1 * f22 + o1 * j22 + p1 * n22;
            _p[14] = m1 * c2 + n1 * g22 + o1 * k22 + p1 * o22;
            _p[15] = m1 * d2 + n1 * h22 + o1 * l2 + p1 * p2;
            this._identityCalculated = false;
            return this;
          }
          function isIdentity() {
            if (!this._identityCalculated) {
              this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);
              this._identityCalculated = true;
            }
            return this._identity;
          }
          function equals(matr) {
            var i2 = 0;
            while (i2 < 16) {
              if (matr.props[i2] !== this.props[i2]) {
                return false;
              }
              i2 += 1;
            }
            return true;
          }
          function clone(matr) {
            var i2;
            for (i2 = 0; i2 < 16; i2 += 1) {
              matr.props[i2] = this.props[i2];
            }
            return matr;
          }
          function cloneFromProps(props) {
            var i2;
            for (i2 = 0; i2 < 16; i2 += 1) {
              this.props[i2] = props[i2];
            }
          }
          function applyToPoint(x3, y3, z3) {
            return {
              x: x3 * this.props[0] + y3 * this.props[4] + z3 * this.props[8] + this.props[12],
              y: x3 * this.props[1] + y3 * this.props[5] + z3 * this.props[9] + this.props[13],
              z: x3 * this.props[2] + y3 * this.props[6] + z3 * this.props[10] + this.props[14]
            };
          }
          function applyToX(x3, y3, z3) {
            return x3 * this.props[0] + y3 * this.props[4] + z3 * this.props[8] + this.props[12];
          }
          function applyToY(x3, y3, z3) {
            return x3 * this.props[1] + y3 * this.props[5] + z3 * this.props[9] + this.props[13];
          }
          function applyToZ(x3, y3, z3) {
            return x3 * this.props[2] + y3 * this.props[6] + z3 * this.props[10] + this.props[14];
          }
          function getInverseMatrix() {
            var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];
            var a2 = this.props[5] / determinant;
            var b3 = -this.props[1] / determinant;
            var c2 = -this.props[4] / determinant;
            var d2 = this.props[0] / determinant;
            var e2 = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;
            var f3 = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;
            var inverseMatrix = new Matrix();
            inverseMatrix.props[0] = a2;
            inverseMatrix.props[1] = b3;
            inverseMatrix.props[4] = c2;
            inverseMatrix.props[5] = d2;
            inverseMatrix.props[12] = e2;
            inverseMatrix.props[13] = f3;
            return inverseMatrix;
          }
          function inversePoint(pt2) {
            var inverseMatrix = this.getInverseMatrix();
            return inverseMatrix.applyToPointArray(pt2[0], pt2[1], pt2[2] || 0);
          }
          function inversePoints(pts) {
            var i2;
            var len = pts.length;
            var retPts = [];
            for (i2 = 0; i2 < len; i2 += 1) {
              retPts[i2] = inversePoint(pts[i2]);
            }
            return retPts;
          }
          function applyToTriplePoints(pt1, pt2, pt3) {
            var arr = createTypedArray("float32", 6);
            if (this.isIdentity()) {
              arr[0] = pt1[0];
              arr[1] = pt1[1];
              arr[2] = pt2[0];
              arr[3] = pt2[1];
              arr[4] = pt3[0];
              arr[5] = pt3[1];
            } else {
              var p0 = this.props[0];
              var p1 = this.props[1];
              var p4 = this.props[4];
              var p5 = this.props[5];
              var p12 = this.props[12];
              var p13 = this.props[13];
              arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;
              arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;
              arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;
              arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;
              arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;
              arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;
            }
            return arr;
          }
          function applyToPointArray(x3, y3, z3) {
            var arr;
            if (this.isIdentity()) {
              arr = [x3, y3, z3];
            } else {
              arr = [
                x3 * this.props[0] + y3 * this.props[4] + z3 * this.props[8] + this.props[12],
                x3 * this.props[1] + y3 * this.props[5] + z3 * this.props[9] + this.props[13],
                x3 * this.props[2] + y3 * this.props[6] + z3 * this.props[10] + this.props[14]
              ];
            }
            return arr;
          }
          function applyToPointStringified(x3, y3) {
            if (this.isIdentity()) {
              return x3 + "," + y3;
            }
            var _p = this.props;
            return Math.round((x3 * _p[0] + y3 * _p[4] + _p[12]) * 100) / 100 + "," + Math.round((x3 * _p[1] + y3 * _p[5] + _p[13]) * 100) / 100;
          }
          function toCSS() {
            var i2 = 0;
            var props = this.props;
            var cssValue = "matrix3d(";
            var v3 = 1e4;
            while (i2 < 16) {
              cssValue += _rnd(props[i2] * v3) / v3;
              cssValue += i2 === 15 ? ")" : ",";
              i2 += 1;
            }
            return cssValue;
          }
          function roundMatrixProperty(val) {
            var v3 = 1e4;
            if (val < 1e-6 && val > 0 || val > -1e-6 && val < 0) {
              return _rnd(val * v3) / v3;
            }
            return val;
          }
          function to2dCSS() {
            var props = this.props;
            var _a = roundMatrixProperty(props[0]);
            var _b = roundMatrixProperty(props[1]);
            var _c = roundMatrixProperty(props[4]);
            var _d = roundMatrixProperty(props[5]);
            var _e = roundMatrixProperty(props[12]);
            var _f = roundMatrixProperty(props[13]);
            return "matrix(" + _a + "," + _b + "," + _c + "," + _d + "," + _e + "," + _f + ")";
          }
          return function() {
            this.reset = reset;
            this.rotate = rotate;
            this.rotateX = rotateX;
            this.rotateY = rotateY;
            this.rotateZ = rotateZ;
            this.skew = skew;
            this.skewFromAxis = skewFromAxis;
            this.shear = shear;
            this.scale = scale;
            this.setTransform = setTransform;
            this.translate = translate;
            this.transform = transform;
            this.applyToPoint = applyToPoint;
            this.applyToX = applyToX;
            this.applyToY = applyToY;
            this.applyToZ = applyToZ;
            this.applyToPointArray = applyToPointArray;
            this.applyToTriplePoints = applyToTriplePoints;
            this.applyToPointStringified = applyToPointStringified;
            this.toCSS = toCSS;
            this.to2dCSS = to2dCSS;
            this.clone = clone;
            this.cloneFromProps = cloneFromProps;
            this.equals = equals;
            this.inversePoints = inversePoints;
            this.inversePoint = inversePoint;
            this.getInverseMatrix = getInverseMatrix;
            this._t = this.transform;
            this.isIdentity = isIdentity;
            this._identity = true;
            this._identityCalculated = false;
            this.props = createTypedArray("float32", 16);
            this.reset();
          };
        }();
        (function(pool, math) {
          var global2 = this, width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
          function seedrandom(seed, options, callback) {
            var key = [];
            options = options === true ? { entropy: true } : options || {};
            var shortseed = mixkey(flatten(
              options.entropy ? [seed, tostring(pool)] : seed === null ? autoseed() : seed,
              3
            ), key);
            var arc4 = new ARC4(key);
            var prng = function() {
              var n3 = arc4.g(chunks), d2 = startdenom, x3 = 0;
              while (n3 < significance) {
                n3 = (n3 + x3) * width;
                d2 *= width;
                x3 = arc4.g(1);
              }
              while (n3 >= overflow) {
                n3 /= 2;
                d2 /= 2;
                x3 >>>= 1;
              }
              return (n3 + x3) / d2;
            };
            prng.int32 = function() {
              return arc4.g(4) | 0;
            };
            prng.quick = function() {
              return arc4.g(4) / 4294967296;
            };
            prng.double = prng;
            mixkey(tostring(arc4.S), pool);
            return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
              if (state) {
                if (state.S) {
                  copy(state, arc4);
                }
                prng2.state = function() {
                  return copy(arc4, {});
                };
              }
              if (is_math_call) {
                math[rngname] = prng2;
                return seed2;
              } else return prng2;
            })(
              prng,
              shortseed,
              "global" in options ? options.global : this == math,
              options.state
            );
          }
          math["seed" + rngname] = seedrandom;
          function ARC4(key) {
            var t, keylen = key.length, me = this, i2 = 0, j3 = me.i = me.j = 0, s2 = me.S = [];
            if (!keylen) {
              key = [keylen++];
            }
            while (i2 < width) {
              s2[i2] = i2++;
            }
            for (i2 = 0; i2 < width; i2++) {
              s2[i2] = s2[j3 = mask & j3 + key[i2 % keylen] + (t = s2[i2])];
              s2[j3] = t;
            }
            me.g = function(count) {
              var t2, r3 = 0, i3 = me.i, j4 = me.j, s3 = me.S;
              while (count--) {
                t2 = s3[i3 = mask & i3 + 1];
                r3 = r3 * width + s3[mask & (s3[i3] = s3[j4 = mask & j4 + t2]) + (s3[j4] = t2)];
              }
              me.i = i3;
              me.j = j4;
              return r3;
            };
          }
          function copy(f3, t) {
            t.i = f3.i;
            t.j = f3.j;
            t.S = f3.S.slice();
            return t;
          }
          function flatten(obj, depth) {
            var result = [], typ = typeof obj, prop;
            if (depth && typ == "object") {
              for (prop in obj) {
                try {
                  result.push(flatten(obj[prop], depth - 1));
                } catch (e2) {
                }
              }
            }
            return result.length ? result : typ == "string" ? obj : obj + "\0";
          }
          function mixkey(seed, key) {
            var stringseed = seed + "", smear, j3 = 0;
            while (j3 < stringseed.length) {
              key[mask & j3] = mask & (smear ^= key[mask & j3] * 19) + stringseed.charCodeAt(j3++);
            }
            return tostring(key);
          }
          function autoseed() {
            try {
              if (nodecrypto) {
                return tostring(nodecrypto.randomBytes(width));
              }
              var out = new Uint8Array(width);
              (global2.crypto || global2.msCrypto).getRandomValues(out);
              return tostring(out);
            } catch (e2) {
              var browser = global2.navigator, plugins = browser && browser.plugins;
              return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool)];
            }
          }
          function tostring(a2) {
            return String.fromCharCode.apply(0, a2);
          }
          mixkey(math.random(), pool);
        })(
          [],
          // pool: entropy pool starts empty
          BMMath
          // math: package containing random, pow, and seedrandom
        );
        var BezierFactory = function() {
          var ob = {};
          ob.getBezierEasing = getBezierEasing;
          var beziers = {};
          function getBezierEasing(a2, b3, c2, d2, nm) {
            var str = nm || ("bez_" + a2 + "_" + b3 + "_" + c2 + "_" + d2).replace(/\./g, "p");
            if (beziers[str]) {
              return beziers[str];
            }
            var bezEasing = new BezierEasing([a2, b3, c2, d2]);
            beziers[str] = bezEasing;
            return bezEasing;
          }
          var NEWTON_ITERATIONS = 4;
          var NEWTON_MIN_SLOPE = 1e-3;
          var SUBDIVISION_PRECISION = 1e-7;
          var SUBDIVISION_MAX_ITERATIONS = 10;
          var kSplineTableSize = 11;
          var kSampleStepSize = 1 / (kSplineTableSize - 1);
          var float32ArraySupported = typeof Float32Array === "function";
          function A3(aA1, aA2) {
            return 1 - 3 * aA2 + 3 * aA1;
          }
          function B3(aA1, aA2) {
            return 3 * aA2 - 6 * aA1;
          }
          function C3(aA1) {
            return 3 * aA1;
          }
          function calcBezier(aT, aA1, aA2) {
            return ((A3(aA1, aA2) * aT + B3(aA1, aA2)) * aT + C3(aA1)) * aT;
          }
          function getSlope(aT, aA1, aA2) {
            return 3 * A3(aA1, aA2) * aT * aT + 2 * B3(aA1, aA2) * aT + C3(aA1);
          }
          function binarySubdivide(aX, aA, aB, mX1, mX2) {
            var currentX, currentT, i2 = 0;
            do {
              currentT = aA + (aB - aA) / 2;
              currentX = calcBezier(currentT, mX1, mX2) - aX;
              if (currentX > 0) {
                aB = currentT;
              } else {
                aA = currentT;
              }
            } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i2 < SUBDIVISION_MAX_ITERATIONS);
            return currentT;
          }
          function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
            for (var i2 = 0; i2 < NEWTON_ITERATIONS; ++i2) {
              var currentSlope = getSlope(aGuessT, mX1, mX2);
              if (currentSlope === 0) return aGuessT;
              var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
              aGuessT -= currentX / currentSlope;
            }
            return aGuessT;
          }
          function BezierEasing(points) {
            this._p = points;
            this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
            this._precomputed = false;
            this.get = this.get.bind(this);
          }
          BezierEasing.prototype = {
            get: function(x3) {
              var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
              if (!this._precomputed) this._precompute();
              if (mX1 === mY1 && mX2 === mY2) return x3;
              if (x3 === 0) return 0;
              if (x3 === 1) return 1;
              return calcBezier(this._getTForX(x3), mY1, mY2);
            },
            // Private part
            _precompute: function() {
              var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];
              this._precomputed = true;
              if (mX1 !== mY1 || mX2 !== mY2) {
                this._calcSampleValues();
              }
            },
            _calcSampleValues: function() {
              var mX1 = this._p[0], mX2 = this._p[2];
              for (var i2 = 0; i2 < kSplineTableSize; ++i2) {
                this._mSampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
              }
            },
            /**
                 * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
                 */
            _getTForX: function(aX) {
              var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;
              var intervalStart = 0;
              var currentSample = 1;
              var lastSample = kSplineTableSize - 1;
              for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
                intervalStart += kSampleStepSize;
              }
              --currentSample;
              var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);
              var guessForT = intervalStart + dist * kSampleStepSize;
              var initialSlope = getSlope(guessForT, mX1, mX2);
              if (initialSlope >= NEWTON_MIN_SLOPE) {
                return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
              }
              if (initialSlope === 0) {
                return guessForT;
              }
              return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
            }
          };
          return ob;
        }();
        (function() {
          var lastTime = 0;
          var vendors = ["ms", "moz", "webkit", "o"];
          for (var x3 = 0; x3 < vendors.length && !window2.requestAnimationFrame; ++x3) {
            window2.requestAnimationFrame = window2[vendors[x3] + "RequestAnimationFrame"];
            window2.cancelAnimationFrame = window2[vendors[x3] + "CancelAnimationFrame"] || window2[vendors[x3] + "CancelRequestAnimationFrame"];
          }
          if (!window2.requestAnimationFrame) {
            window2.requestAnimationFrame = function(callback) {
              var currTime = (/* @__PURE__ */ new Date()).getTime();
              var timeToCall = Math.max(0, 16 - (currTime - lastTime));
              var id = setTimeout(
                function() {
                  callback(currTime + timeToCall);
                },
                timeToCall
              );
              lastTime = currTime + timeToCall;
              return id;
            };
          }
          if (!window2.cancelAnimationFrame) {
            window2.cancelAnimationFrame = function(id) {
              clearTimeout(id);
            };
          }
        })();
        function extendPrototype(sources, destination) {
          var i2;
          var len = sources.length;
          var sourcePrototype;
          for (i2 = 0; i2 < len; i2 += 1) {
            sourcePrototype = sources[i2].prototype;
            for (var attr in sourcePrototype) {
              if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];
            }
          }
        }
        function getDescriptor(object, prop) {
          return Object.getOwnPropertyDescriptor(object, prop);
        }
        function createProxyFunction(prototype) {
          function ProxyFunction() {
          }
          ProxyFunction.prototype = prototype;
          return ProxyFunction;
        }
        function bezFunction() {
          var math = Math;
          function pointOnLine2D(x1, y1, x22, y22, x3, y3) {
            var det1 = x1 * y22 + y1 * x3 + x22 * y3 - x3 * y22 - y3 * x1 - x22 * y1;
            return det1 > -1e-3 && det1 < 1e-3;
          }
          function pointOnLine3D(x1, y1, z1, x22, y22, z22, x3, y3, z3) {
            if (z1 === 0 && z22 === 0 && z3 === 0) {
              return pointOnLine2D(x1, y1, x22, y22, x3, y3);
            }
            var dist1 = math.sqrt(math.pow(x22 - x1, 2) + math.pow(y22 - y1, 2) + math.pow(z22 - z1, 2));
            var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));
            var dist3 = math.sqrt(math.pow(x3 - x22, 2) + math.pow(y3 - y22, 2) + math.pow(z3 - z22, 2));
            var diffDist;
            if (dist1 > dist2) {
              if (dist1 > dist3) {
                diffDist = dist1 - dist2 - dist3;
              } else {
                diffDist = dist3 - dist2 - dist1;
              }
            } else if (dist3 > dist2) {
              diffDist = dist3 - dist2 - dist1;
            } else {
              diffDist = dist2 - dist1 - dist3;
            }
            return diffDist > -1e-4 && diffDist < 1e-4;
          }
          var getBezierLength = /* @__PURE__ */ function() {
            return function(pt1, pt2, pt3, pt4) {
              var curveSegments = defaultCurveSegments;
              var k3;
              var i2;
              var len;
              var ptCoord;
              var perc;
              var addedLength = 0;
              var ptDistance;
              var point = [];
              var lastPoint = [];
              var lengthData = bezierLengthPool.newElement();
              len = pt3.length;
              for (k3 = 0; k3 < curveSegments; k3 += 1) {
                perc = k3 / (curveSegments - 1);
                ptDistance = 0;
                for (i2 = 0; i2 < len; i2 += 1) {
                  ptCoord = bmPow(1 - perc, 3) * pt1[i2] + 3 * bmPow(1 - perc, 2) * perc * pt3[i2] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i2] + bmPow(perc, 3) * pt2[i2];
                  point[i2] = ptCoord;
                  if (lastPoint[i2] !== null) {
                    ptDistance += bmPow(point[i2] - lastPoint[i2], 2);
                  }
                  lastPoint[i2] = point[i2];
                }
                if (ptDistance) {
                  ptDistance = bmSqrt(ptDistance);
                  addedLength += ptDistance;
                }
                lengthData.percents[k3] = perc;
                lengthData.lengths[k3] = addedLength;
              }
              lengthData.addedLength = addedLength;
              return lengthData;
            };
          }();
          function getSegmentsLength(shapeData) {
            var segmentsLength = segmentsLengthPool.newElement();
            var closed = shapeData.c;
            var pathV = shapeData.v;
            var pathO = shapeData.o;
            var pathI = shapeData.i;
            var i2;
            var len = shapeData._length;
            var lengths = segmentsLength.lengths;
            var totalLength = 0;
            for (i2 = 0; i2 < len - 1; i2 += 1) {
              lengths[i2] = getBezierLength(pathV[i2], pathV[i2 + 1], pathO[i2], pathI[i2 + 1]);
              totalLength += lengths[i2].addedLength;
            }
            if (closed && len) {
              lengths[i2] = getBezierLength(pathV[i2], pathV[0], pathO[i2], pathI[0]);
              totalLength += lengths[i2].addedLength;
            }
            segmentsLength.totalLength = totalLength;
            return segmentsLength;
          }
          function BezierData(length) {
            this.segmentLength = 0;
            this.points = new Array(length);
          }
          function PointData(partial, point) {
            this.partialLength = partial;
            this.point = point;
          }
          var buildBezierData = /* @__PURE__ */ function() {
            var storedData = {};
            return function(pt1, pt2, pt3, pt4) {
              var bezierName = (pt1[0] + "_" + pt1[1] + "_" + pt2[0] + "_" + pt2[1] + "_" + pt3[0] + "_" + pt3[1] + "_" + pt4[0] + "_" + pt4[1]).replace(/\./g, "p");
              if (!storedData[bezierName]) {
                var curveSegments = defaultCurveSegments;
                var k3;
                var i2;
                var len;
                var ptCoord;
                var perc;
                var addedLength = 0;
                var ptDistance;
                var point;
                var lastPoint = null;
                if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {
                  curveSegments = 2;
                }
                var bezierData = new BezierData(curveSegments);
                len = pt3.length;
                for (k3 = 0; k3 < curveSegments; k3 += 1) {
                  point = createSizedArray(len);
                  perc = k3 / (curveSegments - 1);
                  ptDistance = 0;
                  for (i2 = 0; i2 < len; i2 += 1) {
                    ptCoord = bmPow(1 - perc, 3) * pt1[i2] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i2] + pt3[i2]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i2] + pt4[i2]) + bmPow(perc, 3) * pt2[i2];
                    point[i2] = ptCoord;
                    if (lastPoint !== null) {
                      ptDistance += bmPow(point[i2] - lastPoint[i2], 2);
                    }
                  }
                  ptDistance = bmSqrt(ptDistance);
                  addedLength += ptDistance;
                  bezierData.points[k3] = new PointData(ptDistance, point);
                  lastPoint = point;
                }
                bezierData.segmentLength = addedLength;
                storedData[bezierName] = bezierData;
              }
              return storedData[bezierName];
            };
          }();
          function getDistancePerc(perc, bezierData) {
            var percents = bezierData.percents;
            var lengths = bezierData.lengths;
            var len = percents.length;
            var initPos = bmFloor((len - 1) * perc);
            var lengthPos = perc * bezierData.addedLength;
            var lPerc = 0;
            if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {
              return percents[initPos];
            }
            var dir = lengths[initPos] > lengthPos ? -1 : 1;
            var flag = true;
            while (flag) {
              if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {
                lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);
                flag = false;
              } else {
                initPos += dir;
              }
              if (initPos < 0 || initPos >= len - 1) {
                if (initPos === len - 1) {
                  return percents[initPos];
                }
                flag = false;
              }
            }
            return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;
          }
          function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {
            var t1 = getDistancePerc(percent, bezierData);
            var u1 = 1 - t1;
            var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1e3) / 1e3;
            var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1e3) / 1e3;
            return [ptX, ptY];
          }
          var bezierSegmentPoints = createTypedArray("float32", 8);
          function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {
            if (startPerc < 0) {
              startPerc = 0;
            } else if (startPerc > 1) {
              startPerc = 1;
            }
            var t0 = getDistancePerc(startPerc, bezierData);
            endPerc = endPerc > 1 ? 1 : endPerc;
            var t1 = getDistancePerc(endPerc, bezierData);
            var i2;
            var len = pt1.length;
            var u0 = 1 - t0;
            var u1 = 1 - t1;
            var u0u0u0 = u0 * u0 * u0;
            var t0u0u0_3 = t0 * u0 * u0 * 3;
            var t0t0u0_3 = t0 * t0 * u0 * 3;
            var t0t0t0 = t0 * t0 * t0;
            var u0u0u1 = u0 * u0 * u1;
            var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1;
            var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1;
            var t0t0t1 = t0 * t0 * t1;
            var u0u1u1 = u0 * u1 * u1;
            var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1;
            var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1;
            var t0t1t1 = t0 * t1 * t1;
            var u1u1u1 = u1 * u1 * u1;
            var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1;
            var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1;
            var t1t1t1 = t1 * t1 * t1;
            for (i2 = 0; i2 < len; i2 += 1) {
              bezierSegmentPoints[i2 * 4] = math.round((u0u0u0 * pt1[i2] + t0u0u0_3 * pt3[i2] + t0t0u0_3 * pt4[i2] + t0t0t0 * pt2[i2]) * 1e3) / 1e3;
              bezierSegmentPoints[i2 * 4 + 1] = math.round((u0u0u1 * pt1[i2] + t0u0u1_3 * pt3[i2] + t0t0u1_3 * pt4[i2] + t0t0t1 * pt2[i2]) * 1e3) / 1e3;
              bezierSegmentPoints[i2 * 4 + 2] = math.round((u0u1u1 * pt1[i2] + t0u1u1_3 * pt3[i2] + t0t1u1_3 * pt4[i2] + t0t1t1 * pt2[i2]) * 1e3) / 1e3;
              bezierSegmentPoints[i2 * 4 + 3] = math.round((u1u1u1 * pt1[i2] + t1u1u1_3 * pt3[i2] + t1t1u1_3 * pt4[i2] + t1t1t1 * pt2[i2]) * 1e3) / 1e3;
            }
            return bezierSegmentPoints;
          }
          return {
            getSegmentsLength,
            getNewSegment,
            getPointInSegment,
            buildBezierData,
            pointOnLine2D,
            pointOnLine3D
          };
        }
        var bez = bezFunction();
        var dataManager = /* @__PURE__ */ function() {
          var _counterId = 1;
          var processes = [];
          var workerFn;
          var workerInstance;
          var workerProxy = {
            onmessage: function() {
            },
            postMessage: function(path) {
              workerFn({
                data: path
              });
            }
          };
          var _workerSelf = {
            postMessage: function(data) {
              workerProxy.onmessage({
                data
              });
            }
          };
          function createWorker(fn) {
            if (window2.Worker && window2.Blob && _useWebWorker) {
              var blob = new Blob(["var _workerSelf = self; self.onmessage = ", fn.toString()], { type: "text/javascript" });
              var url = URL.createObjectURL(blob);
              return new Worker(url);
            }
            workerFn = fn;
            return workerProxy;
          }
          function setupWorker() {
            if (!workerInstance) {
              workerInstance = createWorker(function workerStart(e2) {
                function dataFunctionManager() {
                  function completeLayers(layers, comps) {
                    var layerData;
                    var i2;
                    var len = layers.length;
                    var j3;
                    var jLen;
                    var k3;
                    var kLen;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      layerData = layers[i2];
                      if ("ks" in layerData && !layerData.completed) {
                        layerData.completed = true;
                        if (layerData.tt) {
                          layers[i2 - 1].td = layerData.tt;
                        }
                        if (layerData.hasMask) {
                          var maskProps = layerData.masksProperties;
                          jLen = maskProps.length;
                          for (j3 = 0; j3 < jLen; j3 += 1) {
                            if (maskProps[j3].pt.k.i) {
                              convertPathsToAbsoluteValues(maskProps[j3].pt.k);
                            } else {
                              kLen = maskProps[j3].pt.k.length;
                              for (k3 = 0; k3 < kLen; k3 += 1) {
                                if (maskProps[j3].pt.k[k3].s) {
                                  convertPathsToAbsoluteValues(maskProps[j3].pt.k[k3].s[0]);
                                }
                                if (maskProps[j3].pt.k[k3].e) {
                                  convertPathsToAbsoluteValues(maskProps[j3].pt.k[k3].e[0]);
                                }
                              }
                            }
                          }
                        }
                        if (layerData.ty === 0) {
                          layerData.layers = findCompLayers(layerData.refId, comps);
                          completeLayers(layerData.layers, comps);
                        } else if (layerData.ty === 4) {
                          completeShapes(layerData.shapes);
                        } else if (layerData.ty === 5) {
                          completeText(layerData);
                        }
                      }
                    }
                  }
                  function findCompLayers(id, comps) {
                    var i2 = 0;
                    var len = comps.length;
                    while (i2 < len) {
                      if (comps[i2].id === id) {
                        if (!comps[i2].layers.__used) {
                          comps[i2].layers.__used = true;
                          return comps[i2].layers;
                        }
                        return JSON.parse(JSON.stringify(comps[i2].layers));
                      }
                      i2 += 1;
                    }
                    return null;
                  }
                  function completeShapes(arr) {
                    var i2;
                    var len = arr.length;
                    var j3;
                    var jLen;
                    for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                      if (arr[i2].ty === "sh") {
                        if (arr[i2].ks.k.i) {
                          convertPathsToAbsoluteValues(arr[i2].ks.k);
                        } else {
                          jLen = arr[i2].ks.k.length;
                          for (j3 = 0; j3 < jLen; j3 += 1) {
                            if (arr[i2].ks.k[j3].s) {
                              convertPathsToAbsoluteValues(arr[i2].ks.k[j3].s[0]);
                            }
                            if (arr[i2].ks.k[j3].e) {
                              convertPathsToAbsoluteValues(arr[i2].ks.k[j3].e[0]);
                            }
                          }
                        }
                      } else if (arr[i2].ty === "gr") {
                        completeShapes(arr[i2].it);
                      }
                    }
                  }
                  function convertPathsToAbsoluteValues(path) {
                    var i2;
                    var len = path.i.length;
                    for (i2 = 0; i2 < len; i2 += 1) {
                      path.i[i2][0] += path.v[i2][0];
                      path.i[i2][1] += path.v[i2][1];
                      path.o[i2][0] += path.v[i2][0];
                      path.o[i2][1] += path.v[i2][1];
                    }
                  }
                  function checkVersion(minimum, animVersionString) {
                    var animVersion = animVersionString ? animVersionString.split(".") : [100, 100, 100];
                    if (minimum[0] > animVersion[0]) {
                      return true;
                    }
                    if (animVersion[0] > minimum[0]) {
                      return false;
                    }
                    if (minimum[1] > animVersion[1]) {
                      return true;
                    }
                    if (animVersion[1] > minimum[1]) {
                      return false;
                    }
                    if (minimum[2] > animVersion[2]) {
                      return true;
                    }
                    if (animVersion[2] > minimum[2]) {
                      return false;
                    }
                    return null;
                  }
                  var checkText = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 4, 14];
                    function updateTextLayer(textLayer) {
                      var documentData = textLayer.t.d;
                      textLayer.t.d = {
                        k: [
                          {
                            s: documentData,
                            t: 0
                          }
                        ]
                      };
                    }
                    function iterateLayers(layers) {
                      var i2;
                      var len = layers.length;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        if (layers[i2].ty === 5) {
                          updateTextLayer(layers[i2]);
                        }
                      }
                    }
                    return function(animationData2) {
                      if (checkVersion(minimumVersion, animationData2.v)) {
                        iterateLayers(animationData2.layers);
                        if (animationData2.assets) {
                          var i2;
                          var len = animationData2.assets.length;
                          for (i2 = 0; i2 < len; i2 += 1) {
                            if (animationData2.assets[i2].layers) {
                              iterateLayers(animationData2.assets[i2].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkChars = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 7, 99];
                    return function(animationData2) {
                      if (animationData2.chars && !checkVersion(minimumVersion, animationData2.v)) {
                        var i2;
                        var len = animationData2.chars.length;
                        var j3;
                        var jLen;
                        var pathData;
                        var paths;
                        for (i2 = 0; i2 < len; i2 += 1) {
                          if (animationData2.chars[i2].data && animationData2.chars[i2].data.shapes) {
                            paths = animationData2.chars[i2].data.shapes[0].it;
                            jLen = paths.length;
                            for (j3 = 0; j3 < jLen; j3 += 1) {
                              pathData = paths[j3].ks.k;
                              if (!pathData.__converted) {
                                convertPathsToAbsoluteValues(paths[j3].ks.k);
                                pathData.__converted = true;
                              }
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkPathProperties = /* @__PURE__ */ function() {
                    var minimumVersion = [5, 7, 15];
                    function updateTextLayer(textLayer) {
                      var pathData = textLayer.t.p;
                      if (typeof pathData.a === "number") {
                        pathData.a = {
                          a: 0,
                          k: pathData.a
                        };
                      }
                      if (typeof pathData.p === "number") {
                        pathData.p = {
                          a: 0,
                          k: pathData.p
                        };
                      }
                      if (typeof pathData.r === "number") {
                        pathData.r = {
                          a: 0,
                          k: pathData.r
                        };
                      }
                    }
                    function iterateLayers(layers) {
                      var i2;
                      var len = layers.length;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        if (layers[i2].ty === 5) {
                          updateTextLayer(layers[i2]);
                        }
                      }
                    }
                    return function(animationData2) {
                      if (checkVersion(minimumVersion, animationData2.v)) {
                        iterateLayers(animationData2.layers);
                        if (animationData2.assets) {
                          var i2;
                          var len = animationData2.assets.length;
                          for (i2 = 0; i2 < len; i2 += 1) {
                            if (animationData2.assets[i2].layers) {
                              iterateLayers(animationData2.assets[i2].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkColors = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 1, 9];
                    function iterateShapes(shapes) {
                      var i2;
                      var len = shapes.length;
                      var j3;
                      var jLen;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        if (shapes[i2].ty === "gr") {
                          iterateShapes(shapes[i2].it);
                        } else if (shapes[i2].ty === "fl" || shapes[i2].ty === "st") {
                          if (shapes[i2].c.k && shapes[i2].c.k[0].i) {
                            jLen = shapes[i2].c.k.length;
                            for (j3 = 0; j3 < jLen; j3 += 1) {
                              if (shapes[i2].c.k[j3].s) {
                                shapes[i2].c.k[j3].s[0] /= 255;
                                shapes[i2].c.k[j3].s[1] /= 255;
                                shapes[i2].c.k[j3].s[2] /= 255;
                                shapes[i2].c.k[j3].s[3] /= 255;
                              }
                              if (shapes[i2].c.k[j3].e) {
                                shapes[i2].c.k[j3].e[0] /= 255;
                                shapes[i2].c.k[j3].e[1] /= 255;
                                shapes[i2].c.k[j3].e[2] /= 255;
                                shapes[i2].c.k[j3].e[3] /= 255;
                              }
                            }
                          } else {
                            shapes[i2].c.k[0] /= 255;
                            shapes[i2].c.k[1] /= 255;
                            shapes[i2].c.k[2] /= 255;
                            shapes[i2].c.k[3] /= 255;
                          }
                        }
                      }
                    }
                    function iterateLayers(layers) {
                      var i2;
                      var len = layers.length;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        if (layers[i2].ty === 4) {
                          iterateShapes(layers[i2].shapes);
                        }
                      }
                    }
                    return function(animationData2) {
                      if (checkVersion(minimumVersion, animationData2.v)) {
                        iterateLayers(animationData2.layers);
                        if (animationData2.assets) {
                          var i2;
                          var len = animationData2.assets.length;
                          for (i2 = 0; i2 < len; i2 += 1) {
                            if (animationData2.assets[i2].layers) {
                              iterateLayers(animationData2.assets[i2].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  var checkShapes = /* @__PURE__ */ function() {
                    var minimumVersion = [4, 4, 18];
                    function completeClosingShapes(arr) {
                      var i2;
                      var len = arr.length;
                      var j3;
                      var jLen;
                      for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                        if (arr[i2].ty === "sh") {
                          if (arr[i2].ks.k.i) {
                            arr[i2].ks.k.c = arr[i2].closed;
                          } else {
                            jLen = arr[i2].ks.k.length;
                            for (j3 = 0; j3 < jLen; j3 += 1) {
                              if (arr[i2].ks.k[j3].s) {
                                arr[i2].ks.k[j3].s[0].c = arr[i2].closed;
                              }
                              if (arr[i2].ks.k[j3].e) {
                                arr[i2].ks.k[j3].e[0].c = arr[i2].closed;
                              }
                            }
                          }
                        } else if (arr[i2].ty === "gr") {
                          completeClosingShapes(arr[i2].it);
                        }
                      }
                    }
                    function iterateLayers(layers) {
                      var layerData;
                      var i2;
                      var len = layers.length;
                      var j3;
                      var jLen;
                      var k3;
                      var kLen;
                      for (i2 = 0; i2 < len; i2 += 1) {
                        layerData = layers[i2];
                        if (layerData.hasMask) {
                          var maskProps = layerData.masksProperties;
                          jLen = maskProps.length;
                          for (j3 = 0; j3 < jLen; j3 += 1) {
                            if (maskProps[j3].pt.k.i) {
                              maskProps[j3].pt.k.c = maskProps[j3].cl;
                            } else {
                              kLen = maskProps[j3].pt.k.length;
                              for (k3 = 0; k3 < kLen; k3 += 1) {
                                if (maskProps[j3].pt.k[k3].s) {
                                  maskProps[j3].pt.k[k3].s[0].c = maskProps[j3].cl;
                                }
                                if (maskProps[j3].pt.k[k3].e) {
                                  maskProps[j3].pt.k[k3].e[0].c = maskProps[j3].cl;
                                }
                              }
                            }
                          }
                        }
                        if (layerData.ty === 4) {
                          completeClosingShapes(layerData.shapes);
                        }
                      }
                    }
                    return function(animationData2) {
                      if (checkVersion(minimumVersion, animationData2.v)) {
                        iterateLayers(animationData2.layers);
                        if (animationData2.assets) {
                          var i2;
                          var len = animationData2.assets.length;
                          for (i2 = 0; i2 < len; i2 += 1) {
                            if (animationData2.assets[i2].layers) {
                              iterateLayers(animationData2.assets[i2].layers);
                            }
                          }
                        }
                      }
                    };
                  }();
                  function completeData(animationData2) {
                    if (animationData2.__complete) {
                      return;
                    }
                    checkColors(animationData2);
                    checkText(animationData2);
                    checkChars(animationData2);
                    checkPathProperties(animationData2);
                    checkShapes(animationData2);
                    completeLayers(animationData2.layers, animationData2.assets);
                    animationData2.__complete = true;
                  }
                  function completeText(data) {
                    if (data.t.a.length === 0 && !("m" in data.t.p)) {
                      data.singleShape = true;
                    }
                  }
                  var moduleOb = {};
                  moduleOb.completeData = completeData;
                  moduleOb.checkColors = checkColors;
                  moduleOb.checkChars = checkChars;
                  moduleOb.checkPathProperties = checkPathProperties;
                  moduleOb.checkShapes = checkShapes;
                  moduleOb.completeLayers = completeLayers;
                  return moduleOb;
                }
                if (!_workerSelf.dataManager) {
                  _workerSelf.dataManager = dataFunctionManager();
                }
                if (!_workerSelf.assetLoader) {
                  _workerSelf.assetLoader = /* @__PURE__ */ function() {
                    function formatResponse(xhr) {
                      var contentTypeHeader = xhr.getResponseHeader("content-type");
                      if (contentTypeHeader && xhr.responseType === "json" && contentTypeHeader.indexOf("json") !== -1) {
                        return xhr.response;
                      }
                      if (xhr.response && typeof xhr.response === "object") {
                        return xhr.response;
                      }
                      if (xhr.response && typeof xhr.response === "string") {
                        return JSON.parse(xhr.response);
                      }
                      if (xhr.responseText) {
                        return JSON.parse(xhr.responseText);
                      }
                      return null;
                    }
                    function loadAsset(path, fullPath, callback, errorCallback) {
                      var response;
                      var xhr = new XMLHttpRequest();
                      try {
                        xhr.responseType = "json";
                      } catch (err) {
                      }
                      xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                          if (xhr.status === 200) {
                            response = formatResponse(xhr);
                            callback(response);
                          } else {
                            try {
                              response = formatResponse(xhr);
                              callback(response);
                            } catch (err) {
                              if (errorCallback) {
                                errorCallback(err);
                              }
                            }
                          }
                        }
                      };
                      try {
                        xhr.open("GET", path, true);
                      } catch (error) {
                        xhr.open("GET", fullPath + "/" + path, true);
                      }
                      xhr.send();
                    }
                    return {
                      load: loadAsset
                    };
                  }();
                }
                if (e2.data.type === "loadAnimation") {
                  _workerSelf.assetLoader.load(
                    e2.data.path,
                    e2.data.fullPath,
                    function(data) {
                      _workerSelf.dataManager.completeData(data);
                      _workerSelf.postMessage({
                        id: e2.data.id,
                        payload: data,
                        status: "success"
                      });
                    },
                    function() {
                      _workerSelf.postMessage({
                        id: e2.data.id,
                        status: "error"
                      });
                    }
                  );
                } else if (e2.data.type === "complete") {
                  var animation = e2.data.animation;
                  _workerSelf.dataManager.completeData(animation);
                  _workerSelf.postMessage({
                    id: e2.data.id,
                    payload: animation,
                    status: "success"
                  });
                } else if (e2.data.type === "loadData") {
                  _workerSelf.assetLoader.load(
                    e2.data.path,
                    e2.data.fullPath,
                    function(data) {
                      _workerSelf.postMessage({
                        id: e2.data.id,
                        payload: data,
                        status: "success"
                      });
                    },
                    function() {
                      _workerSelf.postMessage({
                        id: e2.data.id,
                        status: "error"
                      });
                    }
                  );
                }
              });
              workerInstance.onmessage = function(event) {
                var data = event.data;
                var id = data.id;
                var process2 = processes[id];
                processes[id] = null;
                if (data.status === "success") {
                  process2.onComplete(data.payload);
                } else if (process2.onError) {
                  process2.onError();
                }
              };
            }
          }
          function createProcess(onComplete, onError) {
            _counterId += 1;
            var id = "processId_" + _counterId;
            processes[id] = {
              onComplete,
              onError
            };
            return id;
          }
          function loadAnimation2(path, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
              type: "loadAnimation",
              path,
              fullPath: window2.location.origin + window2.location.pathname,
              id: processId
            });
          }
          function loadData(path, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
              type: "loadData",
              path,
              fullPath: window2.location.origin + window2.location.pathname,
              id: processId
            });
          }
          function completeAnimation(anim, onComplete, onError) {
            setupWorker();
            var processId = createProcess(onComplete, onError);
            workerInstance.postMessage({
              type: "complete",
              animation: anim,
              id: processId
            });
          }
          return {
            loadAnimation: loadAnimation2,
            loadData,
            completeAnimation
          };
        }();
        function getFontProperties(fontData) {
          var styles = fontData.fStyle ? fontData.fStyle.split(" ") : [];
          var fWeight = "normal";
          var fStyle = "normal";
          var len = styles.length;
          var styleName;
          for (var i2 = 0; i2 < len; i2 += 1) {
            styleName = styles[i2].toLowerCase();
            switch (styleName) {
              case "italic":
                fStyle = "italic";
                break;
              case "bold":
                fWeight = "700";
                break;
              case "black":
                fWeight = "900";
                break;
              case "medium":
                fWeight = "500";
                break;
              case "regular":
              case "normal":
                fWeight = "400";
                break;
              case "light":
              case "thin":
                fWeight = "200";
                break;
              default:
                break;
            }
          }
          return {
            style: fStyle,
            weight: fontData.fWeight || fWeight
          };
        }
        var FontManager = function() {
          var maxWaitingTime = 5e3;
          var emptyChar = {
            w: 0,
            size: 0,
            shapes: []
          };
          var combinedCharacters = [];
          combinedCharacters = combinedCharacters.concat([
            2304,
            2305,
            2306,
            2307,
            2362,
            2363,
            2364,
            2364,
            2366,
            2367,
            2368,
            2369,
            2370,
            2371,
            2372,
            2373,
            2374,
            2375,
            2376,
            2377,
            2378,
            2379,
            2380,
            2381,
            2382,
            2383,
            2387,
            2388,
            2389,
            2390,
            2391,
            2402,
            2403
          ]);
          var surrogateModifiers = [
            "d83cdffb",
            "d83cdffc",
            "d83cdffd",
            "d83cdffe",
            "d83cdfff"
          ];
          var zeroWidthJoiner = [65039, 8205];
          function trimFontOptions(font) {
            var familyArray = font.split(",");
            var i2;
            var len = familyArray.length;
            var enabledFamilies = [];
            for (i2 = 0; i2 < len; i2 += 1) {
              if (familyArray[i2] !== "sans-serif" && familyArray[i2] !== "monospace") {
                enabledFamilies.push(familyArray[i2]);
              }
            }
            return enabledFamilies.join(",");
          }
          function setUpNode(font, family) {
            var parentNode = createTag("span");
            parentNode.setAttribute("aria-hidden", true);
            parentNode.style.fontFamily = family;
            var node = createTag("span");
            node.innerText = "giItT1WQy@!-/#";
            parentNode.style.position = "absolute";
            parentNode.style.left = "-10000px";
            parentNode.style.top = "-10000px";
            parentNode.style.fontSize = "300px";
            parentNode.style.fontVariant = "normal";
            parentNode.style.fontStyle = "normal";
            parentNode.style.fontWeight = "normal";
            parentNode.style.letterSpacing = "0";
            parentNode.appendChild(node);
            document.body.appendChild(parentNode);
            var width = node.offsetWidth;
            node.style.fontFamily = trimFontOptions(font) + ", " + family;
            return { node, w: width, parent: parentNode };
          }
          function checkLoadedFonts() {
            var i2;
            var len = this.fonts.length;
            var node;
            var w3;
            var loadedCount = len;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.fonts[i2].loaded) {
                loadedCount -= 1;
              } else if (this.fonts[i2].fOrigin === "n" || this.fonts[i2].origin === 0) {
                this.fonts[i2].loaded = true;
              } else {
                node = this.fonts[i2].monoCase.node;
                w3 = this.fonts[i2].monoCase.w;
                if (node.offsetWidth !== w3) {
                  loadedCount -= 1;
                  this.fonts[i2].loaded = true;
                } else {
                  node = this.fonts[i2].sansCase.node;
                  w3 = this.fonts[i2].sansCase.w;
                  if (node.offsetWidth !== w3) {
                    loadedCount -= 1;
                    this.fonts[i2].loaded = true;
                  }
                }
                if (this.fonts[i2].loaded) {
                  this.fonts[i2].sansCase.parent.parentNode.removeChild(this.fonts[i2].sansCase.parent);
                  this.fonts[i2].monoCase.parent.parentNode.removeChild(this.fonts[i2].monoCase.parent);
                }
              }
            }
            if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {
              setTimeout(this.checkLoadedFontsBinded, 20);
            } else {
              setTimeout(this.setIsLoadedBinded, 10);
            }
          }
          function createHelper(def, fontData) {
            var tHelper = createNS("text");
            tHelper.style.fontSize = "100px";
            var fontProps = getFontProperties(fontData);
            tHelper.setAttribute("font-family", fontData.fFamily);
            tHelper.setAttribute("font-style", fontProps.style);
            tHelper.setAttribute("font-weight", fontProps.weight);
            tHelper.textContent = "1";
            if (fontData.fClass) {
              tHelper.style.fontFamily = "inherit";
              tHelper.setAttribute("class", fontData.fClass);
            } else {
              tHelper.style.fontFamily = fontData.fFamily;
            }
            def.appendChild(tHelper);
            var tCanvasHelper = createTag("canvas").getContext("2d");
            tCanvasHelper.font = fontData.fWeight + " " + fontData.fStyle + " 100px " + fontData.fFamily;
            return tHelper;
          }
          function addFonts(fontData, defs) {
            if (!fontData) {
              this.isLoaded = true;
              return;
            }
            if (this.chars) {
              this.isLoaded = true;
              this.fonts = fontData.list;
              return;
            }
            var fontArr = fontData.list;
            var i2;
            var len = fontArr.length;
            var _pendingFonts = len;
            for (i2 = 0; i2 < len; i2 += 1) {
              var shouldLoadFont = true;
              var loadedSelector;
              var j3;
              fontArr[i2].loaded = false;
              fontArr[i2].monoCase = setUpNode(fontArr[i2].fFamily, "monospace");
              fontArr[i2].sansCase = setUpNode(fontArr[i2].fFamily, "sans-serif");
              if (!fontArr[i2].fPath) {
                fontArr[i2].loaded = true;
                _pendingFonts -= 1;
              } else if (fontArr[i2].fOrigin === "p" || fontArr[i2].origin === 3) {
                loadedSelector = document.querySelectorAll('style[f-forigin="p"][f-family="' + fontArr[i2].fFamily + '"], style[f-origin="3"][f-family="' + fontArr[i2].fFamily + '"]');
                if (loadedSelector.length > 0) {
                  shouldLoadFont = false;
                }
                if (shouldLoadFont) {
                  var s2 = createTag("style");
                  s2.setAttribute("f-forigin", fontArr[i2].fOrigin);
                  s2.setAttribute("f-origin", fontArr[i2].origin);
                  s2.setAttribute("f-family", fontArr[i2].fFamily);
                  s2.type = "text/css";
                  s2.innerText = "@font-face {font-family: " + fontArr[i2].fFamily + "; font-style: normal; src: url('" + fontArr[i2].fPath + "');}";
                  defs.appendChild(s2);
                }
              } else if (fontArr[i2].fOrigin === "g" || fontArr[i2].origin === 1) {
                loadedSelector = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');
                for (j3 = 0; j3 < loadedSelector.length; j3 += 1) {
                  if (loadedSelector[j3].href.indexOf(fontArr[i2].fPath) !== -1) {
                    shouldLoadFont = false;
                  }
                }
                if (shouldLoadFont) {
                  var l2 = createTag("link");
                  l2.setAttribute("f-forigin", fontArr[i2].fOrigin);
                  l2.setAttribute("f-origin", fontArr[i2].origin);
                  l2.type = "text/css";
                  l2.rel = "stylesheet";
                  l2.href = fontArr[i2].fPath;
                  document.body.appendChild(l2);
                }
              } else if (fontArr[i2].fOrigin === "t" || fontArr[i2].origin === 2) {
                loadedSelector = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');
                for (j3 = 0; j3 < loadedSelector.length; j3 += 1) {
                  if (fontArr[i2].fPath === loadedSelector[j3].src) {
                    shouldLoadFont = false;
                  }
                }
                if (shouldLoadFont) {
                  var sc = createTag("link");
                  sc.setAttribute("f-forigin", fontArr[i2].fOrigin);
                  sc.setAttribute("f-origin", fontArr[i2].origin);
                  sc.setAttribute("rel", "stylesheet");
                  sc.setAttribute("href", fontArr[i2].fPath);
                  defs.appendChild(sc);
                }
              }
              fontArr[i2].helper = createHelper(defs, fontArr[i2]);
              fontArr[i2].cache = {};
              this.fonts.push(fontArr[i2]);
            }
            if (_pendingFonts === 0) {
              this.isLoaded = true;
            } else {
              setTimeout(this.checkLoadedFonts.bind(this), 100);
            }
          }
          function addChars(chars) {
            if (!chars) {
              return;
            }
            if (!this.chars) {
              this.chars = [];
            }
            var i2;
            var len = chars.length;
            var j3;
            var jLen = this.chars.length;
            var found;
            for (i2 = 0; i2 < len; i2 += 1) {
              j3 = 0;
              found = false;
              while (j3 < jLen) {
                if (this.chars[j3].style === chars[i2].style && this.chars[j3].fFamily === chars[i2].fFamily && this.chars[j3].ch === chars[i2].ch) {
                  found = true;
                }
                j3 += 1;
              }
              if (!found) {
                this.chars.push(chars[i2]);
                jLen += 1;
              }
            }
          }
          function getCharData(char, style, font) {
            var i2 = 0;
            var len = this.chars.length;
            while (i2 < len) {
              if (this.chars[i2].ch === char && this.chars[i2].style === style && this.chars[i2].fFamily === font) {
                return this.chars[i2];
              }
              i2 += 1;
            }
            if ((typeof char === "string" && char.charCodeAt(0) !== 13 || !char) && console && console.warn && !this._warned) {
              this._warned = true;
              console.warn("Missing character from exported characters list: ", char, style, font);
            }
            return emptyChar;
          }
          function measureText(char, fontName, size) {
            var fontData = this.getFontByName(fontName);
            var index2 = char.charCodeAt(0);
            if (!fontData.cache[index2 + 1]) {
              var tHelper = fontData.helper;
              if (char === " ") {
                tHelper.textContent = "|" + char + "|";
                var doubleSize = tHelper.getComputedTextLength();
                tHelper.textContent = "||";
                var singleSize = tHelper.getComputedTextLength();
                fontData.cache[index2 + 1] = (doubleSize - singleSize) / 100;
              } else {
                tHelper.textContent = char;
                fontData.cache[index2 + 1] = tHelper.getComputedTextLength() / 100;
              }
            }
            return fontData.cache[index2 + 1] * size;
          }
          function getFontByName(name) {
            var i2 = 0;
            var len = this.fonts.length;
            while (i2 < len) {
              if (this.fonts[i2].fName === name) {
                return this.fonts[i2];
              }
              i2 += 1;
            }
            return this.fonts[0];
          }
          function isModifier(firstCharCode, secondCharCode) {
            var sum = firstCharCode.toString(16) + secondCharCode.toString(16);
            return surrogateModifiers.indexOf(sum) !== -1;
          }
          function isZeroWidthJoiner(firstCharCode, secondCharCode) {
            if (!secondCharCode) {
              return firstCharCode === zeroWidthJoiner[1];
            }
            return firstCharCode === zeroWidthJoiner[0] && secondCharCode === zeroWidthJoiner[1];
          }
          function isCombinedCharacter(char) {
            return combinedCharacters.indexOf(char) !== -1;
          }
          function setIsLoaded() {
            this.isLoaded = true;
          }
          var Font = function() {
            this.fonts = [];
            this.chars = null;
            this.typekitLoaded = 0;
            this.isLoaded = false;
            this._warned = false;
            this.initTime = Date.now();
            this.setIsLoadedBinded = this.setIsLoaded.bind(this);
            this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
          };
          Font.isModifier = isModifier;
          Font.isZeroWidthJoiner = isZeroWidthJoiner;
          Font.isCombinedCharacter = isCombinedCharacter;
          var fontPrototype = {
            addChars,
            addFonts,
            getCharData,
            getFontByName,
            measureText,
            checkLoadedFonts,
            setIsLoaded
          };
          Font.prototype = fontPrototype;
          return Font;
        }();
        var PropertyFactory = /* @__PURE__ */ function() {
          var initFrame = initialDefaultFrame;
          var mathAbs = Math.abs;
          function interpolateValue(frameNum, caching) {
            var offsetTime = this.offsetTime;
            var newValue;
            if (this.propType === "multidimensional") {
              newValue = createTypedArray("float32", this.pv.length);
            }
            var iterationIndex = caching.lastIndex;
            var i2 = iterationIndex;
            var len = this.keyframes.length - 1;
            var flag = true;
            var keyData;
            var nextKeyData;
            var keyframeMetadata;
            while (flag) {
              keyData = this.keyframes[i2];
              nextKeyData = this.keyframes[i2 + 1];
              if (i2 === len - 1 && frameNum >= nextKeyData.t - offsetTime) {
                if (keyData.h) {
                  keyData = nextKeyData;
                }
                iterationIndex = 0;
                break;
              }
              if (nextKeyData.t - offsetTime > frameNum) {
                iterationIndex = i2;
                break;
              }
              if (i2 < len - 1) {
                i2 += 1;
              } else {
                iterationIndex = 0;
                flag = false;
              }
            }
            keyframeMetadata = this.keyframesMetadata[i2] || {};
            var k3;
            var kLen;
            var perc;
            var jLen;
            var j3;
            var fnc;
            var nextKeyTime = nextKeyData.t - offsetTime;
            var keyTime = keyData.t - offsetTime;
            var endValue;
            if (keyData.to) {
              if (!keyframeMetadata.bezierData) {
                keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);
              }
              var bezierData = keyframeMetadata.bezierData;
              if (frameNum >= nextKeyTime || frameNum < keyTime) {
                var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;
                kLen = bezierData.points[ind].point.length;
                for (k3 = 0; k3 < kLen; k3 += 1) {
                  newValue[k3] = bezierData.points[ind].point[k3];
                }
              } else {
                if (keyframeMetadata.__fnct) {
                  fnc = keyframeMetadata.__fnct;
                } else {
                  fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;
                  keyframeMetadata.__fnct = fnc;
                }
                perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                var distanceInLine = bezierData.segmentLength * perc;
                var segmentPerc;
                var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i2 ? caching._lastAddedLength : 0;
                j3 = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i2 ? caching._lastPoint : 0;
                flag = true;
                jLen = bezierData.points.length;
                while (flag) {
                  addedLength += bezierData.points[j3].partialLength;
                  if (distanceInLine === 0 || perc === 0 || j3 === bezierData.points.length - 1) {
                    kLen = bezierData.points[j3].point.length;
                    for (k3 = 0; k3 < kLen; k3 += 1) {
                      newValue[k3] = bezierData.points[j3].point[k3];
                    }
                    break;
                  } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j3 + 1].partialLength) {
                    segmentPerc = (distanceInLine - addedLength) / bezierData.points[j3 + 1].partialLength;
                    kLen = bezierData.points[j3].point.length;
                    for (k3 = 0; k3 < kLen; k3 += 1) {
                      newValue[k3] = bezierData.points[j3].point[k3] + (bezierData.points[j3 + 1].point[k3] - bezierData.points[j3].point[k3]) * segmentPerc;
                    }
                    break;
                  }
                  if (j3 < jLen - 1) {
                    j3 += 1;
                  } else {
                    flag = false;
                  }
                }
                caching._lastPoint = j3;
                caching._lastAddedLength = addedLength - bezierData.points[j3].partialLength;
                caching._lastKeyframeIndex = i2;
              }
            } else {
              var outX;
              var outY;
              var inX;
              var inY;
              var keyValue;
              len = keyData.s.length;
              endValue = nextKeyData.s || keyData.e;
              if (this.sh && keyData.h !== 1) {
                if (frameNum >= nextKeyTime) {
                  newValue[0] = endValue[0];
                  newValue[1] = endValue[1];
                  newValue[2] = endValue[2];
                } else if (frameNum <= keyTime) {
                  newValue[0] = keyData.s[0];
                  newValue[1] = keyData.s[1];
                  newValue[2] = keyData.s[2];
                } else {
                  var quatStart = createQuaternion(keyData.s);
                  var quatEnd = createQuaternion(endValue);
                  var time = (frameNum - keyTime) / (nextKeyTime - keyTime);
                  quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));
                }
              } else {
                for (i2 = 0; i2 < len; i2 += 1) {
                  if (keyData.h !== 1) {
                    if (frameNum >= nextKeyTime) {
                      perc = 1;
                    } else if (frameNum < keyTime) {
                      perc = 0;
                    } else {
                      if (keyData.o.x.constructor === Array) {
                        if (!keyframeMetadata.__fnct) {
                          keyframeMetadata.__fnct = [];
                        }
                        if (!keyframeMetadata.__fnct[i2]) {
                          outX = keyData.o.x[i2] === void 0 ? keyData.o.x[0] : keyData.o.x[i2];
                          outY = keyData.o.y[i2] === void 0 ? keyData.o.y[0] : keyData.o.y[i2];
                          inX = keyData.i.x[i2] === void 0 ? keyData.i.x[0] : keyData.i.x[i2];
                          inY = keyData.i.y[i2] === void 0 ? keyData.i.y[0] : keyData.i.y[i2];
                          fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                          keyframeMetadata.__fnct[i2] = fnc;
                        } else {
                          fnc = keyframeMetadata.__fnct[i2];
                        }
                      } else if (!keyframeMetadata.__fnct) {
                        outX = keyData.o.x;
                        outY = keyData.o.y;
                        inX = keyData.i.x;
                        inY = keyData.i.y;
                        fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;
                        keyData.keyframeMetadata = fnc;
                      } else {
                        fnc = keyframeMetadata.__fnct;
                      }
                      perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));
                    }
                  }
                  endValue = nextKeyData.s || keyData.e;
                  keyValue = keyData.h === 1 ? keyData.s[i2] : keyData.s[i2] + (endValue[i2] - keyData.s[i2]) * perc;
                  if (this.propType === "multidimensional") {
                    newValue[i2] = keyValue;
                  } else {
                    newValue = keyValue;
                  }
                }
              }
            }
            caching.lastIndex = iterationIndex;
            return newValue;
          }
          function slerp(a2, b3, t) {
            var out = [];
            var ax = a2[0];
            var ay = a2[1];
            var az = a2[2];
            var aw = a2[3];
            var bx = b3[0];
            var by = b3[1];
            var bz = b3[2];
            var bw = b3[3];
            var omega;
            var cosom;
            var sinom;
            var scale0;
            var scale1;
            cosom = ax * bx + ay * by + az * bz + aw * bw;
            if (cosom < 0) {
              cosom = -cosom;
              bx = -bx;
              by = -by;
              bz = -bz;
              bw = -bw;
            }
            if (1 - cosom > 1e-6) {
              omega = Math.acos(cosom);
              sinom = Math.sin(omega);
              scale0 = Math.sin((1 - t) * omega) / sinom;
              scale1 = Math.sin(t * omega) / sinom;
            } else {
              scale0 = 1 - t;
              scale1 = t;
            }
            out[0] = scale0 * ax + scale1 * bx;
            out[1] = scale0 * ay + scale1 * by;
            out[2] = scale0 * az + scale1 * bz;
            out[3] = scale0 * aw + scale1 * bw;
            return out;
          }
          function quaternionToEuler(out, quat) {
            var qx = quat[0];
            var qy = quat[1];
            var qz = quat[2];
            var qw = quat[3];
            var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);
            var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);
            var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);
            out[0] = heading / degToRads;
            out[1] = attitude / degToRads;
            out[2] = bank / degToRads;
          }
          function createQuaternion(values) {
            var heading = values[0] * degToRads;
            var attitude = values[1] * degToRads;
            var bank = values[2] * degToRads;
            var c1 = Math.cos(heading / 2);
            var c2 = Math.cos(attitude / 2);
            var c3 = Math.cos(bank / 2);
            var s1 = Math.sin(heading / 2);
            var s2 = Math.sin(attitude / 2);
            var s3 = Math.sin(bank / 2);
            var w3 = c1 * c2 * c3 - s1 * s2 * s3;
            var x3 = s1 * s2 * c3 + c1 * c2 * s3;
            var y3 = s1 * c2 * c3 + c1 * s2 * s3;
            var z3 = c1 * s2 * c3 - s1 * c2 * s3;
            return [x3, y3, z3, w3];
          }
          function getValueAtCurrentTime() {
            var frameNum = this.comp.renderedFrame - this.offsetTime;
            var initTime = this.keyframes[0].t - this.offsetTime;
            var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
            if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {
              if (this._caching.lastFrame >= frameNum) {
                this._caching._lastKeyframeIndex = -1;
                this._caching.lastIndex = 0;
              }
              var renderResult = this.interpolateValue(frameNum, this._caching);
              this.pv = renderResult;
            }
            this._caching.lastFrame = frameNum;
            return this.pv;
          }
          function setVValue(val) {
            var multipliedValue;
            if (this.propType === "unidimensional") {
              multipliedValue = val * this.mult;
              if (mathAbs(this.v - multipliedValue) > 1e-5) {
                this.v = multipliedValue;
                this._mdf = true;
              }
            } else {
              var i2 = 0;
              var len = this.v.length;
              while (i2 < len) {
                multipliedValue = val[i2] * this.mult;
                if (mathAbs(this.v[i2] - multipliedValue) > 1e-5) {
                  this.v[i2] = multipliedValue;
                  this._mdf = true;
                }
                i2 += 1;
              }
            }
          }
          function processEffectsSequence() {
            if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {
              return;
            }
            if (this.lock) {
              this.setVValue(this.pv);
              return;
            }
            this.lock = true;
            this._mdf = this._isFirstFrame;
            var i2;
            var len = this.effectsSequence.length;
            var finalValue = this.kf ? this.pv : this.data.k;
            for (i2 = 0; i2 < len; i2 += 1) {
              finalValue = this.effectsSequence[i2](finalValue);
            }
            this.setVValue(finalValue);
            this._isFirstFrame = false;
            this.lock = false;
            this.frameId = this.elem.globalData.frameId;
          }
          function addEffect(effectFunction) {
            this.effectsSequence.push(effectFunction);
            this.container.addDynamicProperty(this);
          }
          function ValueProperty(elem, data, mult, container) {
            this.propType = "unidimensional";
            this.mult = mult || 1;
            this.data = data;
            this.v = mult ? data.k * mult : data.k;
            this.pv = data.k;
            this._mdf = false;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.k = false;
            this.kf = false;
            this.vel = 0;
            this.effectsSequence = [];
            this._isFirstFrame = true;
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.addEffect = addEffect;
          }
          function MultiDimensionalProperty(elem, data, mult, container) {
            this.propType = "multidimensional";
            this.mult = mult || 1;
            this.data = data;
            this._mdf = false;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.k = false;
            this.kf = false;
            this.frameId = -1;
            var i2;
            var len = data.k.length;
            this.v = createTypedArray("float32", len);
            this.pv = createTypedArray("float32", len);
            this.vel = createTypedArray("float32", len);
            for (i2 = 0; i2 < len; i2 += 1) {
              this.v[i2] = data.k[i2] * this.mult;
              this.pv[i2] = data.k[i2];
            }
            this._isFirstFrame = true;
            this.effectsSequence = [];
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.addEffect = addEffect;
          }
          function KeyframedValueProperty(elem, data, mult, container) {
            this.propType = "unidimensional";
            this.keyframes = data.k;
            this.keyframesMetadata = [];
            this.offsetTime = elem.data.st;
            this.frameId = -1;
            this._caching = {
              lastFrame: initFrame,
              lastIndex: 0,
              value: 0,
              _lastKeyframeIndex: -1
            };
            this.k = true;
            this.kf = true;
            this.data = data;
            this.mult = mult || 1;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.v = initFrame;
            this.pv = initFrame;
            this._isFirstFrame = true;
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.interpolateValue = interpolateValue;
            this.effectsSequence = [getValueAtCurrentTime.bind(this)];
            this.addEffect = addEffect;
          }
          function KeyframedMultidimensionalProperty(elem, data, mult, container) {
            this.propType = "multidimensional";
            var i2;
            var len = data.k.length;
            var s2;
            var e2;
            var to;
            var ti;
            for (i2 = 0; i2 < len - 1; i2 += 1) {
              if (data.k[i2].to && data.k[i2].s && data.k[i2 + 1] && data.k[i2 + 1].s) {
                s2 = data.k[i2].s;
                e2 = data.k[i2 + 1].s;
                to = data.k[i2].to;
                ti = data.k[i2].ti;
                if (s2.length === 2 && !(s2[0] === e2[0] && s2[1] === e2[1]) && bez.pointOnLine2D(s2[0], s2[1], e2[0], e2[1], s2[0] + to[0], s2[1] + to[1]) && bez.pointOnLine2D(s2[0], s2[1], e2[0], e2[1], e2[0] + ti[0], e2[1] + ti[1]) || s2.length === 3 && !(s2[0] === e2[0] && s2[1] === e2[1] && s2[2] === e2[2]) && bez.pointOnLine3D(s2[0], s2[1], s2[2], e2[0], e2[1], e2[2], s2[0] + to[0], s2[1] + to[1], s2[2] + to[2]) && bez.pointOnLine3D(s2[0], s2[1], s2[2], e2[0], e2[1], e2[2], e2[0] + ti[0], e2[1] + ti[1], e2[2] + ti[2])) {
                  data.k[i2].to = null;
                  data.k[i2].ti = null;
                }
                if (s2[0] === e2[0] && s2[1] === e2[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {
                  if (s2.length === 2 || s2[2] === e2[2] && to[2] === 0 && ti[2] === 0) {
                    data.k[i2].to = null;
                    data.k[i2].ti = null;
                  }
                }
              }
            }
            this.effectsSequence = [getValueAtCurrentTime.bind(this)];
            this.data = data;
            this.keyframes = data.k;
            this.keyframesMetadata = [];
            this.offsetTime = elem.data.st;
            this.k = true;
            this.kf = true;
            this._isFirstFrame = true;
            this.mult = mult || 1;
            this.elem = elem;
            this.container = container;
            this.comp = elem.comp;
            this.getValue = processEffectsSequence;
            this.setVValue = setVValue;
            this.interpolateValue = interpolateValue;
            this.frameId = -1;
            var arrLen = data.k[0].s.length;
            this.v = createTypedArray("float32", arrLen);
            this.pv = createTypedArray("float32", arrLen);
            for (i2 = 0; i2 < arrLen; i2 += 1) {
              this.v[i2] = initFrame;
              this.pv[i2] = initFrame;
            }
            this._caching = { lastFrame: initFrame, lastIndex: 0, value: createTypedArray("float32", arrLen) };
            this.addEffect = addEffect;
          }
          function getProp(elem, data, type, mult, container) {
            var p2;
            if (!data.k.length) {
              p2 = new ValueProperty(elem, data, mult, container);
            } else if (typeof data.k[0] === "number") {
              p2 = new MultiDimensionalProperty(elem, data, mult, container);
            } else {
              switch (type) {
                case 0:
                  p2 = new KeyframedValueProperty(elem, data, mult, container);
                  break;
                case 1:
                  p2 = new KeyframedMultidimensionalProperty(elem, data, mult, container);
                  break;
                default:
                  break;
              }
            }
            if (p2.effectsSequence.length) {
              container.addDynamicProperty(p2);
            }
            return p2;
          }
          var ob = {
            getProp
          };
          return ob;
        }();
        var TransformPropertyFactory = function() {
          var defaultVector = [0, 0];
          function applyToMatrix(mat) {
            var _mdf = this._mdf;
            this.iterateDynamicProperties();
            this._mdf = this._mdf || _mdf;
            if (this.a) {
              mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
            }
            if (this.s) {
              mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
            }
            if (this.sk) {
              mat.skewFromAxis(-this.sk.v, this.sa.v);
            }
            if (this.r) {
              mat.rotate(-this.r.v);
            } else {
              mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
            }
            if (this.data.p.s) {
              if (this.data.p.z) {
                mat.translate(this.px.v, this.py.v, -this.pz.v);
              } else {
                mat.translate(this.px.v, this.py.v, 0);
              }
            } else {
              mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
            }
          }
          function processKeys(forceRender) {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            if (this._isDirty) {
              this.precalculateMatrix();
              this._isDirty = false;
            }
            this.iterateDynamicProperties();
            if (this._mdf || forceRender) {
              var frameRate;
              this.v.cloneFromProps(this.pre.props);
              if (this.appliedTransformations < 1) {
                this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
              }
              if (this.appliedTransformations < 2) {
                this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
              }
              if (this.sk && this.appliedTransformations < 3) {
                this.v.skewFromAxis(-this.sk.v, this.sa.v);
              }
              if (this.r && this.appliedTransformations < 4) {
                this.v.rotate(-this.r.v);
              } else if (!this.r && this.appliedTransformations < 4) {
                this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
              }
              if (this.autoOriented) {
                var v1;
                var v22;
                frameRate = this.elem.globalData.frameRate;
                if (this.p && this.p.keyframes && this.p.getValueAtTime) {
                  if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {
                    v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);
                    v22 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);
                  } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {
                    v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);
                    v22 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);
                  } else {
                    v1 = this.p.pv;
                    v22 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);
                  }
                } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                  v1 = [];
                  v22 = [];
                  var px = this.px;
                  var py = this.py;
                  if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {
                    v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);
                    v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);
                    v22[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);
                    v22[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);
                  } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {
                    v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);
                    v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);
                    v22[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);
                    v22[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);
                  } else {
                    v1 = [px.pv, py.pv];
                    v22[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);
                    v22[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);
                  }
                } else {
                  v22 = defaultVector;
                  v1 = v22;
                }
                this.v.rotate(-Math.atan2(v1[1] - v22[1], v1[0] - v22[0]));
              }
              if (this.data.p && this.data.p.s) {
                if (this.data.p.z) {
                  this.v.translate(this.px.v, this.py.v, -this.pz.v);
                } else {
                  this.v.translate(this.px.v, this.py.v, 0);
                }
              } else {
                this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
              }
            }
            this.frameId = this.elem.globalData.frameId;
          }
          function precalculateMatrix() {
            if (!this.a.k) {
              this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);
              this.appliedTransformations = 1;
            } else {
              return;
            }
            if (!this.s.effectsSequence.length) {
              this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);
              this.appliedTransformations = 2;
            } else {
              return;
            }
            if (this.sk) {
              if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {
                this.pre.skewFromAxis(-this.sk.v, this.sa.v);
                this.appliedTransformations = 3;
              } else {
                return;
              }
            }
            if (this.r) {
              if (!this.r.effectsSequence.length) {
                this.pre.rotate(-this.r.v);
                this.appliedTransformations = 4;
              }
            } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {
              this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);
              this.appliedTransformations = 4;
            }
          }
          function autoOrient() {
          }
          function addDynamicProperty(prop) {
            this._addDynamicProperty(prop);
            this.elem.addDynamicProperty(prop);
            this._isDirty = true;
          }
          function TransformProperty(elem, data, container) {
            this.elem = elem;
            this.frameId = -1;
            this.propType = "transform";
            this.data = data;
            this.v = new Matrix();
            this.pre = new Matrix();
            this.appliedTransformations = 0;
            this.initDynamicPropertyContainer(container || elem);
            if (data.p && data.p.s) {
              this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);
              this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);
              if (data.p.z) {
                this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);
              }
            } else {
              this.p = PropertyFactory.getProp(elem, data.p || { k: [0, 0, 0] }, 1, 0, this);
            }
            if (data.rx) {
              this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);
              this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);
              this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);
              if (data.or.k[0].ti) {
                var i2;
                var len = data.or.k.length;
                for (i2 = 0; i2 < len; i2 += 1) {
                  data.or.k[i2].to = null;
                  data.or.k[i2].ti = null;
                }
              }
              this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);
              this.or.sh = true;
            } else {
              this.r = PropertyFactory.getProp(elem, data.r || { k: 0 }, 0, degToRads, this);
            }
            if (data.sk) {
              this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);
              this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);
            }
            this.a = PropertyFactory.getProp(elem, data.a || { k: [0, 0, 0] }, 1, 0, this);
            this.s = PropertyFactory.getProp(elem, data.s || { k: [100, 100, 100] }, 1, 0.01, this);
            if (data.o) {
              this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);
            } else {
              this.o = { _mdf: false, v: 1 };
            }
            this._isDirty = true;
            if (!this.dynamicProperties.length) {
              this.getValue(true);
            }
          }
          TransformProperty.prototype = {
            applyToMatrix,
            getValue: processKeys,
            precalculateMatrix,
            autoOrient
          };
          extendPrototype([DynamicPropertyContainer], TransformProperty);
          TransformProperty.prototype.addDynamicProperty = addDynamicProperty;
          TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
          function getTransformProperty(elem, data, container) {
            return new TransformProperty(elem, data, container);
          }
          return {
            getTransformProperty
          };
        }();
        function ShapePath() {
          this.c = false;
          this._length = 0;
          this._maxLength = 8;
          this.v = createSizedArray(this._maxLength);
          this.o = createSizedArray(this._maxLength);
          this.i = createSizedArray(this._maxLength);
        }
        ShapePath.prototype.setPathData = function(closed, len) {
          this.c = closed;
          this.setLength(len);
          var i2 = 0;
          while (i2 < len) {
            this.v[i2] = pointPool.newElement();
            this.o[i2] = pointPool.newElement();
            this.i[i2] = pointPool.newElement();
            i2 += 1;
          }
        };
        ShapePath.prototype.setLength = function(len) {
          while (this._maxLength < len) {
            this.doubleArrayLength();
          }
          this._length = len;
        };
        ShapePath.prototype.doubleArrayLength = function() {
          this.v = this.v.concat(createSizedArray(this._maxLength));
          this.i = this.i.concat(createSizedArray(this._maxLength));
          this.o = this.o.concat(createSizedArray(this._maxLength));
          this._maxLength *= 2;
        };
        ShapePath.prototype.setXYAt = function(x3, y3, type, pos, replace) {
          var arr;
          this._length = Math.max(this._length, pos + 1);
          if (this._length >= this._maxLength) {
            this.doubleArrayLength();
          }
          switch (type) {
            case "v":
              arr = this.v;
              break;
            case "i":
              arr = this.i;
              break;
            case "o":
              arr = this.o;
              break;
            default:
              arr = [];
              break;
          }
          if (!arr[pos] || arr[pos] && !replace) {
            arr[pos] = pointPool.newElement();
          }
          arr[pos][0] = x3;
          arr[pos][1] = y3;
        };
        ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {
          this.setXYAt(vX, vY, "v", pos, replace);
          this.setXYAt(oX, oY, "o", pos, replace);
          this.setXYAt(iX, iY, "i", pos, replace);
        };
        ShapePath.prototype.reverse = function() {
          var newPath = new ShapePath();
          newPath.setPathData(this.c, this._length);
          var vertices = this.v;
          var outPoints = this.o;
          var inPoints = this.i;
          var init = 0;
          if (this.c) {
            newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);
            init = 1;
          }
          var cnt = this._length - 1;
          var len = this._length;
          var i2;
          for (i2 = init; i2 < len; i2 += 1) {
            newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i2, false);
            cnt -= 1;
          }
          return newPath;
        };
        var ShapePropertyFactory = function() {
          var initFrame = -999999;
          function interpolateShape(frameNum, previousValue, caching) {
            var iterationIndex = caching.lastIndex;
            var keyPropS;
            var keyPropE;
            var isHold;
            var j3;
            var k3;
            var jLen;
            var kLen;
            var perc;
            var vertexValue;
            var kf = this.keyframes;
            if (frameNum < kf[0].t - this.offsetTime) {
              keyPropS = kf[0].s[0];
              isHold = true;
              iterationIndex = 0;
            } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {
              keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];
              isHold = true;
            } else {
              var i2 = iterationIndex;
              var len = kf.length - 1;
              var flag = true;
              var keyData;
              var nextKeyData;
              var keyframeMetadata;
              while (flag) {
                keyData = kf[i2];
                nextKeyData = kf[i2 + 1];
                if (nextKeyData.t - this.offsetTime > frameNum) {
                  break;
                }
                if (i2 < len - 1) {
                  i2 += 1;
                } else {
                  flag = false;
                }
              }
              keyframeMetadata = this.keyframesMetadata[i2] || {};
              isHold = keyData.h === 1;
              iterationIndex = i2;
              if (!isHold) {
                if (frameNum >= nextKeyData.t - this.offsetTime) {
                  perc = 1;
                } else if (frameNum < keyData.t - this.offsetTime) {
                  perc = 0;
                } else {
                  var fnc;
                  if (keyframeMetadata.__fnct) {
                    fnc = keyframeMetadata.__fnct;
                  } else {
                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;
                    keyframeMetadata.__fnct = fnc;
                  }
                  perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));
                }
                keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];
              }
              keyPropS = keyData.s[0];
            }
            jLen = previousValue._length;
            kLen = keyPropS.i[0].length;
            caching.lastIndex = iterationIndex;
            for (j3 = 0; j3 < jLen; j3 += 1) {
              for (k3 = 0; k3 < kLen; k3 += 1) {
                vertexValue = isHold ? keyPropS.i[j3][k3] : keyPropS.i[j3][k3] + (keyPropE.i[j3][k3] - keyPropS.i[j3][k3]) * perc;
                previousValue.i[j3][k3] = vertexValue;
                vertexValue = isHold ? keyPropS.o[j3][k3] : keyPropS.o[j3][k3] + (keyPropE.o[j3][k3] - keyPropS.o[j3][k3]) * perc;
                previousValue.o[j3][k3] = vertexValue;
                vertexValue = isHold ? keyPropS.v[j3][k3] : keyPropS.v[j3][k3] + (keyPropE.v[j3][k3] - keyPropS.v[j3][k3]) * perc;
                previousValue.v[j3][k3] = vertexValue;
              }
            }
          }
          function interpolateShapeCurrentTime() {
            var frameNum = this.comp.renderedFrame - this.offsetTime;
            var initTime = this.keyframes[0].t - this.offsetTime;
            var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
            var lastFrame = this._caching.lastFrame;
            if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {
              this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;
              this.interpolateShape(frameNum, this.pv, this._caching);
            }
            this._caching.lastFrame = frameNum;
            return this.pv;
          }
          function resetShape() {
            this.paths = this.localShapeCollection;
          }
          function shapesEqual(shape1, shape2) {
            if (shape1._length !== shape2._length || shape1.c !== shape2.c) {
              return false;
            }
            var i2;
            var len = shape1._length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (shape1.v[i2][0] !== shape2.v[i2][0] || shape1.v[i2][1] !== shape2.v[i2][1] || shape1.o[i2][0] !== shape2.o[i2][0] || shape1.o[i2][1] !== shape2.o[i2][1] || shape1.i[i2][0] !== shape2.i[i2][0] || shape1.i[i2][1] !== shape2.i[i2][1]) {
                return false;
              }
            }
            return true;
          }
          function setVValue(newPath) {
            if (!shapesEqual(this.v, newPath)) {
              this.v = shapePool.clone(newPath);
              this.localShapeCollection.releaseShapes();
              this.localShapeCollection.addShape(this.v);
              this._mdf = true;
              this.paths = this.localShapeCollection;
            }
          }
          function processEffectsSequence() {
            if (this.elem.globalData.frameId === this.frameId) {
              return;
            }
            if (!this.effectsSequence.length) {
              this._mdf = false;
              return;
            }
            if (this.lock) {
              this.setVValue(this.pv);
              return;
            }
            this.lock = true;
            this._mdf = false;
            var finalValue;
            if (this.kf) {
              finalValue = this.pv;
            } else if (this.data.ks) {
              finalValue = this.data.ks.k;
            } else {
              finalValue = this.data.pt.k;
            }
            var i2;
            var len = this.effectsSequence.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              finalValue = this.effectsSequence[i2](finalValue);
            }
            this.setVValue(finalValue);
            this.lock = false;
            this.frameId = this.elem.globalData.frameId;
          }
          function ShapeProperty(elem, data, type) {
            this.propType = "shape";
            this.comp = elem.comp;
            this.container = elem;
            this.elem = elem;
            this.data = data;
            this.k = false;
            this.kf = false;
            this._mdf = false;
            var pathData = type === 3 ? data.pt.k : data.ks.k;
            this.v = shapePool.clone(pathData);
            this.pv = shapePool.clone(this.v);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.paths.addShape(this.v);
            this.reset = resetShape;
            this.effectsSequence = [];
          }
          function addEffect(effectFunction) {
            this.effectsSequence.push(effectFunction);
            this.container.addDynamicProperty(this);
          }
          ShapeProperty.prototype.interpolateShape = interpolateShape;
          ShapeProperty.prototype.getValue = processEffectsSequence;
          ShapeProperty.prototype.setVValue = setVValue;
          ShapeProperty.prototype.addEffect = addEffect;
          function KeyframedShapeProperty(elem, data, type) {
            this.propType = "shape";
            this.comp = elem.comp;
            this.elem = elem;
            this.container = elem;
            this.offsetTime = elem.data.st;
            this.keyframes = type === 3 ? data.pt.k : data.ks.k;
            this.keyframesMetadata = [];
            this.k = true;
            this.kf = true;
            var len = this.keyframes[0].s[0].i.length;
            this.v = shapePool.newElement();
            this.v.setPathData(this.keyframes[0].s[0].c, len);
            this.pv = shapePool.clone(this.v);
            this.localShapeCollection = shapeCollectionPool.newShapeCollection();
            this.paths = this.localShapeCollection;
            this.paths.addShape(this.v);
            this.lastFrame = initFrame;
            this.reset = resetShape;
            this._caching = { lastFrame: initFrame, lastIndex: 0 };
            this.effectsSequence = [interpolateShapeCurrentTime.bind(this)];
          }
          KeyframedShapeProperty.prototype.getValue = processEffectsSequence;
          KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;
          KeyframedShapeProperty.prototype.setVValue = setVValue;
          KeyframedShapeProperty.prototype.addEffect = addEffect;
          var EllShapeProperty = function() {
            var cPoint = roundCorner;
            function EllShapePropertyFactory(elem, data) {
              this.v = shapePool.newElement();
              this.v.setPathData(true, 4);
              this.localShapeCollection = shapeCollectionPool.newShapeCollection();
              this.paths = this.localShapeCollection;
              this.localShapeCollection.addShape(this.v);
              this.d = data.d;
              this.elem = elem;
              this.comp = elem.comp;
              this.frameId = -1;
              this.initDynamicPropertyContainer(elem);
              this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
              this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
              if (this.dynamicProperties.length) {
                this.k = true;
              } else {
                this.k = false;
                this.convertEllToPath();
              }
            }
            EllShapePropertyFactory.prototype = {
              reset: resetShape,
              getValue: function() {
                if (this.elem.globalData.frameId === this.frameId) {
                  return;
                }
                this.frameId = this.elem.globalData.frameId;
                this.iterateDynamicProperties();
                if (this._mdf) {
                  this.convertEllToPath();
                }
              },
              convertEllToPath: function() {
                var p0 = this.p.v[0];
                var p1 = this.p.v[1];
                var s0 = this.s.v[0] / 2;
                var s1 = this.s.v[1] / 2;
                var _cw = this.d !== 3;
                var _v = this.v;
                _v.v[0][0] = p0;
                _v.v[0][1] = p1 - s1;
                _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;
                _v.v[1][1] = p1;
                _v.v[2][0] = p0;
                _v.v[2][1] = p1 + s1;
                _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;
                _v.v[3][1] = p1;
                _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                _v.i[0][1] = p1 - s1;
                _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;
                _v.i[1][1] = p1 - s1 * cPoint;
                _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                _v.i[2][1] = p1 + s1;
                _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;
                _v.i[3][1] = p1 + s1 * cPoint;
                _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;
                _v.o[0][1] = p1 - s1;
                _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;
                _v.o[1][1] = p1 + s1 * cPoint;
                _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;
                _v.o[2][1] = p1 + s1;
                _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;
                _v.o[3][1] = p1 - s1 * cPoint;
              }
            };
            extendPrototype([DynamicPropertyContainer], EllShapePropertyFactory);
            return EllShapePropertyFactory;
          }();
          var StarShapeProperty = function() {
            function StarShapePropertyFactory(elem, data) {
              this.v = shapePool.newElement();
              this.v.setPathData(true, 0);
              this.elem = elem;
              this.comp = elem.comp;
              this.data = data;
              this.frameId = -1;
              this.d = data.d;
              this.initDynamicPropertyContainer(elem);
              if (data.sy === 1) {
                this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);
                this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);
                this.convertToPath = this.convertStarToPath;
              } else {
                this.convertToPath = this.convertPolygonToPath;
              }
              this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);
              this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
              this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);
              this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);
              this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);
              this.localShapeCollection = shapeCollectionPool.newShapeCollection();
              this.localShapeCollection.addShape(this.v);
              this.paths = this.localShapeCollection;
              if (this.dynamicProperties.length) {
                this.k = true;
              } else {
                this.k = false;
                this.convertToPath();
              }
            }
            StarShapePropertyFactory.prototype = {
              reset: resetShape,
              getValue: function() {
                if (this.elem.globalData.frameId === this.frameId) {
                  return;
                }
                this.frameId = this.elem.globalData.frameId;
                this.iterateDynamicProperties();
                if (this._mdf) {
                  this.convertToPath();
                }
              },
              convertStarToPath: function() {
                var numPts = Math.floor(this.pt.v) * 2;
                var angle = Math.PI * 2 / numPts;
                var longFlag = true;
                var longRad = this.or.v;
                var shortRad = this.ir.v;
                var longRound = this.os.v;
                var shortRound = this.is.v;
                var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);
                var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);
                var i2;
                var rad;
                var roundness;
                var perimSegment;
                var currentAng = -Math.PI / 2;
                currentAng += this.r.v;
                var dir = this.data.d === 3 ? -1 : 1;
                this.v._length = 0;
                for (i2 = 0; i2 < numPts; i2 += 1) {
                  rad = longFlag ? longRad : shortRad;
                  roundness = longFlag ? longRound : shortRound;
                  perimSegment = longFlag ? longPerimSegment : shortPerimSegment;
                  var x3 = rad * Math.cos(currentAng);
                  var y3 = rad * Math.sin(currentAng);
                  var ox = x3 === 0 && y3 === 0 ? 0 : y3 / Math.sqrt(x3 * x3 + y3 * y3);
                  var oy = x3 === 0 && y3 === 0 ? 0 : -x3 / Math.sqrt(x3 * x3 + y3 * y3);
                  x3 += +this.p.v[0];
                  y3 += +this.p.v[1];
                  this.v.setTripleAt(x3, y3, x3 - ox * perimSegment * roundness * dir, y3 - oy * perimSegment * roundness * dir, x3 + ox * perimSegment * roundness * dir, y3 + oy * perimSegment * roundness * dir, i2, true);
                  longFlag = !longFlag;
                  currentAng += angle * dir;
                }
              },
              convertPolygonToPath: function() {
                var numPts = Math.floor(this.pt.v);
                var angle = Math.PI * 2 / numPts;
                var rad = this.or.v;
                var roundness = this.os.v;
                var perimSegment = 2 * Math.PI * rad / (numPts * 4);
                var i2;
                var currentAng = -Math.PI * 0.5;
                var dir = this.data.d === 3 ? -1 : 1;
                currentAng += this.r.v;
                this.v._length = 0;
                for (i2 = 0; i2 < numPts; i2 += 1) {
                  var x3 = rad * Math.cos(currentAng);
                  var y3 = rad * Math.sin(currentAng);
                  var ox = x3 === 0 && y3 === 0 ? 0 : y3 / Math.sqrt(x3 * x3 + y3 * y3);
                  var oy = x3 === 0 && y3 === 0 ? 0 : -x3 / Math.sqrt(x3 * x3 + y3 * y3);
                  x3 += +this.p.v[0];
                  y3 += +this.p.v[1];
                  this.v.setTripleAt(x3, y3, x3 - ox * perimSegment * roundness * dir, y3 - oy * perimSegment * roundness * dir, x3 + ox * perimSegment * roundness * dir, y3 + oy * perimSegment * roundness * dir, i2, true);
                  currentAng += angle * dir;
                }
                this.paths.length = 0;
                this.paths[0] = this.v;
              }
            };
            extendPrototype([DynamicPropertyContainer], StarShapePropertyFactory);
            return StarShapePropertyFactory;
          }();
          var RectShapeProperty = function() {
            function RectShapePropertyFactory(elem, data) {
              this.v = shapePool.newElement();
              this.v.c = true;
              this.localShapeCollection = shapeCollectionPool.newShapeCollection();
              this.localShapeCollection.addShape(this.v);
              this.paths = this.localShapeCollection;
              this.elem = elem;
              this.comp = elem.comp;
              this.frameId = -1;
              this.d = data.d;
              this.initDynamicPropertyContainer(elem);
              this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);
              this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);
              this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);
              if (this.dynamicProperties.length) {
                this.k = true;
              } else {
                this.k = false;
                this.convertRectToPath();
              }
            }
            RectShapePropertyFactory.prototype = {
              convertRectToPath: function() {
                var p0 = this.p.v[0];
                var p1 = this.p.v[1];
                var v0 = this.s.v[0] / 2;
                var v1 = this.s.v[1] / 2;
                var round = bmMin(v0, v1, this.r.v);
                var cPoint = round * (1 - roundCorner);
                this.v._length = 0;
                if (this.d === 2 || this.d === 1) {
                  this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);
                  this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);
                  if (round !== 0) {
                    this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);
                    this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);
                    this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);
                    this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);
                  } else {
                    this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);
                    this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);
                  }
                } else {
                  this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);
                  if (round !== 0) {
                    this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);
                    this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);
                    this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);
                    this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);
                    this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);
                    this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);
                  } else {
                    this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);
                    this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);
                    this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);
                  }
                }
              },
              getValue: function() {
                if (this.elem.globalData.frameId === this.frameId) {
                  return;
                }
                this.frameId = this.elem.globalData.frameId;
                this.iterateDynamicProperties();
                if (this._mdf) {
                  this.convertRectToPath();
                }
              },
              reset: resetShape
            };
            extendPrototype([DynamicPropertyContainer], RectShapePropertyFactory);
            return RectShapePropertyFactory;
          }();
          function getShapeProp(elem, data, type) {
            var prop;
            if (type === 3 || type === 4) {
              var dataProp = type === 3 ? data.pt : data.ks;
              var keys = dataProp.k;
              if (keys.length) {
                prop = new KeyframedShapeProperty(elem, data, type);
              } else {
                prop = new ShapeProperty(elem, data, type);
              }
            } else if (type === 5) {
              prop = new RectShapeProperty(elem, data);
            } else if (type === 6) {
              prop = new EllShapeProperty(elem, data);
            } else if (type === 7) {
              prop = new StarShapeProperty(elem, data);
            }
            if (prop.k) {
              elem.addDynamicProperty(prop);
            }
            return prop;
          }
          function getConstructorFunction() {
            return ShapeProperty;
          }
          function getKeyframedConstructorFunction() {
            return KeyframedShapeProperty;
          }
          var ob = {};
          ob.getShapeProp = getShapeProp;
          ob.getConstructorFunction = getConstructorFunction;
          ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;
          return ob;
        }();
        var ShapeModifiers = function() {
          var ob = {};
          var modifiers = {};
          ob.registerModifier = registerModifier;
          ob.getModifier = getModifier;
          function registerModifier(nm, factory) {
            if (!modifiers[nm]) {
              modifiers[nm] = factory;
            }
          }
          function getModifier(nm, elem, data) {
            return new modifiers[nm](elem, data);
          }
          return ob;
        }();
        function ShapeModifier() {
        }
        ShapeModifier.prototype.initModifierProperties = function() {
        };
        ShapeModifier.prototype.addShapeToModifier = function() {
        };
        ShapeModifier.prototype.addShape = function(data) {
          if (!this.closed) {
            data.sh.container.addDynamicProperty(data.sh);
            var shapeData = { shape: data.sh, data, localShapeCollection: shapeCollectionPool.newShapeCollection() };
            this.shapes.push(shapeData);
            this.addShapeToModifier(shapeData);
            if (this._isAnimated) {
              data.setAsAnimated();
            }
          }
        };
        ShapeModifier.prototype.init = function(elem, data) {
          this.shapes = [];
          this.elem = elem;
          this.initDynamicPropertyContainer(elem);
          this.initModifierProperties(elem, data);
          this.frameId = initialDefaultFrame;
          this.closed = false;
          this.k = false;
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.getValue(true);
          }
        };
        ShapeModifier.prototype.processKeys = function() {
          if (this.elem.globalData.frameId === this.frameId) {
            return;
          }
          this.frameId = this.elem.globalData.frameId;
          this.iterateDynamicProperties();
        };
        extendPrototype([DynamicPropertyContainer], ShapeModifier);
        function TrimModifier() {
        }
        extendPrototype([ShapeModifier], TrimModifier);
        TrimModifier.prototype.initModifierProperties = function(elem, data) {
          this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);
          this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);
          this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);
          this.sValue = 0;
          this.eValue = 0;
          this.getValue = this.processKeys;
          this.m = data.m;
          this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
        };
        TrimModifier.prototype.addShapeToModifier = function(shapeData) {
          shapeData.pathsData = [];
        };
        TrimModifier.prototype.calculateShapeEdges = function(s2, e2, shapeLength, addedLength, totalModifierLength) {
          var segments = [];
          if (e2 <= 1) {
            segments.push({
              s: s2,
              e: e2
            });
          } else if (s2 >= 1) {
            segments.push({
              s: s2 - 1,
              e: e2 - 1
            });
          } else {
            segments.push({
              s: s2,
              e: 1
            });
            segments.push({
              s: 0,
              e: e2 - 1
            });
          }
          var shapeSegments = [];
          var i2;
          var len = segments.length;
          var segmentOb;
          for (i2 = 0; i2 < len; i2 += 1) {
            segmentOb = segments[i2];
            if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {
              var shapeS;
              var shapeE;
              if (segmentOb.s * totalModifierLength <= addedLength) {
                shapeS = 0;
              } else {
                shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;
              }
              if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {
                shapeE = 1;
              } else {
                shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;
              }
              shapeSegments.push([shapeS, shapeE]);
            }
          }
          if (!shapeSegments.length) {
            shapeSegments.push([0, 0]);
          }
          return shapeSegments;
        };
        TrimModifier.prototype.releasePathsData = function(pathsData) {
          var i2;
          var len = pathsData.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            segmentsLengthPool.release(pathsData[i2]);
          }
          pathsData.length = 0;
          return pathsData;
        };
        TrimModifier.prototype.processShapes = function(_isFirstFrame) {
          var s2;
          var e2;
          if (this._mdf || _isFirstFrame) {
            var o3 = this.o.v % 360 / 360;
            if (o3 < 0) {
              o3 += 1;
            }
            if (this.s.v > 1) {
              s2 = 1 + o3;
            } else if (this.s.v < 0) {
              s2 = 0 + o3;
            } else {
              s2 = this.s.v + o3;
            }
            if (this.e.v > 1) {
              e2 = 1 + o3;
            } else if (this.e.v < 0) {
              e2 = 0 + o3;
            } else {
              e2 = this.e.v + o3;
            }
            if (s2 > e2) {
              var _s = s2;
              s2 = e2;
              e2 = _s;
            }
            s2 = Math.round(s2 * 1e4) * 1e-4;
            e2 = Math.round(e2 * 1e4) * 1e-4;
            this.sValue = s2;
            this.eValue = e2;
          } else {
            s2 = this.sValue;
            e2 = this.eValue;
          }
          var shapePaths;
          var i2;
          var len = this.shapes.length;
          var j3;
          var jLen;
          var pathsData;
          var pathData;
          var totalShapeLength;
          var totalModifierLength = 0;
          if (e2 === s2) {
            for (i2 = 0; i2 < len; i2 += 1) {
              this.shapes[i2].localShapeCollection.releaseShapes();
              this.shapes[i2].shape._mdf = true;
              this.shapes[i2].shape.paths = this.shapes[i2].localShapeCollection;
              if (this._mdf) {
                this.shapes[i2].pathsData.length = 0;
              }
            }
          } else if (!(e2 === 1 && s2 === 0 || e2 === 0 && s2 === 1)) {
            var segments = [];
            var shapeData;
            var localShapeCollection;
            for (i2 = 0; i2 < len; i2 += 1) {
              shapeData = this.shapes[i2];
              if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {
                shapeData.shape.paths = shapeData.localShapeCollection;
              } else {
                shapePaths = shapeData.shape.paths;
                jLen = shapePaths._length;
                totalShapeLength = 0;
                if (!shapeData.shape._mdf && shapeData.pathsData.length) {
                  totalShapeLength = shapeData.totalShapeLength;
                } else {
                  pathsData = this.releasePathsData(shapeData.pathsData);
                  for (j3 = 0; j3 < jLen; j3 += 1) {
                    pathData = bez.getSegmentsLength(shapePaths.shapes[j3]);
                    pathsData.push(pathData);
                    totalShapeLength += pathData.totalLength;
                  }
                  shapeData.totalShapeLength = totalShapeLength;
                  shapeData.pathsData = pathsData;
                }
                totalModifierLength += totalShapeLength;
                shapeData.shape._mdf = true;
              }
            }
            var shapeS = s2;
            var shapeE = e2;
            var addedLength = 0;
            var edges;
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              shapeData = this.shapes[i2];
              if (shapeData.shape._mdf) {
                localShapeCollection = shapeData.localShapeCollection;
                localShapeCollection.releaseShapes();
                if (this.m === 2 && len > 1) {
                  edges = this.calculateShapeEdges(s2, e2, shapeData.totalShapeLength, addedLength, totalModifierLength);
                  addedLength += shapeData.totalShapeLength;
                } else {
                  edges = [[shapeS, shapeE]];
                }
                jLen = edges.length;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  shapeS = edges[j3][0];
                  shapeE = edges[j3][1];
                  segments.length = 0;
                  if (shapeE <= 1) {
                    segments.push({
                      s: shapeData.totalShapeLength * shapeS,
                      e: shapeData.totalShapeLength * shapeE
                    });
                  } else if (shapeS >= 1) {
                    segments.push({
                      s: shapeData.totalShapeLength * (shapeS - 1),
                      e: shapeData.totalShapeLength * (shapeE - 1)
                    });
                  } else {
                    segments.push({
                      s: shapeData.totalShapeLength * shapeS,
                      e: shapeData.totalShapeLength
                    });
                    segments.push({
                      s: 0,
                      e: shapeData.totalShapeLength * (shapeE - 1)
                    });
                  }
                  var newShapesData = this.addShapes(shapeData, segments[0]);
                  if (segments[0].s !== segments[0].e) {
                    if (segments.length > 1) {
                      var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];
                      if (lastShapeInCollection.c) {
                        var lastShape = newShapesData.pop();
                        this.addPaths(newShapesData, localShapeCollection);
                        newShapesData = this.addShapes(shapeData, segments[1], lastShape);
                      } else {
                        this.addPaths(newShapesData, localShapeCollection);
                        newShapesData = this.addShapes(shapeData, segments[1]);
                      }
                    }
                    this.addPaths(newShapesData, localShapeCollection);
                  }
                }
                shapeData.shape.paths = localShapeCollection;
              }
            }
          } else if (this._mdf) {
            for (i2 = 0; i2 < len; i2 += 1) {
              this.shapes[i2].pathsData.length = 0;
              this.shapes[i2].shape._mdf = true;
            }
          }
        };
        TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {
          var i2;
          var len = newPaths.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            localShapeCollection.addShape(newPaths[i2]);
          }
        };
        TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {
          shapePath.setXYAt(pt2[0], pt2[1], "o", pos);
          shapePath.setXYAt(pt3[0], pt3[1], "i", pos + 1);
          if (newShape) {
            shapePath.setXYAt(pt1[0], pt1[1], "v", pos);
          }
          shapePath.setXYAt(pt4[0], pt4[1], "v", pos + 1);
        };
        TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {
          shapePath.setXYAt(points[1], points[5], "o", pos);
          shapePath.setXYAt(points[2], points[6], "i", pos + 1);
          if (newShape) {
            shapePath.setXYAt(points[0], points[4], "v", pos);
          }
          shapePath.setXYAt(points[3], points[7], "v", pos + 1);
        };
        TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {
          var pathsData = shapeData.pathsData;
          var shapePaths = shapeData.shape.paths.shapes;
          var i2;
          var len = shapeData.shape.paths._length;
          var j3;
          var jLen;
          var addedLength = 0;
          var currentLengthData;
          var segmentCount;
          var lengths;
          var segment;
          var shapes = [];
          var initPos;
          var newShape = true;
          if (!shapePath) {
            shapePath = shapePool.newElement();
            segmentCount = 0;
            initPos = 0;
          } else {
            segmentCount = shapePath._length;
            initPos = shapePath._length;
          }
          shapes.push(shapePath);
          for (i2 = 0; i2 < len; i2 += 1) {
            lengths = pathsData[i2].lengths;
            shapePath.c = shapePaths[i2].c;
            jLen = shapePaths[i2].c ? lengths.length : lengths.length + 1;
            for (j3 = 1; j3 < jLen; j3 += 1) {
              currentLengthData = lengths[j3 - 1];
              if (addedLength + currentLengthData.addedLength < shapeSegment.s) {
                addedLength += currentLengthData.addedLength;
                shapePath.c = false;
              } else if (addedLength > shapeSegment.e) {
                shapePath.c = false;
                break;
              } else {
                if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {
                  this.addSegment(shapePaths[i2].v[j3 - 1], shapePaths[i2].o[j3 - 1], shapePaths[i2].i[j3], shapePaths[i2].v[j3], shapePath, segmentCount, newShape);
                  newShape = false;
                } else {
                  segment = bez.getNewSegment(shapePaths[i2].v[j3 - 1], shapePaths[i2].v[j3], shapePaths[i2].o[j3 - 1], shapePaths[i2].i[j3], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j3 - 1]);
                  this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                  newShape = false;
                  shapePath.c = false;
                }
                addedLength += currentLengthData.addedLength;
                segmentCount += 1;
              }
            }
            if (shapePaths[i2].c && lengths.length) {
              currentLengthData = lengths[j3 - 1];
              if (addedLength <= shapeSegment.e) {
                var segmentLength = lengths[j3 - 1].addedLength;
                if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {
                  this.addSegment(shapePaths[i2].v[j3 - 1], shapePaths[i2].o[j3 - 1], shapePaths[i2].i[0], shapePaths[i2].v[0], shapePath, segmentCount, newShape);
                  newShape = false;
                } else {
                  segment = bez.getNewSegment(shapePaths[i2].v[j3 - 1], shapePaths[i2].v[0], shapePaths[i2].o[j3 - 1], shapePaths[i2].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j3 - 1]);
                  this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);
                  newShape = false;
                  shapePath.c = false;
                }
              } else {
                shapePath.c = false;
              }
              addedLength += currentLengthData.addedLength;
              segmentCount += 1;
            }
            if (shapePath._length) {
              shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], "i", initPos);
              shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], "o", shapePath._length - 1);
            }
            if (addedLength > shapeSegment.e) {
              break;
            }
            if (i2 < len - 1) {
              shapePath = shapePool.newElement();
              newShape = true;
              shapes.push(shapePath);
              segmentCount = 0;
            }
          }
          return shapes;
        };
        ShapeModifiers.registerModifier("tm", TrimModifier);
        function RoundCornersModifier() {
        }
        extendPrototype([ShapeModifier], RoundCornersModifier);
        RoundCornersModifier.prototype.initModifierProperties = function(elem, data) {
          this.getValue = this.processKeys;
          this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);
          this._isAnimated = !!this.rd.effectsSequence.length;
        };
        RoundCornersModifier.prototype.processPath = function(path, round) {
          var clonedPath = shapePool.newElement();
          clonedPath.c = path.c;
          var i2;
          var len = path._length;
          var currentV;
          var currentI;
          var currentO;
          var closerV;
          var distance;
          var newPosPerc;
          var index2 = 0;
          var vX;
          var vY;
          var oX;
          var oY;
          var iX;
          var iY;
          for (i2 = 0; i2 < len; i2 += 1) {
            currentV = path.v[i2];
            currentO = path.o[i2];
            currentI = path.i[i2];
            if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {
              if ((i2 === 0 || i2 === len - 1) && !path.c) {
                clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index2);
                index2 += 1;
              } else {
                if (i2 === 0) {
                  closerV = path.v[len - 1];
                } else {
                  closerV = path.v[i2 - 1];
                }
                distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                vX = iX;
                iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;
                vY = iY;
                oX = vX - (vX - currentV[0]) * roundCorner;
                oY = vY - (vY - currentV[1]) * roundCorner;
                clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
                index2 += 1;
                if (i2 === len - 1) {
                  closerV = path.v[0];
                } else {
                  closerV = path.v[i2 + 1];
                }
                distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));
                newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;
                oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;
                vX = oX;
                oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;
                vY = oY;
                iX = vX - (vX - currentV[0]) * roundCorner;
                iY = vY - (vY - currentV[1]) * roundCorner;
                clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index2);
                index2 += 1;
              }
            } else {
              clonedPath.setTripleAt(path.v[i2][0], path.v[i2][1], path.o[i2][0], path.o[i2][1], path.i[i2][0], path.i[i2][1], index2);
              index2 += 1;
            }
          }
          return clonedPath;
        };
        RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {
          var shapePaths;
          var i2;
          var len = this.shapes.length;
          var j3;
          var jLen;
          var rd = this.rd.v;
          if (rd !== 0) {
            var shapeData;
            var localShapeCollection;
            for (i2 = 0; i2 < len; i2 += 1) {
              shapeData = this.shapes[i2];
              localShapeCollection = shapeData.localShapeCollection;
              if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                localShapeCollection.releaseShapes();
                shapeData.shape._mdf = true;
                shapePaths = shapeData.shape.paths.shapes;
                jLen = shapeData.shape.paths._length;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  localShapeCollection.addShape(this.processPath(shapePaths[j3], rd));
                }
              }
              shapeData.shape.paths = shapeData.localShapeCollection;
            }
          }
          if (!this.dynamicProperties.length) {
            this._mdf = false;
          }
        };
        ShapeModifiers.registerModifier("rd", RoundCornersModifier);
        function PuckerAndBloatModifier() {
        }
        extendPrototype([ShapeModifier], PuckerAndBloatModifier);
        PuckerAndBloatModifier.prototype.initModifierProperties = function(elem, data) {
          this.getValue = this.processKeys;
          this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);
          this._isAnimated = !!this.amount.effectsSequence.length;
        };
        PuckerAndBloatModifier.prototype.processPath = function(path, amount) {
          var percent = amount / 100;
          var centerPoint = [0, 0];
          var pathLength = path._length;
          var i2 = 0;
          for (i2 = 0; i2 < pathLength; i2 += 1) {
            centerPoint[0] += path.v[i2][0];
            centerPoint[1] += path.v[i2][1];
          }
          centerPoint[0] /= pathLength;
          centerPoint[1] /= pathLength;
          var clonedPath = shapePool.newElement();
          clonedPath.c = path.c;
          var vX;
          var vY;
          var oX;
          var oY;
          var iX;
          var iY;
          for (i2 = 0; i2 < pathLength; i2 += 1) {
            vX = path.v[i2][0] + (centerPoint[0] - path.v[i2][0]) * percent;
            vY = path.v[i2][1] + (centerPoint[1] - path.v[i2][1]) * percent;
            oX = path.o[i2][0] + (centerPoint[0] - path.o[i2][0]) * -percent;
            oY = path.o[i2][1] + (centerPoint[1] - path.o[i2][1]) * -percent;
            iX = path.i[i2][0] + (centerPoint[0] - path.i[i2][0]) * -percent;
            iY = path.i[i2][1] + (centerPoint[1] - path.i[i2][1]) * -percent;
            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i2);
          }
          return clonedPath;
        };
        PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {
          var shapePaths;
          var i2;
          var len = this.shapes.length;
          var j3;
          var jLen;
          var amount = this.amount.v;
          if (amount !== 0) {
            var shapeData;
            var localShapeCollection;
            for (i2 = 0; i2 < len; i2 += 1) {
              shapeData = this.shapes[i2];
              localShapeCollection = shapeData.localShapeCollection;
              if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {
                localShapeCollection.releaseShapes();
                shapeData.shape._mdf = true;
                shapePaths = shapeData.shape.paths.shapes;
                jLen = shapeData.shape.paths._length;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  localShapeCollection.addShape(this.processPath(shapePaths[j3], amount));
                }
              }
              shapeData.shape.paths = shapeData.localShapeCollection;
            }
          }
          if (!this.dynamicProperties.length) {
            this._mdf = false;
          }
        };
        ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier);
        function RepeaterModifier() {
        }
        extendPrototype([ShapeModifier], RepeaterModifier);
        RepeaterModifier.prototype.initModifierProperties = function(elem, data) {
          this.getValue = this.processKeys;
          this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);
          this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);
          this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);
          this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);
          this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);
          this.data = data;
          if (!this.dynamicProperties.length) {
            this.getValue(true);
          }
          this._isAnimated = !!this.dynamicProperties.length;
          this.pMatrix = new Matrix();
          this.rMatrix = new Matrix();
          this.sMatrix = new Matrix();
          this.tMatrix = new Matrix();
          this.matrix = new Matrix();
        };
        RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv) {
          var dir = inv ? -1 : 1;
          var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);
          var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);
          pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);
          rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
          rMatrix.rotate(-transform.r.v * dir * perc);
          rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
          sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);
          sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);
          sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);
        };
        RepeaterModifier.prototype.init = function(elem, arr, pos, elemsData) {
          this.elem = elem;
          this.arr = arr;
          this.pos = pos;
          this.elemsData = elemsData;
          this._currentCopies = 0;
          this._elements = [];
          this._groups = [];
          this.frameId = -1;
          this.initDynamicPropertyContainer(elem);
          this.initModifierProperties(elem, arr[pos]);
          while (pos > 0) {
            pos -= 1;
            this._elements.unshift(arr[pos]);
          }
          if (this.dynamicProperties.length) {
            this.k = true;
          } else {
            this.getValue(true);
          }
        };
        RepeaterModifier.prototype.resetElements = function(elements) {
          var i2;
          var len = elements.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            elements[i2]._processed = false;
            if (elements[i2].ty === "gr") {
              this.resetElements(elements[i2].it);
            }
          }
        };
        RepeaterModifier.prototype.cloneElements = function(elements) {
          var newElements = JSON.parse(JSON.stringify(elements));
          this.resetElements(newElements);
          return newElements;
        };
        RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {
          var i2;
          var len = elements.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            elements[i2]._render = renderFlag;
            if (elements[i2].ty === "gr") {
              this.changeGroupRender(elements[i2].it, renderFlag);
            }
          }
        };
        RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {
          var items;
          var itemsTransform;
          var i2;
          var dir;
          var cont;
          var hasReloaded = false;
          if (this._mdf || _isFirstFrame) {
            var copies = Math.ceil(this.c.v);
            if (this._groups.length < copies) {
              while (this._groups.length < copies) {
                var group = {
                  it: this.cloneElements(this._elements),
                  ty: "gr"
                };
                group.it.push({
                  a: { a: 0, ix: 1, k: [0, 0] },
                  nm: "Transform",
                  o: { a: 0, ix: 7, k: 100 },
                  p: { a: 0, ix: 2, k: [0, 0] },
                  r: { a: 1, ix: 6, k: [{ s: 0, e: 0, t: 0 }, { s: 0, e: 0, t: 1 }] },
                  s: { a: 0, ix: 3, k: [100, 100] },
                  sa: { a: 0, ix: 5, k: 0 },
                  sk: { a: 0, ix: 4, k: 0 },
                  ty: "tr"
                });
                this.arr.splice(0, 0, group);
                this._groups.splice(0, 0, group);
                this._currentCopies += 1;
              }
              this.elem.reloadShapes();
              hasReloaded = true;
            }
            cont = 0;
            var renderFlag;
            for (i2 = 0; i2 <= this._groups.length - 1; i2 += 1) {
              renderFlag = cont < copies;
              this._groups[i2]._render = renderFlag;
              this.changeGroupRender(this._groups[i2].it, renderFlag);
              if (!renderFlag) {
                var elems = this.elemsData[i2].it;
                var transformData = elems[elems.length - 1];
                if (transformData.transform.op.v !== 0) {
                  transformData.transform.op._mdf = true;
                  transformData.transform.op.v = 0;
                } else {
                  transformData.transform.op._mdf = false;
                }
              }
              cont += 1;
            }
            this._currentCopies = copies;
            var offset = this.o.v;
            var offsetModulo = offset % 1;
            var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);
            var pProps = this.pMatrix.props;
            var rProps = this.rMatrix.props;
            var sProps = this.sMatrix.props;
            this.pMatrix.reset();
            this.rMatrix.reset();
            this.sMatrix.reset();
            this.tMatrix.reset();
            this.matrix.reset();
            var iteration = 0;
            if (offset > 0) {
              while (iteration < roundOffset) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                iteration += 1;
              }
              if (offsetModulo) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);
                iteration += offsetModulo;
              }
            } else if (offset < 0) {
              while (iteration > roundOffset) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);
                iteration -= 1;
              }
              if (offsetModulo) {
                this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);
                iteration -= offsetModulo;
              }
            }
            i2 = this.data.m === 1 ? 0 : this._currentCopies - 1;
            dir = this.data.m === 1 ? 1 : -1;
            cont = this._currentCopies;
            var j3;
            var jLen;
            while (cont) {
              items = this.elemsData[i2].it;
              itemsTransform = items[items.length - 1].transform.mProps.v.props;
              jLen = itemsTransform.length;
              items[items.length - 1].transform.mProps._mdf = true;
              items[items.length - 1].transform.op._mdf = true;
              items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i2 / (this._currentCopies - 1));
              if (iteration !== 0) {
                if (i2 !== 0 && dir === 1 || i2 !== this._currentCopies - 1 && dir === -1) {
                  this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);
                }
                this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);
                this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);
                this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  itemsTransform[j3] = this.matrix.props[j3];
                }
                this.matrix.reset();
              } else {
                this.matrix.reset();
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  itemsTransform[j3] = this.matrix.props[j3];
                }
              }
              iteration += 1;
              cont -= 1;
              i2 += dir;
            }
          } else {
            cont = this._currentCopies;
            i2 = 0;
            dir = 1;
            while (cont) {
              items = this.elemsData[i2].it;
              itemsTransform = items[items.length - 1].transform.mProps.v.props;
              items[items.length - 1].transform.mProps._mdf = false;
              items[items.length - 1].transform.op._mdf = false;
              cont -= 1;
              i2 += dir;
            }
          }
          return hasReloaded;
        };
        RepeaterModifier.prototype.addShape = function() {
        };
        ShapeModifiers.registerModifier("rp", RepeaterModifier);
        function ShapeCollection() {
          this._length = 0;
          this._maxLength = 4;
          this.shapes = createSizedArray(this._maxLength);
        }
        ShapeCollection.prototype.addShape = function(shapeData) {
          if (this._length === this._maxLength) {
            this.shapes = this.shapes.concat(createSizedArray(this._maxLength));
            this._maxLength *= 2;
          }
          this.shapes[this._length] = shapeData;
          this._length += 1;
        };
        ShapeCollection.prototype.releaseShapes = function() {
          var i2;
          for (i2 = 0; i2 < this._length; i2 += 1) {
            shapePool.release(this.shapes[i2]);
          }
          this._length = 0;
        };
        function DashProperty(elem, data, renderer2, container) {
          this.elem = elem;
          this.frameId = -1;
          this.dataProps = createSizedArray(data.length);
          this.renderer = renderer2;
          this.k = false;
          this.dashStr = "";
          this.dashArray = createTypedArray("float32", data.length ? data.length - 1 : 0);
          this.dashoffset = createTypedArray("float32", 1);
          this.initDynamicPropertyContainer(container);
          var i2;
          var len = data.length || 0;
          var prop;
          for (i2 = 0; i2 < len; i2 += 1) {
            prop = PropertyFactory.getProp(elem, data[i2].v, 0, 0, this);
            this.k = prop.k || this.k;
            this.dataProps[i2] = { n: data[i2].n, p: prop };
          }
          if (!this.k) {
            this.getValue(true);
          }
          this._isAnimated = this.k;
        }
        DashProperty.prototype.getValue = function(forceRender) {
          if (this.elem.globalData.frameId === this.frameId && !forceRender) {
            return;
          }
          this.frameId = this.elem.globalData.frameId;
          this.iterateDynamicProperties();
          this._mdf = this._mdf || forceRender;
          if (this._mdf) {
            var i2 = 0;
            var len = this.dataProps.length;
            if (this.renderer === "svg") {
              this.dashStr = "";
            }
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.dataProps[i2].n !== "o") {
                if (this.renderer === "svg") {
                  this.dashStr += " " + this.dataProps[i2].p.v;
                } else {
                  this.dashArray[i2] = this.dataProps[i2].p.v;
                }
              } else {
                this.dashoffset[0] = this.dataProps[i2].p.v;
              }
            }
          }
        };
        extendPrototype([DynamicPropertyContainer], DashProperty);
        function GradientProperty(elem, data, container) {
          this.data = data;
          this.c = createTypedArray("uint8c", data.p * 4);
          var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;
          this.o = createTypedArray("float32", cLength);
          this._cmdf = false;
          this._omdf = false;
          this._collapsable = this.checkCollapsable();
          this._hasOpacity = cLength;
          this.initDynamicPropertyContainer(container);
          this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);
          this.k = this.prop.k;
          this.getValue(true);
        }
        GradientProperty.prototype.comparePoints = function(values, points) {
          var i2 = 0;
          var len = this.o.length / 2;
          var diff;
          while (i2 < len) {
            diff = Math.abs(values[i2 * 4] - values[points * 4 + i2 * 2]);
            if (diff > 0.01) {
              return false;
            }
            i2 += 1;
          }
          return true;
        };
        GradientProperty.prototype.checkCollapsable = function() {
          if (this.o.length / 2 !== this.c.length / 4) {
            return false;
          }
          if (this.data.k.k[0].s) {
            var i2 = 0;
            var len = this.data.k.k.length;
            while (i2 < len) {
              if (!this.comparePoints(this.data.k.k[i2].s, this.data.p)) {
                return false;
              }
              i2 += 1;
            }
          } else if (!this.comparePoints(this.data.k.k, this.data.p)) {
            return false;
          }
          return true;
        };
        GradientProperty.prototype.getValue = function(forceRender) {
          this.prop.getValue();
          this._mdf = false;
          this._cmdf = false;
          this._omdf = false;
          if (this.prop._mdf || forceRender) {
            var i2;
            var len = this.data.p * 4;
            var mult;
            var val;
            for (i2 = 0; i2 < len; i2 += 1) {
              mult = i2 % 4 === 0 ? 100 : 255;
              val = Math.round(this.prop.v[i2] * mult);
              if (this.c[i2] !== val) {
                this.c[i2] = val;
                this._cmdf = !forceRender;
              }
            }
            if (this.o.length) {
              len = this.prop.v.length;
              for (i2 = this.data.p * 4; i2 < len; i2 += 1) {
                mult = i2 % 2 === 0 ? 100 : 1;
                val = i2 % 2 === 0 ? Math.round(this.prop.v[i2] * 100) : this.prop.v[i2];
                if (this.o[i2 - this.data.p * 4] !== val) {
                  this.o[i2 - this.data.p * 4] = val;
                  this._omdf = !forceRender;
                }
              }
            }
            this._mdf = !forceRender;
          }
        };
        extendPrototype([DynamicPropertyContainer], GradientProperty);
        var buildShapeString = function(pathNodes, length, closed, mat) {
          if (length === 0) {
            return "";
          }
          var _o = pathNodes.o;
          var _i = pathNodes.i;
          var _v = pathNodes.v;
          var i2;
          var shapeString = " M" + mat.applyToPointStringified(_v[0][0], _v[0][1]);
          for (i2 = 1; i2 < length; i2 += 1) {
            shapeString += " C" + mat.applyToPointStringified(_o[i2 - 1][0], _o[i2 - 1][1]) + " " + mat.applyToPointStringified(_i[i2][0], _i[i2][1]) + " " + mat.applyToPointStringified(_v[i2][0], _v[i2][1]);
          }
          if (closed && length) {
            shapeString += " C" + mat.applyToPointStringified(_o[i2 - 1][0], _o[i2 - 1][1]) + " " + mat.applyToPointStringified(_i[0][0], _i[0][1]) + " " + mat.applyToPointStringified(_v[0][0], _v[0][1]);
            shapeString += "z";
          }
          return shapeString;
        };
        var audioControllerFactory = function() {
          function AudioController(audioFactory) {
            this.audios = [];
            this.audioFactory = audioFactory;
            this._volume = 1;
            this._isMuted = false;
          }
          AudioController.prototype = {
            addAudio: function(audio) {
              this.audios.push(audio);
            },
            pause: function() {
              var i2;
              var len = this.audios.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.audios[i2].pause();
              }
            },
            resume: function() {
              var i2;
              var len = this.audios.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.audios[i2].resume();
              }
            },
            setRate: function(rateValue) {
              var i2;
              var len = this.audios.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.audios[i2].setRate(rateValue);
              }
            },
            createAudio: function(assetPath) {
              if (this.audioFactory) {
                return this.audioFactory(assetPath);
              }
              if (Howl) {
                return new Howl({
                  src: [assetPath]
                });
              }
              return {
                isPlaying: false,
                play: function() {
                  this.isPlaying = true;
                },
                seek: function() {
                  this.isPlaying = false;
                },
                playing: function() {
                },
                rate: function() {
                },
                setVolume: function() {
                }
              };
            },
            setAudioFactory: function(audioFactory) {
              this.audioFactory = audioFactory;
            },
            setVolume: function(value) {
              this._volume = value;
              this._updateVolume();
            },
            mute: function() {
              this._isMuted = true;
              this._updateVolume();
            },
            unmute: function() {
              this._isMuted = false;
              this._updateVolume();
            },
            getVolume: function() {
              return this._volume;
            },
            _updateVolume: function() {
              var i2;
              var len = this.audios.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                this.audios[i2].volume(this._volume * (this._isMuted ? 0 : 1));
              }
            }
          };
          return function() {
            return new AudioController();
          };
        }();
        var ImagePreloader = function() {
          var proxyImage = function() {
            var canvas = createTag("canvas");
            canvas.width = 1;
            canvas.height = 1;
            var ctx = canvas.getContext("2d");
            ctx.fillStyle = "rgba(0,0,0,0)";
            ctx.fillRect(0, 0, 1, 1);
            return canvas;
          }();
          function imageLoaded() {
            this.loadedAssets += 1;
            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
              if (this.imagesLoadedCb) {
                this.imagesLoadedCb(null);
              }
            }
          }
          function footageLoaded() {
            this.loadedFootagesCount += 1;
            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {
              if (this.imagesLoadedCb) {
                this.imagesLoadedCb(null);
              }
            }
          }
          function getAssetsPath(assetData, assetsPath, originalPath) {
            var path = "";
            if (assetData.e) {
              path = assetData.p;
            } else if (assetsPath) {
              var imagePath = assetData.p;
              if (imagePath.indexOf("images/") !== -1) {
                imagePath = imagePath.split("/")[1];
              }
              path = assetsPath + imagePath;
            } else {
              path = originalPath;
              path += assetData.u ? assetData.u : "";
              path += assetData.p;
            }
            return path;
          }
          function testImageLoaded(img) {
            var _count = 0;
            var intervalId = setInterval(function() {
              var box = img.getBBox();
              if (box.width || _count > 500) {
                this._imageLoaded();
                clearInterval(intervalId);
              }
              _count += 1;
            }.bind(this), 50);
          }
          function createImageData(assetData) {
            var path = getAssetsPath(assetData, this.assetsPath, this.path);
            var img = createNS("image");
            if (isSafari) {
              this.testImageLoaded(img);
            } else {
              img.addEventListener("load", this._imageLoaded, false);
            }
            img.addEventListener("error", function() {
              ob.img = proxyImage;
              this._imageLoaded();
            }.bind(this), false);
            img.setAttributeNS("http://www.w3.org/1999/xlink", "href", path);
            if (this._elementHelper.append) {
              this._elementHelper.append(img);
            } else {
              this._elementHelper.appendChild(img);
            }
            var ob = {
              img,
              assetData
            };
            return ob;
          }
          function createImgData(assetData) {
            var path = getAssetsPath(assetData, this.assetsPath, this.path);
            var img = createTag("img");
            img.crossOrigin = "anonymous";
            img.addEventListener("load", this._imageLoaded, false);
            img.addEventListener("error", function() {
              ob.img = proxyImage;
              this._imageLoaded();
            }.bind(this), false);
            img.src = path;
            var ob = {
              img,
              assetData
            };
            return ob;
          }
          function createFootageData(data) {
            var ob = {
              assetData: data
            };
            var path = getAssetsPath(data, this.assetsPath, this.path);
            dataManager.loadData(path, function(footageData) {
              ob.img = footageData;
              this._footageLoaded();
            }.bind(this), function() {
              ob.img = {};
              this._footageLoaded();
            }.bind(this));
            return ob;
          }
          function loadAssets(assets, cb) {
            this.imagesLoadedCb = cb;
            var i2;
            var len = assets.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (!assets[i2].layers) {
                if (!assets[i2].t || assets[i2].t === "seq") {
                  this.totalImages += 1;
                  this.images.push(this._createImageData(assets[i2]));
                } else if (assets[i2].t === 3) {
                  this.totalFootages += 1;
                  this.images.push(this.createFootageData(assets[i2]));
                }
              }
            }
          }
          function setPath(path) {
            this.path = path || "";
          }
          function setAssetsPath(path) {
            this.assetsPath = path || "";
          }
          function getAsset(assetData) {
            var i2 = 0;
            var len = this.images.length;
            while (i2 < len) {
              if (this.images[i2].assetData === assetData) {
                return this.images[i2].img;
              }
              i2 += 1;
            }
            return null;
          }
          function destroy() {
            this.imagesLoadedCb = null;
            this.images.length = 0;
          }
          function loadedImages() {
            return this.totalImages === this.loadedAssets;
          }
          function loadedFootages() {
            return this.totalFootages === this.loadedFootagesCount;
          }
          function setCacheType(type, elementHelper) {
            if (type === "svg") {
              this._elementHelper = elementHelper;
              this._createImageData = this.createImageData.bind(this);
            } else {
              this._createImageData = this.createImgData.bind(this);
            }
          }
          function ImagePreloaderFactory() {
            this._imageLoaded = imageLoaded.bind(this);
            this._footageLoaded = footageLoaded.bind(this);
            this.testImageLoaded = testImageLoaded.bind(this);
            this.createFootageData = createFootageData.bind(this);
            this.assetsPath = "";
            this.path = "";
            this.totalImages = 0;
            this.totalFootages = 0;
            this.loadedAssets = 0;
            this.loadedFootagesCount = 0;
            this.imagesLoadedCb = null;
            this.images = [];
          }
          ImagePreloaderFactory.prototype = {
            loadAssets,
            setAssetsPath,
            setPath,
            loadedImages,
            loadedFootages,
            destroy,
            getAsset,
            createImgData,
            createImageData,
            imageLoaded,
            footageLoaded,
            setCacheType
          };
          return ImagePreloaderFactory;
        }();
        var featureSupport = function() {
          var ob = {
            maskType: true
          };
          if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) {
            ob.maskType = false;
          }
          return ob;
        }();
        var filtersFactory = function() {
          var ob = {};
          ob.createFilter = createFilter;
          ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;
          function createFilter(filId, skipCoordinates) {
            var fil = createNS("filter");
            fil.setAttribute("id", filId);
            if (skipCoordinates !== true) {
              fil.setAttribute("filterUnits", "objectBoundingBox");
              fil.setAttribute("x", "0%");
              fil.setAttribute("y", "0%");
              fil.setAttribute("width", "100%");
              fil.setAttribute("height", "100%");
            }
            return fil;
          }
          function createAlphaToLuminanceFilter() {
            var feColorMatrix = createNS("feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
            feColorMatrix.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1");
            return feColorMatrix;
          }
          return ob;
        }();
        function TextAnimatorProperty(textData, renderType, elem) {
          this._isFirstFrame = true;
          this._hasMaskedPath = false;
          this._frameId = -1;
          this._textData = textData;
          this._renderType = renderType;
          this._elem = elem;
          this._animatorsData = createSizedArray(this._textData.a.length);
          this._pathData = {};
          this._moreOptions = {
            alignment: {}
          };
          this.renderedLetters = [];
          this.lettersChangedFlag = false;
          this.initDynamicPropertyContainer(elem);
        }
        TextAnimatorProperty.prototype.searchProperties = function() {
          var i2;
          var len = this._textData.a.length;
          var animatorProps;
          var getProp = PropertyFactory.getProp;
          for (i2 = 0; i2 < len; i2 += 1) {
            animatorProps = this._textData.a[i2];
            this._animatorsData[i2] = new TextAnimatorDataProperty(this._elem, animatorProps, this);
          }
          if (this._textData.p && "m" in this._textData.p) {
            this._pathData = {
              a: getProp(this._elem, this._textData.p.a, 0, 0, this),
              f: getProp(this._elem, this._textData.p.f, 0, 0, this),
              l: getProp(this._elem, this._textData.p.l, 0, 0, this),
              r: getProp(this._elem, this._textData.p.r, 0, 0, this),
              p: getProp(this._elem, this._textData.p.p, 0, 0, this),
              m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
            };
            this._hasMaskedPath = true;
          } else {
            this._hasMaskedPath = false;
          }
          this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);
        };
        TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {
          this.lettersChangedFlag = lettersChangedFlag;
          if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {
            return;
          }
          this._isFirstFrame = false;
          var alignment = this._moreOptions.alignment.v;
          var animators = this._animatorsData;
          var textData = this._textData;
          var matrixHelper = this.mHelper;
          var renderType = this._renderType;
          var renderedLettersCount = this.renderedLetters.length;
          var xPos;
          var yPos;
          var i2;
          var len;
          var letters = documentData.l;
          var pathInfo;
          var currentLength;
          var currentPoint;
          var segmentLength;
          var flag;
          var pointInd;
          var segmentInd;
          var prevPoint;
          var points;
          var segments;
          var partialLength;
          var totalLength;
          var perc;
          var tanAngle;
          var mask;
          if (this._hasMaskedPath) {
            mask = this._pathData.m;
            if (!this._pathData.n || this._pathData._mdf) {
              var paths = mask.v;
              if (this._pathData.r.v) {
                paths = paths.reverse();
              }
              pathInfo = {
                tLength: 0,
                segments: []
              };
              len = paths._length - 1;
              var bezierData;
              totalLength = 0;
              for (i2 = 0; i2 < len; i2 += 1) {
                bezierData = bez.buildBezierData(
                  paths.v[i2],
                  paths.v[i2 + 1],
                  [paths.o[i2][0] - paths.v[i2][0], paths.o[i2][1] - paths.v[i2][1]],
                  [paths.i[i2 + 1][0] - paths.v[i2 + 1][0], paths.i[i2 + 1][1] - paths.v[i2 + 1][1]]
                );
                pathInfo.tLength += bezierData.segmentLength;
                pathInfo.segments.push(bezierData);
                totalLength += bezierData.segmentLength;
              }
              i2 = len;
              if (mask.v.c) {
                bezierData = bez.buildBezierData(
                  paths.v[i2],
                  paths.v[0],
                  [paths.o[i2][0] - paths.v[i2][0], paths.o[i2][1] - paths.v[i2][1]],
                  [paths.i[0][0] - paths.v[0][0], paths.i[0][1] - paths.v[0][1]]
                );
                pathInfo.tLength += bezierData.segmentLength;
                pathInfo.segments.push(bezierData);
                totalLength += bezierData.segmentLength;
              }
              this._pathData.pi = pathInfo;
            }
            pathInfo = this._pathData.pi;
            currentLength = this._pathData.f.v;
            segmentInd = 0;
            pointInd = 1;
            segmentLength = 0;
            flag = true;
            segments = pathInfo.segments;
            if (currentLength < 0 && mask.v.c) {
              if (pathInfo.tLength < Math.abs(currentLength)) {
                currentLength = -Math.abs(currentLength) % pathInfo.tLength;
              }
              segmentInd = segments.length - 1;
              points = segments[segmentInd].points;
              pointInd = points.length - 1;
              while (currentLength < 0) {
                currentLength += points[pointInd].partialLength;
                pointInd -= 1;
                if (pointInd < 0) {
                  segmentInd -= 1;
                  points = segments[segmentInd].points;
                  pointInd = points.length - 1;
                }
              }
            }
            points = segments[segmentInd].points;
            prevPoint = points[pointInd - 1];
            currentPoint = points[pointInd];
            partialLength = currentPoint.partialLength;
          }
          len = letters.length;
          xPos = 0;
          yPos = 0;
          var yOff = documentData.finalSize * 1.2 * 0.714;
          var firstLine = true;
          var animatorProps;
          var animatorSelector;
          var j3;
          var jLen;
          var letterValue;
          jLen = animators.length;
          var mult;
          var ind = -1;
          var offf;
          var xPathPos;
          var yPathPos;
          var initPathPos = currentLength;
          var initSegmentInd = segmentInd;
          var initPointInd = pointInd;
          var currentLine = -1;
          var elemOpacity;
          var sc;
          var sw;
          var fc;
          var k3;
          var letterSw;
          var letterSc;
          var letterFc;
          var letterM = "";
          var letterP = this.defaultPropsArray;
          var letterO;
          if (documentData.j === 2 || documentData.j === 1) {
            var animatorJustifyOffset = 0;
            var animatorFirstCharOffset = 0;
            var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;
            var lastIndex = 0;
            var isNewLine = true;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (letters[i2].n) {
                if (animatorJustifyOffset) {
                  animatorJustifyOffset += animatorFirstCharOffset;
                }
                while (lastIndex < i2) {
                  letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
                  lastIndex += 1;
                }
                animatorJustifyOffset = 0;
                isNewLine = true;
              } else {
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  animatorProps = animators[j3].a;
                  if (animatorProps.t.propType) {
                    if (isNewLine && documentData.j === 2) {
                      animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;
                    }
                    animatorSelector = animators[j3].s;
                    mult = animatorSelector.getMult(letters[i2].anIndexes[j3], textData.a[j3].s.totalChars);
                    if (mult.length) {
                      animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;
                    } else {
                      animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;
                    }
                  }
                }
                isNewLine = false;
              }
            }
            if (animatorJustifyOffset) {
              animatorJustifyOffset += animatorFirstCharOffset;
            }
            while (lastIndex < i2) {
              letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;
              lastIndex += 1;
            }
          }
          for (i2 = 0; i2 < len; i2 += 1) {
            matrixHelper.reset();
            elemOpacity = 1;
            if (letters[i2].n) {
              xPos = 0;
              yPos += documentData.yOffset;
              yPos += firstLine ? 1 : 0;
              currentLength = initPathPos;
              firstLine = false;
              if (this._hasMaskedPath) {
                segmentInd = initSegmentInd;
                pointInd = initPointInd;
                points = segments[segmentInd].points;
                prevPoint = points[pointInd - 1];
                currentPoint = points[pointInd];
                partialLength = currentPoint.partialLength;
                segmentLength = 0;
              }
              letterM = "";
              letterFc = "";
              letterSw = "";
              letterO = "";
              letterP = this.defaultPropsArray;
            } else {
              if (this._hasMaskedPath) {
                if (currentLine !== letters[i2].line) {
                  switch (documentData.j) {
                    case 1:
                      currentLength += totalLength - documentData.lineWidths[letters[i2].line];
                      break;
                    case 2:
                      currentLength += (totalLength - documentData.lineWidths[letters[i2].line]) / 2;
                      break;
                    default:
                      break;
                  }
                  currentLine = letters[i2].line;
                }
                if (ind !== letters[i2].ind) {
                  if (letters[ind]) {
                    currentLength += letters[ind].extra;
                  }
                  currentLength += letters[i2].an / 2;
                  ind = letters[i2].ind;
                }
                currentLength += alignment[0] * letters[i2].an * 5e-3;
                var animatorOffset = 0;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  animatorProps = animators[j3].a;
                  if (animatorProps.p.propType) {
                    animatorSelector = animators[j3].s;
                    mult = animatorSelector.getMult(letters[i2].anIndexes[j3], textData.a[j3].s.totalChars);
                    if (mult.length) {
                      animatorOffset += animatorProps.p.v[0] * mult[0];
                    } else {
                      animatorOffset += animatorProps.p.v[0] * mult;
                    }
                  }
                  if (animatorProps.a.propType) {
                    animatorSelector = animators[j3].s;
                    mult = animatorSelector.getMult(letters[i2].anIndexes[j3], textData.a[j3].s.totalChars);
                    if (mult.length) {
                      animatorOffset += animatorProps.a.v[0] * mult[0];
                    } else {
                      animatorOffset += animatorProps.a.v[0] * mult;
                    }
                  }
                }
                flag = true;
                if (this._pathData.a.v) {
                  currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);
                  currentLength += this._pathData.f.v;
                }
                while (flag) {
                  if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {
                    perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;
                    xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;
                    yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;
                    matrixHelper.translate(-alignment[0] * letters[i2].an * 5e-3, -(alignment[1] * yOff) * 0.01);
                    flag = false;
                  } else if (points) {
                    segmentLength += currentPoint.partialLength;
                    pointInd += 1;
                    if (pointInd >= points.length) {
                      pointInd = 0;
                      segmentInd += 1;
                      if (!segments[segmentInd]) {
                        if (mask.v.c) {
                          pointInd = 0;
                          segmentInd = 0;
                          points = segments[segmentInd].points;
                        } else {
                          segmentLength -= currentPoint.partialLength;
                          points = null;
                        }
                      } else {
                        points = segments[segmentInd].points;
                      }
                    }
                    if (points) {
                      prevPoint = currentPoint;
                      currentPoint = points[pointInd];
                      partialLength = currentPoint.partialLength;
                    }
                  }
                }
                offf = letters[i2].an / 2 - letters[i2].add;
                matrixHelper.translate(-offf, 0, 0);
              } else {
                offf = letters[i2].an / 2 - letters[i2].add;
                matrixHelper.translate(-offf, 0, 0);
                matrixHelper.translate(-alignment[0] * letters[i2].an * 5e-3, -alignment[1] * yOff * 0.01, 0);
              }
              for (j3 = 0; j3 < jLen; j3 += 1) {
                animatorProps = animators[j3].a;
                if (animatorProps.t.propType) {
                  animatorSelector = animators[j3].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j3], textData.a[j3].s.totalChars);
                  if (xPos !== 0 || documentData.j !== 0) {
                    if (this._hasMaskedPath) {
                      if (mult.length) {
                        currentLength += animatorProps.t.v * mult[0];
                      } else {
                        currentLength += animatorProps.t.v * mult;
                      }
                    } else if (mult.length) {
                      xPos += animatorProps.t.v * mult[0];
                    } else {
                      xPos += animatorProps.t.v * mult;
                    }
                  }
                }
              }
              if (documentData.strokeWidthAnim) {
                sw = documentData.sw || 0;
              }
              if (documentData.strokeColorAnim) {
                if (documentData.sc) {
                  sc = [documentData.sc[0], documentData.sc[1], documentData.sc[2]];
                } else {
                  sc = [0, 0, 0];
                }
              }
              if (documentData.fillColorAnim && documentData.fc) {
                fc = [documentData.fc[0], documentData.fc[1], documentData.fc[2]];
              }
              for (j3 = 0; j3 < jLen; j3 += 1) {
                animatorProps = animators[j3].a;
                if (animatorProps.a.propType) {
                  animatorSelector = animators[j3].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j3], textData.a[j3].s.totalChars);
                  if (mult.length) {
                    matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);
                  } else {
                    matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);
                  }
                }
              }
              for (j3 = 0; j3 < jLen; j3 += 1) {
                animatorProps = animators[j3].a;
                if (animatorProps.s.propType) {
                  animatorSelector = animators[j3].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j3], textData.a[j3].s.totalChars);
                  if (mult.length) {
                    matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);
                  } else {
                    matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);
                  }
                }
              }
              for (j3 = 0; j3 < jLen; j3 += 1) {
                animatorProps = animators[j3].a;
                animatorSelector = animators[j3].s;
                mult = animatorSelector.getMult(letters[i2].anIndexes[j3], textData.a[j3].s.totalChars);
                if (animatorProps.sk.propType) {
                  if (mult.length) {
                    matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);
                  } else {
                    matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);
                  }
                }
                if (animatorProps.r.propType) {
                  if (mult.length) {
                    matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);
                  } else {
                    matrixHelper.rotateZ(-animatorProps.r.v * mult);
                  }
                }
                if (animatorProps.ry.propType) {
                  if (mult.length) {
                    matrixHelper.rotateY(animatorProps.ry.v * mult[1]);
                  } else {
                    matrixHelper.rotateY(animatorProps.ry.v * mult);
                  }
                }
                if (animatorProps.rx.propType) {
                  if (mult.length) {
                    matrixHelper.rotateX(animatorProps.rx.v * mult[0]);
                  } else {
                    matrixHelper.rotateX(animatorProps.rx.v * mult);
                  }
                }
                if (animatorProps.o.propType) {
                  if (mult.length) {
                    elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];
                  } else {
                    elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;
                  }
                }
                if (documentData.strokeWidthAnim && animatorProps.sw.propType) {
                  if (mult.length) {
                    sw += animatorProps.sw.v * mult[0];
                  } else {
                    sw += animatorProps.sw.v * mult;
                  }
                }
                if (documentData.strokeColorAnim && animatorProps.sc.propType) {
                  for (k3 = 0; k3 < 3; k3 += 1) {
                    if (mult.length) {
                      sc[k3] += (animatorProps.sc.v[k3] - sc[k3]) * mult[0];
                    } else {
                      sc[k3] += (animatorProps.sc.v[k3] - sc[k3]) * mult;
                    }
                  }
                }
                if (documentData.fillColorAnim && documentData.fc) {
                  if (animatorProps.fc.propType) {
                    for (k3 = 0; k3 < 3; k3 += 1) {
                      if (mult.length) {
                        fc[k3] += (animatorProps.fc.v[k3] - fc[k3]) * mult[0];
                      } else {
                        fc[k3] += (animatorProps.fc.v[k3] - fc[k3]) * mult;
                      }
                    }
                  }
                  if (animatorProps.fh.propType) {
                    if (mult.length) {
                      fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);
                    } else {
                      fc = addHueToRGB(fc, animatorProps.fh.v * mult);
                    }
                  }
                  if (animatorProps.fs.propType) {
                    if (mult.length) {
                      fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);
                    } else {
                      fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);
                    }
                  }
                  if (animatorProps.fb.propType) {
                    if (mult.length) {
                      fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);
                    } else {
                      fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);
                    }
                  }
                }
              }
              for (j3 = 0; j3 < jLen; j3 += 1) {
                animatorProps = animators[j3].a;
                if (animatorProps.p.propType) {
                  animatorSelector = animators[j3].s;
                  mult = animatorSelector.getMult(letters[i2].anIndexes[j3], textData.a[j3].s.totalChars);
                  if (this._hasMaskedPath) {
                    if (mult.length) {
                      matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);
                    } else {
                      matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                    }
                  } else if (mult.length) {
                    matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);
                  } else {
                    matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);
                  }
                }
              }
              if (documentData.strokeWidthAnim) {
                letterSw = sw < 0 ? 0 : sw;
              }
              if (documentData.strokeColorAnim) {
                letterSc = "rgb(" + Math.round(sc[0] * 255) + "," + Math.round(sc[1] * 255) + "," + Math.round(sc[2] * 255) + ")";
              }
              if (documentData.fillColorAnim && documentData.fc) {
                letterFc = "rgb(" + Math.round(fc[0] * 255) + "," + Math.round(fc[1] * 255) + "," + Math.round(fc[2] * 255) + ")";
              }
              if (this._hasMaskedPath) {
                matrixHelper.translate(0, -documentData.ls);
                matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);
                if (this._pathData.p.v) {
                  tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);
                  var rot = Math.atan(tanAngle) * 180 / Math.PI;
                  if (currentPoint.point[0] < prevPoint.point[0]) {
                    rot += 180;
                  }
                  matrixHelper.rotate(-rot * Math.PI / 180);
                }
                matrixHelper.translate(xPathPos, yPathPos, 0);
                currentLength -= alignment[0] * letters[i2].an * 5e-3;
                if (letters[i2 + 1] && ind !== letters[i2 + 1].ind) {
                  currentLength += letters[i2].an / 2;
                  currentLength += documentData.tr * 1e-3 * documentData.finalSize;
                }
              } else {
                matrixHelper.translate(xPos, yPos, 0);
                if (documentData.ps) {
                  matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
                }
                switch (documentData.j) {
                  case 1:
                    matrixHelper.translate(letters[i2].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i2].line]), 0, 0);
                    break;
                  case 2:
                    matrixHelper.translate(letters[i2].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i2].line]) / 2, 0, 0);
                    break;
                  default:
                    break;
                }
                matrixHelper.translate(0, -documentData.ls);
                matrixHelper.translate(offf, 0, 0);
                matrixHelper.translate(alignment[0] * letters[i2].an * 5e-3, alignment[1] * yOff * 0.01, 0);
                xPos += letters[i2].l + documentData.tr * 1e-3 * documentData.finalSize;
              }
              if (renderType === "html") {
                letterM = matrixHelper.toCSS();
              } else if (renderType === "svg") {
                letterM = matrixHelper.to2dCSS();
              } else {
                letterP = [matrixHelper.props[0], matrixHelper.props[1], matrixHelper.props[2], matrixHelper.props[3], matrixHelper.props[4], matrixHelper.props[5], matrixHelper.props[6], matrixHelper.props[7], matrixHelper.props[8], matrixHelper.props[9], matrixHelper.props[10], matrixHelper.props[11], matrixHelper.props[12], matrixHelper.props[13], matrixHelper.props[14], matrixHelper.props[15]];
              }
              letterO = elemOpacity;
            }
            if (renderedLettersCount <= i2) {
              letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);
              this.renderedLetters.push(letterValue);
              renderedLettersCount += 1;
              this.lettersChangedFlag = true;
            } else {
              letterValue = this.renderedLetters[i2];
              this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;
            }
          }
        };
        TextAnimatorProperty.prototype.getValue = function() {
          if (this._elem.globalData.frameId === this._frameId) {
            return;
          }
          this._frameId = this._elem.globalData.frameId;
          this.iterateDynamicProperties();
        };
        TextAnimatorProperty.prototype.mHelper = new Matrix();
        TextAnimatorProperty.prototype.defaultPropsArray = [];
        extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
        function TextAnimatorDataProperty(elem, animatorProps, container) {
          var defaultData = { propType: false };
          var getProp = PropertyFactory.getProp;
          var textAnimatorAnimatables = animatorProps.a;
          this.a = {
            r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,
            rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,
            ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,
            sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,
            sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,
            s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,
            a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,
            o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,
            p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,
            sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,
            sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,
            fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,
            fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,
            fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,
            fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,
            t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData
          };
          this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);
          this.s.t = animatorProps.s.t;
        }
        function LetterProps(o3, sw, sc, fc, m3, p2) {
          this.o = o3;
          this.sw = sw;
          this.sc = sc;
          this.fc = fc;
          this.m = m3;
          this.p = p2;
          this._mdf = {
            o: true,
            sw: !!sw,
            sc: !!sc,
            fc: !!fc,
            m: true,
            p: true
          };
        }
        LetterProps.prototype.update = function(o3, sw, sc, fc, m3, p2) {
          this._mdf.o = false;
          this._mdf.sw = false;
          this._mdf.sc = false;
          this._mdf.fc = false;
          this._mdf.m = false;
          this._mdf.p = false;
          var updated = false;
          if (this.o !== o3) {
            this.o = o3;
            this._mdf.o = true;
            updated = true;
          }
          if (this.sw !== sw) {
            this.sw = sw;
            this._mdf.sw = true;
            updated = true;
          }
          if (this.sc !== sc) {
            this.sc = sc;
            this._mdf.sc = true;
            updated = true;
          }
          if (this.fc !== fc) {
            this.fc = fc;
            this._mdf.fc = true;
            updated = true;
          }
          if (this.m !== m3) {
            this.m = m3;
            this._mdf.m = true;
            updated = true;
          }
          if (p2.length && (this.p[0] !== p2[0] || this.p[1] !== p2[1] || this.p[4] !== p2[4] || this.p[5] !== p2[5] || this.p[12] !== p2[12] || this.p[13] !== p2[13])) {
            this.p = p2;
            this._mdf.p = true;
            updated = true;
          }
          return updated;
        };
        function TextProperty(elem, data) {
          this._frameId = initialDefaultFrame;
          this.pv = "";
          this.v = "";
          this.kf = false;
          this._isFirstFrame = true;
          this._mdf = false;
          this.data = data;
          this.elem = elem;
          this.comp = this.elem.comp;
          this.keysIndex = 0;
          this.canResize = false;
          this.minimumFontSize = 1;
          this.effectsSequence = [];
          this.currentData = {
            ascent: 0,
            boxWidth: this.defaultBoxWidth,
            f: "",
            fStyle: "",
            fWeight: "",
            fc: "",
            j: "",
            justifyOffset: "",
            l: [],
            lh: 0,
            lineWidths: [],
            ls: "",
            of: "",
            s: "",
            sc: "",
            sw: 0,
            t: 0,
            tr: 0,
            sz: 0,
            ps: null,
            fillColorAnim: false,
            strokeColorAnim: false,
            strokeWidthAnim: false,
            yOffset: 0,
            finalSize: 0,
            finalText: [],
            finalLineHeight: 0,
            __complete: false
          };
          this.copyData(this.currentData, this.data.d.k[0].s);
          if (!this.searchProperty()) {
            this.completeTextData(this.currentData);
          }
        }
        TextProperty.prototype.defaultBoxWidth = [0, 0];
        TextProperty.prototype.copyData = function(obj, data) {
          for (var s2 in data) {
            if (Object.prototype.hasOwnProperty.call(data, s2)) {
              obj[s2] = data[s2];
            }
          }
          return obj;
        };
        TextProperty.prototype.setCurrentData = function(data) {
          if (!data.__complete) {
            this.completeTextData(data);
          }
          this.currentData = data;
          this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;
          this._mdf = true;
        };
        TextProperty.prototype.searchProperty = function() {
          return this.searchKeyframes();
        };
        TextProperty.prototype.searchKeyframes = function() {
          this.kf = this.data.d.k.length > 1;
          if (this.kf) {
            this.addEffect(this.getKeyframeValue.bind(this));
          }
          return this.kf;
        };
        TextProperty.prototype.addEffect = function(effectFunction) {
          this.effectsSequence.push(effectFunction);
          this.elem.addDynamicProperty(this);
        };
        TextProperty.prototype.getValue = function(_finalValue) {
          if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {
            return;
          }
          this.currentData.t = this.data.d.k[this.keysIndex].s.t;
          var currentValue = this.currentData;
          var currentIndex = this.keysIndex;
          if (this.lock) {
            this.setCurrentData(this.currentData);
            return;
          }
          this.lock = true;
          this._mdf = false;
          var i2;
          var len = this.effectsSequence.length;
          var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (currentIndex !== this.keysIndex) {
              finalValue = this.effectsSequence[i2](finalValue, finalValue.t);
            } else {
              finalValue = this.effectsSequence[i2](this.currentData, finalValue.t);
            }
          }
          if (currentValue !== finalValue) {
            this.setCurrentData(finalValue);
          }
          this.v = this.currentData;
          this.pv = this.v;
          this.lock = false;
          this.frameId = this.elem.globalData.frameId;
        };
        TextProperty.prototype.getKeyframeValue = function() {
          var textKeys = this.data.d.k;
          var frameNum = this.elem.comp.renderedFrame;
          var i2 = 0;
          var len = textKeys.length;
          while (i2 <= len - 1) {
            if (i2 === len - 1 || textKeys[i2 + 1].t > frameNum) {
              break;
            }
            i2 += 1;
          }
          if (this.keysIndex !== i2) {
            this.keysIndex = i2;
          }
          return this.data.d.k[this.keysIndex].s;
        };
        TextProperty.prototype.buildFinalText = function(text) {
          var charactersArray = [];
          var i2 = 0;
          var len = text.length;
          var charCode;
          var secondCharCode;
          var shouldCombine = false;
          while (i2 < len) {
            charCode = text.charCodeAt(i2);
            if (FontManager.isCombinedCharacter(charCode)) {
              charactersArray[charactersArray.length - 1] += text.charAt(i2);
            } else if (charCode >= 55296 && charCode <= 56319) {
              secondCharCode = text.charCodeAt(i2 + 1);
              if (secondCharCode >= 56320 && secondCharCode <= 57343) {
                if (shouldCombine || FontManager.isModifier(charCode, secondCharCode)) {
                  charactersArray[charactersArray.length - 1] += text.substr(i2, 2);
                  shouldCombine = false;
                } else {
                  charactersArray.push(text.substr(i2, 2));
                }
                i2 += 1;
              } else {
                charactersArray.push(text.charAt(i2));
              }
            } else if (charCode > 56319) {
              secondCharCode = text.charCodeAt(i2 + 1);
              if (FontManager.isZeroWidthJoiner(charCode, secondCharCode)) {
                shouldCombine = true;
                charactersArray[charactersArray.length - 1] += text.substr(i2, 2);
                i2 += 1;
              } else {
                charactersArray.push(text.charAt(i2));
              }
            } else if (FontManager.isZeroWidthJoiner(charCode)) {
              charactersArray[charactersArray.length - 1] += text.charAt(i2);
              shouldCombine = true;
            } else {
              charactersArray.push(text.charAt(i2));
            }
            i2 += 1;
          }
          return charactersArray;
        };
        TextProperty.prototype.completeTextData = function(documentData) {
          documentData.__complete = true;
          var fontManager = this.elem.globalData.fontManager;
          var data = this.data;
          var letters = [];
          var i2;
          var len;
          var newLineFlag;
          var index2 = 0;
          var val;
          var anchorGrouping = data.m.g;
          var currentSize = 0;
          var currentPos = 0;
          var currentLine = 0;
          var lineWidths = [];
          var lineWidth = 0;
          var maxLineWidth = 0;
          var j3;
          var jLen;
          var fontData = fontManager.getFontByName(documentData.f);
          var charData;
          var cLength = 0;
          var fontProps = getFontProperties(fontData);
          documentData.fWeight = fontProps.weight;
          documentData.fStyle = fontProps.style;
          documentData.finalSize = documentData.s;
          documentData.finalText = this.buildFinalText(documentData.t);
          len = documentData.finalText.length;
          documentData.finalLineHeight = documentData.lh;
          var trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
          var charCode;
          if (documentData.sz) {
            var flag = true;
            var boxWidth = documentData.sz[0];
            var boxHeight = documentData.sz[1];
            var currentHeight;
            var finalText;
            while (flag) {
              finalText = this.buildFinalText(documentData.t);
              currentHeight = 0;
              lineWidth = 0;
              len = finalText.length;
              trackingOffset = documentData.tr / 1e3 * documentData.finalSize;
              var lastSpaceIndex = -1;
              for (i2 = 0; i2 < len; i2 += 1) {
                charCode = finalText[i2].charCodeAt(0);
                newLineFlag = false;
                if (finalText[i2] === " ") {
                  lastSpaceIndex = i2;
                } else if (charCode === 13 || charCode === 3) {
                  lineWidth = 0;
                  newLineFlag = true;
                  currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                }
                if (fontManager.chars) {
                  charData = fontManager.getCharData(finalText[i2], fontData.fStyle, fontData.fFamily);
                  cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
                } else {
                  cLength = fontManager.measureText(finalText[i2], documentData.f, documentData.finalSize);
                }
                if (lineWidth + cLength > boxWidth && finalText[i2] !== " ") {
                  if (lastSpaceIndex === -1) {
                    len += 1;
                  } else {
                    i2 = lastSpaceIndex;
                  }
                  currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;
                  finalText.splice(i2, lastSpaceIndex === i2 ? 1 : 0, "\r");
                  lastSpaceIndex = -1;
                  lineWidth = 0;
                } else {
                  lineWidth += cLength;
                  lineWidth += trackingOffset;
                }
              }
              currentHeight += fontData.ascent * documentData.finalSize / 100;
              if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {
                documentData.finalSize -= 1;
                documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;
              } else {
                documentData.finalText = finalText;
                len = documentData.finalText.length;
                flag = false;
              }
            }
          }
          lineWidth = -trackingOffset;
          cLength = 0;
          var uncollapsedSpaces = 0;
          var currentChar;
          for (i2 = 0; i2 < len; i2 += 1) {
            newLineFlag = false;
            currentChar = documentData.finalText[i2];
            charCode = currentChar.charCodeAt(0);
            if (charCode === 13 || charCode === 3) {
              uncollapsedSpaces = 0;
              lineWidths.push(lineWidth);
              maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
              lineWidth = -2 * trackingOffset;
              val = "";
              newLineFlag = true;
              currentLine += 1;
            } else {
              val = currentChar;
            }
            if (fontManager.chars) {
              charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);
              cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;
            } else {
              cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);
            }
            if (currentChar === " ") {
              uncollapsedSpaces += cLength + trackingOffset;
            } else {
              lineWidth += cLength + trackingOffset + uncollapsedSpaces;
              uncollapsedSpaces = 0;
            }
            letters.push({
              l: cLength,
              an: cLength,
              add: currentSize,
              n: newLineFlag,
              anIndexes: [],
              val,
              line: currentLine,
              animatorJustifyOffset: 0
            });
            if (anchorGrouping == 2) {
              currentSize += cLength;
              if (val === "" || val === " " || i2 === len - 1) {
                if (val === "" || val === " ") {
                  currentSize -= cLength;
                }
                while (currentPos <= i2) {
                  letters[currentPos].an = currentSize;
                  letters[currentPos].ind = index2;
                  letters[currentPos].extra = cLength;
                  currentPos += 1;
                }
                index2 += 1;
                currentSize = 0;
              }
            } else if (anchorGrouping == 3) {
              currentSize += cLength;
              if (val === "" || i2 === len - 1) {
                if (val === "") {
                  currentSize -= cLength;
                }
                while (currentPos <= i2) {
                  letters[currentPos].an = currentSize;
                  letters[currentPos].ind = index2;
                  letters[currentPos].extra = cLength;
                  currentPos += 1;
                }
                currentSize = 0;
                index2 += 1;
              }
            } else {
              letters[index2].ind = index2;
              letters[index2].extra = 0;
              index2 += 1;
            }
          }
          documentData.l = letters;
          maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;
          lineWidths.push(lineWidth);
          if (documentData.sz) {
            documentData.boxWidth = documentData.sz[0];
            documentData.justifyOffset = 0;
          } else {
            documentData.boxWidth = maxLineWidth;
            switch (documentData.j) {
              case 1:
                documentData.justifyOffset = -documentData.boxWidth;
                break;
              case 2:
                documentData.justifyOffset = -documentData.boxWidth / 2;
                break;
              default:
                documentData.justifyOffset = 0;
            }
          }
          documentData.lineWidths = lineWidths;
          var animators = data.a;
          var animatorData;
          var letterData;
          jLen = animators.length;
          var based;
          var ind;
          var indexes = [];
          for (j3 = 0; j3 < jLen; j3 += 1) {
            animatorData = animators[j3];
            if (animatorData.a.sc) {
              documentData.strokeColorAnim = true;
            }
            if (animatorData.a.sw) {
              documentData.strokeWidthAnim = true;
            }
            if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {
              documentData.fillColorAnim = true;
            }
            ind = 0;
            based = animatorData.s.b;
            for (i2 = 0; i2 < len; i2 += 1) {
              letterData = letters[i2];
              letterData.anIndexes[j3] = ind;
              if (based == 1 && letterData.val !== "" || based == 2 && letterData.val !== "" && letterData.val !== " " || based == 3 && (letterData.n || letterData.val == " " || i2 == len - 1) || based == 4 && (letterData.n || i2 == len - 1)) {
                if (animatorData.s.rn === 1) {
                  indexes.push(ind);
                }
                ind += 1;
              }
            }
            data.a[j3].s.totalChars = ind;
            var currentInd = -1;
            var newInd;
            if (animatorData.s.rn === 1) {
              for (i2 = 0; i2 < len; i2 += 1) {
                letterData = letters[i2];
                if (currentInd != letterData.anIndexes[j3]) {
                  currentInd = letterData.anIndexes[j3];
                  newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];
                }
                letterData.anIndexes[j3] = newInd;
              }
            }
          }
          documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;
          documentData.ls = documentData.ls || 0;
          documentData.ascent = fontData.ascent * documentData.finalSize / 100;
        };
        TextProperty.prototype.updateDocumentData = function(newData, index2) {
          index2 = index2 === void 0 ? this.keysIndex : index2;
          var dData = this.copyData({}, this.data.d.k[index2].s);
          dData = this.copyData(dData, newData);
          this.data.d.k[index2].s = dData;
          this.recalculate(index2);
          this.elem.addDynamicProperty(this);
        };
        TextProperty.prototype.recalculate = function(index2) {
          var dData = this.data.d.k[index2].s;
          dData.__complete = false;
          this.keysIndex = 0;
          this._isFirstFrame = true;
          this.getValue(dData);
        };
        TextProperty.prototype.canResizeFont = function(_canResize) {
          this.canResize = _canResize;
          this.recalculate(this.keysIndex);
          this.elem.addDynamicProperty(this);
        };
        TextProperty.prototype.setMinimumFontSize = function(_fontValue) {
          this.minimumFontSize = Math.floor(_fontValue) || 1;
          this.recalculate(this.keysIndex);
          this.elem.addDynamicProperty(this);
        };
        var TextSelectorProp = function() {
          var max = Math.max;
          var min = Math.min;
          var floor = Math.floor;
          function TextSelectorPropFactory(elem, data) {
            this._currentTextLength = -1;
            this.k = false;
            this.data = data;
            this.elem = elem;
            this.comp = elem.comp;
            this.finalS = 0;
            this.finalE = 0;
            this.initDynamicPropertyContainer(elem);
            this.s = PropertyFactory.getProp(elem, data.s || { k: 0 }, 0, 0, this);
            if ("e" in data) {
              this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);
            } else {
              this.e = { v: 100 };
            }
            this.o = PropertyFactory.getProp(elem, data.o || { k: 0 }, 0, 0, this);
            this.xe = PropertyFactory.getProp(elem, data.xe || { k: 0 }, 0, 0, this);
            this.ne = PropertyFactory.getProp(elem, data.ne || { k: 0 }, 0, 0, this);
            this.sm = PropertyFactory.getProp(elem, data.sm || { k: 100 }, 0, 0, this);
            this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);
            if (!this.dynamicProperties.length) {
              this.getValue();
            }
          }
          TextSelectorPropFactory.prototype = {
            getMult: function(ind) {
              if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {
                this.getValue();
              }
              var x1 = 0;
              var y1 = 0;
              var x22 = 1;
              var y22 = 1;
              if (this.ne.v > 0) {
                x1 = this.ne.v / 100;
              } else {
                y1 = -this.ne.v / 100;
              }
              if (this.xe.v > 0) {
                x22 = 1 - this.xe.v / 100;
              } else {
                y22 = 1 + this.xe.v / 100;
              }
              var easer = BezierFactory.getBezierEasing(x1, y1, x22, y22).get;
              var mult = 0;
              var s2 = this.finalS;
              var e2 = this.finalE;
              var type = this.data.sh;
              if (type === 2) {
                if (e2 === s2) {
                  mult = ind >= e2 ? 1 : 0;
                } else {
                  mult = max(0, min(0.5 / (e2 - s2) + (ind - s2) / (e2 - s2), 1));
                }
                mult = easer(mult);
              } else if (type === 3) {
                if (e2 === s2) {
                  mult = ind >= e2 ? 0 : 1;
                } else {
                  mult = 1 - max(0, min(0.5 / (e2 - s2) + (ind - s2) / (e2 - s2), 1));
                }
                mult = easer(mult);
              } else if (type === 4) {
                if (e2 === s2) {
                  mult = 0;
                } else {
                  mult = max(0, min(0.5 / (e2 - s2) + (ind - s2) / (e2 - s2), 1));
                  if (mult < 0.5) {
                    mult *= 2;
                  } else {
                    mult = 1 - 2 * (mult - 0.5);
                  }
                }
                mult = easer(mult);
              } else if (type === 5) {
                if (e2 === s2) {
                  mult = 0;
                } else {
                  var tot = e2 - s2;
                  ind = min(max(0, ind + 0.5 - s2), e2 - s2);
                  var x3 = -tot / 2 + ind;
                  var a2 = tot / 2;
                  mult = Math.sqrt(1 - x3 * x3 / (a2 * a2));
                }
                mult = easer(mult);
              } else if (type === 6) {
                if (e2 === s2) {
                  mult = 0;
                } else {
                  ind = min(max(0, ind + 0.5 - s2), e2 - s2);
                  mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e2 - s2))) / 2;
                }
                mult = easer(mult);
              } else {
                if (ind >= floor(s2)) {
                  if (ind - s2 < 0) {
                    mult = max(0, min(min(e2, 1) - (s2 - ind), 1));
                  } else {
                    mult = max(0, min(e2 - ind, 1));
                  }
                }
                mult = easer(mult);
              }
              if (this.sm.v !== 100) {
                var smoothness = this.sm.v * 0.01;
                if (smoothness === 0) {
                  smoothness = 1e-8;
                }
                var threshold = 0.5 - smoothness * 0.5;
                if (mult < threshold) {
                  mult = 0;
                } else {
                  mult = (mult - threshold) / smoothness;
                  if (mult > 1) {
                    mult = 1;
                  }
                }
              }
              return mult * this.a.v;
            },
            getValue: function(newCharsFlag) {
              this.iterateDynamicProperties();
              this._mdf = newCharsFlag || this._mdf;
              this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;
              if (newCharsFlag && this.data.r === 2) {
                this.e.v = this._currentTextLength;
              }
              var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;
              var o3 = this.o.v / divisor;
              var s2 = this.s.v / divisor + o3;
              var e2 = this.e.v / divisor + o3;
              if (s2 > e2) {
                var _s = s2;
                s2 = e2;
                e2 = _s;
              }
              this.finalS = s2;
              this.finalE = e2;
            }
          };
          extendPrototype([DynamicPropertyContainer], TextSelectorPropFactory);
          function getTextSelectorProp(elem, data, arr) {
            return new TextSelectorPropFactory(elem, data, arr);
          }
          return {
            getTextSelectorProp
          };
        }();
        var poolFactory = /* @__PURE__ */ function() {
          return function(initialLength, _create, _release) {
            var _length = 0;
            var _maxLength = initialLength;
            var pool = createSizedArray(_maxLength);
            var ob = {
              newElement,
              release
            };
            function newElement() {
              var element;
              if (_length) {
                _length -= 1;
                element = pool[_length];
              } else {
                element = _create();
              }
              return element;
            }
            function release(element) {
              if (_length === _maxLength) {
                pool = pooling.double(pool);
                _maxLength *= 2;
              }
              if (_release) {
                _release(element);
              }
              pool[_length] = element;
              _length += 1;
            }
            return ob;
          };
        }();
        var pooling = /* @__PURE__ */ function() {
          function double(arr) {
            return arr.concat(createSizedArray(arr.length));
          }
          return {
            double
          };
        }();
        var pointPool = function() {
          function create() {
            return createTypedArray("float32", 2);
          }
          return poolFactory(8, create);
        }();
        var shapePool = function() {
          function create() {
            return new ShapePath();
          }
          function release(shapePath) {
            var len = shapePath._length;
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              pointPool.release(shapePath.v[i2]);
              pointPool.release(shapePath.i[i2]);
              pointPool.release(shapePath.o[i2]);
              shapePath.v[i2] = null;
              shapePath.i[i2] = null;
              shapePath.o[i2] = null;
            }
            shapePath._length = 0;
            shapePath.c = false;
          }
          function clone(shape) {
            var cloned = factory.newElement();
            var i2;
            var len = shape._length === void 0 ? shape.v.length : shape._length;
            cloned.setLength(len);
            cloned.c = shape.c;
            for (i2 = 0; i2 < len; i2 += 1) {
              cloned.setTripleAt(shape.v[i2][0], shape.v[i2][1], shape.o[i2][0], shape.o[i2][1], shape.i[i2][0], shape.i[i2][1], i2);
            }
            return cloned;
          }
          var factory = poolFactory(4, create, release);
          factory.clone = clone;
          return factory;
        }();
        var shapeCollectionPool = function() {
          var ob = {
            newShapeCollection,
            release
          };
          var _length = 0;
          var _maxLength = 4;
          var pool = createSizedArray(_maxLength);
          function newShapeCollection() {
            var shapeCollection;
            if (_length) {
              _length -= 1;
              shapeCollection = pool[_length];
            } else {
              shapeCollection = new ShapeCollection();
            }
            return shapeCollection;
          }
          function release(shapeCollection) {
            var i2;
            var len = shapeCollection._length;
            for (i2 = 0; i2 < len; i2 += 1) {
              shapePool.release(shapeCollection.shapes[i2]);
            }
            shapeCollection._length = 0;
            if (_length === _maxLength) {
              pool = pooling.double(pool);
              _maxLength *= 2;
            }
            pool[_length] = shapeCollection;
            _length += 1;
          }
          return ob;
        }();
        var segmentsLengthPool = function() {
          function create() {
            return {
              lengths: [],
              totalLength: 0
            };
          }
          function release(element) {
            var i2;
            var len = element.lengths.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              bezierLengthPool.release(element.lengths[i2]);
            }
            element.lengths.length = 0;
          }
          return poolFactory(8, create, release);
        }();
        var bezierLengthPool = function() {
          function create() {
            return {
              addedLength: 0,
              percents: createTypedArray("float32", defaultCurveSegments),
              lengths: createTypedArray("float32", defaultCurveSegments)
            };
          }
          return poolFactory(8, create);
        }();
        var markerParser = /* @__PURE__ */ function() {
          function parsePayloadLines(payload) {
            var lines = payload.split("\r\n");
            var keys = {};
            var line;
            var keysCount = 0;
            for (var i2 = 0; i2 < lines.length; i2 += 1) {
              line = lines[i2].split(":");
              if (line.length === 2) {
                keys[line[0]] = line[1].trim();
                keysCount += 1;
              }
            }
            if (keysCount === 0) {
              throw new Error();
            }
            return keys;
          }
          return function(_markers) {
            var markers = [];
            for (var i2 = 0; i2 < _markers.length; i2 += 1) {
              var _marker = _markers[i2];
              var markerData = {
                time: _marker.tm,
                duration: _marker.dr
              };
              try {
                markerData.payload = JSON.parse(_markers[i2].cm);
              } catch (_3) {
                try {
                  markerData.payload = parsePayloadLines(_markers[i2].cm);
                } catch (__) {
                  markerData.payload = {
                    name: _markers[i2]
                  };
                }
              }
              markers.push(markerData);
            }
            return markers;
          };
        }();
        function BaseRenderer() {
        }
        BaseRenderer.prototype.checkLayers = function(num) {
          var i2;
          var len = this.layers.length;
          var data;
          this.completeLayers = true;
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (!this.elements[i2]) {
              data = this.layers[i2];
              if (data.ip - data.st <= num - this.layers[i2].st && data.op - data.st > num - this.layers[i2].st) {
                this.buildItem(i2);
              }
            }
            this.completeLayers = this.elements[i2] ? this.completeLayers : false;
          }
          this.checkPendingElements();
        };
        BaseRenderer.prototype.createItem = function(layer) {
          switch (layer.ty) {
            case 2:
              return this.createImage(layer);
            case 0:
              return this.createComp(layer);
            case 1:
              return this.createSolid(layer);
            case 3:
              return this.createNull(layer);
            case 4:
              return this.createShape(layer);
            case 5:
              return this.createText(layer);
            case 6:
              return this.createAudio(layer);
            case 13:
              return this.createCamera(layer);
            case 15:
              return this.createFootage(layer);
            default:
              return this.createNull(layer);
          }
        };
        BaseRenderer.prototype.createCamera = function() {
          throw new Error("You're using a 3d camera. Try the html renderer.");
        };
        BaseRenderer.prototype.createAudio = function(data) {
          return new AudioElement(data, this.globalData, this);
        };
        BaseRenderer.prototype.createFootage = function(data) {
          return new FootageElement(data, this.globalData, this);
        };
        BaseRenderer.prototype.buildAllItems = function() {
          var i2;
          var len = this.layers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.buildItem(i2);
          }
          this.checkPendingElements();
        };
        BaseRenderer.prototype.includeLayers = function(newLayers) {
          this.completeLayers = false;
          var i2;
          var len = newLayers.length;
          var j3;
          var jLen = this.layers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            j3 = 0;
            while (j3 < jLen) {
              if (this.layers[j3].id === newLayers[i2].id) {
                this.layers[j3] = newLayers[i2];
                break;
              }
              j3 += 1;
            }
          }
        };
        BaseRenderer.prototype.setProjectInterface = function(pInterface) {
          this.globalData.projectInterface = pInterface;
        };
        BaseRenderer.prototype.initItems = function() {
          if (!this.globalData.progressiveLoad) {
            this.buildAllItems();
          }
        };
        BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {
          var elements = this.elements;
          var layers = this.layers;
          var i2 = 0;
          var len = layers.length;
          while (i2 < len) {
            if (layers[i2].ind == parentName) {
              if (!elements[i2] || elements[i2] === true) {
                this.buildItem(i2);
                this.addPendingElement(element);
              } else {
                hierarchy.push(elements[i2]);
                elements[i2].setAsParent();
                if (layers[i2].parent !== void 0) {
                  this.buildElementParenting(element, layers[i2].parent, hierarchy);
                } else {
                  element.setHierarchy(hierarchy);
                }
              }
            }
            i2 += 1;
          }
        };
        BaseRenderer.prototype.addPendingElement = function(element) {
          this.pendingElements.push(element);
        };
        BaseRenderer.prototype.searchExtraCompositions = function(assets) {
          var i2;
          var len = assets.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (assets[i2].xt) {
              var comp = this.createComp(assets[i2]);
              comp.initExpressions();
              this.globalData.projectInterface.registerComposition(comp);
            }
          }
        };
        BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {
          this.globalData.fontManager = new FontManager();
          this.globalData.fontManager.addChars(animData.chars);
          this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);
          this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);
          this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);
          this.globalData.imageLoader = this.animationItem.imagePreloader;
          this.globalData.audioController = this.animationItem.audioController;
          this.globalData.frameId = 0;
          this.globalData.frameRate = animData.fr;
          this.globalData.nm = animData.nm;
          this.globalData.compSize = {
            w: animData.w,
            h: animData.h
          };
        };
        function SVGRenderer(animationItem, config) {
          this.animationItem = animationItem;
          this.layers = null;
          this.renderedFrame = -1;
          this.svgElement = createNS("svg");
          var ariaLabel = "";
          if (config && config.title) {
            var titleElement = createNS("title");
            var titleId = createElementID();
            titleElement.setAttribute("id", titleId);
            titleElement.textContent = config.title;
            this.svgElement.appendChild(titleElement);
            ariaLabel += titleId;
          }
          if (config && config.description) {
            var descElement = createNS("desc");
            var descId = createElementID();
            descElement.setAttribute("id", descId);
            descElement.textContent = config.description;
            this.svgElement.appendChild(descElement);
            ariaLabel += " " + descId;
          }
          if (ariaLabel) {
            this.svgElement.setAttribute("aria-labelledby", ariaLabel);
          }
          var defs = createNS("defs");
          this.svgElement.appendChild(defs);
          var maskElement = createNS("g");
          this.svgElement.appendChild(maskElement);
          this.layerElement = maskElement;
          this.renderConfig = {
            preserveAspectRatio: config && config.preserveAspectRatio || "xMidYMid meet",
            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || "xMidYMid slice",
            contentVisibility: config && config.contentVisibility || "visible",
            progressiveLoad: config && config.progressiveLoad || false,
            hideOnTransparent: !(config && config.hideOnTransparent === false),
            viewBoxOnly: config && config.viewBoxOnly || false,
            viewBoxSize: config && config.viewBoxSize || false,
            className: config && config.className || "",
            id: config && config.id || "",
            focusable: config && config.focusable,
            filterSize: {
              width: config && config.filterSize && config.filterSize.width || "100%",
              height: config && config.filterSize && config.filterSize.height || "100%",
              x: config && config.filterSize && config.filterSize.x || "0%",
              y: config && config.filterSize && config.filterSize.y || "0%"
            }
          };
          this.globalData = {
            _mdf: false,
            frameNum: -1,
            defs,
            renderConfig: this.renderConfig
          };
          this.elements = [];
          this.pendingElements = [];
          this.destroyed = false;
          this.rendererType = "svg";
        }
        extendPrototype([BaseRenderer], SVGRenderer);
        SVGRenderer.prototype.createNull = function(data) {
          return new NullElement(data, this.globalData, this);
        };
        SVGRenderer.prototype.createShape = function(data) {
          return new SVGShapeElement(data, this.globalData, this);
        };
        SVGRenderer.prototype.createText = function(data) {
          return new SVGTextLottieElement(data, this.globalData, this);
        };
        SVGRenderer.prototype.createImage = function(data) {
          return new IImageElement(data, this.globalData, this);
        };
        SVGRenderer.prototype.createComp = function(data) {
          return new SVGCompElement(data, this.globalData, this);
        };
        SVGRenderer.prototype.createSolid = function(data) {
          return new ISolidElement(data, this.globalData, this);
        };
        SVGRenderer.prototype.configAnimation = function(animData) {
          this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
          if (this.renderConfig.viewBoxSize) {
            this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize);
          } else {
            this.svgElement.setAttribute("viewBox", "0 0 " + animData.w + " " + animData.h);
          }
          if (!this.renderConfig.viewBoxOnly) {
            this.svgElement.setAttribute("width", animData.w);
            this.svgElement.setAttribute("height", animData.h);
            this.svgElement.style.width = "100%";
            this.svgElement.style.height = "100%";
            this.svgElement.style.transform = "translate3d(0,0,0)";
            this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;
          }
          if (this.renderConfig.className) {
            this.svgElement.setAttribute("class", this.renderConfig.className);
          }
          if (this.renderConfig.id) {
            this.svgElement.setAttribute("id", this.renderConfig.id);
          }
          if (this.renderConfig.focusable !== void 0) {
            this.svgElement.setAttribute("focusable", this.renderConfig.focusable);
          }
          this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio);
          this.animationItem.wrapper.appendChild(this.svgElement);
          var defs = this.globalData.defs;
          this.setupGlobalData(animData, defs);
          this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;
          this.data = animData;
          var maskElement = createNS("clipPath");
          var rect = createNS("rect");
          rect.setAttribute("width", animData.w);
          rect.setAttribute("height", animData.h);
          rect.setAttribute("x", 0);
          rect.setAttribute("y", 0);
          var maskId = createElementID();
          maskElement.setAttribute("id", maskId);
          maskElement.appendChild(rect);
          this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + maskId + ")");
          defs.appendChild(maskElement);
          this.layers = animData.layers;
          this.elements = createSizedArray(animData.layers.length);
        };
        SVGRenderer.prototype.destroy = function() {
          if (this.animationItem.wrapper) {
            this.animationItem.wrapper.innerText = "";
          }
          this.layerElement = null;
          this.globalData.defs = null;
          var i2;
          var len = this.layers ? this.layers.length : 0;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.elements[i2]) {
              this.elements[i2].destroy();
            }
          }
          this.elements.length = 0;
          this.destroyed = true;
          this.animationItem = null;
        };
        SVGRenderer.prototype.updateContainerSize = function() {
        };
        SVGRenderer.prototype.buildItem = function(pos) {
          var elements = this.elements;
          if (elements[pos] || this.layers[pos].ty === 99) {
            return;
          }
          elements[pos] = true;
          var element = this.createItem(this.layers[pos]);
          elements[pos] = element;
          if (expressionsPlugin) {
            if (this.layers[pos].ty === 0) {
              this.globalData.projectInterface.registerComposition(element);
            }
            element.initExpressions();
          }
          this.appendElementInPos(element, pos);
          if (this.layers[pos].tt) {
            if (!this.elements[pos - 1] || this.elements[pos - 1] === true) {
              this.buildItem(pos - 1);
              this.addPendingElement(element);
            } else {
              element.setMatte(elements[pos - 1].layerId);
            }
          }
        };
        SVGRenderer.prototype.checkPendingElements = function() {
          while (this.pendingElements.length) {
            var element = this.pendingElements.pop();
            element.checkParenting();
            if (element.data.tt) {
              var i2 = 0;
              var len = this.elements.length;
              while (i2 < len) {
                if (this.elements[i2] === element) {
                  element.setMatte(this.elements[i2 - 1].layerId);
                  break;
                }
                i2 += 1;
              }
            }
          }
        };
        SVGRenderer.prototype.renderFrame = function(num) {
          if (this.renderedFrame === num || this.destroyed) {
            return;
          }
          if (num === null) {
            num = this.renderedFrame;
          } else {
            this.renderedFrame = num;
          }
          this.globalData.frameNum = num;
          this.globalData.frameId += 1;
          this.globalData.projectInterface.currentFrame = num;
          this.globalData._mdf = false;
          var i2;
          var len = this.layers.length;
          if (!this.completeLayers) {
            this.checkLayers(num);
          }
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].prepareFrame(num - this.layers[i2].st);
            }
          }
          if (this.globalData._mdf) {
            for (i2 = 0; i2 < len; i2 += 1) {
              if (this.completeLayers || this.elements[i2]) {
                this.elements[i2].renderFrame();
              }
            }
          }
        };
        SVGRenderer.prototype.appendElementInPos = function(element, pos) {
          var newElement = element.getBaseElement();
          if (!newElement) {
            return;
          }
          var i2 = 0;
          var nextElement;
          while (i2 < pos) {
            if (this.elements[i2] && this.elements[i2] !== true && this.elements[i2].getBaseElement()) {
              nextElement = this.elements[i2].getBaseElement();
            }
            i2 += 1;
          }
          if (nextElement) {
            this.layerElement.insertBefore(newElement, nextElement);
          } else {
            this.layerElement.appendChild(newElement);
          }
        };
        SVGRenderer.prototype.hide = function() {
          this.layerElement.style.display = "none";
        };
        SVGRenderer.prototype.show = function() {
          this.layerElement.style.display = "block";
        };
        function MaskElement(data, element, globalData) {
          this.data = data;
          this.element = element;
          this.globalData = globalData;
          this.storedData = [];
          this.masksProperties = this.data.masksProperties || [];
          this.maskElement = null;
          var defs = this.globalData.defs;
          var i2;
          var len = this.masksProperties ? this.masksProperties.length : 0;
          this.viewData = createSizedArray(len);
          this.solidPath = "";
          var path;
          var properties = this.masksProperties;
          var count = 0;
          var currentMasks = [];
          var j3;
          var jLen;
          var layerId = createElementID();
          var rect;
          var expansor;
          var feMorph;
          var x3;
          var maskType = "clipPath";
          var maskRef = "clip-path";
          for (i2 = 0; i2 < len; i2 += 1) {
            if (properties[i2].mode !== "a" && properties[i2].mode !== "n" || properties[i2].inv || properties[i2].o.k !== 100 || properties[i2].o.x) {
              maskType = "mask";
              maskRef = "mask";
            }
            if ((properties[i2].mode === "s" || properties[i2].mode === "i") && count === 0) {
              rect = createNS("rect");
              rect.setAttribute("fill", "#ffffff");
              rect.setAttribute("width", this.element.comp.data.w || 0);
              rect.setAttribute("height", this.element.comp.data.h || 0);
              currentMasks.push(rect);
            } else {
              rect = null;
            }
            path = createNS("path");
            if (properties[i2].mode === "n") {
              this.viewData[i2] = {
                op: PropertyFactory.getProp(this.element, properties[i2].o, 0, 0.01, this.element),
                prop: ShapePropertyFactory.getShapeProp(this.element, properties[i2], 3),
                elem: path,
                lastPath: ""
              };
              defs.appendChild(path);
            } else {
              count += 1;
              path.setAttribute("fill", properties[i2].mode === "s" ? "#000000" : "#ffffff");
              path.setAttribute("clip-rule", "nonzero");
              var filterID;
              if (properties[i2].x.k !== 0) {
                maskType = "mask";
                maskRef = "mask";
                x3 = PropertyFactory.getProp(this.element, properties[i2].x, 0, null, this.element);
                filterID = createElementID();
                expansor = createNS("filter");
                expansor.setAttribute("id", filterID);
                feMorph = createNS("feMorphology");
                feMorph.setAttribute("operator", "erode");
                feMorph.setAttribute("in", "SourceGraphic");
                feMorph.setAttribute("radius", "0");
                expansor.appendChild(feMorph);
                defs.appendChild(expansor);
                path.setAttribute("stroke", properties[i2].mode === "s" ? "#000000" : "#ffffff");
              } else {
                feMorph = null;
                x3 = null;
              }
              this.storedData[i2] = {
                elem: path,
                x: x3,
                expan: feMorph,
                lastPath: "",
                lastOperator: "",
                filterId: filterID,
                lastRadius: 0
              };
              if (properties[i2].mode === "i") {
                jLen = currentMasks.length;
                var g3 = createNS("g");
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  g3.appendChild(currentMasks[j3]);
                }
                var mask = createNS("mask");
                mask.setAttribute("mask-type", "alpha");
                mask.setAttribute("id", layerId + "_" + count);
                mask.appendChild(path);
                defs.appendChild(mask);
                g3.setAttribute("mask", "url(" + locationHref + "#" + layerId + "_" + count + ")");
                currentMasks.length = 0;
                currentMasks.push(g3);
              } else {
                currentMasks.push(path);
              }
              if (properties[i2].inv && !this.solidPath) {
                this.solidPath = this.createLayerSolidPath();
              }
              this.viewData[i2] = {
                elem: path,
                lastPath: "",
                op: PropertyFactory.getProp(this.element, properties[i2].o, 0, 0.01, this.element),
                prop: ShapePropertyFactory.getShapeProp(this.element, properties[i2], 3),
                invRect: rect
              };
              if (!this.viewData[i2].prop.k) {
                this.drawPath(properties[i2], this.viewData[i2].prop.v, this.viewData[i2]);
              }
            }
          }
          this.maskElement = createNS(maskType);
          len = currentMasks.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.maskElement.appendChild(currentMasks[i2]);
          }
          if (count > 0) {
            this.maskElement.setAttribute("id", layerId);
            this.element.maskedElement.setAttribute(maskRef, "url(" + locationHref + "#" + layerId + ")");
            defs.appendChild(this.maskElement);
          }
          if (this.viewData.length) {
            this.element.addRenderableComponent(this);
          }
        }
        MaskElement.prototype.getMaskProperty = function(pos) {
          return this.viewData[pos].prop;
        };
        MaskElement.prototype.renderFrame = function(isFirstFrame) {
          var finalMat = this.element.finalTransform.mat;
          var i2;
          var len = this.masksProperties.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.viewData[i2].prop._mdf || isFirstFrame) {
              this.drawPath(this.masksProperties[i2], this.viewData[i2].prop.v, this.viewData[i2]);
            }
            if (this.viewData[i2].op._mdf || isFirstFrame) {
              this.viewData[i2].elem.setAttribute("fill-opacity", this.viewData[i2].op.v);
            }
            if (this.masksProperties[i2].mode !== "n") {
              if (this.viewData[i2].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {
                this.viewData[i2].invRect.setAttribute("transform", finalMat.getInverseMatrix().to2dCSS());
              }
              if (this.storedData[i2].x && (this.storedData[i2].x._mdf || isFirstFrame)) {
                var feMorph = this.storedData[i2].expan;
                if (this.storedData[i2].x.v < 0) {
                  if (this.storedData[i2].lastOperator !== "erode") {
                    this.storedData[i2].lastOperator = "erode";
                    this.storedData[i2].elem.setAttribute("filter", "url(" + locationHref + "#" + this.storedData[i2].filterId + ")");
                  }
                  feMorph.setAttribute("radius", -this.storedData[i2].x.v);
                } else {
                  if (this.storedData[i2].lastOperator !== "dilate") {
                    this.storedData[i2].lastOperator = "dilate";
                    this.storedData[i2].elem.setAttribute("filter", null);
                  }
                  this.storedData[i2].elem.setAttribute("stroke-width", this.storedData[i2].x.v * 2);
                }
              }
            }
          }
        };
        MaskElement.prototype.getMaskelement = function() {
          return this.maskElement;
        };
        MaskElement.prototype.createLayerSolidPath = function() {
          var path = "M0,0 ";
          path += " h" + this.globalData.compSize.w;
          path += " v" + this.globalData.compSize.h;
          path += " h-" + this.globalData.compSize.w;
          path += " v-" + this.globalData.compSize.h + " ";
          return path;
        };
        MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {
          var pathString = " M" + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
          var i2;
          var len;
          len = pathNodes._length;
          for (i2 = 1; i2 < len; i2 += 1) {
            pathString += " C" + pathNodes.o[i2 - 1][0] + "," + pathNodes.o[i2 - 1][1] + " " + pathNodes.i[i2][0] + "," + pathNodes.i[i2][1] + " " + pathNodes.v[i2][0] + "," + pathNodes.v[i2][1];
          }
          if (pathNodes.c && len > 1) {
            pathString += " C" + pathNodes.o[i2 - 1][0] + "," + pathNodes.o[i2 - 1][1] + " " + pathNodes.i[0][0] + "," + pathNodes.i[0][1] + " " + pathNodes.v[0][0] + "," + pathNodes.v[0][1];
          }
          if (viewData.lastPath !== pathString) {
            var pathShapeValue = "";
            if (viewData.elem) {
              if (pathNodes.c) {
                pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;
              }
              viewData.elem.setAttribute("d", pathShapeValue);
            }
            viewData.lastPath = pathString;
          }
        };
        MaskElement.prototype.destroy = function() {
          this.element = null;
          this.globalData = null;
          this.maskElement = null;
          this.data = null;
          this.masksProperties = null;
        };
        function HierarchyElement() {
        }
        HierarchyElement.prototype = {
          /**
             * @function
             * Initializes hierarchy properties
             *
             */
          initHierarchy: function() {
            this.hierarchy = [];
            this._isParent = false;
            this.checkParenting();
          },
          /**
             * @function
             * Sets layer's hierarchy.
             * @param {array} hierarch
             * layer's parent list
             *
             */
          setHierarchy: function(hierarchy) {
            this.hierarchy = hierarchy;
          },
          /**
             * @function
             * Sets layer as parent.
             *
             */
          setAsParent: function() {
            this._isParent = true;
          },
          /**
             * @function
             * Searches layer's parenting chain
             *
             */
          checkParenting: function() {
            if (this.data.parent !== void 0) {
              this.comp.buildElementParenting(this, this.data.parent, []);
            }
          }
        };
        function FrameElement() {
        }
        FrameElement.prototype = {
          /**
             * @function
             * Initializes frame related properties.
             *
             */
          initFrame: function() {
            this._isFirstFrame = false;
            this.dynamicProperties = [];
            this._mdf = false;
          },
          /**
             * @function
             * Calculates all dynamic values
             *
             * @param {number} num
             * current frame number in Layer's time
             * @param {boolean} isVisible
             * if layers is currently in range
             *
             */
          prepareProperties: function(num, isVisible) {
            var i2;
            var len = this.dynamicProperties.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (isVisible || this._isParent && this.dynamicProperties[i2].propType === "transform") {
                this.dynamicProperties[i2].getValue();
                if (this.dynamicProperties[i2]._mdf) {
                  this.globalData._mdf = true;
                  this._mdf = true;
                }
              }
            }
          },
          addDynamicProperty: function(prop) {
            if (this.dynamicProperties.indexOf(prop) === -1) {
              this.dynamicProperties.push(prop);
            }
          }
        };
        function TransformElement() {
        }
        TransformElement.prototype = {
          initTransform: function() {
            this.finalTransform = {
              mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : { o: 0 },
              _matMdf: false,
              _opMdf: false,
              mat: new Matrix()
            };
            if (this.data.ao) {
              this.finalTransform.mProp.autoOriented = true;
            }
            if (this.data.ty !== 11) {
            }
          },
          renderTransform: function() {
            this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;
            this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;
            if (this.hierarchy) {
              var mat;
              var finalMat = this.finalTransform.mat;
              var i2 = 0;
              var len = this.hierarchy.length;
              if (!this.finalTransform._matMdf) {
                while (i2 < len) {
                  if (this.hierarchy[i2].finalTransform.mProp._mdf) {
                    this.finalTransform._matMdf = true;
                    break;
                  }
                  i2 += 1;
                }
              }
              if (this.finalTransform._matMdf) {
                mat = this.finalTransform.mProp.v.props;
                finalMat.cloneFromProps(mat);
                for (i2 = 0; i2 < len; i2 += 1) {
                  mat = this.hierarchy[i2].finalTransform.mProp.v.props;
                  finalMat.transform(mat[0], mat[1], mat[2], mat[3], mat[4], mat[5], mat[6], mat[7], mat[8], mat[9], mat[10], mat[11], mat[12], mat[13], mat[14], mat[15]);
                }
              }
            }
          },
          globalToLocal: function(pt2) {
            var transforms = [];
            transforms.push(this.finalTransform);
            var flag = true;
            var comp = this.comp;
            while (flag) {
              if (comp.finalTransform) {
                if (comp.data.hasMask) {
                  transforms.splice(0, 0, comp.finalTransform);
                }
                comp = comp.comp;
              } else {
                flag = false;
              }
            }
            var i2;
            var len = transforms.length;
            var ptNew;
            for (i2 = 0; i2 < len; i2 += 1) {
              ptNew = transforms[i2].mat.applyToPointArray(0, 0, 0);
              pt2 = [pt2[0] - ptNew[0], pt2[1] - ptNew[1], 0];
            }
            return pt2;
          },
          mHelper: new Matrix()
        };
        function RenderableElement() {
        }
        RenderableElement.prototype = {
          initRenderable: function() {
            this.isInRange = false;
            this.hidden = false;
            this.isTransparent = false;
            this.renderableComponents = [];
          },
          addRenderableComponent: function(component) {
            if (this.renderableComponents.indexOf(component) === -1) {
              this.renderableComponents.push(component);
            }
          },
          removeRenderableComponent: function(component) {
            if (this.renderableComponents.indexOf(component) !== -1) {
              this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);
            }
          },
          prepareRenderableFrame: function(num) {
            this.checkLayerLimits(num);
          },
          checkTransparency: function() {
            if (this.finalTransform.mProp.o.v <= 0) {
              if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {
                this.isTransparent = true;
                this.hide();
              }
            } else if (this.isTransparent) {
              this.isTransparent = false;
              this.show();
            }
          },
          /**
             * @function
             * Initializes frame related properties.
             *
             * @param {number} num
             * current frame number in Layer's time
             *
             */
          checkLayerLimits: function(num) {
            if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {
              if (this.isInRange !== true) {
                this.globalData._mdf = true;
                this._mdf = true;
                this.isInRange = true;
                this.show();
              }
            } else if (this.isInRange !== false) {
              this.globalData._mdf = true;
              this.isInRange = false;
              this.hide();
            }
          },
          renderRenderable: function() {
            var i2;
            var len = this.renderableComponents.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.renderableComponents[i2].renderFrame(this._isFirstFrame);
            }
          },
          sourceRectAtTime: function() {
            return {
              top: 0,
              left: 0,
              width: 100,
              height: 100
            };
          },
          getLayerSize: function() {
            if (this.data.ty === 5) {
              return { w: this.data.textData.width, h: this.data.textData.height };
            }
            return { w: this.data.width, h: this.data.height };
          }
        };
        function RenderableDOMElement() {
        }
        (function() {
          var _prototype = {
            initElement: function(data, globalData, comp) {
              this.initFrame();
              this.initBaseData(data, globalData, comp);
              this.initTransform(data, globalData, comp);
              this.initHierarchy();
              this.initRenderable();
              this.initRendererElement();
              this.createContainerElements();
              this.createRenderableComponents();
              this.createContent();
              this.hide();
            },
            hide: function() {
              if (!this.hidden && (!this.isInRange || this.isTransparent)) {
                var elem = this.baseElement || this.layerElement;
                elem.style.display = "none";
                this.hidden = true;
              }
            },
            show: function() {
              if (this.isInRange && !this.isTransparent) {
                if (!this.data.hd) {
                  var elem = this.baseElement || this.layerElement;
                  elem.style.display = "block";
                }
                this.hidden = false;
                this._isFirstFrame = true;
              }
            },
            renderFrame: function() {
              if (this.data.hd || this.hidden) {
                return;
              }
              this.renderTransform();
              this.renderRenderable();
              this.renderElement();
              this.renderInnerContent();
              if (this._isFirstFrame) {
                this._isFirstFrame = false;
              }
            },
            renderInnerContent: function() {
            },
            prepareFrame: function(num) {
              this._mdf = false;
              this.prepareRenderableFrame(num);
              this.prepareProperties(num, this.isInRange);
              this.checkTransparency();
            },
            destroy: function() {
              this.innerElem = null;
              this.destroyBaseElement();
            }
          };
          extendPrototype([RenderableElement, createProxyFunction(_prototype)], RenderableDOMElement);
        })();
        function ProcessedElement(element, position) {
          this.elem = element;
          this.pos = position;
        }
        function SVGStyleData(data, level) {
          this.data = data;
          this.type = data.ty;
          this.d = "";
          this.lvl = level;
          this._mdf = false;
          this.closed = data.hd === true;
          this.pElem = createNS("path");
          this.msElem = null;
        }
        SVGStyleData.prototype.reset = function() {
          this.d = "";
          this._mdf = false;
        };
        function SVGShapeData(transformers, level, shape) {
          this.caches = [];
          this.styles = [];
          this.transformers = transformers;
          this.lStr = "";
          this.sh = shape;
          this.lvl = level;
          this._isAnimated = !!shape.k;
          var i2 = 0;
          var len = transformers.length;
          while (i2 < len) {
            if (transformers[i2].mProps.dynamicProperties.length) {
              this._isAnimated = true;
              break;
            }
            i2 += 1;
          }
        }
        SVGShapeData.prototype.setAsAnimated = function() {
          this._isAnimated = true;
        };
        function SVGTransformData(mProps, op, container) {
          this.transform = {
            mProps,
            op,
            container
          };
          this.elements = [];
          this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
        }
        function SVGStrokeStyleData(elem, data, styleOb) {
          this.initDynamicPropertyContainer(elem);
          this.getValue = this.iterateDynamicProperties;
          this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
          this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
          this.d = new DashProperty(elem, data.d || {}, "svg", this);
          this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
          this.style = styleOb;
          this._isAnimated = !!this._isAnimated;
        }
        extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
        function SVGFillStyleData(elem, data, styleOb) {
          this.initDynamicPropertyContainer(elem);
          this.getValue = this.iterateDynamicProperties;
          this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
          this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);
          this.style = styleOb;
        }
        extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
        function SVGGradientFillStyleData(elem, data, styleOb) {
          this.initDynamicPropertyContainer(elem);
          this.getValue = this.iterateDynamicProperties;
          this.initGradientData(elem, data, styleOb);
        }
        SVGGradientFillStyleData.prototype.initGradientData = function(elem, data, styleOb) {
          this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);
          this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);
          this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);
          this.h = PropertyFactory.getProp(elem, data.h || { k: 0 }, 0, 0.01, this);
          this.a = PropertyFactory.getProp(elem, data.a || { k: 0 }, 0, degToRads, this);
          this.g = new GradientProperty(elem, data.g, this);
          this.style = styleOb;
          this.stops = [];
          this.setGradientData(styleOb.pElem, data);
          this.setGradientOpacity(data, styleOb);
          this._isAnimated = !!this._isAnimated;
        };
        SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data) {
          var gradientId = createElementID();
          var gfill = createNS(data.t === 1 ? "linearGradient" : "radialGradient");
          gfill.setAttribute("id", gradientId);
          gfill.setAttribute("spreadMethod", "pad");
          gfill.setAttribute("gradientUnits", "userSpaceOnUse");
          var stops = [];
          var stop;
          var j3;
          var jLen;
          jLen = data.g.p * 4;
          for (j3 = 0; j3 < jLen; j3 += 4) {
            stop = createNS("stop");
            gfill.appendChild(stop);
            stops.push(stop);
          }
          pathElement.setAttribute(data.ty === "gf" ? "fill" : "stroke", "url(" + locationHref + "#" + gradientId + ")");
          this.gf = gfill;
          this.cst = stops;
        };
        SVGGradientFillStyleData.prototype.setGradientOpacity = function(data, styleOb) {
          if (this.g._hasOpacity && !this.g._collapsable) {
            var stop;
            var j3;
            var jLen;
            var mask = createNS("mask");
            var maskElement = createNS("path");
            mask.appendChild(maskElement);
            var opacityId = createElementID();
            var maskId = createElementID();
            mask.setAttribute("id", maskId);
            var opFill = createNS(data.t === 1 ? "linearGradient" : "radialGradient");
            opFill.setAttribute("id", opacityId);
            opFill.setAttribute("spreadMethod", "pad");
            opFill.setAttribute("gradientUnits", "userSpaceOnUse");
            jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;
            var stops = this.stops;
            for (j3 = data.g.p * 4; j3 < jLen; j3 += 2) {
              stop = createNS("stop");
              stop.setAttribute("stop-color", "rgb(255,255,255)");
              opFill.appendChild(stop);
              stops.push(stop);
            }
            maskElement.setAttribute(data.ty === "gf" ? "fill" : "stroke", "url(" + locationHref + "#" + opacityId + ")");
            if (data.ty === "gs") {
              maskElement.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]);
              maskElement.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]);
              if (data.lj === 1) {
                maskElement.setAttribute("stroke-miterlimit", data.ml);
              }
            }
            this.of = opFill;
            this.ms = mask;
            this.ost = stops;
            this.maskId = maskId;
            styleOb.msElem = maskElement;
          }
        };
        extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
        function SVGGradientStrokeStyleData(elem, data, styleOb) {
          this.initDynamicPropertyContainer(elem);
          this.getValue = this.iterateDynamicProperties;
          this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);
          this.d = new DashProperty(elem, data.d || {}, "svg", this);
          this.initGradientData(elem, data, styleOb);
          this._isAnimated = !!this._isAnimated;
        }
        extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
        function ShapeGroupData() {
          this.it = [];
          this.prevViewData = [];
          this.gr = createNS("g");
        }
        var SVGElementsRenderer = function() {
          var _identityMatrix = new Matrix();
          var _matrixHelper = new Matrix();
          var ob = {
            createRenderFunction
          };
          function createRenderFunction(data) {
            switch (data.ty) {
              case "fl":
                return renderFill;
              case "gf":
                return renderGradient;
              case "gs":
                return renderGradientStroke;
              case "st":
                return renderStroke;
              case "sh":
              case "el":
              case "rc":
              case "sr":
                return renderPath;
              case "tr":
                return renderContentTransform;
              default:
                return null;
            }
          }
          function renderContentTransform(styleData, itemData, isFirstFrame) {
            if (isFirstFrame || itemData.transform.op._mdf) {
              itemData.transform.container.setAttribute("opacity", itemData.transform.op.v);
            }
            if (isFirstFrame || itemData.transform.mProps._mdf) {
              itemData.transform.container.setAttribute("transform", itemData.transform.mProps.v.to2dCSS());
            }
          }
          function renderPath(styleData, itemData, isFirstFrame) {
            var j3;
            var jLen;
            var pathStringTransformed;
            var redraw;
            var pathNodes;
            var l2;
            var lLen = itemData.styles.length;
            var lvl = itemData.lvl;
            var paths;
            var mat;
            var props;
            var iterations;
            var k3;
            for (l2 = 0; l2 < lLen; l2 += 1) {
              redraw = itemData.sh._mdf || isFirstFrame;
              if (itemData.styles[l2].lvl < lvl) {
                mat = _matrixHelper.reset();
                iterations = lvl - itemData.styles[l2].lvl;
                k3 = itemData.transformers.length - 1;
                while (!redraw && iterations > 0) {
                  redraw = itemData.transformers[k3].mProps._mdf || redraw;
                  iterations -= 1;
                  k3 -= 1;
                }
                if (redraw) {
                  iterations = lvl - itemData.styles[l2].lvl;
                  k3 = itemData.transformers.length - 1;
                  while (iterations > 0) {
                    props = itemData.transformers[k3].mProps.v.props;
                    mat.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
                    iterations -= 1;
                    k3 -= 1;
                  }
                }
              } else {
                mat = _identityMatrix;
              }
              paths = itemData.sh.paths;
              jLen = paths._length;
              if (redraw) {
                pathStringTransformed = "";
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  pathNodes = paths.shapes[j3];
                  if (pathNodes && pathNodes._length) {
                    pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);
                  }
                }
                itemData.caches[l2] = pathStringTransformed;
              } else {
                pathStringTransformed = itemData.caches[l2];
              }
              itemData.styles[l2].d += styleData.hd === true ? "" : pathStringTransformed;
              itemData.styles[l2]._mdf = redraw || itemData.styles[l2]._mdf;
            }
          }
          function renderFill(styleData, itemData, isFirstFrame) {
            var styleElem = itemData.style;
            if (itemData.c._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("fill", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
            }
            if (itemData.o._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("fill-opacity", itemData.o.v);
            }
          }
          function renderGradientStroke(styleData, itemData, isFirstFrame) {
            renderGradient(styleData, itemData, isFirstFrame);
            renderStroke(styleData, itemData, isFirstFrame);
          }
          function renderGradient(styleData, itemData, isFirstFrame) {
            var gfill = itemData.gf;
            var hasOpacity = itemData.g._hasOpacity;
            var pt1 = itemData.s.v;
            var pt2 = itemData.e.v;
            if (itemData.o._mdf || isFirstFrame) {
              var attr = styleData.ty === "gf" ? "fill-opacity" : "stroke-opacity";
              itemData.style.pElem.setAttribute(attr, itemData.o.v);
            }
            if (itemData.s._mdf || isFirstFrame) {
              var attr1 = styleData.t === 1 ? "x1" : "cx";
              var attr2 = attr1 === "x1" ? "y1" : "cy";
              gfill.setAttribute(attr1, pt1[0]);
              gfill.setAttribute(attr2, pt1[1]);
              if (hasOpacity && !itemData.g._collapsable) {
                itemData.of.setAttribute(attr1, pt1[0]);
                itemData.of.setAttribute(attr2, pt1[1]);
              }
            }
            var stops;
            var i2;
            var len;
            var stop;
            if (itemData.g._cmdf || isFirstFrame) {
              stops = itemData.cst;
              var cValues = itemData.g.c;
              len = stops.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                stop = stops[i2];
                stop.setAttribute("offset", cValues[i2 * 4] + "%");
                stop.setAttribute("stop-color", "rgb(" + cValues[i2 * 4 + 1] + "," + cValues[i2 * 4 + 2] + "," + cValues[i2 * 4 + 3] + ")");
              }
            }
            if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {
              var oValues = itemData.g.o;
              if (itemData.g._collapsable) {
                stops = itemData.cst;
              } else {
                stops = itemData.ost;
              }
              len = stops.length;
              for (i2 = 0; i2 < len; i2 += 1) {
                stop = stops[i2];
                if (!itemData.g._collapsable) {
                  stop.setAttribute("offset", oValues[i2 * 2] + "%");
                }
                stop.setAttribute("stop-opacity", oValues[i2 * 2 + 1]);
              }
            }
            if (styleData.t === 1) {
              if (itemData.e._mdf || isFirstFrame) {
                gfill.setAttribute("x2", pt2[0]);
                gfill.setAttribute("y2", pt2[1]);
                if (hasOpacity && !itemData.g._collapsable) {
                  itemData.of.setAttribute("x2", pt2[0]);
                  itemData.of.setAttribute("y2", pt2[1]);
                }
              }
            } else {
              var rad;
              if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {
                rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                gfill.setAttribute("r", rad);
                if (hasOpacity && !itemData.g._collapsable) {
                  itemData.of.setAttribute("r", rad);
                }
              }
              if (itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {
                if (!rad) {
                  rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));
                }
                var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);
                var percent = itemData.h.v;
                if (percent >= 1) {
                  percent = 0.99;
                } else if (percent <= -1) {
                  percent = -0.99;
                }
                var dist = rad * percent;
                var x3 = Math.cos(ang + itemData.a.v) * dist + pt1[0];
                var y3 = Math.sin(ang + itemData.a.v) * dist + pt1[1];
                gfill.setAttribute("fx", x3);
                gfill.setAttribute("fy", y3);
                if (hasOpacity && !itemData.g._collapsable) {
                  itemData.of.setAttribute("fx", x3);
                  itemData.of.setAttribute("fy", y3);
                }
              }
            }
          }
          function renderStroke(styleData, itemData, isFirstFrame) {
            var styleElem = itemData.style;
            var d2 = itemData.d;
            if (d2 && (d2._mdf || isFirstFrame) && d2.dashStr) {
              styleElem.pElem.setAttribute("stroke-dasharray", d2.dashStr);
              styleElem.pElem.setAttribute("stroke-dashoffset", d2.dashoffset[0]);
            }
            if (itemData.c && (itemData.c._mdf || isFirstFrame)) {
              styleElem.pElem.setAttribute("stroke", "rgb(" + bmFloor(itemData.c.v[0]) + "," + bmFloor(itemData.c.v[1]) + "," + bmFloor(itemData.c.v[2]) + ")");
            }
            if (itemData.o._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("stroke-opacity", itemData.o.v);
            }
            if (itemData.w._mdf || isFirstFrame) {
              styleElem.pElem.setAttribute("stroke-width", itemData.w.v);
              if (styleElem.msElem) {
                styleElem.msElem.setAttribute("stroke-width", itemData.w.v);
              }
            }
          }
          return ob;
        }();
        function ShapeTransformManager() {
          this.sequences = {};
          this.sequenceList = [];
          this.transform_key_count = 0;
        }
        ShapeTransformManager.prototype = {
          addTransformSequence: function(transforms) {
            var i2;
            var len = transforms.length;
            var key = "_";
            for (i2 = 0; i2 < len; i2 += 1) {
              key += transforms[i2].transform.key + "_";
            }
            var sequence = this.sequences[key];
            if (!sequence) {
              sequence = {
                transforms: [].concat(transforms),
                finalTransform: new Matrix(),
                _mdf: false
              };
              this.sequences[key] = sequence;
              this.sequenceList.push(sequence);
            }
            return sequence;
          },
          processSequence: function(sequence, isFirstFrame) {
            var i2 = 0;
            var len = sequence.transforms.length;
            var _mdf = isFirstFrame;
            while (i2 < len && !isFirstFrame) {
              if (sequence.transforms[i2].transform.mProps._mdf) {
                _mdf = true;
                break;
              }
              i2 += 1;
            }
            if (_mdf) {
              var props;
              sequence.finalTransform.reset();
              for (i2 = len - 1; i2 >= 0; i2 -= 1) {
                props = sequence.transforms[i2].transform.mProps.v.props;
                sequence.finalTransform.transform(props[0], props[1], props[2], props[3], props[4], props[5], props[6], props[7], props[8], props[9], props[10], props[11], props[12], props[13], props[14], props[15]);
              }
            }
            sequence._mdf = _mdf;
          },
          processSequences: function(isFirstFrame) {
            var i2;
            var len = this.sequenceList.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.processSequence(this.sequenceList[i2], isFirstFrame);
            }
          },
          getNewKey: function() {
            this.transform_key_count += 1;
            return "_" + this.transform_key_count;
          }
        };
        function BaseElement() {
        }
        BaseElement.prototype = {
          checkMasks: function() {
            if (!this.data.hasMask) {
              return false;
            }
            var i2 = 0;
            var len = this.data.masksProperties.length;
            while (i2 < len) {
              if (this.data.masksProperties[i2].mode !== "n" && this.data.masksProperties[i2].cl !== false) {
                return true;
              }
              i2 += 1;
            }
            return false;
          },
          initExpressions: function() {
            this.layerInterface = LayerExpressionInterface(this);
            if (this.data.hasMask && this.maskManager) {
              this.layerInterface.registerMaskInterface(this.maskManager);
            }
            var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);
            this.layerInterface.registerEffectsInterface(effectsInterface);
            if (this.data.ty === 0 || this.data.xt) {
              this.compInterface = CompExpressionInterface(this);
            } else if (this.data.ty === 4) {
              this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);
              this.layerInterface.content = this.layerInterface.shapeInterface;
            } else if (this.data.ty === 5) {
              this.layerInterface.textInterface = TextExpressionInterface(this);
              this.layerInterface.text = this.layerInterface.textInterface;
            }
          },
          setBlendMode: function() {
            var blendModeValue = getBlendMode(this.data.bm);
            var elem = this.baseElement || this.layerElement;
            elem.style["mix-blend-mode"] = blendModeValue;
          },
          initBaseData: function(data, globalData, comp) {
            this.globalData = globalData;
            this.comp = comp;
            this.data = data;
            this.layerId = createElementID();
            if (!this.data.sr) {
              this.data.sr = 1;
            }
            this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
          },
          getType: function() {
            return this.type;
          },
          sourceRectAtTime: function() {
          }
        };
        function NullElement(data, globalData, comp) {
          this.initFrame();
          this.initBaseData(data, globalData, comp);
          this.initFrame();
          this.initTransform(data, globalData, comp);
          this.initHierarchy();
        }
        NullElement.prototype.prepareFrame = function(num) {
          this.prepareProperties(num, true);
        };
        NullElement.prototype.renderFrame = function() {
        };
        NullElement.prototype.getBaseElement = function() {
          return null;
        };
        NullElement.prototype.destroy = function() {
        };
        NullElement.prototype.sourceRectAtTime = function() {
        };
        NullElement.prototype.hide = function() {
        };
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
        function SVGBaseElement() {
        }
        SVGBaseElement.prototype = {
          initRendererElement: function() {
            this.layerElement = createNS("g");
          },
          createContainerElements: function() {
            this.matteElement = createNS("g");
            this.transformedElement = this.layerElement;
            this.maskedElement = this.layerElement;
            this._sizeChanged = false;
            var layerElementParent = null;
            var filId;
            var fil;
            var gg;
            if (this.data.td) {
              if (this.data.td == 3 || this.data.td == 1) {
                var masker = createNS("mask");
                masker.setAttribute("id", this.layerId);
                masker.setAttribute("mask-type", this.data.td == 3 ? "luminance" : "alpha");
                masker.appendChild(this.layerElement);
                layerElementParent = masker;
                this.globalData.defs.appendChild(masker);
                if (!featureSupport.maskType && this.data.td == 1) {
                  masker.setAttribute("mask-type", "luminance");
                  filId = createElementID();
                  fil = filtersFactory.createFilter(filId);
                  this.globalData.defs.appendChild(fil);
                  fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                  gg = createNS("g");
                  gg.appendChild(this.layerElement);
                  layerElementParent = gg;
                  masker.appendChild(gg);
                  gg.setAttribute("filter", "url(" + locationHref + "#" + filId + ")");
                }
              } else if (this.data.td == 2) {
                var maskGroup = createNS("mask");
                maskGroup.setAttribute("id", this.layerId);
                maskGroup.setAttribute("mask-type", "alpha");
                var maskGrouper = createNS("g");
                maskGroup.appendChild(maskGrouper);
                filId = createElementID();
                fil = filtersFactory.createFilter(filId);
                var feCTr = createNS("feComponentTransfer");
                feCTr.setAttribute("in", "SourceGraphic");
                fil.appendChild(feCTr);
                var feFunc = createNS("feFuncA");
                feFunc.setAttribute("type", "table");
                feFunc.setAttribute("tableValues", "1.0 0.0");
                feCTr.appendChild(feFunc);
                this.globalData.defs.appendChild(fil);
                var alphaRect = createNS("rect");
                alphaRect.setAttribute("width", this.comp.data.w);
                alphaRect.setAttribute("height", this.comp.data.h);
                alphaRect.setAttribute("x", "0");
                alphaRect.setAttribute("y", "0");
                alphaRect.setAttribute("fill", "#ffffff");
                alphaRect.setAttribute("opacity", "0");
                maskGrouper.setAttribute("filter", "url(" + locationHref + "#" + filId + ")");
                maskGrouper.appendChild(alphaRect);
                maskGrouper.appendChild(this.layerElement);
                layerElementParent = maskGrouper;
                if (!featureSupport.maskType) {
                  maskGroup.setAttribute("mask-type", "luminance");
                  fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());
                  gg = createNS("g");
                  maskGrouper.appendChild(alphaRect);
                  gg.appendChild(this.layerElement);
                  layerElementParent = gg;
                  maskGrouper.appendChild(gg);
                }
                this.globalData.defs.appendChild(maskGroup);
              }
            } else if (this.data.tt) {
              this.matteElement.appendChild(this.layerElement);
              layerElementParent = this.matteElement;
              this.baseElement = this.matteElement;
            } else {
              this.baseElement = this.layerElement;
            }
            if (this.data.ln) {
              this.layerElement.setAttribute("id", this.data.ln);
            }
            if (this.data.cl) {
              this.layerElement.setAttribute("class", this.data.cl);
            }
            if (this.data.ty === 0 && !this.data.hd) {
              var cp = createNS("clipPath");
              var pt2 = createNS("path");
              pt2.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
              var clipId = createElementID();
              cp.setAttribute("id", clipId);
              cp.appendChild(pt2);
              this.globalData.defs.appendChild(cp);
              if (this.checkMasks()) {
                var cpGroup = createNS("g");
                cpGroup.setAttribute("clip-path", "url(" + locationHref + "#" + clipId + ")");
                cpGroup.appendChild(this.layerElement);
                this.transformedElement = cpGroup;
                if (layerElementParent) {
                  layerElementParent.appendChild(this.transformedElement);
                } else {
                  this.baseElement = this.transformedElement;
                }
              } else {
                this.layerElement.setAttribute("clip-path", "url(" + locationHref + "#" + clipId + ")");
              }
            }
            if (this.data.bm !== 0) {
              this.setBlendMode();
            }
          },
          renderElement: function() {
            if (this.finalTransform._matMdf) {
              this.transformedElement.setAttribute("transform", this.finalTransform.mat.to2dCSS());
            }
            if (this.finalTransform._opMdf) {
              this.transformedElement.setAttribute("opacity", this.finalTransform.mProp.o.v);
            }
          },
          destroyBaseElement: function() {
            this.layerElement = null;
            this.matteElement = null;
            this.maskManager.destroy();
          },
          getBaseElement: function() {
            if (this.data.hd) {
              return null;
            }
            return this.baseElement;
          },
          createRenderableComponents: function() {
            this.maskManager = new MaskElement(this.data, this, this.globalData);
            this.renderableEffectsManager = new SVGEffects(this);
          },
          setMatte: function(id) {
            if (!this.matteElement) {
              return;
            }
            this.matteElement.setAttribute("mask", "url(" + locationHref + "#" + id + ")");
          }
        };
        function IShapeElement() {
        }
        IShapeElement.prototype = {
          addShapeToModifiers: function(data) {
            var i2;
            var len = this.shapeModifiers.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.shapeModifiers[i2].addShape(data);
            }
          },
          isShapeInAnimatedModifiers: function(data) {
            var i2 = 0;
            var len = this.shapeModifiers.length;
            while (i2 < len) {
              if (this.shapeModifiers[i2].isAnimatedWithShape(data)) {
                return true;
              }
            }
            return false;
          },
          renderModifiers: function() {
            if (!this.shapeModifiers.length) {
              return;
            }
            var i2;
            var len = this.shapes.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.shapes[i2].sh.reset();
            }
            len = this.shapeModifiers.length;
            var shouldBreakProcess;
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              shouldBreakProcess = this.shapeModifiers[i2].processShapes(this._isFirstFrame);
              if (shouldBreakProcess) {
                break;
              }
            }
          },
          searchProcessedElement: function(elem) {
            var elements = this.processedElements;
            var i2 = 0;
            var len = elements.length;
            while (i2 < len) {
              if (elements[i2].elem === elem) {
                return elements[i2].pos;
              }
              i2 += 1;
            }
            return 0;
          },
          addProcessedElement: function(elem, pos) {
            var elements = this.processedElements;
            var i2 = elements.length;
            while (i2) {
              i2 -= 1;
              if (elements[i2].elem === elem) {
                elements[i2].pos = pos;
                return;
              }
            }
            elements.push(new ProcessedElement(elem, pos));
          },
          prepareFrame: function(num) {
            this.prepareRenderableFrame(num);
            this.prepareProperties(num, this.isInRange);
          }
        };
        function ITextElement() {
        }
        ITextElement.prototype.initElement = function(data, globalData, comp) {
          this.lettersChangedFlag = true;
          this.initFrame();
          this.initBaseData(data, globalData, comp);
          this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);
          this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);
          this.initTransform(data, globalData, comp);
          this.initHierarchy();
          this.initRenderable();
          this.initRendererElement();
          this.createContainerElements();
          this.createRenderableComponents();
          this.createContent();
          this.hide();
          this.textAnimator.searchProperties(this.dynamicProperties);
        };
        ITextElement.prototype.prepareFrame = function(num) {
          this._mdf = false;
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
          if (this.textProperty._mdf || this.textProperty._isFirstFrame) {
            this.buildNewText();
            this.textProperty._isFirstFrame = false;
            this.textProperty._mdf = false;
          }
        };
        ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {
          var j3;
          var jLen = shapes.length;
          var pathNodes;
          var shapeStr = "";
          for (j3 = 0; j3 < jLen; j3 += 1) {
            pathNodes = shapes[j3].ks.k;
            shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);
          }
          return shapeStr;
        };
        ITextElement.prototype.updateDocumentData = function(newData, index2) {
          this.textProperty.updateDocumentData(newData, index2);
        };
        ITextElement.prototype.canResizeFont = function(_canResize) {
          this.textProperty.canResizeFont(_canResize);
        };
        ITextElement.prototype.setMinimumFontSize = function(_fontSize) {
          this.textProperty.setMinimumFontSize(_fontSize);
        };
        ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {
          if (documentData.ps) {
            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);
          }
          matrixHelper.translate(0, -documentData.ls, 0);
          switch (documentData.j) {
            case 1:
              matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);
              break;
            case 2:
              matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);
              break;
            default:
              break;
          }
          matrixHelper.translate(xPos, yPos, 0);
        };
        ITextElement.prototype.buildColor = function(colorData) {
          return "rgb(" + Math.round(colorData[0] * 255) + "," + Math.round(colorData[1] * 255) + "," + Math.round(colorData[2] * 255) + ")";
        };
        ITextElement.prototype.emptyProp = new LetterProps();
        ITextElement.prototype.destroy = function() {
        };
        function ICompElement() {
        }
        extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement);
        ICompElement.prototype.initElement = function(data, globalData, comp) {
          this.initFrame();
          this.initBaseData(data, globalData, comp);
          this.initTransform(data, globalData, comp);
          this.initRenderable();
          this.initHierarchy();
          this.initRendererElement();
          this.createContainerElements();
          this.createRenderableComponents();
          if (this.data.xt || !globalData.progressiveLoad) {
            this.buildAllItems();
          }
          this.hide();
        };
        ICompElement.prototype.prepareFrame = function(num) {
          this._mdf = false;
          this.prepareRenderableFrame(num);
          this.prepareProperties(num, this.isInRange);
          if (!this.isInRange && !this.data.xt) {
            return;
          }
          if (!this.tm._placeholder) {
            var timeRemapped = this.tm.v;
            if (timeRemapped === this.data.op) {
              timeRemapped = this.data.op - 1;
            }
            this.renderedFrame = timeRemapped;
          } else {
            this.renderedFrame = num / this.data.sr;
          }
          var i2;
          var len = this.elements.length;
          if (!this.completeLayers) {
            this.checkLayers(this.renderedFrame);
          }
          for (i2 = len - 1; i2 >= 0; i2 -= 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].prepareFrame(this.renderedFrame - this.layers[i2].st);
              if (this.elements[i2]._mdf) {
                this._mdf = true;
              }
            }
          }
        };
        ICompElement.prototype.renderInnerContent = function() {
          var i2;
          var len = this.layers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.completeLayers || this.elements[i2]) {
              this.elements[i2].renderFrame();
            }
          }
        };
        ICompElement.prototype.setElements = function(elems) {
          this.elements = elems;
        };
        ICompElement.prototype.getElements = function() {
          return this.elements;
        };
        ICompElement.prototype.destroyElements = function() {
          var i2;
          var len = this.layers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.elements[i2]) {
              this.elements[i2].destroy();
            }
          }
        };
        ICompElement.prototype.destroy = function() {
          this.destroyElements();
          this.destroyBaseElement();
        };
        function IImageElement(data, globalData, comp) {
          this.assetData = globalData.getAssetData(data.refId);
          this.initElement(data, globalData, comp);
          this.sourceRect = {
            top: 0,
            left: 0,
            width: this.assetData.w,
            height: this.assetData.h
          };
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement);
        IImageElement.prototype.createContent = function() {
          var assetPath = this.globalData.getAssetsPath(this.assetData);
          this.innerElem = createNS("image");
          this.innerElem.setAttribute("width", this.assetData.w + "px");
          this.innerElem.setAttribute("height", this.assetData.h + "px");
          this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);
          this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", assetPath);
          this.layerElement.appendChild(this.innerElem);
        };
        IImageElement.prototype.sourceRectAtTime = function() {
          return this.sourceRect;
        };
        function ISolidElement(data, globalData, comp) {
          this.initElement(data, globalData, comp);
        }
        extendPrototype([IImageElement], ISolidElement);
        ISolidElement.prototype.createContent = function() {
          var rect = createNS("rect");
          rect.setAttribute("width", this.data.sw);
          rect.setAttribute("height", this.data.sh);
          rect.setAttribute("fill", this.data.sc);
          this.layerElement.appendChild(rect);
        };
        function AudioElement(data, globalData, comp) {
          this.initFrame();
          this.initRenderable();
          this.assetData = globalData.getAssetData(data.refId);
          this.initBaseData(data, globalData, comp);
          this._isPlaying = false;
          this._canPlay = false;
          var assetPath = this.globalData.getAssetsPath(this.assetData);
          this.audio = this.globalData.audioController.createAudio(assetPath);
          this._currentTime = 0;
          this.globalData.audioController.addAudio(this);
          this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
        }
        AudioElement.prototype.prepareFrame = function(num) {
          this.prepareRenderableFrame(num, true);
          this.prepareProperties(num, true);
          if (!this.tm._placeholder) {
            var timeRemapped = this.tm.v;
            this._currentTime = timeRemapped;
          } else {
            this._currentTime = num / this.data.sr;
          }
        };
        extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement);
        AudioElement.prototype.renderFrame = function() {
          if (this.isInRange && this._canPlay) {
            if (!this._isPlaying) {
              this.audio.play();
              this.audio.seek(this._currentTime / this.globalData.frameRate);
              this._isPlaying = true;
            } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {
              this.audio.seek(this._currentTime / this.globalData.frameRate);
            }
          }
        };
        AudioElement.prototype.show = function() {
        };
        AudioElement.prototype.hide = function() {
          this.audio.pause();
          this._isPlaying = false;
        };
        AudioElement.prototype.pause = function() {
          this.audio.pause();
          this._isPlaying = false;
          this._canPlay = false;
        };
        AudioElement.prototype.resume = function() {
          this._canPlay = true;
        };
        AudioElement.prototype.setRate = function(rateValue) {
          this.audio.rate(rateValue);
        };
        AudioElement.prototype.volume = function(volumeValue) {
          this.audio.volume(volumeValue);
        };
        AudioElement.prototype.getBaseElement = function() {
          return null;
        };
        AudioElement.prototype.destroy = function() {
        };
        AudioElement.prototype.sourceRectAtTime = function() {
        };
        AudioElement.prototype.initExpressions = function() {
        };
        function SVGCompElement(data, globalData, comp) {
          this.layers = data.layers;
          this.supports3d = true;
          this.completeLayers = false;
          this.pendingElements = [];
          this.elements = this.layers ? createSizedArray(this.layers.length) : [];
          this.initElement(data, globalData, comp);
          this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : { _placeholder: true };
        }
        extendPrototype([SVGRenderer, ICompElement, SVGBaseElement], SVGCompElement);
        function SVGTextLottieElement(data, globalData, comp) {
          this.textSpans = [];
          this.renderType = "svg";
          this.initElement(data, globalData, comp);
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement);
        SVGTextLottieElement.prototype.createContent = function() {
          if (this.data.singleShape && !this.globalData.fontManager.chars) {
            this.textContainer = createNS("text");
          }
        };
        SVGTextLottieElement.prototype.buildTextContents = function(textArray) {
          var i2 = 0;
          var len = textArray.length;
          var textContents = [];
          var currentTextContent = "";
          while (i2 < len) {
            if (textArray[i2] === String.fromCharCode(13) || textArray[i2] === String.fromCharCode(3)) {
              textContents.push(currentTextContent);
              currentTextContent = "";
            } else {
              currentTextContent += textArray[i2];
            }
            i2 += 1;
          }
          textContents.push(currentTextContent);
          return textContents;
        };
        SVGTextLottieElement.prototype.buildNewText = function() {
          var i2;
          var len;
          var documentData = this.textProperty.currentData;
          this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);
          if (documentData.fc) {
            this.layerElement.setAttribute("fill", this.buildColor(documentData.fc));
          } else {
            this.layerElement.setAttribute("fill", "rgba(0,0,0,0)");
          }
          if (documentData.sc) {
            this.layerElement.setAttribute("stroke", this.buildColor(documentData.sc));
            this.layerElement.setAttribute("stroke-width", documentData.sw);
          }
          this.layerElement.setAttribute("font-size", documentData.finalSize);
          var fontData = this.globalData.fontManager.getFontByName(documentData.f);
          if (fontData.fClass) {
            this.layerElement.setAttribute("class", fontData.fClass);
          } else {
            this.layerElement.setAttribute("font-family", fontData.fFamily);
            var fWeight = documentData.fWeight;
            var fStyle = documentData.fStyle;
            this.layerElement.setAttribute("font-style", fStyle);
            this.layerElement.setAttribute("font-weight", fWeight);
          }
          this.layerElement.setAttribute("aria-label", documentData.t);
          var letters = documentData.l || [];
          var usesGlyphs = !!this.globalData.fontManager.chars;
          len = letters.length;
          var tSpan;
          var matrixHelper = this.mHelper;
          var shapes;
          var shapeStr = "";
          var singleShape = this.data.singleShape;
          var xPos = 0;
          var yPos = 0;
          var firstLine = true;
          var trackingOffset = documentData.tr * 1e-3 * documentData.finalSize;
          if (singleShape && !usesGlyphs && !documentData.sz) {
            var tElement = this.textContainer;
            var justify = "start";
            switch (documentData.j) {
              case 1:
                justify = "end";
                break;
              case 2:
                justify = "middle";
                break;
              default:
                justify = "start";
                break;
            }
            tElement.setAttribute("text-anchor", justify);
            tElement.setAttribute("letter-spacing", trackingOffset);
            var textContent = this.buildTextContents(documentData.finalText);
            len = textContent.length;
            yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;
            for (i2 = 0; i2 < len; i2 += 1) {
              tSpan = this.textSpans[i2] || createNS("tspan");
              tSpan.textContent = textContent[i2];
              tSpan.setAttribute("x", 0);
              tSpan.setAttribute("y", yPos);
              tSpan.style.display = "inherit";
              tElement.appendChild(tSpan);
              this.textSpans[i2] = tSpan;
              yPos += documentData.finalLineHeight;
            }
            this.layerElement.appendChild(tElement);
          } else {
            var cachedSpansLength = this.textSpans.length;
            var shapeData;
            var charData;
            for (i2 = 0; i2 < len; i2 += 1) {
              if (!usesGlyphs || !singleShape || i2 === 0) {
                tSpan = cachedSpansLength > i2 ? this.textSpans[i2] : createNS(usesGlyphs ? "path" : "text");
                if (cachedSpansLength <= i2) {
                  tSpan.setAttribute("stroke-linecap", "butt");
                  tSpan.setAttribute("stroke-linejoin", "round");
                  tSpan.setAttribute("stroke-miterlimit", "4");
                  this.textSpans[i2] = tSpan;
                  this.layerElement.appendChild(tSpan);
                }
                tSpan.style.display = "inherit";
              }
              matrixHelper.reset();
              matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);
              if (singleShape) {
                if (letters[i2].n) {
                  xPos = -trackingOffset;
                  yPos += documentData.yOffset;
                  yPos += firstLine ? 1 : 0;
                  firstLine = false;
                }
                this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i2].line, xPos, yPos);
                xPos += letters[i2].l || 0;
                xPos += trackingOffset;
              }
              if (usesGlyphs) {
                charData = this.globalData.fontManager.getCharData(documentData.finalText[i2], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);
                shapeData = charData && charData.data || {};
                shapes = shapeData.shapes ? shapeData.shapes[0].it : [];
                if (!singleShape) {
                  tSpan.setAttribute("d", this.createPathShape(matrixHelper, shapes));
                } else {
                  shapeStr += this.createPathShape(matrixHelper, shapes);
                }
              } else {
                if (singleShape) {
                  tSpan.setAttribute("transform", "translate(" + matrixHelper.props[12] + "," + matrixHelper.props[13] + ")");
                }
                tSpan.textContent = letters[i2].val;
                tSpan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
              }
            }
            if (singleShape && tSpan) {
              tSpan.setAttribute("d", shapeStr);
            }
          }
          while (i2 < this.textSpans.length) {
            this.textSpans[i2].style.display = "none";
            i2 += 1;
          }
          this._sizeChanged = true;
        };
        SVGTextLottieElement.prototype.sourceRectAtTime = function() {
          this.prepareFrame(this.comp.renderedFrame - this.data.st);
          this.renderInnerContent();
          if (this._sizeChanged) {
            this._sizeChanged = false;
            var textBox = this.layerElement.getBBox();
            this.bbox = {
              top: textBox.y,
              left: textBox.x,
              width: textBox.width,
              height: textBox.height
            };
          }
          return this.bbox;
        };
        SVGTextLottieElement.prototype.renderInnerContent = function() {
          if (!this.data.singleShape) {
            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
            if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {
              this._sizeChanged = true;
              var i2;
              var len;
              var renderedLetters = this.textAnimator.renderedLetters;
              var letters = this.textProperty.currentData.l;
              len = letters.length;
              var renderedLetter;
              var textSpan;
              for (i2 = 0; i2 < len; i2 += 1) {
                if (!letters[i2].n) {
                  renderedLetter = renderedLetters[i2];
                  textSpan = this.textSpans[i2];
                  if (renderedLetter._mdf.m) {
                    textSpan.setAttribute("transform", renderedLetter.m);
                  }
                  if (renderedLetter._mdf.o) {
                    textSpan.setAttribute("opacity", renderedLetter.o);
                  }
                  if (renderedLetter._mdf.sw) {
                    textSpan.setAttribute("stroke-width", renderedLetter.sw);
                  }
                  if (renderedLetter._mdf.sc) {
                    textSpan.setAttribute("stroke", renderedLetter.sc);
                  }
                  if (renderedLetter._mdf.fc) {
                    textSpan.setAttribute("fill", renderedLetter.fc);
                  }
                }
              }
            }
          }
        };
        function SVGShapeElement(data, globalData, comp) {
          this.shapes = [];
          this.shapesData = data.shapes;
          this.stylesList = [];
          this.shapeModifiers = [];
          this.itemsData = [];
          this.processedElements = [];
          this.animatedContents = [];
          this.initElement(data, globalData, comp);
          this.prevViewData = [];
        }
        extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement);
        SVGShapeElement.prototype.initSecondaryElement = function() {
        };
        SVGShapeElement.prototype.identityMatrix = new Matrix();
        SVGShapeElement.prototype.buildExpressionInterface = function() {
        };
        SVGShapeElement.prototype.createContent = function() {
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
          this.filterUniqueShapes();
        };
        SVGShapeElement.prototype.filterUniqueShapes = function() {
          var i2;
          var len = this.shapes.length;
          var shape;
          var j3;
          var jLen = this.stylesList.length;
          var style;
          var tempShapes = [];
          var areAnimated = false;
          for (j3 = 0; j3 < jLen; j3 += 1) {
            style = this.stylesList[j3];
            areAnimated = false;
            tempShapes.length = 0;
            for (i2 = 0; i2 < len; i2 += 1) {
              shape = this.shapes[i2];
              if (shape.styles.indexOf(style) !== -1) {
                tempShapes.push(shape);
                areAnimated = shape._isAnimated || areAnimated;
              }
            }
            if (tempShapes.length > 1 && areAnimated) {
              this.setShapesAsAnimated(tempShapes);
            }
          }
        };
        SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {
          var i2;
          var len = shapes.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            shapes[i2].setAsAnimated();
          }
        };
        SVGShapeElement.prototype.createStyleElement = function(data, level) {
          var elementData;
          var styleOb = new SVGStyleData(data, level);
          var pathElement = styleOb.pElem;
          if (data.ty === "st") {
            elementData = new SVGStrokeStyleData(this, data, styleOb);
          } else if (data.ty === "fl") {
            elementData = new SVGFillStyleData(this, data, styleOb);
          } else if (data.ty === "gf" || data.ty === "gs") {
            var GradientConstructor = data.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
            elementData = new GradientConstructor(this, data, styleOb);
            this.globalData.defs.appendChild(elementData.gf);
            if (elementData.maskId) {
              this.globalData.defs.appendChild(elementData.ms);
              this.globalData.defs.appendChild(elementData.of);
              pathElement.setAttribute("mask", "url(" + locationHref + "#" + elementData.maskId + ")");
            }
          }
          if (data.ty === "st" || data.ty === "gs") {
            pathElement.setAttribute("stroke-linecap", lineCapEnum[data.lc || 2]);
            pathElement.setAttribute("stroke-linejoin", lineJoinEnum[data.lj || 2]);
            pathElement.setAttribute("fill-opacity", "0");
            if (data.lj === 1) {
              pathElement.setAttribute("stroke-miterlimit", data.ml);
            }
          }
          if (data.r === 2) {
            pathElement.setAttribute("fill-rule", "evenodd");
          }
          if (data.ln) {
            pathElement.setAttribute("id", data.ln);
          }
          if (data.cl) {
            pathElement.setAttribute("class", data.cl);
          }
          if (data.bm) {
            pathElement.style["mix-blend-mode"] = getBlendMode(data.bm);
          }
          this.stylesList.push(styleOb);
          this.addToAnimatedContents(data, elementData);
          return elementData;
        };
        SVGShapeElement.prototype.createGroupElement = function(data) {
          var elementData = new ShapeGroupData();
          if (data.ln) {
            elementData.gr.setAttribute("id", data.ln);
          }
          if (data.cl) {
            elementData.gr.setAttribute("class", data.cl);
          }
          if (data.bm) {
            elementData.gr.style["mix-blend-mode"] = getBlendMode(data.bm);
          }
          return elementData;
        };
        SVGShapeElement.prototype.createTransformElement = function(data, container) {
          var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);
          var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);
          this.addToAnimatedContents(data, elementData);
          return elementData;
        };
        SVGShapeElement.prototype.createShapeElement = function(data, ownTransformers, level) {
          var ty = 4;
          if (data.ty === "rc") {
            ty = 5;
          } else if (data.ty === "el") {
            ty = 6;
          } else if (data.ty === "sr") {
            ty = 7;
          }
          var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);
          var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);
          this.shapes.push(elementData);
          this.addShapeToModifiers(elementData);
          this.addToAnimatedContents(data, elementData);
          return elementData;
        };
        SVGShapeElement.prototype.addToAnimatedContents = function(data, element) {
          var i2 = 0;
          var len = this.animatedContents.length;
          while (i2 < len) {
            if (this.animatedContents[i2].element === element) {
              return;
            }
            i2 += 1;
          }
          this.animatedContents.push({
            fn: SVGElementsRenderer.createRenderFunction(data),
            element,
            data
          });
        };
        SVGShapeElement.prototype.setElementStyles = function(elementData) {
          var arr = elementData.styles;
          var j3;
          var jLen = this.stylesList.length;
          for (j3 = 0; j3 < jLen; j3 += 1) {
            if (!this.stylesList[j3].closed) {
              arr.push(this.stylesList[j3]);
            }
          }
        };
        SVGShapeElement.prototype.reloadShapes = function() {
          this._isFirstFrame = true;
          var i2;
          var len = this.itemsData.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.prevViewData[i2] = this.itemsData[i2];
          }
          this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);
          this.filterUniqueShapes();
          len = this.dynamicProperties.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.dynamicProperties[i2].getValue();
          }
          this.renderModifiers();
        };
        SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render) {
          var ownTransformers = [].concat(transformers);
          var i2;
          var len = arr.length - 1;
          var j3;
          var jLen;
          var ownStyles = [];
          var ownModifiers = [];
          var currentTransform;
          var modifier;
          var processedPos;
          for (i2 = len; i2 >= 0; i2 -= 1) {
            processedPos = this.searchProcessedElement(arr[i2]);
            if (!processedPos) {
              arr[i2]._render = render;
            } else {
              itemsData[i2] = prevViewData[processedPos - 1];
            }
            if (arr[i2].ty === "fl" || arr[i2].ty === "st" || arr[i2].ty === "gf" || arr[i2].ty === "gs") {
              if (!processedPos) {
                itemsData[i2] = this.createStyleElement(arr[i2], level);
              } else {
                itemsData[i2].style.closed = false;
              }
              if (arr[i2]._render) {
                if (itemsData[i2].style.pElem.parentNode !== container) {
                  container.appendChild(itemsData[i2].style.pElem);
                }
              }
              ownStyles.push(itemsData[i2].style);
            } else if (arr[i2].ty === "gr") {
              if (!processedPos) {
                itemsData[i2] = this.createGroupElement(arr[i2]);
              } else {
                jLen = itemsData[i2].it.length;
                for (j3 = 0; j3 < jLen; j3 += 1) {
                  itemsData[i2].prevViewData[j3] = itemsData[i2].it[j3];
                }
              }
              this.searchShapes(arr[i2].it, itemsData[i2].it, itemsData[i2].prevViewData, itemsData[i2].gr, level + 1, ownTransformers, render);
              if (arr[i2]._render) {
                if (itemsData[i2].gr.parentNode !== container) {
                  container.appendChild(itemsData[i2].gr);
                }
              }
            } else if (arr[i2].ty === "tr") {
              if (!processedPos) {
                itemsData[i2] = this.createTransformElement(arr[i2], container);
              }
              currentTransform = itemsData[i2].transform;
              ownTransformers.push(currentTransform);
            } else if (arr[i2].ty === "sh" || arr[i2].ty === "rc" || arr[i2].ty === "el" || arr[i2].ty === "sr") {
              if (!processedPos) {
                itemsData[i2] = this.createShapeElement(arr[i2], ownTransformers, level);
              }
              this.setElementStyles(itemsData[i2]);
            } else if (arr[i2].ty === "tm" || arr[i2].ty === "rd" || arr[i2].ty === "ms" || arr[i2].ty === "pb") {
              if (!processedPos) {
                modifier = ShapeModifiers.getModifier(arr[i2].ty);
                modifier.init(this, arr[i2]);
                itemsData[i2] = modifier;
                this.shapeModifiers.push(modifier);
              } else {
                modifier = itemsData[i2];
                modifier.closed = false;
              }
              ownModifiers.push(modifier);
            } else if (arr[i2].ty === "rp") {
              if (!processedPos) {
                modifier = ShapeModifiers.getModifier(arr[i2].ty);
                itemsData[i2] = modifier;
                modifier.init(this, arr, i2, itemsData);
                this.shapeModifiers.push(modifier);
                render = false;
              } else {
                modifier = itemsData[i2];
                modifier.closed = true;
              }
              ownModifiers.push(modifier);
            }
            this.addProcessedElement(arr[i2], i2 + 1);
          }
          len = ownStyles.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            ownStyles[i2].closed = true;
          }
          len = ownModifiers.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            ownModifiers[i2].closed = true;
          }
        };
        SVGShapeElement.prototype.renderInnerContent = function() {
          this.renderModifiers();
          var i2;
          var len = this.stylesList.length;
          for (i2 = 0; i2 < len; i2 += 1) {
            this.stylesList[i2].reset();
          }
          this.renderShape();
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.stylesList[i2]._mdf || this._isFirstFrame) {
              if (this.stylesList[i2].msElem) {
                this.stylesList[i2].msElem.setAttribute("d", this.stylesList[i2].d);
                this.stylesList[i2].d = "M0 0" + this.stylesList[i2].d;
              }
              this.stylesList[i2].pElem.setAttribute("d", this.stylesList[i2].d || "M0 0");
            }
          }
        };
        SVGShapeElement.prototype.renderShape = function() {
          var i2;
          var len = this.animatedContents.length;
          var animatedContent;
          for (i2 = 0; i2 < len; i2 += 1) {
            animatedContent = this.animatedContents[i2];
            if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {
              animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);
            }
          }
        };
        SVGShapeElement.prototype.destroy = function() {
          this.destroyBaseElement();
          this.shapesData = null;
          this.itemsData = null;
        };
        function SVGTintFilter(filter, filterManager) {
          this.filterManager = filterManager;
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
          feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
          feColorMatrix.setAttribute("result", "f1");
          filter.appendChild(feColorMatrix);
          feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
          feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
          feColorMatrix.setAttribute("result", "f2");
          filter.appendChild(feColorMatrix);
          this.matrixFilter = feColorMatrix;
          if (filterManager.effectElements[2].p.v !== 100 || filterManager.effectElements[2].p.k) {
            var feMerge = createNS("feMerge");
            filter.appendChild(feMerge);
            var feMergeNode;
            feMergeNode = createNS("feMergeNode");
            feMergeNode.setAttribute("in", "SourceGraphic");
            feMerge.appendChild(feMergeNode);
            feMergeNode = createNS("feMergeNode");
            feMergeNode.setAttribute("in", "f2");
            feMerge.appendChild(feMergeNode);
          }
        }
        SVGTintFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var colorBlack = this.filterManager.effectElements[0].p.v;
            var colorWhite = this.filterManager.effectElements[1].p.v;
            var opacity = this.filterManager.effectElements[2].p.v / 100;
            this.matrixFilter.setAttribute("values", colorWhite[0] - colorBlack[0] + " 0 0 0 " + colorBlack[0] + " " + (colorWhite[1] - colorBlack[1]) + " 0 0 0 " + colorBlack[1] + " " + (colorWhite[2] - colorBlack[2]) + " 0 0 0 " + colorBlack[2] + " 0 0 0 " + opacity + " 0");
          }
        };
        function SVGFillFilter(filter, filterManager) {
          this.filterManager = filterManager;
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "sRGB");
          feColorMatrix.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0");
          filter.appendChild(feColorMatrix);
          this.matrixFilter = feColorMatrix;
        }
        SVGFillFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var color = this.filterManager.effectElements[2].p.v;
            var opacity = this.filterManager.effectElements[6].p.v;
            this.matrixFilter.setAttribute("values", "0 0 0 0 " + color[0] + " 0 0 0 0 " + color[1] + " 0 0 0 0 " + color[2] + " 0 0 0 " + opacity + " 0");
          }
        };
        function SVGGaussianBlurEffect(filter, filterManager) {
          filter.setAttribute("x", "-100%");
          filter.setAttribute("y", "-100%");
          filter.setAttribute("width", "300%");
          filter.setAttribute("height", "300%");
          this.filterManager = filterManager;
          var feGaussianBlur = createNS("feGaussianBlur");
          filter.appendChild(feGaussianBlur);
          this.feGaussianBlur = feGaussianBlur;
        }
        SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var kBlurrinessToSigma = 0.3;
            var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;
            var dimensions = this.filterManager.effectElements[1].p.v;
            var sigmaX = dimensions == 3 ? 0 : sigma;
            var sigmaY = dimensions == 2 ? 0 : sigma;
            this.feGaussianBlur.setAttribute("stdDeviation", sigmaX + " " + sigmaY);
            var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
            this.feGaussianBlur.setAttribute("edgeMode", edgeMode);
          }
        };
        function SVGStrokeEffect(elem, filterManager) {
          this.initialized = false;
          this.filterManager = filterManager;
          this.elem = elem;
          this.paths = [];
        }
        SVGStrokeEffect.prototype.initialize = function() {
          var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
          var path;
          var groupPath;
          var i2;
          var len;
          if (this.filterManager.effectElements[1].p.v === 1) {
            len = this.elem.maskManager.masksProperties.length;
            i2 = 0;
          } else {
            i2 = this.filterManager.effectElements[0].p.v - 1;
            len = i2 + 1;
          }
          groupPath = createNS("g");
          groupPath.setAttribute("fill", "none");
          groupPath.setAttribute("stroke-linecap", "round");
          groupPath.setAttribute("stroke-dashoffset", 1);
          for (i2; i2 < len; i2 += 1) {
            path = createNS("path");
            groupPath.appendChild(path);
            this.paths.push({ p: path, m: i2 });
          }
          if (this.filterManager.effectElements[10].p.v === 3) {
            var mask = createNS("mask");
            var id = createElementID();
            mask.setAttribute("id", id);
            mask.setAttribute("mask-type", "alpha");
            mask.appendChild(groupPath);
            this.elem.globalData.defs.appendChild(mask);
            var g3 = createNS("g");
            g3.setAttribute("mask", "url(" + locationHref + "#" + id + ")");
            while (elemChildren[0]) {
              g3.appendChild(elemChildren[0]);
            }
            this.elem.layerElement.appendChild(g3);
            this.masker = mask;
            groupPath.setAttribute("stroke", "#fff");
          } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
            if (this.filterManager.effectElements[10].p.v === 2) {
              elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;
              while (elemChildren.length) {
                this.elem.layerElement.removeChild(elemChildren[0]);
              }
            }
            this.elem.layerElement.appendChild(groupPath);
            this.elem.layerElement.removeAttribute("mask");
            groupPath.setAttribute("stroke", "#fff");
          }
          this.initialized = true;
          this.pathMasker = groupPath;
        };
        SVGStrokeEffect.prototype.renderFrame = function(forceRender) {
          if (!this.initialized) {
            this.initialize();
          }
          var i2;
          var len = this.paths.length;
          var mask;
          var path;
          for (i2 = 0; i2 < len; i2 += 1) {
            if (this.paths[i2].m !== -1) {
              mask = this.elem.maskManager.viewData[this.paths[i2].m];
              path = this.paths[i2].p;
              if (forceRender || this.filterManager._mdf || mask.prop._mdf) {
                path.setAttribute("d", mask.lastPath);
              }
              if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {
                var dasharrayValue;
                if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
                  var s2 = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                  var e2 = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;
                  var l2 = path.getTotalLength();
                  dasharrayValue = "0 0 0 " + l2 * s2 + " ";
                  var lineLength = l2 * (e2 - s2);
                  var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                  var units = Math.floor(lineLength / segment);
                  var j3;
                  for (j3 = 0; j3 < units; j3 += 1) {
                    dasharrayValue += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
                  }
                  dasharrayValue += "0 " + l2 * 10 + " 0 0";
                } else {
                  dasharrayValue = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
                }
                path.setAttribute("stroke-dasharray", dasharrayValue);
              }
            }
          }
          if (forceRender || this.filterManager.effectElements[4].p._mdf) {
            this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2);
          }
          if (forceRender || this.filterManager.effectElements[6].p._mdf) {
            this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v);
          }
          if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
            if (forceRender || this.filterManager.effectElements[3].p._mdf) {
              var color = this.filterManager.effectElements[3].p.v;
              this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(color[0] * 255) + "," + bmFloor(color[1] * 255) + "," + bmFloor(color[2] * 255) + ")");
            }
          }
        };
        function SVGTritoneFilter(filter, filterManager) {
          this.filterManager = filterManager;
          var feColorMatrix = createNS("feColorMatrix");
          feColorMatrix.setAttribute("type", "matrix");
          feColorMatrix.setAttribute("color-interpolation-filters", "linearRGB");
          feColorMatrix.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0");
          feColorMatrix.setAttribute("result", "f1");
          filter.appendChild(feColorMatrix);
          var feComponentTransfer = createNS("feComponentTransfer");
          feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
          filter.appendChild(feComponentTransfer);
          this.matrixFilter = feComponentTransfer;
          var feFuncR = createNS("feFuncR");
          feFuncR.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFuncR);
          this.feFuncR = feFuncR;
          var feFuncG = createNS("feFuncG");
          feFuncG.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFuncG);
          this.feFuncG = feFuncG;
          var feFuncB = createNS("feFuncB");
          feFuncB.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFuncB);
          this.feFuncB = feFuncB;
        }
        SVGTritoneFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var color1 = this.filterManager.effectElements[0].p.v;
            var color2 = this.filterManager.effectElements[1].p.v;
            var color3 = this.filterManager.effectElements[2].p.v;
            var tableR = color3[0] + " " + color2[0] + " " + color1[0];
            var tableG = color3[1] + " " + color2[1] + " " + color1[1];
            var tableB = color3[2] + " " + color2[2] + " " + color1[2];
            this.feFuncR.setAttribute("tableValues", tableR);
            this.feFuncG.setAttribute("tableValues", tableG);
            this.feFuncB.setAttribute("tableValues", tableB);
          }
        };
        function SVGProLevelsFilter(filter, filterManager) {
          this.filterManager = filterManager;
          var effectElements = this.filterManager.effectElements;
          var feComponentTransfer = createNS("feComponentTransfer");
          if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {
            this.feFuncR = this.createFeFunc("feFuncR", feComponentTransfer);
          }
          if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {
            this.feFuncG = this.createFeFunc("feFuncG", feComponentTransfer);
          }
          if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {
            this.feFuncB = this.createFeFunc("feFuncB", feComponentTransfer);
          }
          if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {
            this.feFuncA = this.createFeFunc("feFuncA", feComponentTransfer);
          }
          if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {
            feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
            filter.appendChild(feComponentTransfer);
            feComponentTransfer = createNS("feComponentTransfer");
          }
          if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {
            feComponentTransfer.setAttribute("color-interpolation-filters", "sRGB");
            filter.appendChild(feComponentTransfer);
            this.feFuncRComposed = this.createFeFunc("feFuncR", feComponentTransfer);
            this.feFuncGComposed = this.createFeFunc("feFuncG", feComponentTransfer);
            this.feFuncBComposed = this.createFeFunc("feFuncB", feComponentTransfer);
          }
        }
        SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {
          var feFunc = createNS(type);
          feFunc.setAttribute("type", "table");
          feComponentTransfer.appendChild(feFunc);
          return feFunc;
        };
        SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {
          var cnt = 0;
          var segments = 256;
          var perc;
          var min = Math.min(inputBlack, inputWhite);
          var max = Math.max(inputBlack, inputWhite);
          var table = Array.call(null, { length: segments });
          var colorValue;
          var pos = 0;
          var outputDelta = outputWhite - outputBlack;
          var inputDelta = inputWhite - inputBlack;
          while (cnt <= 256) {
            perc = cnt / 256;
            if (perc <= min) {
              colorValue = inputDelta < 0 ? outputWhite : outputBlack;
            } else if (perc >= max) {
              colorValue = inputDelta < 0 ? outputBlack : outputWhite;
            } else {
              colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);
            }
            table[pos] = colorValue;
            pos += 1;
            cnt += 256 / (segments - 1);
          }
          return table.join(" ");
        };
        SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            var val;
            var effectElements = this.filterManager.effectElements;
            if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {
              val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);
              this.feFuncRComposed.setAttribute("tableValues", val);
              this.feFuncGComposed.setAttribute("tableValues", val);
              this.feFuncBComposed.setAttribute("tableValues", val);
            }
            if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {
              val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);
              this.feFuncR.setAttribute("tableValues", val);
            }
            if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {
              val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);
              this.feFuncG.setAttribute("tableValues", val);
            }
            if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {
              val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);
              this.feFuncB.setAttribute("tableValues", val);
            }
            if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {
              val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);
              this.feFuncA.setAttribute("tableValues", val);
            }
          }
        };
        function SVGDropShadowEffect(filter, filterManager) {
          var filterSize = filterManager.container.globalData.renderConfig.filterSize;
          filter.setAttribute("x", filterSize.x);
          filter.setAttribute("y", filterSize.y);
          filter.setAttribute("width", filterSize.width);
          filter.setAttribute("height", filterSize.height);
          this.filterManager = filterManager;
          var feGaussianBlur = createNS("feGaussianBlur");
          feGaussianBlur.setAttribute("in", "SourceAlpha");
          feGaussianBlur.setAttribute("result", "drop_shadow_1");
          feGaussianBlur.setAttribute("stdDeviation", "0");
          this.feGaussianBlur = feGaussianBlur;
          filter.appendChild(feGaussianBlur);
          var feOffset = createNS("feOffset");
          feOffset.setAttribute("dx", "25");
          feOffset.setAttribute("dy", "0");
          feOffset.setAttribute("in", "drop_shadow_1");
          feOffset.setAttribute("result", "drop_shadow_2");
          this.feOffset = feOffset;
          filter.appendChild(feOffset);
          var feFlood = createNS("feFlood");
          feFlood.setAttribute("flood-color", "#00ff00");
          feFlood.setAttribute("flood-opacity", "1");
          feFlood.setAttribute("result", "drop_shadow_3");
          this.feFlood = feFlood;
          filter.appendChild(feFlood);
          var feComposite = createNS("feComposite");
          feComposite.setAttribute("in", "drop_shadow_3");
          feComposite.setAttribute("in2", "drop_shadow_2");
          feComposite.setAttribute("operator", "in");
          feComposite.setAttribute("result", "drop_shadow_4");
          filter.appendChild(feComposite);
          var feMerge = createNS("feMerge");
          filter.appendChild(feMerge);
          var feMergeNode;
          feMergeNode = createNS("feMergeNode");
          feMerge.appendChild(feMergeNode);
          feMergeNode = createNS("feMergeNode");
          feMergeNode.setAttribute("in", "SourceGraphic");
          this.feMergeNode = feMergeNode;
          this.feMerge = feMerge;
          this.originalNodeAdded = false;
          feMerge.appendChild(feMergeNode);
        }
        SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {
          if (forceRender || this.filterManager._mdf) {
            if (forceRender || this.filterManager.effectElements[4].p._mdf) {
              this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4);
            }
            if (forceRender || this.filterManager.effectElements[0].p._mdf) {
              var col = this.filterManager.effectElements[0].p.v;
              this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));
            }
            if (forceRender || this.filterManager.effectElements[1].p._mdf) {
              this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255);
            }
            if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
              var distance = this.filterManager.effectElements[3].p.v;
              var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;
              var x3 = distance * Math.cos(angle);
              var y3 = distance * Math.sin(angle);
              this.feOffset.setAttribute("dx", x3);
              this.feOffset.setAttribute("dy", y3);
            }
          }
        };
        var _svgMatteSymbols = [];
        function SVGMatte3Effect(filterElem, filterManager, elem) {
          this.initialized = false;
          this.filterManager = filterManager;
          this.filterElem = filterElem;
          this.elem = elem;
          elem.matteElement = createNS("g");
          elem.matteElement.appendChild(elem.layerElement);
          elem.matteElement.appendChild(elem.transformedElement);
          elem.baseElement = elem.matteElement;
        }
        SVGMatte3Effect.prototype.findSymbol = function(mask) {
          var i2 = 0;
          var len = _svgMatteSymbols.length;
          while (i2 < len) {
            if (_svgMatteSymbols[i2] === mask) {
              return _svgMatteSymbols[i2];
            }
            i2 += 1;
          }
          return null;
        };
        SVGMatte3Effect.prototype.replaceInParent = function(mask, symbolId) {
          var parentNode = mask.layerElement.parentNode;
          if (!parentNode) {
            return;
          }
          var children = parentNode.children;
          var i2 = 0;
          var len = children.length;
          while (i2 < len) {
            if (children[i2] === mask.layerElement) {
              break;
            }
            i2 += 1;
          }
          var nextChild;
          if (i2 <= len - 2) {
            nextChild = children[i2 + 1];
          }
          var useElem = createNS("use");
          useElem.setAttribute("href", "#" + symbolId);
          if (nextChild) {
            parentNode.insertBefore(useElem, nextChild);
          } else {
            parentNode.appendChild(useElem);
          }
        };
        SVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {
          if (!this.findSymbol(mask)) {
            var symbolId = createElementID();
            var masker = createNS("mask");
            masker.setAttribute("id", mask.layerId);
            masker.setAttribute("mask-type", "alpha");
            _svgMatteSymbols.push(mask);
            var defs = elem.globalData.defs;
            defs.appendChild(masker);
            var symbol = createNS("symbol");
            symbol.setAttribute("id", symbolId);
            this.replaceInParent(mask, symbolId);
            symbol.appendChild(mask.layerElement);
            defs.appendChild(symbol);
            var useElem = createNS("use");
            useElem.setAttribute("href", "#" + symbolId);
            masker.appendChild(useElem);
            mask.data.hd = false;
            mask.show();
          }
          elem.setMatte(mask.layerId);
        };
        SVGMatte3Effect.prototype.initialize = function() {
          var ind = this.filterManager.effectElements[0].p.v;
          var elements = this.elem.comp.elements;
          var i2 = 0;
          var len = elements.length;
          while (i2 < len) {
            if (elements[i2] && elements[i2].data.ind === ind) {
              this.setElementAsMask(this.elem, elements[i2]);
            }
            i2 += 1;
          }
          this.initialized = true;
        };
        SVGMatte3Effect.prototype.renderFrame = function() {
          if (!this.initialized) {
            this.initialize();
          }
        };
        function SVGEffects() {
        }
        var animationManager = function() {
          var moduleOb = {};
          var registeredAnimations = [];
          var initTime = 0;
          var len = 0;
          var playingAnimationsNum = 0;
          var _stopped = true;
          var _isFrozen = false;
          function removeElement(ev) {
            var i2 = 0;
            var animItem = ev.target;
            while (i2 < len) {
              if (registeredAnimations[i2].animation === animItem) {
                registeredAnimations.splice(i2, 1);
                i2 -= 1;
                len -= 1;
                if (!animItem.isPaused) {
                  subtractPlayingCount();
                }
              }
              i2 += 1;
            }
          }
          function registerAnimation(element, animationData2) {
            if (!element) {
              return null;
            }
            var i2 = 0;
            while (i2 < len) {
              if (registeredAnimations[i2].elem === element && registeredAnimations[i2].elem !== null) {
                return registeredAnimations[i2].animation;
              }
              i2 += 1;
            }
            var animItem = new AnimationItem();
            setupAnimation(animItem, element);
            animItem.setData(element, animationData2);
            return animItem;
          }
          function getRegisteredAnimations() {
            var i2;
            var lenAnims = registeredAnimations.length;
            var animations = [];
            for (i2 = 0; i2 < lenAnims; i2 += 1) {
              animations.push(registeredAnimations[i2].animation);
            }
            return animations;
          }
          function addPlayingCount() {
            playingAnimationsNum += 1;
            activate();
          }
          function subtractPlayingCount() {
            playingAnimationsNum -= 1;
          }
          function setupAnimation(animItem, element) {
            animItem.addEventListener("destroy", removeElement);
            animItem.addEventListener("_active", addPlayingCount);
            animItem.addEventListener("_idle", subtractPlayingCount);
            registeredAnimations.push({ elem: element, animation: animItem });
            len += 1;
          }
          function loadAnimation2(params) {
            var animItem = new AnimationItem();
            setupAnimation(animItem, null);
            animItem.setParams(params);
            return animItem;
          }
          function setSpeed(val, animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.setSpeed(val, animation);
            }
          }
          function setDirection(val, animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.setDirection(val, animation);
            }
          }
          function play(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.play(animation);
            }
          }
          function resume(nowTime) {
            var elapsedTime = nowTime - initTime;
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.advanceTime(elapsedTime);
            }
            initTime = nowTime;
            if (playingAnimationsNum && !_isFrozen) {
              window2.requestAnimationFrame(resume);
            } else {
              _stopped = true;
            }
          }
          function first(nowTime) {
            initTime = nowTime;
            window2.requestAnimationFrame(resume);
          }
          function pause(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.pause(animation);
            }
          }
          function goToAndStop(value, isFrame, animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.goToAndStop(value, isFrame, animation);
            }
          }
          function stop(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.stop(animation);
            }
          }
          function togglePause(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.togglePause(animation);
            }
          }
          function destroy(animation) {
            var i2;
            for (i2 = len - 1; i2 >= 0; i2 -= 1) {
              registeredAnimations[i2].animation.destroy(animation);
            }
          }
          function searchAnimations2(animationData2, standalone2, renderer2) {
            var animElements = [].concat(
              [].slice.call(document.getElementsByClassName("lottie")),
              [].slice.call(document.getElementsByClassName("bodymovin"))
            );
            var i2;
            var lenAnims = animElements.length;
            for (i2 = 0; i2 < lenAnims; i2 += 1) {
              if (renderer2) {
                animElements[i2].setAttribute("data-bm-type", renderer2);
              }
              registerAnimation(animElements[i2], animationData2);
            }
            if (standalone2 && lenAnims === 0) {
              if (!renderer2) {
                renderer2 = "svg";
              }
              var body = document.getElementsByTagName("body")[0];
              body.innerText = "";
              var div = createTag("div");
              div.style.width = "100%";
              div.style.height = "100%";
              div.setAttribute("data-bm-type", renderer2);
              body.appendChild(div);
              registerAnimation(div, animationData2);
            }
          }
          function resize() {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.resize();
            }
          }
          function activate() {
            if (!_isFrozen && playingAnimationsNum) {
              if (_stopped) {
                window2.requestAnimationFrame(first);
                _stopped = false;
              }
            }
          }
          function freeze() {
            _isFrozen = true;
          }
          function unfreeze() {
            _isFrozen = false;
            activate();
          }
          function setVolume(val, animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.setVolume(val, animation);
            }
          }
          function mute(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.mute(animation);
            }
          }
          function unmute(animation) {
            var i2;
            for (i2 = 0; i2 < len; i2 += 1) {
              registeredAnimations[i2].animation.unmute(animation);
            }
          }
          moduleOb.registerAnimation = registerAnimation;
          moduleOb.loadAnimation = loadAnimation2;
          moduleOb.setSpeed = setSpeed;
          moduleOb.setDirection = setDirection;
          moduleOb.play = play;
          moduleOb.pause = pause;
          moduleOb.stop = stop;
          moduleOb.togglePause = togglePause;
          moduleOb.searchAnimations = searchAnimations2;
          moduleOb.resize = resize;
          moduleOb.goToAndStop = goToAndStop;
          moduleOb.destroy = destroy;
          moduleOb.freeze = freeze;
          moduleOb.unfreeze = unfreeze;
          moduleOb.setVolume = setVolume;
          moduleOb.mute = mute;
          moduleOb.unmute = unmute;
          moduleOb.getRegisteredAnimations = getRegisteredAnimations;
          return moduleOb;
        }();
        var AnimationItem = function() {
          this._cbs = [];
          this.name = "";
          this.path = "";
          this.isLoaded = false;
          this.currentFrame = 0;
          this.currentRawFrame = 0;
          this.firstFrame = 0;
          this.totalFrames = 0;
          this.frameRate = 0;
          this.frameMult = 0;
          this.playSpeed = 1;
          this.playDirection = 1;
          this.playCount = 0;
          this.animationData = {};
          this.assets = [];
          this.isPaused = true;
          this.autoplay = false;
          this.loop = true;
          this.renderer = null;
          this.animationID = createElementID();
          this.assetsPath = "";
          this.timeCompleted = 0;
          this.segmentPos = 0;
          this.isSubframeEnabled = subframeEnabled;
          this.segments = [];
          this._idle = true;
          this._completedLoop = false;
          this.projectInterface = ProjectInterface();
          this.imagePreloader = new ImagePreloader();
          this.audioController = audioControllerFactory();
          this.markers = [];
          this.configAnimation = this.configAnimation.bind(this);
          this.onSetupError = this.onSetupError.bind(this);
          this.onSegmentComplete = this.onSegmentComplete.bind(this);
        };
        extendPrototype([BaseEvent], AnimationItem);
        AnimationItem.prototype.setParams = function(params) {
          if (params.wrapper || params.container) {
            this.wrapper = params.wrapper || params.container;
          }
          var animType = "svg";
          if (params.animType) {
            animType = params.animType;
          } else if (params.renderer) {
            animType = params.renderer;
          }
          switch (animType) {
            case "canvas":
              this.renderer = new CanvasRenderer(this, params.rendererSettings);
              break;
            case "svg":
              this.renderer = new SVGRenderer(this, params.rendererSettings);
              break;
            default:
              this.renderer = new HybridRenderer(this, params.rendererSettings);
              break;
          }
          this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);
          this.renderer.setProjectInterface(this.projectInterface);
          this.animType = animType;
          if (params.loop === "" || params.loop === null || params.loop === void 0 || params.loop === true) {
            this.loop = true;
          } else if (params.loop === false) {
            this.loop = false;
          } else {
            this.loop = parseInt(params.loop, 10);
          }
          this.autoplay = "autoplay" in params ? params.autoplay : true;
          this.name = params.name ? params.name : "";
          this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, "autoloadSegments") ? params.autoloadSegments : true;
          this.assetsPath = params.assetsPath;
          this.initialSegment = params.initialSegment;
          if (params.audioFactory) {
            this.audioController.setAudioFactory(params.audioFactory);
          }
          if (params.animationData) {
            this.setupAnimation(params.animationData);
          } else if (params.path) {
            if (params.path.lastIndexOf("\\") !== -1) {
              this.path = params.path.substr(0, params.path.lastIndexOf("\\") + 1);
            } else {
              this.path = params.path.substr(0, params.path.lastIndexOf("/") + 1);
            }
            this.fileName = params.path.substr(params.path.lastIndexOf("/") + 1);
            this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json"));
            dataManager.loadAnimation(
              params.path,
              this.configAnimation,
              this.onSetupError
            );
          }
        };
        AnimationItem.prototype.onSetupError = function() {
          this.trigger("data_failed");
        };
        AnimationItem.prototype.setupAnimation = function(data) {
          dataManager.completeAnimation(
            data,
            this.configAnimation
          );
        };
        AnimationItem.prototype.setData = function(wrapper, animationData2) {
          if (animationData2) {
            if (typeof animationData2 !== "object") {
              animationData2 = JSON.parse(animationData2);
            }
          }
          var params = {
            wrapper,
            animationData: animationData2
          };
          var wrapperAttributes = wrapper.attributes;
          params.path = wrapperAttributes.getNamedItem("data-animation-path") ? wrapperAttributes.getNamedItem("data-animation-path").value : wrapperAttributes.getNamedItem("data-bm-path") ? wrapperAttributes.getNamedItem("data-bm-path").value : wrapperAttributes.getNamedItem("bm-path") ? wrapperAttributes.getNamedItem("bm-path").value : "";
          params.animType = wrapperAttributes.getNamedItem("data-anim-type") ? wrapperAttributes.getNamedItem("data-anim-type").value : wrapperAttributes.getNamedItem("data-bm-type") ? wrapperAttributes.getNamedItem("data-bm-type").value : wrapperAttributes.getNamedItem("bm-type") ? wrapperAttributes.getNamedItem("bm-type").value : wrapperAttributes.getNamedItem("data-bm-renderer") ? wrapperAttributes.getNamedItem("data-bm-renderer").value : wrapperAttributes.getNamedItem("bm-renderer") ? wrapperAttributes.getNamedItem("bm-renderer").value : "canvas";
          var loop = wrapperAttributes.getNamedItem("data-anim-loop") ? wrapperAttributes.getNamedItem("data-anim-loop").value : wrapperAttributes.getNamedItem("data-bm-loop") ? wrapperAttributes.getNamedItem("data-bm-loop").value : wrapperAttributes.getNamedItem("bm-loop") ? wrapperAttributes.getNamedItem("bm-loop").value : "";
          if (loop === "false") {
            params.loop = false;
          } else if (loop === "true") {
            params.loop = true;
          } else if (loop !== "") {
            params.loop = parseInt(loop, 10);
          }
          var autoplay = wrapperAttributes.getNamedItem("data-anim-autoplay") ? wrapperAttributes.getNamedItem("data-anim-autoplay").value : wrapperAttributes.getNamedItem("data-bm-autoplay") ? wrapperAttributes.getNamedItem("data-bm-autoplay").value : wrapperAttributes.getNamedItem("bm-autoplay") ? wrapperAttributes.getNamedItem("bm-autoplay").value : true;
          params.autoplay = autoplay !== "false";
          params.name = wrapperAttributes.getNamedItem("data-name") ? wrapperAttributes.getNamedItem("data-name").value : wrapperAttributes.getNamedItem("data-bm-name") ? wrapperAttributes.getNamedItem("data-bm-name").value : wrapperAttributes.getNamedItem("bm-name") ? wrapperAttributes.getNamedItem("bm-name").value : "";
          var prerender = wrapperAttributes.getNamedItem("data-anim-prerender") ? wrapperAttributes.getNamedItem("data-anim-prerender").value : wrapperAttributes.getNamedItem("data-bm-prerender") ? wrapperAttributes.getNamedItem("data-bm-prerender").value : wrapperAttributes.getNamedItem("bm-prerender") ? wrapperAttributes.getNamedItem("bm-prerender").value : "";
          if (prerender === "false") {
            params.prerender = false;
          }
          this.setParams(params);
        };
        AnimationItem.prototype.includeLayers = function(data) {
          if (data.op > this.animationData.op) {
            this.animationData.op = data.op;
            this.totalFrames = Math.floor(data.op - this.animationData.ip);
          }
          var layers = this.animationData.layers;
          var i2;
          var len = layers.length;
          var newLayers = data.layers;
          var j3;
          var jLen = newLayers.length;
          for (j3 = 0; j3 < jLen; j3 += 1) {
            i2 = 0;
            while (i2 < len) {
              if (layers[i2].id === newLayers[j3].id) {
                layers[i2] = newLayers[j3];
                break;
              }
              i2 += 1;
            }
          }
          if (data.chars || data.fonts) {
            this.renderer.globalData.fontManager.addChars(data.chars);
            this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);
          }
          if (data.assets) {
            len = data.assets.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.animationData.assets.push(data.assets[i2]);
            }
          }
          this.animationData.__complete = false;
          dataManager.completeAnimation(
            this.animationData,
            this.onSegmentComplete
          );
        };
        AnimationItem.prototype.onSegmentComplete = function(data) {
          this.animationData = data;
          if (expressionsPlugin) {
            expressionsPlugin.initExpressions(this);
          }
          this.loadNextSegment();
        };
        AnimationItem.prototype.loadNextSegment = function() {
          var segments = this.animationData.segments;
          if (!segments || segments.length === 0 || !this.autoloadSegments) {
            this.trigger("data_ready");
            this.timeCompleted = this.totalFrames;
            return;
          }
          var segment = segments.shift();
          this.timeCompleted = segment.time * this.frameRate;
          var segmentPath = this.path + this.fileName + "_" + this.segmentPos + ".json";
          this.segmentPos += 1;
          dataManager.loadData(segmentPath, this.includeLayers.bind(this), function() {
            this.trigger("data_failed");
          }.bind(this));
        };
        AnimationItem.prototype.loadSegments = function() {
          var segments = this.animationData.segments;
          if (!segments) {
            this.timeCompleted = this.totalFrames;
          }
          this.loadNextSegment();
        };
        AnimationItem.prototype.imagesLoaded = function() {
          this.trigger("loaded_images");
          this.checkLoaded();
        };
        AnimationItem.prototype.preloadImages = function() {
          this.imagePreloader.setAssetsPath(this.assetsPath);
          this.imagePreloader.setPath(this.path);
          this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
        };
        AnimationItem.prototype.configAnimation = function(animData) {
          if (!this.renderer) {
            return;
          }
          try {
            this.animationData = animData;
            if (this.initialSegment) {
              this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);
              this.firstFrame = Math.round(this.initialSegment[0]);
            } else {
              this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);
              this.firstFrame = Math.round(this.animationData.ip);
            }
            this.renderer.configAnimation(animData);
            if (!animData.assets) {
              animData.assets = [];
            }
            this.assets = this.animationData.assets;
            this.frameRate = this.animationData.fr;
            this.frameMult = this.animationData.fr / 1e3;
            this.renderer.searchExtraCompositions(animData.assets);
            this.markers = markerParser(animData.markers || []);
            this.trigger("config_ready");
            this.preloadImages();
            this.loadSegments();
            this.updaFrameModifier();
            this.waitForFontsLoaded();
            if (this.isPaused) {
              this.audioController.pause();
            }
          } catch (error) {
            this.triggerConfigError(error);
          }
        };
        AnimationItem.prototype.waitForFontsLoaded = function() {
          if (!this.renderer) {
            return;
          }
          if (this.renderer.globalData.fontManager.isLoaded) {
            this.checkLoaded();
          } else {
            setTimeout(this.waitForFontsLoaded.bind(this), 20);
          }
        };
        AnimationItem.prototype.checkLoaded = function() {
          if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
            this.isLoaded = true;
            if (expressionsPlugin) {
              expressionsPlugin.initExpressions(this);
            }
            this.renderer.initItems();
            setTimeout(function() {
              this.trigger("DOMLoaded");
            }.bind(this), 0);
            this.gotoFrame();
            if (this.autoplay) {
              this.play();
            }
          }
        };
        AnimationItem.prototype.resize = function() {
          this.renderer.updateContainerSize();
        };
        AnimationItem.prototype.setSubframe = function(flag) {
          this.isSubframeEnabled = !!flag;
        };
        AnimationItem.prototype.gotoFrame = function() {
          this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame;
          if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {
            this.currentFrame = this.timeCompleted;
          }
          this.trigger("enterFrame");
          this.renderFrame();
          this.trigger("drawnFrame");
        };
        AnimationItem.prototype.renderFrame = function() {
          if (this.isLoaded === false || !this.renderer) {
            return;
          }
          try {
            this.renderer.renderFrame(this.currentFrame + this.firstFrame);
          } catch (error) {
            this.triggerRenderFrameError(error);
          }
        };
        AnimationItem.prototype.play = function(name) {
          if (name && this.name !== name) {
            return;
          }
          if (this.isPaused === true) {
            this.isPaused = false;
            this.audioController.resume();
            if (this._idle) {
              this._idle = false;
              this.trigger("_active");
            }
          }
        };
        AnimationItem.prototype.pause = function(name) {
          if (name && this.name !== name) {
            return;
          }
          if (this.isPaused === false) {
            this.isPaused = true;
            this._idle = true;
            this.trigger("_idle");
            this.audioController.pause();
          }
        };
        AnimationItem.prototype.togglePause = function(name) {
          if (name && this.name !== name) {
            return;
          }
          if (this.isPaused === true) {
            this.play();
          } else {
            this.pause();
          }
        };
        AnimationItem.prototype.stop = function(name) {
          if (name && this.name !== name) {
            return;
          }
          this.pause();
          this.playCount = 0;
          this._completedLoop = false;
          this.setCurrentRawFrameValue(0);
        };
        AnimationItem.prototype.getMarkerData = function(markerName) {
          var marker;
          for (var i2 = 0; i2 < this.markers.length; i2 += 1) {
            marker = this.markers[i2];
            if (marker.payload && marker.payload.name === markerName) {
              return marker;
            }
          }
          return null;
        };
        AnimationItem.prototype.goToAndStop = function(value, isFrame, name) {
          if (name && this.name !== name) {
            return;
          }
          var numValue = Number(value);
          if (isNaN(numValue)) {
            var marker = this.getMarkerData(value);
            if (marker) {
              this.goToAndStop(marker.time, true);
            }
          } else if (isFrame) {
            this.setCurrentRawFrameValue(value);
          } else {
            this.setCurrentRawFrameValue(value * this.frameModifier);
          }
          this.pause();
        };
        AnimationItem.prototype.goToAndPlay = function(value, isFrame, name) {
          if (name && this.name !== name) {
            return;
          }
          var numValue = Number(value);
          if (isNaN(numValue)) {
            var marker = this.getMarkerData(value);
            if (marker) {
              if (!marker.duration) {
                this.goToAndStop(marker.time, true);
              } else {
                this.playSegments([marker.time, marker.time + marker.duration], true);
              }
            }
          } else {
            this.goToAndStop(numValue, isFrame, name);
          }
          this.play();
        };
        AnimationItem.prototype.advanceTime = function(value) {
          if (this.isPaused === true || this.isLoaded === false) {
            return;
          }
          var nextValue = this.currentRawFrame + value * this.frameModifier;
          var _isComplete = false;
          if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {
            if (!this.loop || this.playCount === this.loop) {
              if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {
                _isComplete = true;
                nextValue = this.totalFrames - 1;
              }
            } else if (nextValue >= this.totalFrames) {
              this.playCount += 1;
              if (!this.checkSegments(nextValue % this.totalFrames)) {
                this.setCurrentRawFrameValue(nextValue % this.totalFrames);
                this._completedLoop = true;
                this.trigger("loopComplete");
              }
            } else {
              this.setCurrentRawFrameValue(nextValue);
            }
          } else if (nextValue < 0) {
            if (!this.checkSegments(nextValue % this.totalFrames)) {
              if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {
                this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);
                if (!this._completedLoop) {
                  this._completedLoop = true;
                } else {
                  this.trigger("loopComplete");
                }
              } else {
                _isComplete = true;
                nextValue = 0;
              }
            }
          } else {
            this.setCurrentRawFrameValue(nextValue);
          }
          if (_isComplete) {
            this.setCurrentRawFrameValue(nextValue);
            this.pause();
            this.trigger("complete");
          }
        };
        AnimationItem.prototype.adjustSegment = function(arr, offset) {
          this.playCount = 0;
          if (arr[1] < arr[0]) {
            if (this.frameModifier > 0) {
              if (this.playSpeed < 0) {
                this.setSpeed(-this.playSpeed);
              } else {
                this.setDirection(-1);
              }
            }
            this.totalFrames = arr[0] - arr[1];
            this.timeCompleted = this.totalFrames;
            this.firstFrame = arr[1];
            this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - offset);
          } else if (arr[1] > arr[0]) {
            if (this.frameModifier < 0) {
              if (this.playSpeed < 0) {
                this.setSpeed(-this.playSpeed);
              } else {
                this.setDirection(1);
              }
            }
            this.totalFrames = arr[1] - arr[0];
            this.timeCompleted = this.totalFrames;
            this.firstFrame = arr[0];
            this.setCurrentRawFrameValue(1e-3 + offset);
          }
          this.trigger("segmentStart");
        };
        AnimationItem.prototype.setSegment = function(init, end) {
          var pendingFrame = -1;
          if (this.isPaused) {
            if (this.currentRawFrame + this.firstFrame < init) {
              pendingFrame = init;
            } else if (this.currentRawFrame + this.firstFrame > end) {
              pendingFrame = end - init;
            }
          }
          this.firstFrame = init;
          this.totalFrames = end - init;
          this.timeCompleted = this.totalFrames;
          if (pendingFrame !== -1) {
            this.goToAndStop(pendingFrame, true);
          }
        };
        AnimationItem.prototype.playSegments = function(arr, forceFlag) {
          if (forceFlag) {
            this.segments.length = 0;
          }
          if (typeof arr[0] === "object") {
            var i2;
            var len = arr.length;
            for (i2 = 0; i2 < len; i2 += 1) {
              this.segments.push(arr[i2]);
            }
          } else {
            this.segments.push(arr);
          }
          if (this.segments.length && forceFlag) {
            this.adjustSegment(this.segments.shift(), 0);
          }
          if (this.isPaused) {
            this.play();
          }
        };
        AnimationItem.prototype.resetSegments = function(forceFlag) {
          this.segments.length = 0;
          this.segments.push([this.animationData.ip, this.animationData.op]);
          if (forceFlag) {
            this.checkSegments(0);
          }
        };
        AnimationItem.prototype.checkSegments = function(offset) {
          if (this.segments.length) {
            this.adjustSegment(this.segments.shift(), offset);
            return true;
          }
          return false;
        };
        AnimationItem.prototype.destroy = function(name) {
          if (name && this.name !== name || !this.renderer) {
            return;
          }
          this.renderer.destroy();
          this.imagePreloader.destroy();
          this.trigger("destroy");
          this._cbs = null;
          this.onEnterFrame = null;
          this.onLoopComplete = null;
          this.onComplete = null;
          this.onSegmentStart = null;
          this.onDestroy = null;
          this.renderer = null;
          this.renderer = null;
          this.imagePreloader = null;
          this.projectInterface = null;
        };
        AnimationItem.prototype.setCurrentRawFrameValue = function(value) {
          this.currentRawFrame = value;
          this.gotoFrame();
        };
        AnimationItem.prototype.setSpeed = function(val) {
          this.playSpeed = val;
          this.updaFrameModifier();
        };
        AnimationItem.prototype.setDirection = function(val) {
          this.playDirection = val < 0 ? -1 : 1;
          this.updaFrameModifier();
        };
        AnimationItem.prototype.setVolume = function(val, name) {
          if (name && this.name !== name) {
            return;
          }
          this.audioController.setVolume(val);
        };
        AnimationItem.prototype.getVolume = function() {
          return this.audioController.getVolume();
        };
        AnimationItem.prototype.mute = function(name) {
          if (name && this.name !== name) {
            return;
          }
          this.audioController.mute();
        };
        AnimationItem.prototype.unmute = function(name) {
          if (name && this.name !== name) {
            return;
          }
          this.audioController.unmute();
        };
        AnimationItem.prototype.updaFrameModifier = function() {
          this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;
          this.audioController.setRate(this.playSpeed * this.playDirection);
        };
        AnimationItem.prototype.getPath = function() {
          return this.path;
        };
        AnimationItem.prototype.getAssetsPath = function(assetData) {
          var path = "";
          if (assetData.e) {
            path = assetData.p;
          } else if (this.assetsPath) {
            var imagePath = assetData.p;
            if (imagePath.indexOf("images/") !== -1) {
              imagePath = imagePath.split("/")[1];
            }
            path = this.assetsPath + imagePath;
          } else {
            path = this.path;
            path += assetData.u ? assetData.u : "";
            path += assetData.p;
          }
          return path;
        };
        AnimationItem.prototype.getAssetData = function(id) {
          var i2 = 0;
          var len = this.assets.length;
          while (i2 < len) {
            if (id === this.assets[i2].id) {
              return this.assets[i2];
            }
            i2 += 1;
          }
          return null;
        };
        AnimationItem.prototype.hide = function() {
          this.renderer.hide();
        };
        AnimationItem.prototype.show = function() {
          this.renderer.show();
        };
        AnimationItem.prototype.getDuration = function(isFrame) {
          return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;
        };
        AnimationItem.prototype.trigger = function(name) {
          if (this._cbs && this._cbs[name]) {
            switch (name) {
              case "enterFrame":
              case "drawnFrame":
                this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));
                break;
              case "loopComplete":
                this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
                break;
              case "complete":
                this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));
                break;
              case "segmentStart":
                this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
                break;
              case "destroy":
                this.triggerEvent(name, new BMDestroyEvent(name, this));
                break;
              default:
                this.triggerEvent(name);
            }
          }
          if (name === "enterFrame" && this.onEnterFrame) {
            this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));
          }
          if (name === "loopComplete" && this.onLoopComplete) {
            this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));
          }
          if (name === "complete" && this.onComplete) {
            this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));
          }
          if (name === "segmentStart" && this.onSegmentStart) {
            this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));
          }
          if (name === "destroy" && this.onDestroy) {
            this.onDestroy.call(this, new BMDestroyEvent(name, this));
          }
        };
        AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {
          var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);
          this.triggerEvent("error", error);
          if (this.onError) {
            this.onError.call(this, error);
          }
        };
        AnimationItem.prototype.triggerConfigError = function(nativeError) {
          var error = new BMConfigErrorEvent(nativeError, this.currentFrame);
          this.triggerEvent("error", error);
          if (this.onError) {
            this.onError.call(this, error);
          }
        };
        function EffectsManager() {
          this.effectElements = [];
        }
        var lottie = {};
        function setLocationHref(href) {
          locationHref = href;
        }
        function searchAnimations() {
          if (standalone === true) {
            animationManager.searchAnimations(animationData, standalone, renderer);
          } else {
            animationManager.searchAnimations();
          }
        }
        function setSubframeRendering(flag) {
          subframeEnabled = flag;
        }
        function setIDPrefix(prefix) {
          idPrefix = prefix;
        }
        function loadAnimation(params) {
          if (standalone === true) {
            params.animationData = JSON.parse(animationData);
          }
          return animationManager.loadAnimation(params);
        }
        function setQuality(value) {
          if (typeof value === "string") {
            switch (value) {
              case "high":
                defaultCurveSegments = 200;
                break;
              default:
              case "medium":
                defaultCurveSegments = 50;
                break;
              case "low":
                defaultCurveSegments = 10;
                break;
            }
          } else if (!isNaN(value) && value > 1) {
            defaultCurveSegments = value;
          }
          if (defaultCurveSegments >= 50) {
            roundValues(false);
          } else {
            roundValues(true);
          }
        }
        function inBrowser() {
          return typeof navigator !== "undefined";
        }
        function installPlugin(type, plugin) {
          if (type === "expressions") {
            expressionsPlugin = plugin;
          }
        }
        function getFactory(name) {
          switch (name) {
            case "propertyFactory":
              return PropertyFactory;
            case "shapePropertyFactory":
              return ShapePropertyFactory;
            case "matrix":
              return Matrix;
            default:
              return null;
          }
        }
        lottie.play = animationManager.play;
        lottie.pause = animationManager.pause;
        lottie.setLocationHref = setLocationHref;
        lottie.togglePause = animationManager.togglePause;
        lottie.setSpeed = animationManager.setSpeed;
        lottie.setDirection = animationManager.setDirection;
        lottie.stop = animationManager.stop;
        lottie.searchAnimations = searchAnimations;
        lottie.registerAnimation = animationManager.registerAnimation;
        lottie.loadAnimation = loadAnimation;
        lottie.setSubframeRendering = setSubframeRendering;
        lottie.resize = animationManager.resize;
        lottie.goToAndStop = animationManager.goToAndStop;
        lottie.destroy = animationManager.destroy;
        lottie.setQuality = setQuality;
        lottie.inBrowser = inBrowser;
        lottie.installPlugin = installPlugin;
        lottie.freeze = animationManager.freeze;
        lottie.unfreeze = animationManager.unfreeze;
        lottie.setVolume = animationManager.setVolume;
        lottie.mute = animationManager.mute;
        lottie.unmute = animationManager.unmute;
        lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;
        lottie.useWebWorker = function(flag) {
          _useWebWorker = flag;
        };
        lottie.setIDPrefix = setIDPrefix;
        lottie.__getFactory = getFactory;
        lottie.version = "5.8.1";
        function checkReady() {
          if (document.readyState === "complete") {
            clearInterval(readyStateCheckInterval);
            searchAnimations();
          }
        }
        function getQueryVariable(variable) {
          var vars = queryString.split("&");
          for (var i2 = 0; i2 < vars.length; i2 += 1) {
            var pair = vars[i2].split("=");
            if (decodeURIComponent(pair[0]) == variable) {
              return decodeURIComponent(pair[1]);
            }
          }
          return null;
        }
        var standalone = "__[STANDALONE]__";
        var animationData = "__[ANIMATIONDATA]__";
        var renderer = "";
        var queryString;
        if (standalone) {
          var scripts = document.getElementsByTagName("script");
          var index = scripts.length - 1;
          var myScript = scripts[index] || {
            src: ""
          };
          queryString = myScript.src.replace(/^[^\?]+\??/, "");
          renderer = getQueryVariable("renderer");
        }
        var readyStateCheckInterval = setInterval(checkReady, 100);
        return lottie;
      });
    }
  });

  // node_modules/@perawallet/connect/dist/App-428f5096.js
  var App_428f5096_exports = {};
  function h(e2, n3) {
    void 0 === n3 && (n3 = {});
    var t = n3.insertAt;
    if (e2 && "undefined" != typeof document) {
      var a2 = document.head || document.getElementsByTagName("head")[0], o3 = document.createElement("style");
      o3.type = "text/css", "top" === t && a2.firstChild ? a2.insertBefore(o3, a2.firstChild) : a2.appendChild(o3), o3.styleSheet ? o3.styleSheet.cssText = e2 : o3.appendChild(document.createTextNode(e2));
    }
  }
  function H(e2 = true) {
    let n3 = Bt;
    const t = Ut();
    return e2 && t && (n3 = `${n3}?browser=${encodeURIComponent(t)}`), n3;
  }
  function te() {
    document.documentElement.style.setProperty("--pera-wallet-vh", 0.01 * window.innerHeight + "px");
  }
  function ae(e2, n3) {
    window.customElements.get(e2) || window.customElements.define(e2, n3);
  }
  var import_qr_code_styling, import_lottie_web_light, import_bowser, g, x, f, u, _, b, v, C, k, y, L, M, z, E, Z, B, F, A, V, R, I, S, W, P, $, j, T, D, O, U, q, G, N, Q, J, K, Y, X, ee, ne;
  var init_App_428f5096 = __esm({
    "node_modules/@perawallet/connect/dist/App-428f5096.js"() {
      init_polyfills();
      init_index_87e811df();
      import_qr_code_styling = __toESM(require_qr_code_styling(), 1);
      import_lottie_web_light = __toESM(require_lottie_web_light(), 1);
      init_esm9();
      init_esm10();
      import_bowser = __toESM(require_es5(), 1);
      g = ".pera-wallet-modal-header {\n  position: absolute;\n  top: -44px;\n  right: 0px;\n  left: 0;\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n}\n.pera-wallet-modal-header--mobile {\n  display: flex;\n  align-items: center;\n  justify-content: flex-end;\n  position: static;\n}\n.pera-wallet-modal-header--mobile .pera-wallet-modal-header__close-button {\n  width: 24px;\n  height: 24px;\n  margin: 0;\n  padding: 0;\n  background: transparent;\n  border: unset;\n  box-shadow: unset;\n}\n\n.pera-wallet-modal-header__brand {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  font-size: 14px;\n  font-weight: 600;\n  line-height: 24px;\n  letter-spacing: -0.1px;\n  color: #ffffff;\n}\n\n.pera-wallet-modal-header__brand-text {\n  display: flex;\n  align-items: center;\n  gap: 6px;\n}\n\n.pera-wallet-modal-header__version-number {\n  color: #9d9dae;\n  font-size: 12px;\n  font-weight: 400;\n  line-height: 18px;\n  letter-spacing: 0.01;\n}\n\n.pera-wallet-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: auto;\n  height: 48px;\n  padding: 14px;\n  border: none;\n  border-radius: 12px;\n  outline: none;\n  cursor: pointer;\n  font-family: var(--pera-wallet-modal-font-family);\n  font-size: 14px;\n}\n\n.pera-wallet-modal-header__close-button {\n  width: 32px;\n  height: 32px;\n  margin: 0;\n  padding: 0;\n  background: rgba(44, 53, 89, 0.1);\n  border-radius: 8px;\n}\n\n.pera-wallet-modal-header__close-button__close-icon {\n  width: 20px;\n  height: 20px;\n}";
      h(g);
      x = document.createElement("template");
      f = Mt() ? "pera-wallet-modal-header pera-wallet-modal-header--mobile" : "pera-wallet-modal-header pera-wallet-modal-header--desktop";
      x.innerHTML = `
  <div class="${f}">
      ${Mt() ? "" : `<div class="pera-wallet-modal-header__brand">
              <img src="data:image/svg+xml,%3csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='24' height='24' rx='4.8' fill='%23FFEE55'/%3e%3cpath d='M13.0408 5.92462C13.413 7.46693 13.2872 8.8236 12.7597 8.95482C12.2322 9.08605 11.5028 7.94214 11.1306 6.39983C10.7583 4.85752 10.8842 3.50085 11.4117 3.36963C11.9391 3.2384 12.6685 4.38231 13.0408 5.92462Z' fill='black'/%3e%3cpath d='M19.1876 7.25063C18.3632 6.37689 16.7231 6.61371 15.5243 7.77959C14.3254 8.94547 14.0219 10.5989 14.8463 11.4727C15.6707 12.3464 17.3108 12.1096 18.5097 10.9437C19.7085 9.77781 20.012 8.12438 19.1876 7.25063Z' fill='black'/%3e%3cpath d='M12.6308 20.6297C13.1583 20.4985 13.2656 19.0651 12.8705 17.4281C12.4754 15.7911 11.7275 14.5705 11.2 14.7017C10.6725 14.8329 10.5652 16.2663 10.9603 17.9033C11.3554 19.5403 12.1033 20.7609 12.6308 20.6297Z' fill='black'/%3e%3cpath d='M7.25371 8.05056C8.77551 8.49933 9.8875 9.28664 9.73741 9.80906C9.58731 10.3315 8.23197 10.3912 6.71016 9.94242C5.18836 9.49364 4.07637 8.70633 4.22646 8.18391C4.37656 7.66149 5.7319 7.60178 7.25371 8.05056Z' fill='black'/%3e%3cpath d='M17.1309 13.9497C18.7461 14.4261 19.9338 15.2357 19.7837 15.7581C19.6336 16.2806 18.2025 16.3179 16.5873 15.8416C14.9721 15.3653 13.7844 14.5556 13.9345 14.0332C14.0846 13.5108 15.5157 13.4734 17.1309 13.9497Z' fill='black'/%3e%3cpath d='M8.96609 12.8536C8.5887 12.4624 7.35088 13.0318 6.20133 14.1253C5.05177 15.2188 4.42581 16.4225 4.80319 16.8137C5.18058 17.2048 6.4184 16.6355 7.56796 15.542C8.71751 14.4484 9.34347 13.2448 8.96609 12.8536Z' fill='black'/%3e%3c/svg%3e" />

              <div class="pera-wallet-modal-header__brand-text">
                <span>Pera Connect</span>

                <span class="pera-wallet-modal-header__version-number">v1.4.2</span>
              </div>
            </div>
            `} 

      <button
        id="pera-wallet-modal-header-close-button"
        class="pera-wallet-button pera-wallet-modal-header__close-button">
        <img
          class="pera-wallet-modal-header__close-button__close-icon"
          src="${Mt() ? "data:image/svg+xml,%3csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M18 6L12 12M12 12L6 18M12 12L18 18M12 12L6 6' stroke='%232C3559' stroke-width='2'/%3e%3c/svg%3e" : "data:image/svg+xml,%3csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M18 6L12 12M12 12L6 18M12 12L18 18M12 12L6 6' stroke='white' stroke-width='2'/%3e%3c/svg%3e"}"
        />
      </button>
    </div>
`;
      u = class extends HTMLElement {
        constructor() {
          if (super(), this.attachShadow({ mode: "open" }), this.shadowRoot) {
            const e2 = document.createElement("style");
            e2.textContent = g, this.shadowRoot.append(x.content.cloneNode(true), e2), this.onClose();
          }
        }
        onClose() {
          var e2;
          const a2 = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.getElementById("pera-wallet-modal-header-close-button"), o3 = this.getAttribute("modal-id");
          a2 && o3 === ct && a2.addEventListener("click", () => {
            vt(ct);
          });
        }
      };
      _ = "data:image/svg+xml,%3csvg fill='none' height='80' width='80' xmlns='http://www.w3.org/2000/svg'%3e%3cpath clip-rule='evenodd' d='M39.9 80V68.99h-9.8V80h-.2V68.99h-3.5a6.503 6.503 0 0 1-6.247-4.7 6.514 6.514 0 0 1-4.445-4.444 6.503 6.503 0 0 1-4.695-6.246v-3.5H0v-.2h11.013v-9.8H0v-.2h11.013v-9.8H0v-.2h11.013v-3.5a6.503 6.503 0 0 1 4.694-6.246 6.513 6.513 0 0 1 4.447-4.447 6.503 6.503 0 0 1 6.246-4.696h3.5V0h.2v11.011h9.8V0h.2v11.011h9.8V0h.2v11.011h3.5a6.503 6.503 0 0 1 6.247 4.697 6.514 6.514 0 0 1 4.443 4.444 6.503 6.503 0 0 1 4.701 6.248v3.5H80v.2H68.991v9.8H80v.2H68.991v9.8H80v.2H68.991v3.5a6.503 6.503 0 0 1-4.701 6.248 6.514 6.514 0 0 1-4.443 4.442 6.503 6.503 0 0 1-6.247 4.7h-3.5V80h-.2V68.99h-9.8V80zm28.89-40.1a28.728 28.728 0 0 0-1.746-9.8h-2.5v9.8h4.247zm-4.246.2h4.247a28.729 28.729 0 0 1-1.747 9.8h-2.5zm-.2-.2v-9.8H60.1v9.8zm-4.244.2h4.244v9.8H60.1zm-.2-.2a19.807 19.807 0 0 0-2.633-9.8H50.1v9.8zm-9.8.2h9.8a19.807 19.807 0 0 1-2.633 9.8H50.1zm-.2-.2v-9.8h-9.8v9.8zm-9.8.2h9.8v9.8h-9.8zm-.2-.2v-9.8h-9.8v9.8zm-9.8.2h9.8v9.8h-9.8zm-.2-.2v-9.8h-7.167a19.807 19.807 0 0 0-2.633 9.8zm-9.8.2h9.8v9.8h-7.167a19.807 19.807 0 0 1-2.633-9.8zm-.2-.2v-9.8h-4.245v9.8zm-4.245.2H19.9v9.8h-4.245zm-.2-.2v-9.8H12.96a28.726 28.726 0 0 0-1.748 9.8h4.242zm-4.242.2h4.242v9.8H12.96a28.726 28.726 0 0 1-1.748-9.8zm0 13.5v-3.5h1.608a28.876 28.876 0 0 0 2.634 5.327v2.617c0 .543.066 1.07.192 1.575a6.303 6.303 0 0 1-4.434-6.019zm4.242 1.449a28.674 28.674 0 0 1-2.42-4.949h2.42zm.2.32V50.1H19.9v9.8h-.702a28.915 28.915 0 0 1-3.543-4.53zM20.1 59.9v-9.8h2.518a20.2 20.2 0 0 0 7.282 7.282V59.9zm0-10h2.403a19.966 19.966 0 0 1-2.403-7.053zm9.8 7.25a20 20 0 0 1-7.05-7.05h7.05zm.2.117V50.1h9.8v9.8a19.807 19.807 0 0 1-9.8-2.633zm10 2.633v-9.8h9.8v7.167a19.807 19.807 0 0 1-9.8 2.633zm10-2.75V50.1h7.05a20 20 0 0 1-7.05 7.05zm0 .232a20.2 20.2 0 0 0 7.282-7.282H59.9v9.8h-9.8zm7.397-7.482H59.9v-7.053a19.966 19.966 0 0 1-2.403 7.053zm2.603 10v-9.8h4.244v5.28a28.91 28.91 0 0 1-3.538 4.52zm4.444-4.841V50.1h2.426a28.67 28.67 0 0 1-2.426 4.959zm0 .378a28.881 28.881 0 0 0 2.64-5.337h1.607v3.5a6.303 6.303 0 0 1-4.44 6.021 6.514 6.514 0 0 0 .193-1.577zm2.713-5.537h1.534v-6.477a28.817 28.817 0 0 1-1.534 6.477zm-56.044 0h1.535a28.807 28.807 0 0 1-1.535-6.477zm57.578-20v-3.5a6.303 6.303 0 0 0-4.44-6.02c.126.504.193 1.031.193 1.575v2.608a28.877 28.877 0 0 1 2.639 5.337zm-1.534.2h1.534v6.477a28.815 28.815 0 0 0-1.534-6.477zm-.288-.2a28.673 28.673 0 0 0-2.425-4.958V29.9zm-2.625 0v-5.279a28.911 28.911 0 0 0-3.538-4.521H60.1v9.8zm-4.444 0v-9.8h-9.8v2.518a20.2 20.2 0 0 1 7.282 7.282zm-2.403.2H59.9v7.053a19.966 19.966 0 0 0-2.403-7.053zm-.347-.2a20 20 0 0 0-7.05-7.05v7.05zm-7.25 0v-7.167a19.807 19.807 0 0 0-9.8-2.633v9.8zm-10 0v-9.8a19.807 19.807 0 0 0-9.8 2.633V29.9zm-10 0v-7.05a20 20 0 0 0-7.05 7.05zm-7.282 0a20.2 20.2 0 0 1 7.282-7.282V20.1h-9.8v9.8zm-2.518.2h2.403a19.966 19.966 0 0 0-2.403 7.053zm-.2-.2v-9.8h-.701a28.915 28.915 0 0 0-3.544 4.53v5.27zm-4.445 0v-4.948a28.665 28.665 0 0 0-2.42 4.948zm-2.634 0a28.874 28.874 0 0 1 2.634-5.327v-2.618c0-.543.066-1.07.191-1.574a6.303 6.303 0 0 0-4.433 6.019v3.5zm-1.608.2h1.535a28.81 28.81 0 0 0-1.535 6.477zM36.58 68.79H30.1v-1.536c2.06.749 4.23 1.27 6.479 1.535zm3.321-.001a28.726 28.726 0 0 1-9.8-1.748v-2.497h9.8zm-10-1.822v-2.423h-4.953a28.678 28.678 0 0 0 4.953 2.423zm10-2.623h-9.8V60.1h9.8zm-10 0V60.1h-9.8v.702a28.915 28.915 0 0 0 4.526 3.542H29.9zm7.254-4.444H30.1v-2.403a19.966 19.966 0 0 0 7.053 2.403zm0-39.8a19.966 19.966 0 0 0-7.054 2.403V20.1h7.053zm2.746-.2h-9.8v-4.245h9.8zm-10 0v-4.245h-5.27a28.907 28.907 0 0 0-4.53 3.544v.701zm10-4.445h-9.8V12.96a28.729 28.729 0 0 1 9.8-1.749zm-10 0v-2.421a28.668 28.668 0 0 0-4.95 2.42h4.95zm6.679-4.244a28.81 28.81 0 0 0-6.479 1.536V11.21h6.479zm-6.679 1.61v-1.61h-3.5a6.303 6.303 0 0 0-6.02 4.436 6.514 6.514 0 0 1 1.575-.192h2.617A28.877 28.877 0 0 1 29.9 12.82zm0 55.968V67.18a28.878 28.878 0 0 1-5.331-2.636h-2.614c-.543 0-1.07-.067-1.575-.192a6.303 6.303 0 0 0 6.02 4.437zm20.2 0h3.5a6.303 6.303 0 0 0 6.02-4.438 6.513 6.513 0 0 1-1.576.193h-2.608a28.879 28.879 0 0 1-5.336 2.638zm-.2-1.534v1.534h-6.475a28.808 28.808 0 0 0 6.475-1.534zm.2-.287a28.671 28.671 0 0 0 4.957-2.424H50.1v2.424zm-.2-2.424v2.499a28.728 28.728 0 0 1-9.8 1.746v-4.245zm.2-.2h5.278a28.914 28.914 0 0 0 4.522-3.538V60.1h-9.8zm-.2-4.244v4.244h-9.8V60.1zm0-2.603V59.9h-7.053a19.966 19.966 0 0 0 7.053-2.403zm0-37.397v2.403a19.966 19.966 0 0 0-7.053-2.403H49.9zm.2-.2h9.8v-.705a28.911 28.911 0 0 0-4.526-3.54H50.1V19.9zm-.2-4.245V19.9h-9.8v-4.245h9.8zm.2-.2h4.954a28.676 28.676 0 0 0-4.954-2.423zm-.2-2.497v2.497h-9.8V11.21a28.75 28.75 0 0 1 9.8 1.747zm.2-.14a28.877 28.877 0 0 1 5.332 2.637h2.612c.543 0 1.071.066 1.576.192a6.303 6.303 0 0 0-6.02-4.436h-3.5zm-.2-1.607v1.534a28.812 28.812 0 0 0-6.475-1.534H49.9zm-34.245 44.53v2.303c0 .567.075 1.117.215 1.64a6.309 6.309 0 0 0 1.643.216h1.41a29.118 29.118 0 0 1-3.268-4.16zm3.458 4.359h-1.6a6.513 6.513 0 0 1-1.578-.193 6.315 6.315 0 0 0 4.157 4.157 6.517 6.517 0 0 1-.192-1.575v-1.602a29.35 29.35 0 0 1-.787-.787zm.787.509a29.029 29.029 0 0 1-.508-.509h.508zm.2.469v1.411c0 .567.075 1.117.215 1.64.523.14 1.073.215 1.64.215h2.3a29.118 29.118 0 0 1-4.155-3.266zm35.649 3.266h2.295c.567 0 1.117-.075 1.64-.216a6.286 6.286 0 0 0 .216-1.639v-1.407a29.116 29.116 0 0 1-4.151 3.262zm4.35-3.454v1.598a6.53 6.53 0 0 1-.192 1.574 6.314 6.314 0 0 0 4.155-4.154 6.509 6.509 0 0 1-1.572.191h-1.6a29.08 29.08 0 0 1-.791.791zm.982-.991h1.41c.565 0 1.114-.075 1.636-.215a6.31 6.31 0 0 0 .216-1.641V55.75a29.113 29.113 0 0 1-3.262 4.15zm3.262-35.65v-2.295c0-.568-.075-1.117-.216-1.64a6.307 6.307 0 0 0-1.637-.215h-1.41a29.112 29.112 0 0 1 3.263 4.15zM60.89 19.9h1.6c.542 0 1.069.066 1.573.192a6.314 6.314 0 0 0-4.156-4.157 6.51 6.51 0 0 1 .192 1.576v1.598c.269.259.532.522.79.791zm-.991-.981V17.51a6.31 6.31 0 0 0-.216-1.64 6.308 6.308 0 0 0-1.64-.216h-2.299a29.108 29.108 0 0 1 4.155 3.264zm-35.641-3.264h-2.304a6.31 6.31 0 0 0-1.639.215 6.306 6.306 0 0 0-.216 1.641v1.412a29.115 29.115 0 0 1 4.159-3.268zM19.9 19.113v-1.602c0-.543.067-1.072.193-1.577a6.315 6.315 0 0 0-4.159 4.16 6.518 6.518 0 0 1 1.58-.194h1.6c.257-.267.519-.53.786-.787zm-.508.787h.508v-.508c-.171.167-.34.337-.508.508zm-.47.2h-1.409a6.31 6.31 0 0 0-1.643.216 6.308 6.308 0 0 0-.215 1.639v2.305a29.107 29.107 0 0 1 3.268-4.16zm41.178-.712c.173.168.344.34.512.512H60.1zm.513 40.712c-.169.173-.34.344-.513.513V60.1z' fill='%2394a3b8' fill-rule='evenodd'/%3e%3crect fill='black' height='80' rx='16' width='80'/%3e%3cpath d='M43.47 19.752c1.24 5.14.821 9.663-.937 10.1-1.758.438-4.19-3.375-5.43-8.517-1.241-5.14-.822-9.663.936-10.1 1.759-.438 4.19 3.376 5.43 8.517zm20.49 4.42c-2.749-2.913-8.216-2.123-12.212 1.763s-5.008 9.398-2.26 12.31 8.215 2.123 12.211-1.763 5.008-9.398 2.26-12.31zM42.102 68.769c1.758-.438 2.116-5.216.8-10.673-1.318-5.456-3.81-9.525-5.57-9.088-1.757.438-2.115 5.216-.798 10.672 1.317 5.457 3.81 9.526 5.568 9.089zM24.18 26.838c5.073 1.496 8.78 4.12 8.28 5.862-.5 1.741-5.019 1.94-10.091.444-5.073-1.496-8.78-4.12-8.28-5.861.501-1.742 5.019-1.941 10.092-.445zm32.924 19.664c5.384 1.588 9.343 4.286 8.843 6.028-.5 1.741-5.27 1.866-10.654.278-5.385-1.588-9.343-4.286-8.843-6.028.5-1.741 5.27-1.866 10.654-.278zm-27.216-3.654c-1.258-1.304-5.384.594-9.215 4.24-3.832 3.644-5.919 7.656-4.66 8.96 1.257 1.304 5.383-.594 9.215-4.239s5.918-7.657 4.66-8.96z' fill='%23fe5'/%3e%3c/svg%3e";
      b = ".pera-wallet-download-qr-code-wrapper {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: fit-content;\n  margin: 26px auto 0;\n  padding: 10px;\n  box-shadow: 0px 20px 60px rgba(26, 35, 91, 0.15), 0px 4px 12px rgba(26, 35, 91, 0.05), 0px 1px 4px rgba(26, 35, 91, 0.06);\n  border-radius: 24px;\n}\n\n@media (max-width: 767px) {\n  .pera-wallet-download-qr-code-wrapper {\n    margin-top: 51px;\n  }\n}";
      h(b);
      v = document.createElement("template");
      v.innerHTML = '\n  <div id="pera-wallet-download-qr-code-wrapper" class="pera-wallet-download-qr-code-wrapper"></div>  \n';
      C = class extends HTMLElement {
        constructor() {
          if (super(), this.attachShadow({ mode: "open" }), this.shadowRoot) {
            const e2 = document.createElement("style");
            e2.textContent = b, this.shadowRoot.append(v.content.cloneNode(true), e2);
          }
        }
        connectedCallback() {
          var e2;
          const n3 = new import_qr_code_styling.default({ width: 205, height: 205, type: "svg", data: Wt, image: _, dotsOptions: { color: "#000", type: "extra-rounded" }, imageOptions: { crossOrigin: "anonymous", margin: 10 }, cornersSquareOptions: { type: "extra-rounded" }, cornersDotOptions: { type: "dot" } }), t = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.getElementById("pera-wallet-download-qr-code-wrapper");
          t && n3.append(t);
        }
      };
      k = "data:image/svg+xml,%3csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M8.5 19L15.5 12L8.5 5' stroke='%233C3C49' stroke-width='2'/%3e%3c/svg%3e";
      y = ".pera-wallet-connect-modal-desktop-mode {\n  display: grid;\n  grid-template-columns: 205px auto;\n  gap: 70px;\n}\n.pera-wallet-connect-modal-desktop-mode--default .pera-wallet-connect-modal-desktop-mode__default-view {\n  display: block;\n}\n.pera-wallet-connect-modal-desktop-mode--default .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-accordion-item--active .pera-wallet-accordion-item__content {\n  height: 364px;\n}\n.pera-wallet-connect-modal-desktop-mode--default .pera-wallet-connect-modal-desktop-mode__default-view--web-wallet-not-avaliable .pera-wallet-accordion-item--web-wallet {\n  display: none;\n}\n.pera-wallet-connect-modal-desktop-mode--default .pera-wallet-connect-modal-desktop-mode__default-view--web-wallet-not-avaliable .pera-wallet-accordion-item .pera-wallet-accordion-toggle {\n  padding: 26px 24px 12px;\n  border-radius: 24px 24px 0 0;\n  transition: all ease-in 0.2s;\n}\n.pera-wallet-connect-modal-desktop-mode--default .pera-wallet-connect-modal-desktop-mode__default-view--web-wallet-not-avaliable .pera-wallet-accordion-item .pera-wallet-accordion-item__content {\n  height: 434px;\n  border-radius: 0 0 24px 24px;\n  transition: height ease-in 0.2s;\n}\n.pera-wallet-connect-modal-desktop-mode--default .pera-wallet-connect-modal-desktop-mode__default-view--web-wallet-not-avaliable .pera-wallet-accordion-item .pera-wallet-accordion-icon {\n  transform: rotate(90deg);\n}\n.pera-wallet-connect-modal-desktop-mode--default .pera-wallet-connect-modal-desktop-mode__default-view--web-wallet-not-avaliable .pera-wallet-connect-modal-desktop-mode__download-pera-description {\n  margin-top: 50px;\n}\n.pera-wallet-connect-modal-desktop-mode--default .pera-wallet-connect-modal-desktop-mode__download-view {\n  display: none;\n}\n.pera-wallet-connect-modal-desktop-mode--download .pera-wallet-connect-modal-desktop-mode__default-view {\n  display: none;\n}\n.pera-wallet-connect-modal-desktop-mode--download .pera-wallet-connect-modal-desktop-mode__download-view {\n  display: block;\n}\n.pera-wallet-connect-modal-desktop-mode--download .pera-wallet-connect-modal-desktop-mode__download-view .pera-wallet-connect-modal-download-pera-view__footer a {\n  display: flex;\n  cursor: pointer;\n}\n.pera-wallet-connect-modal-desktop-mode--compact {\n  grid-template-columns: unset;\n  gap: unset;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__web-wallet {\n  padding: 28px 40px;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__web-wallet .pera-wallet-connect-modal-desktop-mode__web-wallet__logo-wrapper {\n  box-shadow: unset;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__web-wallet .pera-wallet-connect-modal-desktop-mode__web-wallet__description {\n  margin-bottom: 16px;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__web-wallet .pera-wallet-connect-modal-desktop-mode__web-wallet__launch-button {\n  width: 172px;\n  height: 40px;\n  margin: 0 auto;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__web-wallet-iframe {\n  height: 100%;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view {\n  overflow: hidden;\n  border-radius: 24px;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-accordion-item {\n  margin-bottom: 0;\n  border-radius: 0;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-accordion-item:not(:last-child) {\n  border-bottom: 1px solid #e6e8ee;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-accordion-item #pera-wallet-iframe {\n  height: 100%;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-accordion-toggle {\n  padding: 20px;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-accordion-toggle__text, .pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-accordion-toggle__content-with-label__text {\n  color: #626268;\n  font-size: 14px;\n  font-weight: 500;\n  line-height: 24px;\n  letter-spacing: -0.09px;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-accordion-toggle__bold-color {\n  font-weight: 600;\n  color: #1a1a1a;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-accordion-item--active .pera-wallet-accordion-item__content {\n  height: 265px;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-connect-modal-desktop-mode__download-pera-container {\n  display: flex;\n  justify-content: space-between;\n  margin-top: 14px;\n  padding: 0 20px;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-connect-modal-desktop-mode__download-pera-description,\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-connect-modal-desktop-mode__download-pera-button {\n  margin: 0;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-connect-modal-desktop-mode__download-pera-button {\n  font-weight: 500;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-connect-qr-code-wrapper {\n  margin: 4px auto 0;\n  padding: 0;\n  box-shadow: unset;\n}\n.pera-wallet-connect-modal-desktop-mode--compact .pera-wallet-connect-modal-desktop-mode__default-view .pera-wallet-connect-qr-code-wrapper svg {\n  padding: 8px;\n  box-shadow: 0px 20px 60px rgba(26, 35, 91, 0.15), 0px 4px 12px rgba(26, 35, 91, 0.05), 0px 1px 4px rgba(26, 35, 91, 0.06);\n  border-radius: 12px;\n}\n.pera-wallet-connect-modal-desktop-mode--select-account {\n  width: 100%;\n  height: 100%;\n}\n.pera-wallet-connect-modal-desktop-mode--select-account.pera-wallet-connect-modal-desktop-mode--default {\n  overflow: hidden;\n}\n.pera-wallet-connect-modal-desktop-mode--select-account .pera-wallet-connect-modal-desktop-mode__web-wallet-iframe {\n  position: unset;\n}\n.pera-wallet-connect-modal-desktop-mode--select-account .pera-wallet-accordion {\n  overflow: hidden;\n}\n.pera-wallet-connect-modal-desktop-mode--select-account #pera-wallet-iframe {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 3;\n  width: 100%;\n  height: 100%;\n  border-radius: 16px;\n}\n\n.pera-wallet-connect-modal-desktop-mode__accordion__description,\n.pera-wallet-connect-modal-desktop-mode__connect-button-wrapper {\n  padding: 0 40px 20px 64px;\n}\n\n.pera-wallet-connect-modal-desktop-mode__web-wallet {\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  height: calc(100% - 88px);\n  padding: 48px 52px 40px;\n  margin: 0 auto;\n}\n\n.pera-wallet-connect-modal-desktop-mode__web-wallet__logo-wrapper {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 72px;\n  height: 72px;\n  margin: 0 auto 16px;\n  background: #ffffff;\n  border-radius: 50%;\n  box-shadow: 0px 0px 1px rgba(12, 26, 75, 0.1), 0px 10px 16px rgba(20, 37, 63, 0.06);\n}\n\n.pera-wallet-connect-modal-desktop-mode__web-wallet__description {\n  margin: 0 auto 32px;\n  font-size: 14px;\n  line-height: 24px;\n  letter-spacing: -0.1px;\n  text-align: center;\n  color: #6a6a81;\n}\n\n.pera-wallet-connect-modal-desktop-mode__web-wallet__launch-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 8px;\n  width: 100%;\n  padding: 14px 0;\n  color: #ffffff;\n  background-color: #6b46fe;\n  border-radius: 12px;\n  font-size: 14px;\n  font-weight: 500;\n  line-height: 20px;\n  letter-spacing: -0.1;\n  border: none;\n  outline: none;\n  cursor: pointer;\n}\n\n.pera-wallet-connect-modal-desktop-mode__web-wallet-iframe {\n  position: relative;\n  width: fit-content;\n  margin: 0 auto;\n}\n\n.pera-wallet-connect-modal-desktop-mode__connect-button {\n  display: block;\n  width: 100%;\n  height: 48px;\n  border: unset;\n  border-radius: 6px;\n  background-color: #333333;\n  color: white;\n  cursor: pointer;\n  font-family: var(--pera-wallet-modal-font-family);\n  font-size: 13px;\n}\n\n.pera-wallet-connect-qr-code-wrapper {\n  width: fit-content;\n  margin: 24px auto 0;\n  padding: 10px;\n  box-shadow: 0px 20px 60px rgba(26, 35, 91, 0.15), 0px 4px 12px rgba(26, 35, 91, 0.05), 0px 1px 4px rgba(26, 35, 91, 0.06);\n  border-radius: 24px;\n}\n\n.pera-wallet-connect-modal-desktop-mode__download-pera-description {\n  color: #838aa6;\n  text-align: center;\n  margin: 32px 0 12px;\n  font-size: 13px;\n  font-weight: 500;\n  line-height: 20px;\n  letter-spacing: -0.04px;\n}\n\n.pera-wallet-connect-modal-desktop-mode__download-pera-button {\n  display: flex;\n  align-items: center;\n  gap: 8px;\n  margin: 0 auto;\n  padding: 0;\n  color: #6b46fe;\n  background-color: transparent;\n  outline: none;\n  border: none;\n  font-weight: 600;\n  font-size: 13px;\n  line-height: 20px;\n  letter-spacing: 0.01px;\n  cursor: pointer;\n}\n\n.pera-wallet-connect-modal-download-pera-view__back-button {\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  margin-bottom: 14px;\n  padding: 12px 24px;\n  color: #3c3c49;\n  background-color: #ffffff;\n  outline: none;\n  box-shadow: 0px 0px 1px rgba(12, 26, 75, 0.24), 0px 3px 8px -1px rgba(50, 50, 71, 0.05);\n  border: unset;\n  border-radius: 24px;\n  font-size: 14px;\n  font-weight: 600;\n  line-height: 24px;\n  letter-spacing: -0.1px;\n  cursor: pointer;\n}\n\n.pera-wallet-connect-modal-download-pera-view {\n  padding: 32px 37px 28px;\n  background-color: #ffffff;\n  box-shadow: 0px 0px 1px rgba(12, 26, 75, 0.24), 0px 3px 8px -1px rgba(50, 50, 71, 0.05);\n  border-radius: 24px;\n}\n\n.pera-wallet-connect-modal-download-pera-view__title {\n  margin-bottom: 8px;\n  color: #3c3c49;\n  font-weight: 600;\n  font-size: 15px;\n  line-height: 18px;\n  text-align: center;\n  letter-spacing: -0.13px;\n}\n\n.pera-wallet-connect-modal-download-pera-view__footer {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 12px;\n  margin-top: 53px;\n}\n\n.pera-wallet-connect-modal-download-pera-view__footer__button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 8px;\n  padding: 8px 16px;\n  color: #6a6a81;\n  background-color: #ffffff;\n  box-shadow: 0px 0px 1px rgba(12, 26, 75, 0.24), 0px 3px 8px -1px rgba(50, 50, 71, 0.05);\n  text-decoration: none;\n  border-radius: 12px;\n  font-weight: 500;\n  font-size: 13px;\n  line-height: 200%;\n  letter-spacing: -0.04px;\n  cursor: pointer;\n}\n\n#pera-wallet-iframe {\n  width: 285px;\n  height: 376px;\n  margin: 0 auto;\n  border: none;\n}\n\n@media (max-width: 767px) {\n  .pera-wallet-connect-modal-desktop-mode {\n    grid-template-columns: 1fr;\n    gap: 24px;\n  }\n  .pera-wallet-connect-qr-code-wrapper {\n    margin-top: 16px;\n  }\n  .pera-wallet-connect-modal-download-pera-view {\n    padding: 24px;\n  }\n  .pera-wallet-download-qr-code-wrapper {\n    margin-top: 32px;\n  }\n  .pera-wallet-connect-modal-download-pera-view__footer {\n    margin-top: 40px;\n  }\n}";
      h(y);
      L = ".pera-wallet-accordion-item {\n  background-color: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0px 1px 4px rgba(0, 0, 0, 0.02), 0px 4px 12px rgba(0, 0, 0, 0.03);\n}\n.pera-wallet-accordion-item:not(:last-of-type) {\n  margin-bottom: 20px;\n}\n.pera-wallet-accordion-item:not(:last-of-type) .pera-wallet-accordion-panel {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.pera-wallet-accordion-item .pera-wallet-accordion-item__content {\n  height: 0;\n  overflow: hidden;\n  color: #69708d;\n  background-color: #ffffff;\n  font-size: 13px;\n  font-weight: 500;\n  line-height: 20px;\n  letter-spacing: -0.04px;\n  transition: height ease-in 0.2s;\n}\n.pera-wallet-accordion-item--active .pera-wallet-accordion-toggle {\n  padding: 26px 24px 12px;\n  border-radius: 24px 24px 0 0;\n  transition: all ease-in 0.2s;\n}\n.pera-wallet-accordion-item--active .pera-wallet-accordion-item__content {\n  border-radius: 0 0 24px 24px;\n  transition: height ease-in 0.2s;\n}\n.pera-wallet-accordion-item--active .pera-wallet-accordion-icon {\n  transform: rotate(90deg);\n}\n\n.pera-wallet-accordion-toggle {\n  position: relative;\n  display: flex;\n  align-items: center;\n  gap: 16px;\n  padding: 12px 24px;\n  color: #2c3559;\n  background-color: #ffffff;\n  border: none;\n  border-radius: 24px;\n  outline: none;\n  cursor: pointer;\n  font-size: 16px;\n  line-height: 18px;\n  letter-spacing: -0.1px;\n  font-weight: 600;\n  transition: all ease-in 0.2s;\n}\n.pera-wallet-accordion-toggle__text, .pera-wallet-accordion-toggle__content-with-label__text {\n  color: #626268;\n}\n\n.pera-wallet-accordion-icon {\n  transition: all ease-in 0.2s;\n}\n\n.pera-wallet-accordion-toggle__bold-color {\n  color: #1A1A1A;\n  font-weight: 600;\n}\n\n.pera-wallet-accordion-toggle__content-with-label {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n}\n\n.pera-wallet-accordion-toggle__label {\n  padding: 4px 9px;\n  color: #1C786C;\n  background: #E0FAEE;\n  border-radius: 12px;\n  font-size: 11px;\n  font-weight: 600;\n  line-height: 18px;\n  letter-spacing: 0.01px;\n}\n\n.pera-wallet-accordion-toggle__button {\n  position: absolute;\n  z-index: 2;\n  width: 100%;\n  height: 100%;\n  background: transparent;\n  box-shadow: none;\n  outline: none;\n  border: none;\n  cursor: pointer;\n}\n\n@media (max-width: 767px) {\n  .pera-wallet-accordion-toggle {\n    font-size: 14px;\n    font-weight: 500;\n    line-height: 24px;\n    letter-spacing: -0.1px;\n  }\n}";
      h(L);
      M = document.createElement("template");
      z = document.createElement("style");
      E = document.createElement("style");
      z.textContent = y, E.textContent = L;
      M.innerHTML = `
  <div id="pera-wallet-connect-modal-desktop-mode" class="pera-wallet-connect-modal-desktop-mode pera-wallet-connect-modal-desktop-mode--default">
      <pera-wallet-connect-modal-information-section></pera-wallet-connect-modal-information-section>

      <div class="pera-wallet-connect-modal-desktop-mode__default-view"></div>
       

      <div class="pera-wallet-connect-modal-desktop-mode__download-view">
        <button
          id="pera-wallet-connect-modal-download-pera-view-back-button"
          class="pera-wallet-connect-modal-download-pera-view__back-button">
          <img
            src="data:image/svg+xml,%3csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath fill-rule='evenodd' clip-rule='evenodd' d='M10.7071 6.29387C11.0976 6.68439 11.0976 7.31756 10.7071 7.70808L7.41421 11.001L19 11.001C19.5523 11.001 20 11.4487 20 12.001C20 12.5533 19.5523 13.001 19 13.001L7.41421 13.001L10.7071 16.2939C11.0976 16.6844 11.0976 17.3176 10.7071 17.7081C10.3166 18.0986 9.68342 18.0986 9.29289 17.7081L4.29289 12.7081C4.10536 12.5205 4 12.2662 4 12.001C4 11.7358 4.10536 11.4814 4.29289 11.2939L9.29289 6.29387C9.68342 5.90335 10.3166 5.90335 10.7071 6.29387Z' fill='%233C3C49'/%3e%3c/svg%3e"
            alt="Back Arrow"
          />

          Back
        </button>

        <div class="pera-wallet-connect-modal-download-pera-view">
          <h1 class="pera-wallet-connect-modal-download-pera-view__title">
            Download Pera Wallet
          </h1>

          <pera-wallet-download-qr-code></pera-wallet-download-qr-code>

          <div class="pera-wallet-connect-modal-download-pera-view__footer">
            <a
              href="https://apps.apple.com/us/app/algorand-wallet/id1459898525"
              target="_blank"
              rel="noopener noreferrer">
              <img src="data:image/svg+xml,%3csvg width='40' height='40' viewBox='0 0 40 40' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='40' height='40' rx='12' fill='black'/%3e%3cpath d='M25.6308 20.3011C25.6416 19.4664 25.8633 18.6481 26.2753 17.9221C26.6873 17.1962 27.2763 16.5863 27.9873 16.1491C27.5356 15.5039 26.9397 14.973 26.2469 14.5984C25.554 14.2239 24.7834 14.016 23.9963 13.9914C22.317 13.8151 20.6891 14.9962 19.8333 14.9962C18.9611 14.9962 17.6436 14.0089 16.2249 14.0381C15.3072 14.0677 14.4128 14.3346 13.6289 14.8126C12.8451 15.2906 12.1984 15.9636 11.7519 16.7659C9.81789 20.1144 11.2605 25.0354 13.1132 27.742C14.0401 29.0674 15.1233 30.5478 16.5408 30.4953C17.9278 30.4378 18.4458 29.6108 20.1202 29.6108C21.779 29.6108 22.265 30.4953 23.7112 30.4619C25.1995 30.4378 26.1372 29.1307 27.0316 27.7928C27.6976 26.8484 28.2101 25.8047 28.55 24.7003C27.6853 24.3345 26.9474 23.7224 26.4283 22.9401C25.9092 22.1578 25.6318 21.2399 25.6308 20.3011ZM22.8993 12.2113C23.7108 11.2371 24.1106 9.98492 24.0138 8.7207C22.7739 8.85092 21.6287 9.44347 20.8062 10.3803C20.404 10.838 20.096 11.3704 19.8998 11.9472C19.7035 12.5239 19.6229 13.1337 19.6625 13.7417C20.2826 13.7481 20.8961 13.6137 21.4568 13.3486C22.0175 13.0835 22.5107 12.6946 22.8993 12.2113Z' fill='white'/%3e%3c/svg%3e" alt="App Store icon" />
            </a>

            <a
              href="https://play.google.com/store/apps/details?id=com.algorand.android"
              target="_blank"
              rel="noopener noreferrer">
              <img src="data:image/svg+xml,%3csvg width='40' height='40' viewBox='0 0 40 40' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='40' height='40' rx='12' fill='black'/%3e%3cpath d='M12.41 9.7719C12.1334 10.0219 11.9683 10.4388 11.9683 10.9922V10.8671V29.1294V29.0091C11.9683 29.5202 12.1099 29.9149 12.3497 30.169L12.4109 30.2277V30.228C12.6051 30.4035 12.854 30.4966 13.1393 30.4963C13.418 30.4963 13.7316 30.4073 14.0626 30.2194L26.0264 23.4107L30.1359 21.0717C30.6578 20.7748 30.9508 20.3917 30.9998 20.0014V19.9998C30.9508 19.6087 30.6578 19.2259 30.1359 18.9289L26.0261 16.5902L14.0627 9.78154C13.731 9.59325 13.4171 9.50391 13.1376 9.50391C12.8527 9.50391 12.6041 9.59677 12.41 9.7719H12.41Z' fill='%2300C1FF'/%3e%3cpath d='M12.411 30.2285L12.3497 30.1698C12.1099 29.9157 11.9683 29.5209 11.9683 29.0098V29.1301V10.8724V10.993C11.9683 10.4396 12.1334 10.0226 12.41 9.77268L22.622 20.0009L12.411 30.2285Z' fill='url(%23paint0_linear_173_14441)'/%3e%3cpath d='M26.0256 23.4102L22.6211 19.9996L26.0253 16.5896L30.1351 18.9283C30.657 19.2253 30.95 19.6081 30.9989 19.9993V20.0008C30.95 20.3911 30.657 20.7742 30.1351 21.0712L26.0256 23.4101' fill='url(%23paint1_linear_173_14441)'/%3e%3cpath d='M13.1374 30.4961C12.8522 30.4964 12.6033 30.4032 12.4092 30.2277V30.2275L22.6202 19.9999L26.0246 23.4104L14.0608 30.2191C13.7298 30.4071 13.4162 30.4961 13.1374 30.4961Z' fill='url(%23paint2_linear_173_14441)'/%3e%3cpath d='M22.6212 20.002L12.4092 9.7737C12.6033 9.59858 12.8519 9.50571 13.1368 9.50571C13.4163 9.50571 13.7302 9.59501 14.0618 9.78335L26.0253 16.592L22.6212 20.002' fill='url(%23paint3_linear_173_14441)'/%3e%3cpath d='M13.1394 30.6172C12.8542 30.6172 12.6049 30.524 12.4108 30.3486L12.4105 30.3489C12.4097 30.3481 12.4088 30.3473 12.4079 30.3466L12.3548 30.2947C12.3531 30.2931 12.3516 30.2912 12.3496 30.2893L12.4108 30.2279C12.6049 30.4034 12.8538 30.4966 13.1392 30.4962C13.4179 30.4962 13.7315 30.4073 14.0625 30.2193L26.0263 23.4106L26.1029 23.4874L26.0253 23.5316L14.0625 30.3398C13.7608 30.5111 13.4739 30.6004 13.2147 30.6153C13.1896 30.6165 13.1645 30.6171 13.1394 30.6172' fill='url(%23paint4_linear_173_14441)'/%3e%3cpath d='M12.3497 30.2891C12.1099 30.0349 11.9683 29.6406 11.9683 29.1292V29.0089C11.9683 29.52 12.1099 29.9146 12.3497 30.1688L12.4109 30.2275L12.3497 30.2891Z' fill='url(%23paint5_linear_173_14441)'/%3e%3cpath d='M26.1025 23.4882L26.0259 23.4114L30.1349 21.0727C30.6568 20.7758 30.9498 20.3927 30.9987 20.0025C30.9987 20.1457 30.9668 20.2889 30.9035 20.4282C30.7756 20.7091 30.5194 20.9744 30.135 21.1934L26.1025 23.4883' fill='url(%23paint6_linear_173_14441)'/%3e%3cpath d='M30.9991 20C30.9501 19.6089 30.6571 19.2261 30.1353 18.9291L26.0259 16.5907L26.1025 16.5139H26.1029L30.1353 18.8088C30.7106 19.1365 30.9987 19.5682 30.9991 20Z' fill='url(%23paint7_linear_173_14441)'/%3e%3cpath d='M11.9683 10.9922V10.8661C11.9683 10.8206 11.9695 10.7761 11.9718 10.7329V10.7309C11.9718 10.7303 11.9718 10.7297 11.972 10.729V10.7242C11.9969 10.284 12.1334 9.94066 12.3497 9.71139L12.4099 9.77198C12.1334 10.0219 11.9683 10.4388 11.9683 10.9922Z' fill='url(%23paint8_linear_173_14441)'/%3e%3cpath d='M26.026 16.5898L14.0625 9.78115C13.7308 9.59285 13.417 9.50355 13.1375 9.50355C12.8525 9.50355 12.6039 9.59642 12.4099 9.77154L12.3496 9.71091C12.3684 9.69096 12.388 9.67172 12.4082 9.65322C12.4089 9.65255 12.4099 9.65188 12.4105 9.65125C12.6031 9.47747 12.849 9.3846 13.1314 9.38293H13.1375C13.417 9.38293 13.7308 9.47227 14.0625 9.66064L26.1029 16.5128L26.1026 16.513L26.026 16.5898Z' fill='url(%23paint9_linear_173_14441)'/%3e%3cdefs%3e%3clinearGradient id='paint0_linear_173_14441' x1='18.4943' y1='10.6794' x2='9.69389' y2='19.494' gradientUnits='userSpaceOnUse'%3e%3cstop stop-color='%2300A0FF'/%3e%3cstop offset='0.00657' stop-color='%2300A1FF'/%3e%3cstop offset='0.2601' stop-color='%2300BEFF'/%3e%3cstop offset='0.5122' stop-color='%2300D2FF'/%3e%3cstop offset='0.7604' stop-color='%2300DFFF'/%3e%3cstop offset='1' stop-color='%2300E3FF'/%3e%3c/linearGradient%3e%3clinearGradient id='paint1_linear_173_14441' x1='31.6348' y1='19.9407' x2='11.691' y2='19.9407' gradientUnits='userSpaceOnUse'%3e%3cstop stop-color='%23FFE000'/%3e%3cstop offset='0.4087' stop-color='%23FFBD00'/%3e%3cstop offset='0.7754' stop-color='orange'/%3e%3cstop offset='1' stop-color='%23FF9C00'/%3e%3c/linearGradient%3e%3clinearGradient id='paint2_linear_173_14441' x1='24.2172' y1='23.2425' x2='9.30414' y2='38.0705' gradientUnits='userSpaceOnUse'%3e%3cstop stop-color='%23FF3A44'/%3e%3cstop offset='1' stop-color='%23C31162'/%3e%3c/linearGradient%3e%3clinearGradient id='paint3_linear_173_14441' x1='9.77725' y1='8.25731' x2='16.4237' y2='14.876' gradientUnits='userSpaceOnUse'%3e%3cstop stop-color='%2332A071'/%3e%3cstop offset='0.0685' stop-color='%232DA771'/%3e%3cstop offset='0.4762' stop-color='%2315CF74'/%3e%3cstop offset='0.8009' stop-color='%2306E775'/%3e%3cstop offset='1' stop-color='%2300F076'/%3e%3c/linearGradient%3e%3clinearGradient id='paint4_linear_173_14441' x1='24.2114' y1='25.6084' x2='12.2683' y2='37.5709' gradientUnits='userSpaceOnUse'%3e%3cstop stop-color='%23CC2E36'/%3e%3cstop offset='1' stop-color='%239C0E4E'/%3e%3c/linearGradient%3e%3clinearGradient id='paint5_linear_173_14441' x1='13.3285' y1='10.6804' x2='5.57625' y2='18.4453' gradientUnits='userSpaceOnUse'%3e%3cstop stop-color='%23008DE0'/%3e%3cstop offset='0.00657' stop-color='%23008DE0'/%3e%3cstop offset='0.2601' stop-color='%2300A7E0'/%3e%3cstop offset='0.5122' stop-color='%2300B8E0'/%3e%3cstop offset='0.7604' stop-color='%2300C4E0'/%3e%3cstop offset='1' stop-color='%2300C7E0'/%3e%3c/linearGradient%3e%3clinearGradient id='paint6_linear_173_14441' x1='31.6346' y1='20.0018' x2='11.6929' y2='20.0018' gradientUnits='userSpaceOnUse'%3e%3cstop stop-color='%23E0C500'/%3e%3cstop offset='0.4087' stop-color='%23E0A600'/%3e%3cstop offset='0.7754' stop-color='%23E09100'/%3e%3cstop offset='1' stop-color='%23E08900'/%3e%3c/linearGradient%3e%3clinearGradient id='paint7_linear_173_14441' x1='31.6349' y1='20.0008' x2='11.6933' y2='20.0008' gradientUnits='userSpaceOnUse'%3e%3cstop stop-color='%23FFE840'/%3e%3cstop offset='0.4087' stop-color='%23FFCE40'/%3e%3cstop offset='0.7754' stop-color='%23FFBC40'/%3e%3cstop offset='1' stop-color='%23FFB540'/%3e%3c/linearGradient%3e%3clinearGradient id='paint8_linear_173_14441' x1='13.3201' y1='10.6927' x2='5.8533' y2='17.8475' gradientUnits='userSpaceOnUse'%3e%3cstop stop-color='%2340B8FF'/%3e%3cstop offset='0.00657' stop-color='%2340B9FF'/%3e%3cstop offset='0.2601' stop-color='%2340CEFF'/%3e%3cstop offset='0.5122' stop-color='%2340DDFF'/%3e%3cstop offset='0.7604' stop-color='%2340E7FF'/%3e%3cstop offset='1' stop-color='%2340EAFF'/%3e%3c/linearGradient%3e%3clinearGradient id='paint9_linear_173_14441' x1='9.76302' y1='10.4182' x2='15.0961' y2='15.76' gradientUnits='userSpaceOnUse'%3e%3cstop stop-color='%2365B895'/%3e%3cstop offset='0.0685' stop-color='%2362BD95'/%3e%3cstop offset='0.4762' stop-color='%2350DB97'/%3e%3cstop offset='0.8009' stop-color='%2344ED98'/%3e%3cstop offset='1' stop-color='%2340F498'/%3e%3c/linearGradient%3e%3c/defs%3e%3c/svg%3e" alt="Play Store icon" />
            </a>

            <a
              class="pera-wallet-connect-modal-download-pera-view__footer__button"
              href="https://perawallet.s3-eu-west-3.amazonaws.com/android-releases/app-pera-prod-release-bitrise-signed.apk"
              target="_blank"
              rel="noopener noreferrer">
              <img src="data:image/svg+xml,%3csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M3 14V20C3 20.5523 3.44772 21 4 21H20C20.5523 21 21 20.5523 21 20V14' stroke='%232C3559' stroke-width='1.5'/%3e%3cpath d='M11.9998 16V3M11.9998 16L7.47803 11.4783M11.9998 16L16.5215 11.4783' stroke='%232C3559' stroke-width='1.5'/%3e%3c/svg%3e" alt="Download icon" />

              Download APK File
            </a>
          </div>
        </div>
      </div>
    </div>
  `;
      Z = class extends HTMLElement {
        constructor() {
          var e2;
          if (super(), this.attachShadow({ mode: "open" }), this.shadowRoot) {
            this.shadowRoot.append(M.content.cloneNode(true), z, E), this.shadowRoot.addEventListener("click", (e3) => {
              this.handleAccordion(e3);
            });
            if ("true" === this.getAttribute("compact-mode")) {
              const e3 = this.shadowRoot.getElementById("pera-wallet-connect-modal-desktop-mode");
              null == e3 || e3.classList.add("pera-wallet-connect-modal-desktop-mode--compact");
            }
            const n3 = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.querySelector(".pera-wallet-connect-modal-desktop-mode__default-view"), t = "true" === this.getAttribute("promote-mobile"), { webWalletOption: a2, mobileWalletOption: o3 } = function(e3) {
              const n4 = `
  <div id="web-wallet-option" class="pera-wallet-accordion-item ${e3 ? "" : "pera-wallet-accordion-item--active"}  pera-wallet-accordion-item--web-wallet">
            <a class="pera-wallet-accordion-toggle">
              <button class="pera-wallet-accordion-toggle__button"></button>
  
              <img src="${k}" class="pera-wallet-accordion-icon" />
  
              <div class="pera-wallet-accordion-toggle__content-with-label">
                <div class="pera-wallet-accordion-toggle__content-with-label__text">
                  Connect With
  
                  <span class="pera-wallet-accordion-toggle__bold-color">
                    Pera Web
                  </span>
                </div>
  
                <span id="pera-web-new-label" class="pera-wallet-accordion-toggle__label">NEW</span>
              </div>
            </a>
  
            <div class="pera-wallet-accordion-item__content">
              <div class="pera-wallet-connect-modal-desktop-mode__web-wallet"><div>
              
              <div
                class="pera-wallet-connect-modal-desktop-mode__web-wallet__logo-wrapper">
                <img src="data:image/svg+xml,%3csvg width='44' height='44' viewBox='0 0 44 44' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3crect x='3.5' y='7.5' width='36' height='26' rx='5.5' stroke='%236B46FE' stroke-width='3'/%3e%3cpath d='M22.4973 14.5237C22.8556 16.041 22.7344 17.3757 22.2267 17.5048C21.719 17.6339 21.0169 16.5085 20.6586 14.9912C20.3003 13.4739 20.4214 12.1392 20.9292 12.0101C21.4369 11.881 22.1389 13.0064 22.4973 14.5237Z' fill='%236B46FE'/%3e%3cpath d='M28.4139 15.8282C27.6204 14.9686 26.0417 15.2016 24.8877 16.3486C23.7338 17.4956 23.4417 19.1222 24.2352 19.9818C25.0287 20.8414 26.6074 20.6084 27.7613 19.4614C28.9153 18.3144 29.2074 16.6878 28.4139 15.8282Z' fill='%236B46FE'/%3e%3cpath d='M22.1027 28.9905C22.6104 28.8614 22.7137 27.4512 22.3334 25.8407C21.9531 24.2303 21.2332 23.0294 20.7254 23.1585C20.2177 23.2876 20.1144 24.6978 20.4947 26.3083C20.875 27.9187 21.5949 29.1196 22.1027 28.9905Z' fill='%236B46FE'/%3e%3cpath d='M16.9269 16.6152C18.3917 17.0567 19.4621 17.8312 19.3176 18.3452C19.1731 18.8591 17.8686 18.9179 16.4037 18.4764C14.9389 18.0349 13.8686 17.2603 14.0131 16.7464C14.1575 16.2324 15.4621 16.1737 16.9269 16.6152Z' fill='%236B46FE'/%3e%3cpath d='M26.4342 22.4188C27.9889 22.8874 29.1322 23.6839 28.9877 24.1979C28.8432 24.7118 27.4657 24.7486 25.911 24.28C24.3563 23.8114 23.213 23.0148 23.3575 22.5009C23.502 21.9869 24.8795 21.9502 26.4342 22.4188Z' fill='%236B46FE'/%3e%3cpath d='M18.5752 21.3404C18.2119 20.9555 17.0205 21.5157 15.914 22.5915C14.8075 23.6673 14.2049 24.8514 14.5682 25.2363C14.9314 25.6211 16.1229 25.061 17.2294 23.9852C18.3359 22.9094 18.9384 21.7253 18.5752 21.3404Z' fill='%236B46FE'/%3e%3cpath d='M16 39C21 39.0001 23.5 39.0001 28 39' stroke='%236B46FE' stroke-width='3' stroke-linecap='round'/%3e%3c/svg%3e" />
              </div>
  
              <p
                class="pera-wallet-connect-modal-desktop-mode__web-wallet__description">
                Connect with Pera Web to continue
              </p>
            </div>
  
            <button
              id="pera-wallet-connect-web-wallet-launch-button"
              class="pera-wallet-connect-modal-desktop-mode__web-wallet__launch-button">
              Launch Pera Web
  
              <img src="data:image/svg+xml,%3csvg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath fill-rule='evenodd' clip-rule='evenodd' d='M13.0892 9.41009C13.4147 9.73553 13.4147 10.2632 13.0892 10.5886L8.08924 15.5886C7.7638 15.914 7.23616 15.914 6.91072 15.5886C6.58529 15.2632 6.58529 14.7355 6.91072 14.4101L11.3215 9.99935L6.91073 5.5886C6.58529 5.26317 6.58529 4.73553 6.91073 4.41009C7.23616 4.08466 7.7638 4.08466 8.08924 4.41009L13.0892 9.41009Z' fill='white'/%3e%3c/svg%3e" />
            </button>
          </div>`, t2 = `
  <div id="mobile-wallet-option" class="pera-wallet-accordion-item ${e3 ? "pera-wallet-accordion-item--active" : ""}">
            <a class="pera-wallet-accordion-toggle">
            <button class="pera-wallet-accordion-toggle__button"></button>
  
              <img src="${k}" class="pera-wallet-accordion-icon" />
  
              <div class="pera-wallet-accordion-toggle__text">
                Connect with
  
                <span class="pera-wallet-accordion-toggle__bold-color">
                  Pera Mobile
                </span>
              </div>
            </a>
  
            <div class="pera-wallet-accordion-item__content">
              <div id="pera-wallet-connect-modal-connect-qr-code" class="pera-wallet-connect-qr-code-wrapper"></div>
  
              <div class="pera-wallet-connect-modal-desktop-mode__download-pera-container">
                <p
                  class="pera-wallet-connect-modal-desktop-mode__download-pera-description">
                    Don\u2019t have Pera Wallet app?
                </p>
  
                <button
                  id="pera-wallet-connect-modal-desktop-mode-download-pera-button"
                  class="pera-wallet-connect-modal-desktop-mode__download-pera-button">
                  <img src="data:image/svg+xml,%3csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3crect x='2' y='2' width='4.66667' height='4.66667' rx='1.2' stroke='%236B46FE' stroke-width='1.5'/%3e%3crect x='2' y='9.33203' width='4.66667' height='4.66667' rx='1.2' stroke='%236B46FE' stroke-width='1.5'/%3e%3crect x='9.33325' y='2' width='4.66667' height='4.66667' rx='1.2' stroke='%236B46FE' stroke-width='1.5'/%3e%3cpath d='M8.70581 9.5293H10.9411' stroke='%236B46FE' stroke-width='1.66667' stroke-linejoin='round'/%3e%3cpath d='M13.1765 12.668L14.6667 12.668' stroke='%236B46FE' stroke-width='1.66667' stroke-linejoin='round'/%3e%3cpath d='M13.1765 14L14.6667 14' stroke='%236B46FE' stroke-width='1.66667' stroke-linejoin='round'/%3e%3cpath d='M11.686 14L13.1762 14' stroke='%236B46FE' stroke-width='1.66667' stroke-linejoin='round'/%3e%3cpath d='M12.4314 9.5293H14.6667' stroke='%236B46FE' stroke-width='1.66667' stroke-linejoin='round'/%3e%3cpath d='M8.70581 10.2754H12.4313' stroke='%236B46FE' stroke-width='1.25' stroke-linejoin='round'/%3e%3cpath d='M10.196 11.7656H11.6862' stroke='%236B46FE' stroke-width='1.25' stroke-linejoin='round'/%3e%3cpath d='M10.196 12.5117H11.6862' stroke='%236B46FE' stroke-width='1.25' stroke-linejoin='round'/%3e%3cpath d='M8.70581 13.2539H10.196' stroke='%236B46FE' stroke-width='1.25' stroke-linejoin='round'/%3e%3cpath d='M8.70581 14H10.196' stroke='%236B46FE' stroke-width='1.25' stroke-linejoin='round'/%3e%3cpath d='M10.196 11.0195H12.4313' stroke='%236B46FE' stroke-width='1.25' stroke-linejoin='round'/%3e%3c/svg%3e" alt="QR Icon" />
  
                  Download Pera Wallet
                </button>
              </div>
            </div>
          </div>`;
              return { mobileWalletOption: document.createRange().createContextualFragment(t2), webWalletOption: document.createRange().createContextualFragment(n4) };
            }(t);
            t ? (null == n3 || n3.appendChild(o3), null == n3 || n3.appendChild(a2)) : (null == n3 || n3.appendChild(a2), null == n3 || n3.appendChild(o3));
          }
        }
        connectedCallback() {
          var e2;
          const n3 = this.getAttribute("should-display-new-badge"), t = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.getElementById("pera-web-new-label");
          "false" === n3 && (null == t || t.setAttribute("style", "display:none")), this.handleChangeView();
        }
        handleChangeView() {
          var e2, n3, t;
          const a2 = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.getElementById("pera-wallet-connect-modal-desktop-mode-download-pera-button"), o3 = null === (n3 = this.shadowRoot) || void 0 === n3 ? void 0 : n3.getElementById("pera-wallet-connect-modal-download-pera-view-back-button"), l2 = null === (t = this.shadowRoot) || void 0 === t ? void 0 : t.getElementById("pera-wallet-connect-web-wallet-launch-button");
          a2 && a2.addEventListener("click", () => {
            this.onClickDownload();
          }), o3 && o3.addEventListener("click", () => {
            this.onClickBack();
          }), l2 && l2.addEventListener("click", () => {
            this.webWalletConnect();
          }), this.renderQRCode(), this.checkWebWalletAvaliability();
        }
        webWalletConnect() {
          "true" === this.getAttribute("is-web-wallet-avaliable") && window.onWebWalletConnect();
        }
        handleAccordion(e2) {
          var n3, t;
          if (e2.target instanceof Element) {
            if (!e2.target.classList.contains("pera-wallet-accordion-toggle__button")) return;
            if (this.shadowRoot && (null === (n3 = e2.target.parentElement) || void 0 === n3 ? void 0 : n3.parentElement)) {
              const n4 = null === (t = e2.target.parentElement) || void 0 === t ? void 0 : t.parentElement;
              if (!n4) return;
              if (n4.classList.contains("pera-wallet-accordion-item--active")) return;
              const a2 = this.shadowRoot.querySelectorAll(".pera-wallet-accordion-item.pera-wallet-accordion-item--active");
              for (let e3 = 0; e3 < a2.length; e3++) a2[e3].classList.remove("pera-wallet-accordion-item--active");
              n4.classList.toggle("pera-wallet-accordion-item--active");
            }
          }
        }
        renderQRCode() {
          var e2;
          const n3 = this.getAttribute("is-web-wallet-avaliable"), t = "true" === this.getAttribute("compact-mode"), a2 = "true" === this.getAttribute("single-account");
          let o3 = this.getAttribute("uri");
          a2 && (o3 = `${o3}&singleAccount=true`);
          let l2 = "false" === n3 ? 250 : 205;
          if (t && (l2 = 190), o3) {
            const n4 = new import_qr_code_styling.default({ width: l2, height: l2, type: "svg", data: o3, image: _, dotsOptions: { color: "#000", type: "extra-rounded" }, imageOptions: { crossOrigin: "anonymous", margin: 8 }, cornersSquareOptions: { type: "extra-rounded" }, cornersDotOptions: { type: "dot" } }), t2 = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.getElementById("pera-wallet-connect-modal-connect-qr-code");
            t2 && n4.append(t2);
          }
        }
        onClickDownload() {
          if (this.shadowRoot) {
            const e2 = this.shadowRoot.getElementById("pera-wallet-connect-modal-desktop-mode");
            e2 && (e2.classList.remove("pera-wallet-connect-modal-desktop-mode--default"), e2.classList.add("pera-wallet-connect-modal-desktop-mode--download"));
          }
        }
        onClickBack() {
          if (this.shadowRoot) {
            const e2 = this.shadowRoot.getElementById("pera-wallet-connect-modal-desktop-mode");
            e2 && (e2.classList.add("pera-wallet-connect-modal-desktop-mode--default"), e2.classList.remove("pera-wallet-connect-modal-desktop-mode--download"));
          }
        }
        checkWebWalletAvaliability() {
          var e2;
          if ("false" === this.getAttribute("is-web-wallet-avaliable")) {
            const n3 = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.querySelector(".pera-wallet-connect-modal-desktop-mode__default-view");
            null == n3 || n3.classList.add("pera-wallet-connect-modal-desktop-mode__default-view--web-wallet-not-avaliable");
          }
        }
      };
      B = ".pera-wallet-connect-modal-touch-screen-mode {\n  display: grid;\n  grid-template-columns: 1fr;\n  gap: 46px;\n  padding: 4px;\n}\n\n.pera-wallet-connect-modal-touch-screen-mode--pending-message-view {\n  gap: 56px;\n  grid-template-rows: auto 48px;\n  height: 100%;\n  padding-bottom: 70px;\n}\n\n.pera-wallet-connect-modal-touch-screen-mode__launch-pera-wallet-button,\n.pera-wallet-connect-modal-touch-screen-mode__install-pera-wallet-button {\n  display: block;\n  padding: 14px;\n  border-radius: 12px;\n  text-decoration: none;\n  text-align: center;\n  font-size: 14px;\n  line-height: 20px;\n  letter-spacing: -0.09px;\n  font-weight: 500;\n}\n\n.pera-wallet-connect-modal-touch-screen-mode__launch-pera-wallet-button {\n  margin-bottom: 32px;\n  background-color: #6b46fe;\n  color: #ffffff;\n}\n\n.pera-wallet-connect-modal-touch-screen-mode__install-pera-wallet-button {\n  margin-bottom: 20px;\n  color: #6a6a81;\n  background-color: #ffffff;\n  box-shadow: 0px 0px 1px rgba(12, 26, 75, 0.24), 0px 3px 8px -1px rgba(50, 50, 71, 0.05);\n}\n\n.pera-wallet-connect-modal-touch-screen-mode__new-to-pera-box {\n  position: relative;\n  margin-bottom: 32px;\n  border-top: 1px solid #e6e8ee;\n}\n\n.pera-wallet-connect-modal-touch-screen-mode__new-to-pera-box__text {\n  position: absolute;\n  top: -25px;\n  right: calc(50% - 56px);\n  width: 116px;\n  color: #69708d;\n  background-color: #ffffff;\n  font-size: 13px;\n  font-weight: 500;\n  line-height: 24px;\n  letter-spacing: -0.04px;\n  text-align: center;\n}";
      h(B);
      F = document.createElement("template");
      A = class extends HTMLElement {
        constructor() {
          var e2;
          if (super(), this.attachShadow({ mode: "open" }), F.innerHTML = '\n  <div class="pera-wallet-connect-modal-touch-screen-mode">\n    <pera-wallet-connect-modal-information-section></pera-wallet-connect-modal-information-section>\n\n    <div>\n      <a\n        id="pera-wallet-connect-modal-touch-screen-mode-launch-pera-wallet-button"\n        class="pera-wallet-connect-modal-touch-screen-mode__launch-pera-wallet-button"\n        rel="noopener noreferrer"\n        target="_blank">\n        Launch Pera Wallet\n      </a>\n\n      <div\n        class="pera-wallet-connect-modal-touch-screen-mode__new-to-pera-box">\n        <p\n          class="pera-wallet-connect-modal-touch-screen-mode__new-to-pera-box__text"\n          >\n          New to Pera?\n        </p>\n      </div>\n\n      <a\n        href="https://perawallet.app/download/"\n        class="pera-wallet-connect-modal-touch-screen-mode__install-pera-wallet-button"\n        rel="noopener noreferrer"\n        target="_blank">\n        Install Pera Wallet\n      </a>\n    </div>\n  </div>\n', this.shadowRoot) {
            const n3 = document.createElement("style");
            n3.textContent = B, this.shadowRoot.append(F.content.cloneNode(true), n3);
            const t = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.getElementById("pera-wallet-connect-modal-touch-screen-mode-launch-pera-wallet-button"), a2 = this.getAttribute("uri"), r3 = "true" === this.getAttribute("single-account"), d2 = this.getAttribute("selected-account") || void 0;
            t && a2 && (t.setAttribute("href", function(e3, n4) {
              let t2 = H(false);
              Lt() && !t2.includes("-wc") && (t2 = t2.replace("://", "-wc://"));
              let a3 = `${t2}wc?uri=${encodeURIComponent(e3)}`;
              const r4 = Ut();
              return Ot() && (a3 = e3), r4 && (a3 = `${a3}&browser=${encodeURIComponent(r4)}`), (null == n4 ? void 0 : n4.singleAccount) && (a3 = `${a3}&singleAccount=true`), (null == n4 ? void 0 : n4.selectedAccount) && (a3 = `${a3}&selectedAccount=${n4.selectedAccount}`), a3;
            }(a2, { singleAccount: r3, selectedAccount: d2 })), t.addEventListener("click", () => {
              this.onClickLaunch();
            }));
          }
        }
        onClickLaunch() {
          if (F.innerHTML = `
    <div class="pera-wallet-connect-modal-touch-screen-mode pera-wallet-connect-modal-touch-screen-mode--pending-message-view">
      <pera-wallet-connect-modal-pending-message-section should-use-sound="${this.getAttribute("should-use-sound")}"></pera-wallet-connect-modal-pending-message-section>
    </div>
  `, this.shadowRoot) {
            const e2 = document.createElement("style");
            e2.textContent = B, this.shadowRoot.innerHTML = "", this.shadowRoot.append(F.content.cloneNode(true), e2);
          }
        }
      };
      V = '@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");\n.pera-wallet-modal {\n  --pera-wallet-modal-font-family: "Inter", sans-serif;\n  --pera-wallet-modal-compact-width: 380px;\n  --pera-wallet-modal-compact-height: 396px;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  position: fixed;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  z-index: 999999;\n  width: 100vw;\n  height: 100vh;\n  background-color: rgba(0, 0, 0, 0.7);\n}\n.pera-wallet-modal--select-account .pera-wallet-modal__body {\n  width: 480px;\n  height: 578px;\n  background-color: #ffffff;\n}\n.pera-wallet-modal--mobile .pera-wallet-modal__body {\n  top: 40px;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  max-width: unset;\n  height: calc(100 * var(--pera-wallet-vh));\n  padding: 20px;\n  background-color: #ffffff;\n  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.02), 0 4px 12px rgba(0, 0, 0, 0.03);\n  border-radius: 20px 20px 0px 0px;\n  animation: 0.3s PeraWalletConnectMobileSlideIn ease-out;\n  overflow-y: auto;\n  transform: unset;\n}\n.pera-wallet-modal--mobile .pera-wallet-modal__body::before {\n  background-image: unset;\n}\n.pera-wallet-modal--compact:not(.pera-wallet-modal--mobile) .pera-wallet-modal__body {\n  width: var(--pera-wallet-modal-compact-width);\n  height: var(--pera-wallet-modal-compact-height);\n  padding: 0;\n}\n.pera-wallet-modal * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  font-family: var(--pera-wallet-modal-font-family);\n  font-smooth: antialiased;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n.pera-wallet-modal ul,\n.pera-wallet-modal ol,\n.pera-wallet-modal li {\n  list-style-type: none;\n}\n\n.pera-wallet-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: auto;\n  height: 48px;\n  padding: 14px;\n  border: none;\n  border-radius: 12px;\n  outline: none;\n  cursor: pointer;\n  font-family: var(--pera-wallet-modal-font-family);\n  font-size: 14px;\n}\n\n.pera-wallet-modal__logo img {\n  display: block;\n  width: 32px;\n}\n\n.pera-wallet-modal__body {\n  position: relative;\n  top: 50%;\n  left: 50%;\n  width: 700px;\n  max-width: calc(100vw - 80px);\n  padding: 28px;\n  background-color: #f3f3f7;\n  box-shadow: 1px 2px 2px rgba(0, 0, 0, 0.08);\n  border-radius: 24px;\n  animation: 0.3s PeraWalletConnectSlideIn ease-out;\n  transform: translate(-50%, -50%);\n}\n.pera-wallet-modal__body::before {\n  --background-line: #1e0972 0 1.2px, transparent 0 calc(100% - 1.2px), #1e0972;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: -1;\n  content: "";\n  background-image: linear-gradient(var(--background-line)), linear-gradient(90deg, var(--background-line));\n  background-size: 116px 116px;\n  mix-blend-mode: overlay;\n  border-radius: 24px;\n  opacity: 0.8;\n  pointer-events: none;\n}\n\n@media (max-width: 767px) {\n  .pera-wallet-modal--desktop .pera-wallet-modal__body {\n    width: 100%;\n    max-width: calc(100vw - 32px);\n    padding: 24px;\n  }\n}\n@keyframes PeraWalletConnectSlideIn {\n  0% {\n    opacity: 0;\n    transform: translate(-50%, calc(-50% + 24px));\n  }\n  100% {\n    opacity: 1;\n    transform: translate(-50%, -50%);\n  }\n}\n@keyframes PeraWalletConnectMobileSlideIn {\n  0% {\n    top: 30%;\n    opacity: 0;\n  }\n  100% {\n    top: 40px;\n    opacity: 1;\n  }\n}';
      h(V);
      R = document.createElement("template");
      I = Mt() ? `${dt} ${dt}--mobile` : `${dt} ${dt}--desktop`;
      S = class extends HTMLElement {
        constructor() {
          if (super(), this.attachShadow({ mode: "open" }), this.shadowRoot) {
            const n3 = document.createElement("style");
            n3.textContent = V;
            "true" === this.getAttribute("compact-mode") && (I = `${I} ${dt}--compact`);
            const t = "true" === this.getAttribute("single-account"), a2 = this.getAttribute("selected-account");
            Mt() ? (R.innerHTML = `
        <div class="${I}">
          <div class="pera-wallet-modal__body" part="body">
            <pera-wallet-modal-header modal-id="${ut}"></pera-wallet-modal-header/>
      
            <pera-wallet-modal-touch-screen-mode uri="${this.getAttribute("uri")}" should-use-sound="${this.getAttribute("should-use-sound")}" single-account="${t}" selected-account="${a2}"></pera-wallet-modal-touch-screen-mode>
          </div>
        </div>
      `, this.shadowRoot.append(R.content.cloneNode(true), n3)) : (R.innerHTML = `
          <div class="${I}">
            <div class="pera-wallet-modal__body">
              <pera-wallet-modal-header modal-id="${ut}"></pera-wallet-modal-header/>
        
              <pera-wallet-modal-desktop-mode id="pera-wallet-modal-desktop-mode" uri="${this.getAttribute("uri")}" is-web-wallet-avaliable="${this.getAttribute("is-web-wallet-avaliable")}" should-display-new-badge="${this.getAttribute("should-display-new-badge")}" compact-mode="${this.getAttribute("compact-mode")}" promote-mobile="${this.getAttribute("promote-mobile")}" single-account="${t}"
        ></pera-wallet-modal-desktop-mode>
            </div>
          </div>
        `, this.shadowRoot.append(R.content.cloneNode(true), n3));
          }
        }
      };
      W = '@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");\n.pera-wallet-modal {\n  --pera-wallet-modal-font-family: "Inter", sans-serif;\n  --pera-wallet-modal-compact-width: 380px;\n  --pera-wallet-modal-compact-height: 396px;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  position: fixed;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  z-index: 999999;\n  width: 100vw;\n  height: 100vh;\n  background-color: rgba(0, 0, 0, 0.7);\n}\n.pera-wallet-modal--select-account .pera-wallet-modal__body {\n  width: 480px;\n  height: 578px;\n  background-color: #ffffff;\n}\n.pera-wallet-modal--mobile .pera-wallet-modal__body {\n  top: 40px;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  max-width: unset;\n  height: calc(100 * var(--pera-wallet-vh));\n  padding: 20px;\n  background-color: #ffffff;\n  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.02), 0 4px 12px rgba(0, 0, 0, 0.03);\n  border-radius: 20px 20px 0px 0px;\n  animation: 0.3s PeraWalletConnectMobileSlideIn ease-out;\n  overflow-y: auto;\n  transform: unset;\n}\n.pera-wallet-modal--mobile .pera-wallet-modal__body::before {\n  background-image: unset;\n}\n.pera-wallet-modal--compact:not(.pera-wallet-modal--mobile) .pera-wallet-modal__body {\n  width: var(--pera-wallet-modal-compact-width);\n  height: var(--pera-wallet-modal-compact-height);\n  padding: 0;\n}\n.pera-wallet-modal * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  font-family: var(--pera-wallet-modal-font-family);\n  font-smooth: antialiased;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n.pera-wallet-modal ul,\n.pera-wallet-modal ol,\n.pera-wallet-modal li {\n  list-style-type: none;\n}\n\n.pera-wallet-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: auto;\n  height: 48px;\n  padding: 14px;\n  border: none;\n  border-radius: 12px;\n  outline: none;\n  cursor: pointer;\n  font-family: var(--pera-wallet-modal-font-family);\n  font-size: 14px;\n}\n\n.pera-wallet-modal__logo img {\n  display: block;\n  width: 32px;\n}\n\n.pera-wallet-modal__body {\n  position: relative;\n  top: 50%;\n  left: 50%;\n  width: 700px;\n  max-width: calc(100vw - 80px);\n  padding: 28px;\n  background-color: #f3f3f7;\n  box-shadow: 1px 2px 2px rgba(0, 0, 0, 0.08);\n  border-radius: 24px;\n  animation: 0.3s PeraWalletConnectSlideIn ease-out;\n  transform: translate(-50%, -50%);\n}\n.pera-wallet-modal__body::before {\n  --background-line: #1e0972 0 1.2px, transparent 0 calc(100% - 1.2px), #1e0972;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: -1;\n  content: "";\n  background-image: linear-gradient(var(--background-line)), linear-gradient(90deg, var(--background-line));\n  background-size: 116px 116px;\n  mix-blend-mode: overlay;\n  border-radius: 24px;\n  opacity: 0.8;\n  pointer-events: none;\n}\n\n@media (max-width: 767px) {\n  .pera-wallet-modal--desktop .pera-wallet-modal__body {\n    width: 100%;\n    max-width: calc(100vw - 32px);\n    padding: 24px;\n  }\n}\n@keyframes PeraWalletConnectSlideIn {\n  0% {\n    opacity: 0;\n    transform: translate(-50%, calc(-50% + 24px));\n  }\n  100% {\n    opacity: 1;\n    transform: translate(-50%, -50%);\n  }\n}\n@keyframes PeraWalletConnectMobileSlideIn {\n  0% {\n    top: 30%;\n    opacity: 0;\n  }\n  100% {\n    top: 40px;\n    opacity: 1;\n  }\n}\n.pera-wallet-redirect-modal {\n  display: grid;\n  grid-template-columns: 1fr;\n  gap: 56px;\n  grid-template-rows: auto 48px;\n  height: 100%;\n  padding: 4px;\n  padding-bottom: 70px;\n}\n\n.pera-wallet-redirect-modal__content {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n}\n\n.pera-wallet-redirect-modal__content__title {\n  margin: 20px 0 8px;\n  color: #3c3c49;\n  font-size: 18px;\n  font-weight: 600;\n  line-height: 22px;\n  letter-spacing: -0.26px;\n}\n\n.pera-wallet-redirect-modal__content__description,\n.pera-wallet-redirect-modal__content__install-pera-text {\n  color: #3c3c49;\n  max-width: 271px;\n  font-size: 14px;\n  font-weight: 400;\n  line-height: 24px;\n  letter-spacing: -0.09px;\n  text-align: center;\n}\n\n.pera-wallet-redirect-modal__content__description {\n  margin-bottom: 24px;\n}\n\n.pera-wallet-redirect-modal__content__install-pera-text__link {\n  color: #6b46fe;\n  font-size: 14px;\n  font-weight: 400;\n  line-height: 24px;\n  letter-spacing: -0.09px;\n  text-align: center;\n}\n\n.pera-wallet-redirect-modal__launch-pera-wallet-button {\n  display: block;\n  padding: 14px;\n  color: #ffffff;\n  background-color: #6b46fe;\n  border-radius: 12px;\n  text-decoration: none;\n  text-align: center;\n  font-size: 14px;\n  line-height: 20px;\n  letter-spacing: -0.09px;\n  font-weight: 500;\n}';
      h(W);
      P = document.createElement("template");
      P.innerHTML = `
  <div class="pera-wallet-modal pera-wallet-modal--mobile">
    <div class="pera-wallet-modal__body">
      <pera-wallet-modal-header modal-id="${ct}"></pera-wallet-modal-header/>

      <div class="pera-wallet-redirect-modal">
        <div class="pera-wallet-redirect-modal__content">
          <img src="data:image/svg+xml,%3csvg width='120' height='38' viewBox='0 0 120 38' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cg clip-path='url(%23clip0_38844_290434)'%3e%3cpath d='M103.739 28.6746H109.565' stroke='%236B46FE' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'/%3e%3cpath d='M112.25 37H100.75C97.5731 37 95 34.2336 95 30.8182V9.18182C95 5.76636 97.5731 3 100.75 3H112.25C115.427 3 118 5.76636 118 9.18182V30.8182C118 34.2336 115.427 37 112.25 37Z' fill='%236B46FE' fill-opacity='0.1' stroke='%236B46FE' stroke-width='3' stroke-linecap='round' stroke-linejoin='round'/%3e%3crect y='1' width='36' height='36' rx='7.76829' fill='%236B46FE' fill-opacity='0.1'/%3e%3cpath d='M19.6057 9.47351C20.1851 11.8819 19.9967 14.0022 19.1848 14.2093C18.373 14.4164 17.2452 12.6319 16.6658 10.2235C16.0864 7.81514 16.2748 5.69486 17.0867 5.48775C17.8985 5.28063 19.0263 7.06512 19.6057 9.47351Z' fill='%236B46FE'/%3e%3cpath d='M29.0775 11.5213C27.8045 10.1593 25.2795 10.5358 23.4378 12.3621C21.5961 14.1885 21.1352 16.7732 22.4083 18.1352C23.6814 19.4972 26.2064 19.1207 28.048 17.2943C29.8897 15.4679 30.3506 12.8832 29.0775 11.5213Z' fill='%236B46FE'/%3e%3cpath d='M19.0324 32.4518C19.8443 32.2446 20.0039 30.0045 19.3889 27.4483C18.774 24.8921 17.6173 22.9877 16.8055 23.1948C15.9937 23.402 15.834 25.6421 16.449 28.1983C17.064 30.7545 18.2206 32.6589 19.0324 32.4518Z' fill='%236B46FE'/%3e%3cpath d='M10.7016 12.818C13.0471 13.5132 14.7627 14.739 14.5336 15.5559C14.3045 16.3728 12.2175 16.4714 9.87199 15.7762C7.52653 15.0809 5.81087 13.8551 6.03996 13.0383C6.26906 12.2214 8.35615 12.1228 10.7016 12.818Z' fill='%236B46FE'/%3e%3cpath d='M25.9365 21.9967C28.4259 22.7346 30.2583 23.995 30.0292 24.8119C29.8001 25.6287 27.5963 25.6927 25.1069 24.9548C22.6174 24.2169 20.7851 22.9565 21.0141 22.1397C21.2432 21.3228 23.447 21.2588 25.9365 21.9967Z' fill='%236B46FE'/%3e%3cpath d='M13.3578 20.316C12.775 19.7063 10.8709 20.6007 9.10487 22.3139C7.33879 24.0271 6.37952 25.9102 6.96226 26.5199C7.54501 27.1297 9.4491 26.2352 11.2152 24.522C12.9813 22.8089 13.9405 20.9258 13.3578 20.316Z' fill='%236B46FE'/%3e%3cpath d='M70.2098 10L75.3049 15.0945L52 15.0945' stroke='%23D0CAE7' stroke-width='3'/%3e%3cpath d='M60.7902 29.5945L55.6951 24.5L79 24.5' stroke='%23D0CAE7' stroke-width='3'/%3e%3c/g%3e%3cdefs%3e%3cclipPath id='clip0_38844_290434'%3e%3crect width='120' height='38' fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e" />

          <h1 class="pera-wallet-redirect-modal__content__title">
            Can't Launch Pera
          </h1>

          <p class="pera-wallet-redirect-modal__content__description">
            We couldn't redirect you to Pera Wallet automatically. Please try again.
          </p>

          <p class="pera-wallet-redirect-modal__content__install-pera-text">
            Don't have Pera Wallet installed yet?
            <br />
            
            <a
              id="pera-wallet-redirect-modal-download-pera-link"
              class="pera-wallet-redirect-modal__content__install-pera-text__link"
              href="https://perawallet.app/download/"
              rel="noopener noreferrer"
              target="_blank">
              Tap here to install.
            </a>
          </p>
        </div>

        <a
          id="pera-wallet-redirect-modal-launch-pera-link"
          class="pera-wallet-redirect-modal__launch-pera-wallet-button"
          rel="noopener noreferrer"
          target="_blank">
          Launch Pera Wallet
        </a>
      </div>
    </div>
  </div>
`;
      $ = class extends HTMLElement {
        constructor() {
          var e2, n3;
          if (super(), this.attachShadow({ mode: "open" }), this.shadowRoot) {
            const t = document.createElement("style");
            t.textContent = W, this.shadowRoot.append(P.content.cloneNode(true), t);
            const a2 = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.getElementById("pera-wallet-redirect-modal-download-pera-link");
            null == a2 || a2.addEventListener("click", () => {
              this.onClose();
            });
            const o3 = null === (n3 = this.shadowRoot) || void 0 === n3 ? void 0 : n3.getElementById("pera-wallet-redirect-modal-launch-pera-link");
            null == o3 || o3.addEventListener("click", () => {
              this.onClose(), window.open(H(), "_blank");
            });
          }
        }
        connectedCallback() {
          const e2 = window.open(H(), "_blank");
          e2 && !e2.closed && this.onClose();
        }
        onClose() {
          vt(ct);
        }
      };
      j = "data:image/svg+xml,%3csvg width='32' height='35' viewBox='0 0 32 35' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M18.2837 5.09271C19.0234 8.12325 18.7827 10.7913 17.7463 11.0519C16.7098 11.3126 15.27 9.06712 14.5304 6.03657C13.7908 3.00603 14.0315 0.337996 15.0679 0.0773547C16.1044 -0.183287 17.5441 2.06216 18.2837 5.09271Z' fill='%233C3C49'/%3e%3cpath d='M30.376 7.66915C28.7507 5.95537 25.5271 6.42918 23.1759 8.72745C20.8247 11.0257 20.2361 14.2781 21.8614 15.9919C23.4866 17.7057 26.7102 17.2319 29.0614 14.9336C31.4127 12.6354 32.0012 9.38294 30.376 7.66915Z' fill='%233C3C49'/%3e%3cpath d='M17.5511 34.0071C18.5876 33.7465 18.7914 30.9276 18.0064 27.711C17.2214 24.4945 15.7448 22.0982 14.7084 22.3589C13.6719 22.6195 13.4681 25.4383 14.2531 28.6549C15.0381 31.8715 16.5147 34.2677 17.5511 34.0071Z' fill='%233C3C49'/%3e%3cpath d='M6.91617 9.3015C9.9105 10.1763 12.1008 11.7187 11.8083 12.7466C11.5158 13.7745 8.85126 13.8986 5.85693 13.0239C2.8626 12.1491 0.672334 10.6067 0.964835 9.57881C1.25734 8.5509 3.92184 8.42674 6.91617 9.3015Z' fill='%233C3C49'/%3e%3cpath d='M26.3656 20.8508C29.5437 21.7793 31.883 23.3652 31.5905 24.3932C31.298 25.4211 28.4845 25.5017 25.3063 24.5732C22.1282 23.6448 19.7889 22.0588 20.0814 21.0309C20.3739 20.003 23.1874 19.9224 26.3656 20.8508Z' fill='%233C3C49'/%3e%3cpath d='M10.3069 18.7365C9.56299 17.9692 7.13209 19.0948 4.87736 21.2506C2.62264 23.4064 1.39791 25.776 2.14185 26.5432C2.8858 27.3105 5.3167 26.1849 7.57143 24.0291C9.82615 21.8733 11.0509 19.5037 10.3069 18.7365Z' fill='%233C3C49'/%3e%3c/svg%3e";
      T = ".pera-wallet-connect-modal-information-section {\n  padding: 12px;\n  padding-right: 0;\n}\n.pera-wallet-connect-modal-information-section--mobile {\n  padding: 0;\n}\n.pera-wallet-connect-modal-information-section--mobile .pera-wallet-connect-modal-information-section__pera-icon {\n  margin-bottom: 16px;\n}\n.pera-wallet-connect-modal-information-section--mobile .pera-wallet-connect-modal-information-section__connect-pera-title {\n  margin-bottom: 8px;\n  color: #3c3c49;\n  font-size: 18px;\n  font-weight: 600;\n  line-height: 22px;\n  letter-spacing: -0.2px;\n}\n.pera-wallet-connect-modal-information-section--mobile .pera-wallet-connect-modal-information-section__title {\n  margin-bottom: 24px;\n  color: #3c3c49;\n  font-size: 14px;\n  line-height: 24px;\n  letter-spacing: -0.09px;\n  font-weight: 400;\n}\n.pera-wallet-connect-modal-information-section--mobile .pera-wallet-connect-modal-information-section__features-item__icon-wrapper {\n  background-color: #f2f3f8;\n}\n.pera-wallet-connect-modal-information-section--mobile .pera-wallet-connect-modal-information-section__features-item__description {\n  color: #6a6a81;\n}\n.pera-wallet-connect-modal-information-section * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  font-family: var(--pera-wallet-modal-font-family);\n  font-smooth: antialiased;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.pera-wallet-connect-modal-information-section__pera-icon {\n  margin-bottom: 32px;\n}\n\n.pera-wallet-connect-modal-information-section__title {\n  margin-bottom: 148px;\n  color: #3c3c49;\n  font-size: 20px;\n  font-weight: 500;\n  line-height: 24px;\n  letter-spacing: -0.5px;\n}\n\n.pera-wallet-connect-modal-information-section__secondary-title {\n  margin-bottom: 20px;\n  color: #9d9dae;\n  font-size: 11px;\n  font-weight: 600;\n  line-height: 18px;\n  letter-spacing: 0.06px;\n  text-transform: uppercase;\n}\n\n.pera-wallet-connect-modal-information-section__features-item {\n  display: grid;\n  align-items: center;\n  grid-template-columns: 36px auto;\n  gap: 16px;\n}\n.pera-wallet-connect-modal-information-section__features-item:not(:last-of-type) {\n  margin-bottom: 24px;\n}\n\n.pera-wallet-connect-modal-information-section__features-item__icon-wrapper {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 36px;\n  height: 36px;\n  background-color: #ffffff;\n  border-radius: 50%;\n}\n\n.pera-wallet-connect-modal-information-section__features-item__description {\n  color: #6a6a81;\n  font-size: 12px;\n  font-weight: 500;\n  line-height: 18px;\n  letter-spacing: 0.01px;\n}\n\n@media (max-width: 767px) {\n  .pera-wallet-connect-modal-information-section--desktop {\n    padding: 0;\n  }\n  .pera-wallet-connect-modal-information-section--desktop .pera-wallet-connect-modal-information-section__pera-icon {\n    margin-bottom: 12px;\n  }\n  .pera-wallet-connect-modal-information-section--desktop .pera-wallet-connect-modal-information-section__title {\n    margin-bottom: 24px;\n    font-size: 16px;\n    font-weight: 500;\n    line-height: 24px;\n    letter-spacing: -0.26px;\n  }\n  .pera-wallet-connect-modal-information-section--desktop .pera-wallet-connect-modal-information-section__features-item {\n    display: none;\n  }\n  .pera-wallet-connect-modal-information-section__secondary-title {\n    display: none;\n  }\n}";
      h(T);
      D = document.createElement("template");
      O = Mt() ? "pera-wallet-connect-modal-information-section pera-wallet-connect-modal-information-section--mobile" : "pera-wallet-connect-modal-information-section pera-wallet-connect-modal-information-section--desktop";
      D.innerHTML = `
  <section class="${O}">
    <img
      id="pera-wallet-connect-modal-information-section-pera-icon"
      src="${j}"
      class="pera-wallet-connect-modal-information-section__pera-icon"
      alt="Pera Wallet Logo"
    />

    <h1 id="pera-wallet-connect-modal-information-section-connect-pera-mobile" class="pera-wallet-connect-modal-information-section__connect-pera-title">
        Connect to Pera Wallet
    </h1>

    <h1 class="pera-wallet-connect-modal-information-section__title">
      Simply the best Algorand wallet.
    </h1>

    <h2 id="pera-wallet-connect-modal-information-section-secondary-title" class="pera-wallet-connect-modal-information-section__secondary-title">
      Features
    </h2>

    <ul>
      <li class="pera-wallet-connect-modal-information-section__features-item">
        <div class="pera-wallet-connect-modal-information-section__features-item__icon-wrapper">
          <img src="data:image/svg+xml,%3csvg width='20' height='21' viewBox='0 0 20 21' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M2.5 10.1378C2.5 10.8378 3.025 11.6461 3.66667 11.9294L9.325 14.4461C9.75833 14.6378 10.25 14.6378 10.675 14.4461L16.3333 11.9294C16.975 11.6461 17.5 10.8378 17.5 10.1378M2.5 14.3044C2.5 15.0794 2.95833 15.7794 3.66667 16.0961L9.325 18.6128C9.75833 18.8044 10.25 18.8044 10.675 18.6128L16.3333 16.0961C17.0417 15.7794 17.5 15.0794 17.5 14.3044M10.8417 3.4043L15.7583 5.58763C17.175 6.21263 17.175 7.24596 15.7583 7.87096L10.8417 10.0543C10.2833 10.3043 9.36668 10.3043 8.80835 10.0543L3.89168 7.87096C2.47502 7.24596 2.47502 6.21263 3.89168 5.58763L8.80835 3.4043C9.36668 3.1543 10.2833 3.1543 10.8417 3.4043Z' stroke='%239D9DAE' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e" alt="Layer Icon" />
        </div>
        
        <p
          class="pera-wallet-connect-modal-information-section__features-item__description">
          Connect to any Algorand dApp securely
        </p>
      </li>

      <li class="pera-wallet-connect-modal-information-section__features-item">
        <div
          class="pera-wallet-connect-modal-information-section__features-item__icon-wrapper">
          <img src="data:image/svg+xml,%3csvg width='24' height='25' viewBox='0 0 24 25' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M9.58033 12.3109C9.28744 12.018 8.81257 12.018 8.51967 12.3109C8.22678 12.6038 8.22678 13.0787 8.51967 13.3716L9.58033 12.3109ZM10.66 14.4512L10.1297 14.9816C10.4226 15.2745 10.8974 15.2745 11.1903 14.9816L10.66 14.4512ZM15.4903 10.6816C15.7832 10.3887 15.7832 9.91381 15.4903 9.62092C15.1974 9.32803 14.7226 9.32803 14.4297 9.62092L15.4903 10.6816ZM19.84 8.09125C19.84 8.50546 20.1758 8.84125 20.59 8.84125C21.0042 8.84125 21.34 8.50546 21.34 8.09125H19.84ZM18.5 5.07125L18.2368 5.77355L18.2373 5.77375L18.5 5.07125ZM13.51 3.20125L13.7732 2.49894L13.7724 2.49866L13.51 3.20125ZM10.49 3.20125L10.2276 2.49865L10.2256 2.49941L10.49 3.20125ZM5.5 5.08125L5.76268 5.78375L5.76442 5.78309L5.5 5.08125ZM5.14 18.9612L4.69102 19.562L4.69135 19.5623L5.14 18.9612ZM9.44 22.1713L9.89069 21.5718L9.88866 21.5702L9.44 22.1713ZM14.58 22.1713L14.1313 21.5702L14.1293 21.5718L14.58 22.1713ZM18.88 18.9612L19.3287 19.5623L19.329 19.562L18.88 18.9612ZM21.36 8.09125C21.36 7.67704 21.0242 7.34125 20.61 7.34125C20.1958 7.34125 19.86 7.67704 19.86 8.09125H21.36ZM8.51967 13.3716L10.1297 14.9816L11.1903 13.9209L9.58033 12.3109L8.51967 13.3716ZM11.1903 14.9816L15.4903 10.6816L14.4297 9.62092L10.1297 13.9209L11.1903 14.9816ZM21.34 8.09125C21.34 7.29392 21.0398 6.50041 20.5931 5.85456C20.1463 5.20881 19.5097 4.64807 18.7627 4.36875L18.2373 5.77375C18.6403 5.92443 19.0487 6.25869 19.3595 6.70794C19.6702 7.15709 19.84 7.65858 19.84 8.09125H21.34ZM18.7632 4.36895L13.7732 2.49895L13.2468 3.90355L18.2368 5.77355L18.7632 4.36895ZM13.7724 2.49866C13.2479 2.30277 12.6051 2.21875 12 2.21875C11.3949 2.21875 10.7521 2.30277 10.2276 2.49866L10.7524 3.90384C11.0579 3.78973 11.5101 3.71875 12 3.71875C12.4899 3.71875 12.9421 3.78973 13.2476 3.90384L13.7724 2.49866ZM10.2256 2.49941L5.23558 4.37941L5.76442 5.78309L10.7544 3.90309L10.2256 2.49941ZM5.23733 4.37875C4.49043 4.65803 3.85398 5.2186 3.40741 5.86265C2.96095 6.50656 2.66 7.2978 2.66 8.09125H4.16C4.16 7.6647 4.32906 7.16594 4.64009 6.71735C4.95103 6.2689 5.35957 5.93447 5.76268 5.78375L5.23733 4.37875ZM2.66 8.09125V15.5212H4.16V8.09125H2.66ZM2.66 15.5212C2.66 16.2602 2.8989 17.059 3.24874 17.7545C3.59871 18.4503 4.09802 19.1188 4.69102 19.562L5.58899 18.3605C5.23198 18.0937 4.86629 17.6322 4.58877 17.0805C4.31111 16.5285 4.16 15.9623 4.16 15.5212H2.66ZM4.69135 19.5623L8.99135 22.7723L9.88866 21.5702L5.58866 18.3602L4.69135 19.5623ZM8.98932 22.7707C9.84721 23.4157 10.9462 23.7163 12.01 23.7163C13.0738 23.7163 14.1728 23.4157 15.0307 22.7707L14.1293 21.5718C13.5772 21.9868 12.8112 22.2163 12.01 22.2163C11.2088 22.2163 10.4428 21.9868 9.89068 21.5718L8.98932 22.7707ZM15.0287 22.7723L19.3287 19.5623L18.4313 18.3602L14.1313 21.5702L15.0287 22.7723ZM19.329 19.562C19.922 19.1188 20.4213 18.4503 20.7713 17.7545C21.1211 17.059 21.36 16.2602 21.36 15.5212H19.86C19.86 15.9623 19.7089 16.5285 19.4312 17.0805C19.1537 17.6322 18.788 18.0937 18.431 18.3605L19.329 19.562ZM21.36 15.5212V8.09125H19.86V15.5212H21.36Z' fill='%239D9DAE'/%3e%3c/svg%3e" alt="Tick Icon" />
        </div>

        <p
          class="pera-wallet-connect-modal-information-section__features-item__description">
          Your private keys are safely stored locally
        </p>
      </li>

      <li class="pera-wallet-connect-modal-information-section__features-item">
        <div
          class="pera-wallet-connect-modal-information-section__features-item__icon-wrapper">
          <img src="data:image/svg+xml,%3csvg width='20' height='21' viewBox='0 0 20 21' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M18.05 9.67014L17.3198 9.49894L18.05 9.67014ZM17.2333 13.1535L16.5031 12.9823L16.5029 12.9835L17.2333 13.1535ZM12.55 17.1285L12.6218 16.3818L12.6098 16.3809L12.55 17.1285ZM11.2 16.9035L11.376 16.1744L11.3737 16.1739L11.2 16.9035ZM9.8 16.5701L9.97372 15.8405L9.97324 15.8404L9.8 16.5701ZM6.06667 10.5451L6.79687 10.7163L6.79696 10.7159L6.06667 10.5451ZM6.88334 7.05347L6.15327 6.88169L6.15304 6.88267L6.88334 7.05347ZM7.5 5.22014L8.17303 5.55114L8.17523 5.54659L7.5 5.22014ZM12.9167 3.32014L12.744 4.05L12.7461 4.05049L12.9167 3.32014ZM14.3083 3.64514L14.4791 2.91485L14.4789 2.91479L14.3083 3.64514ZM10.5917 18.0285L10.359 17.3155L10.3572 17.3161L10.5917 18.0285ZM9.27501 18.4618L9.50516 19.1756L9.50947 19.1742L9.27501 18.4618ZM3.15001 15.3285L2.43654 15.5597L2.43672 15.5603L3.15001 15.3285ZM2.08334 12.0368L1.36953 12.267L1.36987 12.268L2.08334 12.0368ZM5.20834 5.91182L5.43849 6.62565L5.44281 6.62423L5.20834 5.91182ZM6.52501 5.47848L6.29831 4.76352L6.29055 4.76608L6.52501 5.47848ZM10.7177 7.35149C10.3162 7.24967 9.90818 7.49261 9.80635 7.89411C9.70453 8.29561 9.94746 8.70364 10.349 8.80546L10.7177 7.35149ZM14.3906 9.83046C14.7921 9.93229 15.2002 9.68935 15.302 9.28785C15.4038 8.88635 15.1609 8.47832 14.7594 8.37649L14.3906 9.83046ZM9.90211 10.5768C9.50076 10.4743 9.09238 10.7167 8.98996 11.118C8.88755 11.5194 9.12988 11.9278 9.53124 12.0302L9.90211 10.5768ZM11.9479 12.6469C12.3493 12.7493 12.7576 12.5069 12.8601 12.1056C12.9625 11.7042 12.7201 11.2958 12.3188 11.1934L11.9479 12.6469ZM17.3198 9.49894L16.5031 12.9823L17.9635 13.3247L18.7802 9.84133L17.3198 9.49894ZM16.5029 12.9835C16.168 14.4224 15.6979 15.2955 15.1165 15.793C14.5605 16.2688 13.7912 16.4944 12.6218 16.3819L12.4782 17.875C13.9088 18.0126 15.1312 17.7548 16.0918 16.9327C17.0271 16.1323 17.5986 14.8928 17.9638 13.3234L16.5029 12.9835ZM12.6098 16.3809C12.2388 16.3512 11.8281 16.2835 11.376 16.1744L11.024 17.6325C11.5386 17.7567 12.0279 17.8391 12.4902 17.8761L12.6098 16.3809ZM11.3737 16.1739L9.97372 15.8405L9.62629 17.2997L11.0263 17.6331L11.3737 16.1739ZM9.97324 15.8404C8.30732 15.4449 7.40652 14.876 6.96107 14.1588C6.51616 13.4425 6.40566 12.385 6.79687 10.7163L5.33647 10.3739C4.91101 12.1887 4.92968 13.7311 5.68685 14.9502C6.44349 16.1685 7.81769 16.8704 9.62676 17.2999L9.97324 15.8404ZM6.79696 10.7159L7.61363 7.22428L6.15304 6.88267L5.33638 10.3743L6.79696 10.7159ZM7.6134 7.22525C7.77277 6.54795 7.95691 5.99053 8.17301 5.55113L6.82699 4.88915C6.54309 5.46641 6.32724 6.14234 6.15327 6.88169L7.6134 7.22525ZM8.17523 5.54659C8.59604 4.67619 9.11898 4.20234 9.77488 3.97598C10.4657 3.73759 11.4133 3.73525 12.744 4.05L13.0893 2.59028C11.6367 2.2467 10.3635 2.18603 9.28554 2.55805C8.17269 2.94211 7.37896 3.74743 6.82478 4.89369L8.17523 5.54659ZM12.7461 4.05049L14.1378 4.37549L14.4789 2.91479L13.0872 2.58979L12.7461 4.05049ZM14.1375 4.37543C15.8111 4.76687 16.7126 5.33603 17.1575 6.05304C17.6023 6.77006 17.7112 7.82942 17.3198 9.49894L18.7802 9.84133C19.2054 8.02753 19.1893 6.48272 18.4321 5.26224C17.6749 4.04175 16.2972 3.34008 14.4791 2.91485L14.1375 4.37543ZM12.1294 16.5075C11.6911 16.8045 11.1123 17.0697 10.359 17.3155L10.8243 18.7415C11.6544 18.4706 12.3756 18.1525 12.9706 17.7494L12.1294 16.5075ZM10.3572 17.3161L9.04055 17.7494L9.50947 19.1742L10.8261 18.7409L10.3572 17.3161ZM9.04486 17.748C7.46037 18.2589 6.43607 18.2362 5.71663 17.8681C4.99693 17.4999 4.37829 16.6816 3.8633 15.0967L2.43672 15.5603C2.99673 17.2837 3.78642 18.5654 5.03339 19.2035C6.28062 19.8416 7.78131 19.7314 9.50516 19.1756L9.04486 17.748ZM3.86348 15.0973L2.79682 11.8056L1.36987 12.268L2.43654 15.5597L3.86348 15.0973ZM2.79716 11.8067C2.28607 10.2215 2.3068 9.19457 2.67362 8.4739C3.03983 7.75443 3.85506 7.13616 5.43849 6.62563L4.9782 5.198C3.25329 5.75414 1.97269 6.54421 1.33682 7.79348C0.701551 9.04157 0.813948 10.5438 1.36953 12.267L2.79716 11.8067ZM5.44281 6.62423L6.75947 6.19089L6.29055 4.76608L4.97388 5.19941L5.44281 6.62423ZM6.75169 6.19341C7.08205 6.08866 7.37424 6.00724 7.63942 5.95707L7.36058 4.48321C7.00909 4.54971 6.6513 4.65164 6.29833 4.76356L6.75169 6.19341ZM10.349 8.80546L14.3906 9.83046L14.7594 8.37649L10.7177 7.35149L10.349 8.80546ZM9.53124 12.0302L11.9479 12.6469L12.3188 11.1934L9.90211 10.5768L9.53124 12.0302Z' fill='%239D9DAE'/%3e%3c/svg%3e" alt="Note Icon" />
        </div>

        <p
          class="pera-wallet-connect-modal-information-section__features-item__description">
          View NFTs, buy and swap crypto and more
        </p>
      </li>
    </ul>
  </section>
`;
      U = class extends HTMLElement {
        constructor() {
          var n3, t, a2, o3;
          super(), this.attachShadow({ mode: "open" });
          const l2 = "true" === (null === (n3 = document.querySelector("pera-wallet-connect-modal")) || void 0 === n3 ? void 0 : n3.getAttribute("compact-mode"));
          if (this.shadowRoot && (!l2 && !Mt() || Mt())) {
            const n4 = document.createElement("style");
            n4.textContent = T, this.shadowRoot.append(D.content.cloneNode(true), n4), Mt() ? null === (t = this.shadowRoot.getElementById("pera-wallet-connect-modal-information-section-title")) || void 0 === t || t.setAttribute("style", "display: none;") : (null === (a2 = this.shadowRoot.getElementById("pera-wallet-connect-modal-information-section-pera-icon")) || void 0 === a2 || a2.setAttribute("src", "data:image/svg+xml,%3csvg width='84' height='38' viewBox='0 0 84 38' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M19.806 8.62773C20.4416 11.2609 20.2268 13.5772 19.3262 13.8012C18.4256 14.0253 17.1803 12.0723 16.5448 9.43906C15.9092 6.80585 16.1241 4.48959 17.0246 4.26555C17.9252 4.04151 19.1705 5.99452 19.806 8.62773Z' fill='%233C3C49'/%3e%3cpath d='M30.3007 10.8917C28.8932 9.3999 26.0929 9.80424 24.0461 11.7948C21.9994 13.7853 21.4812 16.6082 22.8887 18.1C24.2962 19.5917 27.0964 19.1874 29.1432 17.1969C31.1899 15.2064 31.7082 12.3834 30.3007 10.8917Z' fill='%233C3C49'/%3e%3cpath d='M19.1061 33.734C20.0067 33.5099 20.1899 31.0627 19.5153 28.2678C18.8408 25.473 17.5639 23.3889 16.6633 23.613C15.7627 23.837 15.5795 26.2843 16.2541 29.0791C16.9286 31.874 18.2056 33.958 19.1061 33.734Z' fill='%233C3C49'/%3e%3cpath d='M9.92571 12.2574C12.5239 13.0236 14.4224 14.3678 14.1662 15.2597C13.9099 16.1517 11.5959 16.2536 8.99771 15.4874C6.3995 14.7212 4.50098 13.377 4.75724 12.4851C5.0135 11.5931 7.3275 11.4912 9.92571 12.2574Z' fill='%233C3C49'/%3e%3cpath d='M26.7892 22.3292C29.5469 23.1424 31.5747 24.5247 31.3184 25.4167C31.0621 26.3086 28.6189 26.3724 25.8612 25.5592C23.1035 24.7459 21.0757 23.3636 21.3319 22.4717C21.5882 21.5797 24.0315 21.5159 26.7892 22.3292Z' fill='%233C3C49'/%3e%3cpath d='M12.8493 20.4577C12.205 19.7898 10.0916 20.7619 8.12896 22.6289C6.16631 24.4959 5.09759 26.5509 5.7419 27.2188C6.38622 27.8867 8.49958 26.9146 10.4622 25.0476C12.4249 23.1806 13.4936 21.1256 12.8493 20.4577Z' fill='%233C3C49'/%3e%3cpath d='M41.691 12.5347V11.9635H39.3366V27.1957H41.691V23.0915C41.691 22.6472 41.691 22.2876 41.6482 21.801H41.691C42.5471 23.1973 44.0026 23.9377 45.7148 23.9377C48.6043 23.9377 51.1299 21.7587 51.1299 17.7179C51.1299 13.7617 48.6043 11.625 45.7148 11.625C44.0668 11.625 42.6113 12.3443 41.691 13.7617H41.6482C41.691 13.2963 41.691 12.9578 41.691 12.5347ZM45.1155 21.9279C42.9324 21.9068 41.6696 20.0662 41.6696 17.6967C41.6696 15.4542 42.9324 13.656 45.1155 13.6348C47.2559 13.6137 48.6685 15.2638 48.6685 17.7179C48.6685 20.2354 47.2559 21.9491 45.1155 21.9279Z' fill='%233C3C49'/%3e%3cpath d='M63.4932 16.7236C63.4932 13.8041 61.1388 11.625 57.9283 11.625C54.5037 11.625 52.1279 13.931 52.1279 17.7814C52.1279 21.4836 54.4609 23.9377 57.9283 23.9377C60.7749 23.9377 62.8939 22.2876 63.3862 20.0239H60.8177C60.4111 21.1663 59.2981 21.9279 57.9283 21.9279C56.1732 21.9279 54.889 20.6797 54.6107 18.6064H63.4932V16.7236ZM57.9283 13.6348C59.662 13.6348 60.8606 14.8195 61.1174 16.5332H54.6321C54.9318 14.883 56.1518 13.6348 57.9283 13.6348Z' fill='%233C3C49'/%3e%3cpath d='M65.224 23.5992H67.5784V17.0409C67.5784 14.7984 68.8198 13.6348 70.7462 13.6348H72.009V11.625H71.003C69.2693 11.625 68.1991 12.7674 67.5784 13.7617H67.5356V11.9635H65.224V23.5992Z' fill='%233C3C49'/%3e%3cpath d='M83.0154 21.5683C82.6944 21.5683 82.5445 21.3779 82.5445 20.9971V15.8773C82.5445 13.4233 81.3459 11.625 77.8144 11.625C74.3898 11.625 72.8273 13.3175 72.6561 15.7292H75.0105C75.1603 14.4176 76.2091 13.6348 77.8144 13.6348C79.1842 13.6348 80.1259 14.2272 80.1259 15.158C80.1259 15.9196 79.5909 16.3851 77.8358 16.3851H76.894C74.0901 16.3851 72.2066 17.5063 72.2066 20.0662C72.2066 22.753 74.1972 23.98 76.5301 23.98C78.2638 23.98 79.7407 23.2184 80.3186 21.5894C80.3828 22.7742 81.1747 23.5992 82.673 23.5992H84V21.5683H83.0154ZM80.1902 18.1833C80.1902 20.8067 78.7561 21.9491 76.9154 21.9491C75.3101 21.9491 74.668 21.0182 74.668 20.0662C74.668 19.1565 75.2245 18.416 76.9368 18.416H77.2793C78.9273 18.416 79.9547 17.8448 80.1688 16.8505H80.1902V18.1833Z' fill='%233C3C49'/%3e%3c/svg%3e"), null === (o3 = this.shadowRoot.getElementById("pera-wallet-connect-modal-information-section-connect-pera-mobile")) || void 0 === o3 || o3.setAttribute("style", "display: none;"));
          }
        }
      };
      q = '@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");\n.pera-wallet-modal {\n  --pera-wallet-modal-font-family: "Inter", sans-serif;\n  --pera-wallet-modal-compact-width: 380px;\n  --pera-wallet-modal-compact-height: 396px;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  position: fixed;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  z-index: 999999;\n  width: 100vw;\n  height: 100vh;\n  background-color: rgba(0, 0, 0, 0.7);\n}\n.pera-wallet-modal--select-account .pera-wallet-modal__body {\n  width: 480px;\n  height: 578px;\n  background-color: #ffffff;\n}\n.pera-wallet-modal--mobile .pera-wallet-modal__body {\n  top: 40px;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  max-width: unset;\n  height: calc(100 * var(--pera-wallet-vh));\n  padding: 20px;\n  background-color: #ffffff;\n  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.02), 0 4px 12px rgba(0, 0, 0, 0.03);\n  border-radius: 20px 20px 0px 0px;\n  animation: 0.3s PeraWalletConnectMobileSlideIn ease-out;\n  overflow-y: auto;\n  transform: unset;\n}\n.pera-wallet-modal--mobile .pera-wallet-modal__body::before {\n  background-image: unset;\n}\n.pera-wallet-modal--compact:not(.pera-wallet-modal--mobile) .pera-wallet-modal__body {\n  width: var(--pera-wallet-modal-compact-width);\n  height: var(--pera-wallet-modal-compact-height);\n  padding: 0;\n}\n.pera-wallet-modal * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  font-family: var(--pera-wallet-modal-font-family);\n  font-smooth: antialiased;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n.pera-wallet-modal ul,\n.pera-wallet-modal ol,\n.pera-wallet-modal li {\n  list-style-type: none;\n}\n\n.pera-wallet-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: auto;\n  height: 48px;\n  padding: 14px;\n  border: none;\n  border-radius: 12px;\n  outline: none;\n  cursor: pointer;\n  font-family: var(--pera-wallet-modal-font-family);\n  font-size: 14px;\n}\n\n.pera-wallet-modal__logo img {\n  display: block;\n  width: 32px;\n}\n\n.pera-wallet-modal__body {\n  position: relative;\n  top: 50%;\n  left: 50%;\n  width: 700px;\n  max-width: calc(100vw - 80px);\n  padding: 28px;\n  background-color: #f3f3f7;\n  box-shadow: 1px 2px 2px rgba(0, 0, 0, 0.08);\n  border-radius: 24px;\n  animation: 0.3s PeraWalletConnectSlideIn ease-out;\n  transform: translate(-50%, -50%);\n}\n.pera-wallet-modal__body::before {\n  --background-line: #1e0972 0 1.2px, transparent 0 calc(100% - 1.2px), #1e0972;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: -1;\n  content: "";\n  background-image: linear-gradient(var(--background-line)), linear-gradient(90deg, var(--background-line));\n  background-size: 116px 116px;\n  mix-blend-mode: overlay;\n  border-radius: 24px;\n  opacity: 0.8;\n  pointer-events: none;\n}\n\n@media (max-width: 767px) {\n  .pera-wallet-modal--desktop .pera-wallet-modal__body {\n    width: 100%;\n    max-width: calc(100vw - 32px);\n    padding: 24px;\n  }\n}\n@keyframes PeraWalletConnectSlideIn {\n  0% {\n    opacity: 0;\n    transform: translate(-50%, calc(-50% + 24px));\n  }\n  100% {\n    opacity: 1;\n    transform: translate(-50%, -50%);\n  }\n}\n@keyframes PeraWalletConnectMobileSlideIn {\n  0% {\n    top: 30%;\n    opacity: 0;\n  }\n  100% {\n    top: 40px;\n    opacity: 1;\n  }\n}\n.pera-wallet-connect-modal-pending-message-section {\n  display: grid;\n  grid-template-columns: 1fr;\n  grid-template-rows: auto 48px;\n  gap: 56px;\n  height: 100%;\n  padding: 4px;\n  padding-bottom: 70px;\n}\n\n.pera-wallet-connect-modal-pending-message {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  flex-direction: column;\n  text-align: center;\n}\n.pera-wallet-connect-modal-pending-message--try-again-view {\n  display: flex;\n  justify-content: space-between;\n  flex-direction: column;\n  height: 100%;\n  margin-top: 10px;\n}\n.pera-wallet-connect-modal-pending-message--try-again-view__title {\n  margin: 16px 0 12px;\n  color: #3c3c49;\n  font-size: 18px;\n  font-weight: 500;\n  line-height: 24px;\n  letter-spacing: -0.26px;\n}\n.pera-wallet-connect-modal-pending-message--try-again-view__description {\n  color: #6a6a81;\n  font-size: 14px;\n  font-weight: 400;\n  line-height: 24px;\n  letter-spacing: -0.01px;\n}\n.pera-wallet-connect-modal-pending-message--try-again-view__button {\n  display: block;\n  width: 100%;\n  padding: 14px;\n  border-radius: 12px;\n  text-decoration: none;\n  text-align: center;\n  font-size: 14px;\n  line-height: 20px;\n  letter-spacing: -0.09px;\n  font-weight: 500;\n  color: #ffffff;\n  background-color: #6b46fe;\n  border: none;\n}\n.pera-wallet-connect-modal-pending-message--try-again-view__resolving-anchor {\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  padding: 16px;\n  background: #ffffff;\n  box-shadow: 0px 0px 1px rgba(12, 26, 75, 0.24), 0px 3px 8px -1px rgba(50, 50, 71, 0.05);\n  border-radius: 12px;\n  text-decoration: none;\n}\n.pera-wallet-connect-modal-pending-message--try-again-view__resolving-anchor__image {\n  width: 24px;\n  height: 24px;\n}\n.pera-wallet-connect-modal-pending-message--try-again-view__resolving-anchor__title-wrapper {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  margin-bottom: 4px;\n}\n.pera-wallet-connect-modal-pending-message--try-again-view__resolving-anchor__title {\n  margin: 0;\n  font-size: 14px;\n  font-weight: 500;\n  line-height: 20px;\n  letter-spacing: -0.1px;\n  color: #3c3c49;\n}\n.pera-wallet-connect-modal-pending-message--try-again-view__resolving-anchor__description {\n  /* stylelint-disable value-no-vendor-prefix */\n  /* stylelint-disable  property-no-vendor-prefix */\n  display: -webkit-box;\n  max-width: 100%;\n  -webkit-line-clamp: 2;\n  /* autoprefixer: ignore next */\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n  /* stylelint-enable value-no-vendor-prefix */\n  /* stylelint-enable property-no-vendor-prefix */\n  margin: 0;\n  font-size: 12px;\n  font-weight: 400;\n  line-height: 18px;\n  letter-spacing: 0.01px;\n  color: #9d9dae;\n}\n\n.pera-wallet-connect-modal-pending-message__animation-wrapper {\n  width: 56px;\n  height: 56px;\n  background-color: #6b46fe;\n  border-radius: 50%;\n}\n\n.pera-wallet-connect-modal-pending-message__text {\n  max-width: 271px;\n  margin-top: 24px;\n  color: #3c3c49;\n  font-size: 18px;\n  font-weight: 500;\n  line-height: 28px;\n  letter-spacing: -0.26px;\n}\n\n.pera-wallet-connect-modal-pending-message__cancel-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  padding: 14px;\n  color: #6a6a81;\n  background-color: #ffffff;\n  box-shadow: 0px 0px 1px rgba(12, 26, 75, 0.24), 0px 3px 8px -1px rgba(50, 50, 71, 0.05);\n  border-radius: 12px;\n  text-decoration: none;\n  text-align: center;\n  font-size: 14px;\n  line-height: 20px;\n  letter-spacing: -0.09px;\n  font-weight: 500;\n  border: none;\n}';
      h(q);
      G = document.createElement("template");
      G.innerHTML = '\n  <div class="pera-wallet-connect-modal-pending-message-section">\n    <div class="pera-wallet-connect-modal-pending-message">\n      <div id="pera-wallet-connect-modal-pending-message-animation-wrapper" class="pera-wallet-connect-modal-pending-message__animation-wrapper"></div>\n\n      <div class="pera-wallet-connect-modal-pending-message__text">\n        Please wait while we connect you to Pera Wallet\n      </div>\n    </div>\n\n    <button\n      id="pera-wallet-connect-modal-pending-message-cancel-button"\n      class="pera-wallet-button pera-wallet-connect-modal-pending-message__cancel-button">\n        Cancel\n    </button>\n  </div>\n\n  <div id="pera-wallet-connect-modal-pending-message-audio-wrapper"></div>\n';
      N = `
  <div class="pera-wallet-connect-modal-pending-message--try-again-view">
    <div>
      <img src="${j}" alt="Pera Wallet Logo" />

      <h1 class="pera-wallet-connect-modal-pending-message--try-again-view__title">
        Couldn\u2019t establish connection
      </h1>

      <p class="pera-wallet-connect-modal-pending-message--try-again-view__description">
        Having issues? Before trying again, make sure to read the support article below and apply the possible solutions.
      </p>
    </div>

    <div>
      <a
        href="https://support.perawallet.app/en/article/resolving-walletconnect-issues-1tolptm/"
        target="_blank"
        rel="noopener noreferrer"
        class="pera-wallet-connect-modal-pending-message--try-again-view__resolving-anchor">
        <img
          class="pera-wallet-connect-modal-pending-message--try-again-view__resolving-anchor__image"
          src="data:image/svg+xml,%3csvg width='24' height='24' viewBox='0 0 24 24' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath fill-rule='evenodd' clip-rule='evenodd' d='M8 22.3199C7.72 22.3199 7.42998 22.2499 7.16998 22.1099C6.59998 21.8099 6.25 21.2099 6.25 20.5699V19.15C3.23 18.84 1.25 16.6199 1.25 13.4399V7.43994C1.25 3.99994 3.56 1.68994 7 1.68994H17C20.44 1.68994 22.75 3.99994 22.75 7.43994V13.4399C22.75 16.8799 20.44 19.1899 17 19.1899H13.23L8.96997 22.03C8.67997 22.22 8.34 22.3199 8 22.3199ZM7 3.17993C4.42 3.17993 2.75 4.84993 2.75 7.42993V13.43C2.75 16.01 4.42 17.68 7 17.68C7.41 17.68 7.75 18.02 7.75 18.43V20.56C7.75 20.69 7.83 20.75 7.88 20.78C7.93001 20.81 8.03001 20.84 8.14001 20.77L12.59 17.81C12.71 17.73 12.86 17.68 13.01 17.68H17.01C19.59 17.68 21.26 16.01 21.26 13.43V7.42993C21.26 4.84993 19.59 3.17993 17.01 3.17993H7ZM11.9998 12.11C11.5898 12.11 11.2498 11.77 11.2498 11.36V11.15C11.2498 10.0038 12.0798 9.4336 12.4082 9.20798L12.4198 9.20001C12.7898 8.95001 12.9098 8.78002 12.9098 8.52002C12.9098 8.02002 12.4998 7.60999 11.9998 7.60999C11.4998 7.60999 11.0898 8.02002 11.0898 8.52002C11.0898 8.93002 10.7498 9.27002 10.3398 9.27002C9.92984 9.27002 9.58984 8.93002 9.58984 8.52002C9.58984 7.19002 10.6698 6.10999 11.9998 6.10999C13.3298 6.10999 14.4098 7.19002 14.4098 8.52002C14.4098 9.66002 13.5698 10.23 13.2598 10.44C12.8698 10.7 12.7498 10.87 12.7498 11.15V11.36C12.7498 11.78 12.4098 12.11 11.9998 12.11ZM11.25 13.85C11.25 14.26 11.58 14.6 12 14.6C12.42 14.6 12.75 14.26 12.75 13.85C12.75 13.44 12.41 13.1 12 13.1C11.59 13.1 11.25 13.44 11.25 13.85Z' fill='%236B46FE'/%3e%3c/svg%3e"
          alt="Help Icon"
        />

        <div>
          <div
            class="pera-wallet-connect-modal-pending-message--try-again-view__resolving-anchor__title-wrapper">
            <h1
              class="pera-wallet-connect-modal-pending-message--try-again-view__resolving-anchor__title">
                Resolving WalletConnect issues
            </h1>

            <img src="data:image/svg+xml,%3csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath fill-rule='evenodd' clip-rule='evenodd' d='M11.3287 10.0983C10.9574 10.0983 10.6564 9.79734 10.6564 9.42604L10.6564 6.29525L5.14866 11.803C4.88611 12.0655 4.46044 12.0655 4.19789 11.803C3.93534 11.5404 3.93534 11.1147 4.19789 10.8522L9.70561 5.34447L6.57482 5.34447C6.20352 5.34447 5.90252 5.04347 5.90252 4.67218C5.90252 4.30088 6.20352 3.99988 6.57482 3.99988L11.3287 3.99988C11.507 3.99988 11.678 4.07071 11.8041 4.19679C11.9301 4.32287 12.001 4.49387 12.001 4.67218L12.001 9.42604C12.001 9.79734 11.7 10.0983 11.3287 10.0983Z' fill='%239D9DAE'/%3e%3c/svg%3e" alt="Send Icon"/>
          </div>

          <p
            class="pera-wallet-connect-modal-pending-message--try-again-view__resolving-anchor__description">
            Unfortunately there are several known issues related to WalletConnect that our team is working on. Some of these issues are related to the WalletConnect JavaScript implementation on the dApp ...
          </p>
        </div>
      </a>

      <button id="pera-wallet-connect-modal-pending-message-try-again-button" class="pera-wallet-connect-button pera-wallet-connect-modal-pending-message--try-again-view__button">
        Close & Try Again
      </button>
    </div>
  </div>
  `;
      Q = class extends HTMLElement {
        constructor() {
          if (super(), this.attachShadow({ mode: "open" }), this.shadowRoot) {
            const e2 = document.createElement("style");
            e2.textContent = q, this.shadowRoot.append(G.content.cloneNode(true), e2);
          }
        }
        connectedCallback() {
          var e2;
          const n3 = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.getElementById("pera-wallet-connect-modal-pending-message-cancel-button");
          null == n3 || n3.addEventListener("click", () => {
            this.onClose();
          }), this.addAudioForConnection(), this.renderLottieAnimation(), setTimeout(() => {
            var e3;
            if (G.innerHTML = N, this.shadowRoot) {
              const n4 = document.createElement("style");
              n4.textContent = q, this.shadowRoot.innerHTML = "", this.shadowRoot.append(G.content.cloneNode(true), n4);
              const t = null === (e3 = this.shadowRoot) || void 0 === e3 ? void 0 : e3.getElementById("pera-wallet-connect-modal-pending-message-try-again-button");
              null == t || t.addEventListener("click", () => {
                this.onClose();
              });
            }
          }, 3e4);
        }
        onClose() {
          vt(ut);
        }
        addAudioForConnection() {
          var e2;
          if ("true" === this.getAttribute("should-use-sound") && Lt()) {
            const n3 = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.getElementById("pera-wallet-connect-modal-pending-message-audio-wrapper"), t = document.createElement("audio");
            t.src = "https://s3.amazonaws.com/wc.perawallet.app/audio.mp3", t.autoplay = true, t.loop = true, null == n3 || n3.appendChild(t);
          }
        }
        renderLottieAnimation() {
          var e2;
          const n3 = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.getElementById("pera-wallet-connect-modal-pending-message-animation-wrapper");
          n3 && import_lottie_web_light.default.loadAnimation({ container: n3, renderer: "svg", loop: true, autoplay: true, path: "https://s3.amazonaws.com/wc.perawallet.app/static/pera-loader-animation.json" });
        }
      };
      J = '.pera-wallet-sign-txn-toast {\n  --pera-wallet-sign-txn-toast-width: 422px;\n  --pera-wallet-sign-txn-toast-height: 134px;\n  --pera-wallet-sign-txn-toast-font-family: "Inter", sans-serif;\n  position: fixed;\n  bottom: 28px;\n  right: 35px;\n  z-index: 11;\n  overflow: hidden;\n  width: var(--pera-wallet-sign-txn-toast-width);\n  height: var(--pera-wallet-sign-txn-toast-height);\n  background: #edeffb;\n  border-radius: 8px;\n  animation: 0.2s PeraWalletSignTxnToastSlideIn ease-out;\n}\n.pera-wallet-sign-txn-toast * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  font-family: var(--pera-wallet-sign-txn-toast-font-family);\n  font-smooth: antialiased;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n.pera-wallet-sign-txn-toast ul,\n.pera-wallet-sign-txn-toast ol,\n.pera-wallet-sign-txn-toast li {\n  list-style-type: none;\n}\n\n.pera-wallet-sign-txn-toast__header__close-button {\n  position: absolute;\n  top: 10px;\n  right: 10px;\n  width: 20px;\n  height: 20px;\n  margin: 0;\n  padding: 0;\n  background: transparent;\n  border: none;\n  cursor: pointer;\n}\n\n.pera-wallet-sign-txn-toast__content__lottie-animation {\n  position: absolute;\n  top: -75px;\n  left: -100px;\n  width: 368px;\n  height: 368px;\n}\n\n.pera-wallet-sign-txn-toast__content__description {\n  position: absolute;\n  top: 40px;\n  right: 48px;\n  max-width: 197px;\n  color: #3c3c49;\n  font-size: 14px;\n  line-height: 22px;\n  letter-spacing: -0.1px;\n}\n\n@media (max-width: 767px) {\n  .pera-wallet-sign-txn-toast {\n    display: none;\n  }\n}\n@keyframes PeraWalletSignTxnToastSlideIn {\n  0% {\n    bottom: 12px;\n    opacity: 0;\n  }\n  100% {\n    bottom: 26px;\n    opacity: 1;\n  }\n}';
      h(J);
      K = document.createElement("template");
      K.innerHTML = `
  <div class="pera-wallet-sign-txn-toast">
    <div class="pera-wallet-sign-txn-toast__header">
      <button
        id="pera-wallet-sign-txn-toast-close-button"
        class="pera-wallet-sign-txn-toast__header__close-button">
        <img src="data:image/svg+xml,%3csvg width='20' height='20' viewBox='0 0 20 20' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M14.4107 4.41074L9.41074 9.41074L10.5893 10.5893L15.5893 5.58926L14.4107 4.41074ZM9.41074 9.41074L4.41074 14.4107L5.58926 15.5893L10.5893 10.5893L9.41074 9.41074ZM15.5893 14.4107L10.5893 9.41074L9.41074 10.5893L14.4107 15.5893L15.5893 14.4107ZM10.5893 9.41074L5.58926 4.41074L4.41074 5.58926L9.41074 10.5893L10.5893 9.41074Z' fill='%239099BD'/%3e%3c/svg%3e" />
      </button>
    </div>
    <div class="pera-wallet-sign-txn-toast__content">
      <div id="pera-wallet-sign-txn-toast-lottie-animation" style="width:368;height:368" class="pera-wallet-sign-txn-toast__content__lottie-animation"></div>
      <p class="pera-wallet-sign-txn-toast__content__description">
        Please launch <b>Pera Wallet</b> on your iOS or Android device to sign this transaction.
      </p>
    </div>
  </div>
`;
      Y = class extends HTMLElement {
        constructor() {
          if (super(), this.attachShadow({ mode: "open" }), this.shadowRoot) {
            const e2 = document.createElement("style");
            e2.textContent = J, this.shadowRoot.append(K.content.cloneNode(true), e2);
            const n3 = this.shadowRoot.getElementById("pera-wallet-sign-txn-toast-close-button");
            null == n3 || n3.addEventListener("click", () => {
              vt(ht);
            }), this.renderLottieAnimation();
          }
        }
        renderLottieAnimation() {
          var e2;
          const n3 = null === (e2 = this.shadowRoot) || void 0 === e2 ? void 0 : e2.getElementById("pera-wallet-sign-txn-toast-lottie-animation");
          n3 && import_lottie_web_light.default.loadAnimation({ container: n3, renderer: "svg", loop: true, autoplay: true, path: "https://s3.amazonaws.com/wc.perawallet.app/static/sign-toast-animation.json" });
        }
      };
      X = '@import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");\n.pera-wallet-modal {\n  --pera-wallet-modal-font-family: "Inter", sans-serif;\n  --pera-wallet-modal-compact-width: 380px;\n  --pera-wallet-modal-compact-height: 396px;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  position: fixed;\n  top: 0;\n  right: 0;\n  left: 0;\n  bottom: 0;\n  z-index: 999999;\n  width: 100vw;\n  height: 100vh;\n  background-color: rgba(0, 0, 0, 0.7);\n}\n.pera-wallet-modal--select-account .pera-wallet-modal__body {\n  width: 480px;\n  height: 578px;\n  background-color: #ffffff;\n}\n.pera-wallet-modal--mobile .pera-wallet-modal__body {\n  top: 40px;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  max-width: unset;\n  height: calc(100 * var(--pera-wallet-vh));\n  padding: 20px;\n  background-color: #ffffff;\n  box-shadow: 0 1px 4px rgba(0, 0, 0, 0.02), 0 4px 12px rgba(0, 0, 0, 0.03);\n  border-radius: 20px 20px 0px 0px;\n  animation: 0.3s PeraWalletConnectMobileSlideIn ease-out;\n  overflow-y: auto;\n  transform: unset;\n}\n.pera-wallet-modal--mobile .pera-wallet-modal__body::before {\n  background-image: unset;\n}\n.pera-wallet-modal--compact:not(.pera-wallet-modal--mobile) .pera-wallet-modal__body {\n  width: var(--pera-wallet-modal-compact-width);\n  height: var(--pera-wallet-modal-compact-height);\n  padding: 0;\n}\n.pera-wallet-modal * {\n  box-sizing: border-box;\n  margin: 0;\n  padding: 0;\n  font-family: var(--pera-wallet-modal-font-family);\n  font-smooth: antialiased;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n.pera-wallet-modal ul,\n.pera-wallet-modal ol,\n.pera-wallet-modal li {\n  list-style-type: none;\n}\n\n.pera-wallet-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: auto;\n  height: 48px;\n  padding: 14px;\n  border: none;\n  border-radius: 12px;\n  outline: none;\n  cursor: pointer;\n  font-family: var(--pera-wallet-modal-font-family);\n  font-size: 14px;\n}\n\n.pera-wallet-modal__logo img {\n  display: block;\n  width: 32px;\n}\n\n.pera-wallet-modal__body {\n  position: relative;\n  top: 50%;\n  left: 50%;\n  width: 700px;\n  max-width: calc(100vw - 80px);\n  padding: 28px;\n  background-color: #f3f3f7;\n  box-shadow: 1px 2px 2px rgba(0, 0, 0, 0.08);\n  border-radius: 24px;\n  animation: 0.3s PeraWalletConnectSlideIn ease-out;\n  transform: translate(-50%, -50%);\n}\n.pera-wallet-modal__body::before {\n  --background-line: #1e0972 0 1.2px, transparent 0 calc(100% - 1.2px), #1e0972;\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  z-index: -1;\n  content: "";\n  background-image: linear-gradient(var(--background-line)), linear-gradient(90deg, var(--background-line));\n  background-size: 116px 116px;\n  mix-blend-mode: overlay;\n  border-radius: 24px;\n  opacity: 0.8;\n  pointer-events: none;\n}\n\n@media (max-width: 767px) {\n  .pera-wallet-modal--desktop .pera-wallet-modal__body {\n    width: 100%;\n    max-width: calc(100vw - 32px);\n    padding: 24px;\n  }\n}\n@keyframes PeraWalletConnectSlideIn {\n  0% {\n    opacity: 0;\n    transform: translate(-50%, calc(-50% + 24px));\n  }\n  100% {\n    opacity: 1;\n    transform: translate(-50%, -50%);\n  }\n}\n@keyframes PeraWalletConnectMobileSlideIn {\n  0% {\n    top: 30%;\n    opacity: 0;\n  }\n  100% {\n    top: 40px;\n    opacity: 1;\n  }\n}\n.pera-wallet-sign-txn-modal.pera-wallet-modal .pera-wallet-modal__body {\n  width: 480px;\n  height: 578px;\n  background-color: #ffffff;\n  background-image: unset;\n  padding: 0;\n}\n.pera-wallet-sign-txn-modal.pera-wallet-modal .pera-wallet-modal__body .pera-wallet-sign-txn-modal__body__content {\n  width: 100%;\n  height: 100%;\n}\n.pera-wallet-sign-txn-modal.pera-wallet-modal .pera-wallet-modal__body #pera-wallet-iframe {\n  width: 100%;\n  height: 100%;\n  border-radius: 16px;\n  margin: 0 auto;\n  border: none;\n}\n\n.pera-wallet-sign-txn-modal--compact.pera-wallet-modal .pera-wallet-modal__body {\n  width: var(--pera-wallet-modal-compact-width);\n  height: var(--pera-wallet-modal-compact-height);\n}';
      h(X);
      ee = document.createElement("template");
      ee.innerHTML = `
  <div id="pera-wallet-sign-txn-modal" class="${dt} pera-wallet-sign-txn-modal">
    <div class="pera-wallet-modal__body">
      <pera-wallet-modal-header modal-id="${ft}"></pera-wallet-modal-header/>

      <div class="pera-wallet-sign-txn-modal__body__content" />
    </div>
  </div>
`;
      ne = class extends HTMLElement {
        constructor() {
          if (super(), this.attachShadow({ mode: "open" }), this.shadowRoot) {
            const e2 = document.createElement("style");
            e2.textContent = X, this.shadowRoot.append(ee.content.cloneNode(true), e2);
            if ("true" === this.getAttribute("compact-mode")) {
              const e3 = this.shadowRoot.getElementById("pera-wallet-sign-txn-modal");
              null == e3 || e3.classList.add("pera-wallet-sign-txn-modal--compact");
            }
          }
        }
      };
      window.addEventListener("DOMContentLoaded", () => {
        te();
      }), window.addEventListener("resize", () => {
        te();
      }), ae("pera-wallet-connect-modal", S), ae("pera-wallet-modal-desktop-mode", Z), ae("pera-wallet-modal-header", u), ae("pera-wallet-modal-touch-screen-mode", A), ae("pera-wallet-redirect-modal", $), ae("pera-wallet-connect-modal-information-section", U), ae("pera-wallet-connect-modal-pending-message-section", Q), ae("pera-wallet-sign-txn-toast", Y), ae("pera-wallet-sign-txn-modal", ne), ae("pera-wallet-download-qr-code", C);
    }
  });

  // node_modules/@perawallet/connect/dist/index-87e811df.js
  function l() {
    a = true;
    for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e2 = 0; e2 < 64; ++e2) o2[e2] = t[e2], i[t.charCodeAt(e2)] = e2;
    i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63;
  }
  function u2(t, e2, n3) {
    for (var r3, i2, s2 = [], a2 = e2; a2 < n3; a2 += 3) r3 = (t[a2] << 16) + (t[a2 + 1] << 8) + t[a2 + 2], s2.push(o2[(i2 = r3) >> 18 & 63] + o2[i2 >> 12 & 63] + o2[i2 >> 6 & 63] + o2[63 & i2]);
    return s2.join("");
  }
  function c(t) {
    var e2;
    a || l();
    for (var n3 = t.length, r3 = n3 % 3, i2 = "", s2 = [], c2 = 16383, h3 = 0, f3 = n3 - r3; h3 < f3; h3 += c2) s2.push(u2(t, h3, h3 + c2 > f3 ? f3 : h3 + c2));
    return 1 === r3 ? (e2 = t[n3 - 1], i2 += o2[e2 >> 2], i2 += o2[e2 << 4 & 63], i2 += "==") : 2 === r3 && (e2 = (t[n3 - 2] << 8) + t[n3 - 1], i2 += o2[e2 >> 10], i2 += o2[e2 >> 4 & 63], i2 += o2[e2 << 2 & 63], i2 += "="), s2.push(i2), s2.join("");
  }
  function h2(t, e2, n3, r3, o3) {
    var i2, s2, a2 = 8 * o3 - r3 - 1, l2 = (1 << a2) - 1, u3 = l2 >> 1, c2 = -7, h3 = n3 ? o3 - 1 : 0, f3 = n3 ? -1 : 1, d2 = t[e2 + h3];
    for (h3 += f3, i2 = d2 & (1 << -c2) - 1, d2 >>= -c2, c2 += a2; c2 > 0; i2 = 256 * i2 + t[e2 + h3], h3 += f3, c2 -= 8) ;
    for (s2 = i2 & (1 << -c2) - 1, i2 >>= -c2, c2 += r3; c2 > 0; s2 = 256 * s2 + t[e2 + h3], h3 += f3, c2 -= 8) ;
    if (0 === i2) i2 = 1 - u3;
    else {
      if (i2 === l2) return s2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
      s2 += Math.pow(2, r3), i2 -= u3;
    }
    return (d2 ? -1 : 1) * s2 * Math.pow(2, i2 - r3);
  }
  function f2(t, e2, n3, r3, o3, i2) {
    var s2, a2, l2, u3 = 8 * i2 - o3 - 1, c2 = (1 << u3) - 1, h3 = c2 >> 1, f3 = 23 === o3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = r3 ? 0 : i2 - 1, p2 = r3 ? 1 : -1, g3 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
    for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (a2 = isNaN(e2) ? 1 : 0, s2 = c2) : (s2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -s2)) < 1 && (s2--, l2 *= 2), (e2 += s2 + h3 >= 1 ? f3 / l2 : f3 * Math.pow(2, 1 - h3)) * l2 >= 2 && (s2++, l2 /= 2), s2 + h3 >= c2 ? (a2 = 0, s2 = c2) : s2 + h3 >= 1 ? (a2 = (e2 * l2 - 1) * Math.pow(2, o3), s2 += h3) : (a2 = e2 * Math.pow(2, h3 - 1) * Math.pow(2, o3), s2 = 0)); o3 >= 8; t[n3 + d2] = 255 & a2, d2 += p2, a2 /= 256, o3 -= 8) ;
    for (s2 = s2 << o3 | a2, u3 += o3; u3 > 0; t[n3 + d2] = 255 & s2, d2 += p2, s2 /= 256, u3 -= 8) ;
    t[n3 + d2 - p2] |= 128 * g3;
  }
  function g2() {
    return y2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function w2(t, e2) {
    if (g2() < e2) throw new RangeError("Invalid typed array length");
    return y2.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e2)).__proto__ = y2.prototype : (null === t && (t = new y2(e2)), t.length = e2), t;
  }
  function y2(t, e2, n3) {
    if (!(y2.TYPED_ARRAY_SUPPORT || this instanceof y2)) return new y2(t, e2, n3);
    if ("number" == typeof t) {
      if ("string" == typeof e2) throw new Error("If encoding is specified then the first argument must be a string");
      return b2(this, t);
    }
    return v2(this, t, e2, n3);
  }
  function v2(t, e2, n3, r3) {
    if ("number" == typeof e2) throw new TypeError('"value" argument must not be a number');
    return "undefined" != typeof ArrayBuffer && e2 instanceof ArrayBuffer ? function(t2, e3, n4, r4) {
      if (e3.byteLength, n4 < 0 || e3.byteLength < n4) throw new RangeError("'offset' is out of bounds");
      if (e3.byteLength < n4 + (r4 || 0)) throw new RangeError("'length' is out of bounds");
      e3 = void 0 === n4 && void 0 === r4 ? new Uint8Array(e3) : void 0 === r4 ? new Uint8Array(e3, n4) : new Uint8Array(e3, n4, r4);
      y2.TYPED_ARRAY_SUPPORT ? (t2 = e3).__proto__ = y2.prototype : t2 = A2(t2, e3);
      return t2;
    }(t, e2, n3, r3) : "string" == typeof e2 ? function(t2, e3, n4) {
      "string" == typeof n4 && "" !== n4 || (n4 = "utf8");
      if (!y2.isEncoding(n4)) throw new TypeError('"encoding" must be a valid string encoding');
      var r4 = 0 | _2(e3, n4);
      t2 = w2(t2, r4);
      var o3 = t2.write(e3, n4);
      o3 !== r4 && (t2 = t2.slice(0, o3));
      return t2;
    }(t, e2, n3) : function(t2, e3) {
      if (T2(e3)) {
        var n4 = 0 | E2(e3.length);
        return 0 === (t2 = w2(t2, n4)).length || e3.copy(t2, 0, 0, n4), t2;
      }
      if (e3) {
        if ("undefined" != typeof ArrayBuffer && e3.buffer instanceof ArrayBuffer || "length" in e3) return "number" != typeof e3.length || (r4 = e3.length) != r4 ? w2(t2, 0) : A2(t2, e3);
        if ("Buffer" === e3.type && p(e3.data)) return A2(t2, e3.data);
      }
      var r4;
      throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
    }(t, e2);
  }
  function m2(t) {
    if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
    if (t < 0) throw new RangeError('"size" argument must not be negative');
  }
  function b2(t, e2) {
    if (m2(e2), t = w2(t, e2 < 0 ? 0 : 0 | E2(e2)), !y2.TYPED_ARRAY_SUPPORT) for (var n3 = 0; n3 < e2; ++n3) t[n3] = 0;
    return t;
  }
  function A2(t, e2) {
    var n3 = e2.length < 0 ? 0 : 0 | E2(e2.length);
    t = w2(t, n3);
    for (var r3 = 0; r3 < n3; r3 += 1) t[r3] = 255 & e2[r3];
    return t;
  }
  function E2(t) {
    if (t >= g2()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + g2().toString(16) + " bytes");
    return 0 | t;
  }
  function T2(t) {
    return !(null == t || !t._isBuffer);
  }
  function _2(t, e2) {
    if (T2(t)) return t.length;
    if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
    "string" != typeof t && (t = "" + t);
    var n3 = t.length;
    if (0 === n3) return 0;
    for (var r3 = false; ; ) switch (e2) {
      case "ascii":
      case "latin1":
      case "binary":
        return n3;
      case "utf8":
      case "utf-8":
      case void 0:
        return V2(t).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * n3;
      case "hex":
        return n3 >>> 1;
      case "base64":
        return Z2(t).length;
      default:
        if (r3) return V2(t).length;
        e2 = ("" + e2).toLowerCase(), r3 = true;
    }
  }
  function R2(t, e2, n3) {
    var r3 = false;
    if ((void 0 === e2 || e2 < 0) && (e2 = 0), e2 > this.length) return "";
    if ((void 0 === n3 || n3 > this.length) && (n3 = this.length), n3 <= 0) return "";
    if ((n3 >>>= 0) <= (e2 >>>= 0)) return "";
    for (t || (t = "utf8"); ; ) switch (t) {
      case "hex":
        return k2(this, e2, n3);
      case "utf8":
      case "utf-8":
        return W2(this, e2, n3);
      case "ascii":
        return x2(this, e2, n3);
      case "latin1":
      case "binary":
        return Y2(this, e2, n3);
      case "base64":
        return B2(this, e2, n3);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return j2(this, e2, n3);
      default:
        if (r3) throw new TypeError("Unknown encoding: " + t);
        t = (t + "").toLowerCase(), r3 = true;
    }
  }
  function S2(t, e2, n3) {
    var r3 = t[e2];
    t[e2] = t[n3], t[n3] = r3;
  }
  function N2(t, e2, n3, r3, o3) {
    if (0 === t.length) return -1;
    if ("string" == typeof n3 ? (r3 = n3, n3 = 0) : n3 > 2147483647 ? n3 = 2147483647 : n3 < -2147483648 && (n3 = -2147483648), n3 = +n3, isNaN(n3) && (n3 = o3 ? 0 : t.length - 1), n3 < 0 && (n3 = t.length + n3), n3 >= t.length) {
      if (o3) return -1;
      n3 = t.length - 1;
    } else if (n3 < 0) {
      if (!o3) return -1;
      n3 = 0;
    }
    if ("string" == typeof e2 && (e2 = y2.from(e2, r3)), T2(e2)) return 0 === e2.length ? -1 : C2(t, e2, n3, r3, o3);
    if ("number" == typeof e2) return e2 &= 255, y2.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o3 ? Uint8Array.prototype.indexOf.call(t, e2, n3) : Uint8Array.prototype.lastIndexOf.call(t, e2, n3) : C2(t, [e2], n3, r3, o3);
    throw new TypeError("val must be string, number or Buffer");
  }
  function C2(t, e2, n3, r3, o3) {
    var i2, s2 = 1, a2 = t.length, l2 = e2.length;
    if (void 0 !== r3 && ("ucs2" === (r3 = String(r3).toLowerCase()) || "ucs-2" === r3 || "utf16le" === r3 || "utf-16le" === r3)) {
      if (t.length < 2 || e2.length < 2) return -1;
      s2 = 2, a2 /= 2, l2 /= 2, n3 /= 2;
    }
    function u3(t2, e3) {
      return 1 === s2 ? t2[e3] : t2.readUInt16BE(e3 * s2);
    }
    if (o3) {
      var c2 = -1;
      for (i2 = n3; i2 < a2; i2++) if (u3(t, i2) === u3(e2, -1 === c2 ? 0 : i2 - c2)) {
        if (-1 === c2 && (c2 = i2), i2 - c2 + 1 === l2) return c2 * s2;
      } else -1 !== c2 && (i2 -= i2 - c2), c2 = -1;
    } else for (n3 + l2 > a2 && (n3 = a2 - l2), i2 = n3; i2 >= 0; i2--) {
      for (var h3 = true, f3 = 0; f3 < l2; f3++) if (u3(t, i2 + f3) !== u3(e2, f3)) {
        h3 = false;
        break;
      }
      if (h3) return i2;
    }
    return -1;
  }
  function I2(t, e2, n3, r3) {
    n3 = Number(n3) || 0;
    var o3 = t.length - n3;
    r3 ? (r3 = Number(r3)) > o3 && (r3 = o3) : r3 = o3;
    var i2 = e2.length;
    if (i2 % 2 != 0) throw new TypeError("Invalid hex string");
    r3 > i2 / 2 && (r3 = i2 / 2);
    for (var s2 = 0; s2 < r3; ++s2) {
      var a2 = parseInt(e2.substr(2 * s2, 2), 16);
      if (isNaN(a2)) return s2;
      t[n3 + s2] = a2;
    }
    return s2;
  }
  function P2(t, e2, n3, r3) {
    return Q2(V2(e2, t.length - n3), t, n3, r3);
  }
  function O2(t, e2, n3, r3) {
    return Q2(function(t2) {
      for (var e3 = [], n4 = 0; n4 < t2.length; ++n4) e3.push(255 & t2.charCodeAt(n4));
      return e3;
    }(e2), t, n3, r3);
  }
  function L2(t, e2, n3, r3) {
    return O2(t, e2, n3, r3);
  }
  function M2(t, e2, n3, r3) {
    return Q2(Z2(e2), t, n3, r3);
  }
  function U2(t, e2, n3, r3) {
    return Q2(function(t2, e3) {
      for (var n4, r4, o3, i2 = [], s2 = 0; s2 < t2.length && !((e3 -= 2) < 0); ++s2) r4 = (n4 = t2.charCodeAt(s2)) >> 8, o3 = n4 % 256, i2.push(o3), i2.push(r4);
      return i2;
    }(e2, t.length - n3), t, n3, r3);
  }
  function B2(t, e2, n3) {
    return 0 === e2 && n3 === t.length ? c(t) : c(t.slice(e2, n3));
  }
  function W2(t, e2, n3) {
    n3 = Math.min(t.length, n3);
    for (var r3 = [], o3 = e2; o3 < n3; ) {
      var i2, s2, a2, l2, u3 = t[o3], c2 = null, h3 = u3 > 239 ? 4 : u3 > 223 ? 3 : u3 > 191 ? 2 : 1;
      if (o3 + h3 <= n3) switch (h3) {
        case 1:
          u3 < 128 && (c2 = u3);
          break;
        case 2:
          128 == (192 & (i2 = t[o3 + 1])) && (l2 = (31 & u3) << 6 | 63 & i2) > 127 && (c2 = l2);
          break;
        case 3:
          i2 = t[o3 + 1], s2 = t[o3 + 2], 128 == (192 & i2) && 128 == (192 & s2) && (l2 = (15 & u3) << 12 | (63 & i2) << 6 | 63 & s2) > 2047 && (l2 < 55296 || l2 > 57343) && (c2 = l2);
          break;
        case 4:
          i2 = t[o3 + 1], s2 = t[o3 + 2], a2 = t[o3 + 3], 128 == (192 & i2) && 128 == (192 & s2) && 128 == (192 & a2) && (l2 = (15 & u3) << 18 | (63 & i2) << 12 | (63 & s2) << 6 | 63 & a2) > 65535 && l2 < 1114112 && (c2 = l2);
      }
      null === c2 ? (c2 = 65533, h3 = 1) : c2 > 65535 && (c2 -= 65536, r3.push(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), r3.push(c2), o3 += h3;
    }
    return function(t2) {
      var e3 = t2.length;
      if (e3 <= D2) return String.fromCharCode.apply(String, t2);
      var n4 = "", r4 = 0;
      for (; r4 < e3; ) n4 += String.fromCharCode.apply(String, t2.slice(r4, r4 += D2));
      return n4;
    }(r3);
  }
  function x2(t, e2, n3) {
    var r3 = "";
    n3 = Math.min(t.length, n3);
    for (var o3 = e2; o3 < n3; ++o3) r3 += String.fromCharCode(127 & t[o3]);
    return r3;
  }
  function Y2(t, e2, n3) {
    var r3 = "";
    n3 = Math.min(t.length, n3);
    for (var o3 = e2; o3 < n3; ++o3) r3 += String.fromCharCode(t[o3]);
    return r3;
  }
  function k2(t, e2, n3) {
    var r3 = t.length;
    (!e2 || e2 < 0) && (e2 = 0), (!n3 || n3 < 0 || n3 > r3) && (n3 = r3);
    for (var o3 = "", i2 = e2; i2 < n3; ++i2) o3 += J2(t[i2]);
    return o3;
  }
  function j2(t, e2, n3) {
    for (var r3 = t.slice(e2, n3), o3 = "", i2 = 0; i2 < r3.length; i2 += 2) o3 += String.fromCharCode(r3[i2] + 256 * r3[i2 + 1]);
    return o3;
  }
  function $2(t, e2, n3) {
    if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
    if (t + e2 > n3) throw new RangeError("Trying to access beyond buffer length");
  }
  function G2(t, e2, n3, r3, o3, i2) {
    if (!T2(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e2 > o3 || e2 < i2) throw new RangeError('"value" argument is out of bounds');
    if (n3 + r3 > t.length) throw new RangeError("Index out of range");
  }
  function q2(t, e2, n3, r3) {
    e2 < 0 && (e2 = 65535 + e2 + 1);
    for (var o3 = 0, i2 = Math.min(t.length - n3, 2); o3 < i2; ++o3) t[n3 + o3] = (e2 & 255 << 8 * (r3 ? o3 : 1 - o3)) >>> 8 * (r3 ? o3 : 1 - o3);
  }
  function z2(t, e2, n3, r3) {
    e2 < 0 && (e2 = 4294967295 + e2 + 1);
    for (var o3 = 0, i2 = Math.min(t.length - n3, 4); o3 < i2; ++o3) t[n3 + o3] = e2 >>> 8 * (r3 ? o3 : 3 - o3) & 255;
  }
  function F2(t, e2, n3, r3, o3, i2) {
    if (n3 + r3 > t.length) throw new RangeError("Index out of range");
    if (n3 < 0) throw new RangeError("Index out of range");
  }
  function H2(t, e2, n3, r3, o3) {
    return o3 || F2(t, 0, n3, 4), f2(t, e2, n3, r3, 23, 4), n3 + 4;
  }
  function K2(t, e2, n3, r3, o3) {
    return o3 || F2(t, 0, n3, 8), f2(t, e2, n3, r3, 52, 8), n3 + 8;
  }
  function J2(t) {
    return t < 16 ? "0" + t.toString(16) : t.toString(16);
  }
  function V2(t, e2) {
    var n3;
    e2 = e2 || 1 / 0;
    for (var r3 = t.length, o3 = null, i2 = [], s2 = 0; s2 < r3; ++s2) {
      if ((n3 = t.charCodeAt(s2)) > 55295 && n3 < 57344) {
        if (!o3) {
          if (n3 > 56319) {
            (e2 -= 3) > -1 && i2.push(239, 191, 189);
            continue;
          }
          if (s2 + 1 === r3) {
            (e2 -= 3) > -1 && i2.push(239, 191, 189);
            continue;
          }
          o3 = n3;
          continue;
        }
        if (n3 < 56320) {
          (e2 -= 3) > -1 && i2.push(239, 191, 189), o3 = n3;
          continue;
        }
        n3 = 65536 + (o3 - 55296 << 10 | n3 - 56320);
      } else o3 && (e2 -= 3) > -1 && i2.push(239, 191, 189);
      if (o3 = null, n3 < 128) {
        if ((e2 -= 1) < 0) break;
        i2.push(n3);
      } else if (n3 < 2048) {
        if ((e2 -= 2) < 0) break;
        i2.push(n3 >> 6 | 192, 63 & n3 | 128);
      } else if (n3 < 65536) {
        if ((e2 -= 3) < 0) break;
        i2.push(n3 >> 12 | 224, n3 >> 6 & 63 | 128, 63 & n3 | 128);
      } else {
        if (!(n3 < 1114112)) throw new Error("Invalid code point");
        if ((e2 -= 4) < 0) break;
        i2.push(n3 >> 18 | 240, n3 >> 12 & 63 | 128, n3 >> 6 & 63 | 128, 63 & n3 | 128);
      }
    }
    return i2;
  }
  function Z2(t) {
    return function(t2) {
      var e2, n3, r3, o3, u3, c2;
      a || l();
      var h3 = t2.length;
      if (h3 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
      u3 = "=" === t2[h3 - 2] ? 2 : "=" === t2[h3 - 1] ? 1 : 0, c2 = new s(3 * h3 / 4 - u3), r3 = u3 > 0 ? h3 - 4 : h3;
      var f3 = 0;
      for (e2 = 0, n3 = 0; e2 < r3; e2 += 4, n3 += 3) o3 = i[t2.charCodeAt(e2)] << 18 | i[t2.charCodeAt(e2 + 1)] << 12 | i[t2.charCodeAt(e2 + 2)] << 6 | i[t2.charCodeAt(e2 + 3)], c2[f3++] = o3 >> 16 & 255, c2[f3++] = o3 >> 8 & 255, c2[f3++] = 255 & o3;
      return 2 === u3 ? (o3 = i[t2.charCodeAt(e2)] << 2 | i[t2.charCodeAt(e2 + 1)] >> 4, c2[f3++] = 255 & o3) : 1 === u3 && (o3 = i[t2.charCodeAt(e2)] << 10 | i[t2.charCodeAt(e2 + 1)] << 4 | i[t2.charCodeAt(e2 + 2)] >> 2, c2[f3++] = o3 >> 8 & 255, c2[f3++] = 255 & o3), c2;
    }(function(t2) {
      if ((t2 = function(t3) {
        return t3.trim ? t3.trim() : t3.replace(/^\s+|\s+$/g, "");
      }(t2).replace(X2, "")).length < 2) return "";
      for (; t2.length % 4 != 0; ) t2 += "=";
      return t2;
    }(t));
  }
  function Q2(t, e2, n3, r3) {
    for (var o3 = 0; o3 < r3 && !(o3 + n3 >= e2.length || o3 >= t.length); ++o3) e2[o3 + n3] = t[o3];
    return o3;
  }
  function tt(t) {
    return !!t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t);
  }
  function et(t, e2, n3, r3) {
    return new (n3 || (n3 = Promise))(function(o3, i2) {
      function s2(t2) {
        try {
          l2(r3.next(t2));
        } catch (t3) {
          i2(t3);
        }
      }
      function a2(t2) {
        try {
          l2(r3.throw(t2));
        } catch (t3) {
          i2(t3);
        }
      }
      function l2(t2) {
        var e3;
        t2.done ? o3(t2.value) : (e3 = t2.value, e3 instanceof n3 ? e3 : new n3(function(t3) {
          t3(e3);
        })).then(s2, a2);
      }
      l2((r3 = r3.apply(t, e2 || [])).next());
    });
  }
  function st() {
    const t = document.querySelector('meta[name="name"]'), e2 = document.querySelector('meta[name="description"]');
    let { title: n3 } = document, r3 = "";
    return t instanceof HTMLMetaElement && (n3 = t.content), e2 instanceof HTMLMetaElement && (r3 = e2.content), { title: n3, description: r3, url: window.location.origin, favicon: at()[0] };
  }
  function at() {
    const t = document.getElementsByTagName("link"), e2 = [];
    for (let n3 = 0; n3 < t.length; n3++) {
      const r3 = t[n3], o3 = r3.getAttribute("rel");
      if (o3 && o3.toLowerCase().indexOf("icon") > -1) {
        const t2 = r3.getAttribute("href");
        if (t2 && -1 === t2.toLowerCase().indexOf("https:") && -1 === t2.toLowerCase().indexOf("http:") && 0 !== t2.indexOf("//")) {
          let n4 = `${window.location.protocol}//${window.location.host}`;
          if (0 === t2.indexOf("/")) n4 += t2;
          else {
            const e3 = window.location.pathname.split("/");
            e3.pop();
            n4 += `${e3.join("/")}/${t2}`;
          }
          e2.push(n4);
        } else if (0 === (null == t2 ? void 0 : t2.indexOf("//"))) {
          const n4 = window.location.protocol + t2;
          e2.push(n4);
        } else t2 && e2.push(t2);
      }
    }
    return e2;
  }
  function lt(t) {
    return new Promise((e2, n3) => {
      try {
        const r3 = window.open(t, "_blank");
        let o3 = 0;
        const i2 = setInterval(() => {
          if (o3 += 1, o3 === it) return clearInterval(i2), void n3(new nt({ type: "MESSAGE_NOT_RECEIVED" }, "Couldn't open Pera Wallet, please try again."));
          r3 && (true === r3.closed && (clearInterval(i2), n3(new nt({ type: "OPERATION_CANCELLED" }, "Operation cancelled by user"))), rt.sendMessage({ message: { type: "TAB_OPEN" }, origin: t, targetWindow: r3 }));
        }, ot);
        rt.setupListener({ onReceiveMessage: (t2) => {
          "TAB_OPEN_RECEIVED" === t2.data.message.type && (clearInterval(i2), e2(r3));
        } });
      } catch (t2) {
        n3(t2);
      }
    });
  }
  function pt(t) {
    const e2 = document.createElement("div");
    return e2.setAttribute("id", t), document.body.appendChild(e2), e2;
  }
  function gt() {
    pt(ct).innerHTML = "<pera-wallet-redirect-modal></pera-wallet-redirect-modal>";
  }
  function wt() {
    pt(ht).innerHTML = "<pera-wallet-sign-txn-toast></pera-wallet-sign-txn-toast>";
  }
  function vt(t) {
    const e2 = document.getElementById(t);
    e2 && e2.remove();
  }
  function bt() {
    return "undefined" == typeof localStorage ? void 0 : localStorage;
  }
  function At(t, e2) {
    var n3;
    null === (n3 = bt()) || void 0 === n3 || n3.setItem(mt.WALLET, JSON.stringify({ type: e2 || "pera-wallet", accounts: t, selectedAccount: t[0] }));
  }
  function Et() {
    var t;
    const e2 = null === (t = bt()) || void 0 === t ? void 0 : t.getItem(mt.WALLET);
    return e2 ? JSON.parse(e2) : null;
  }
  function Tt() {
    return new Promise((t, e2) => {
      var n3, r3;
      try {
        null === (n3 = bt()) || void 0 === n3 || n3.removeItem(mt.WALLETCONNECT), null === (r3 = bt()) || void 0 === r3 || r3.removeItem(mt.WALLET), t(void 0);
      } catch (t2) {
        e2(t2);
      }
    });
  }
  function _t(t) {
    const e2 = t.slice();
    for (let t2 = e2.length - 1; t2 > 0; t2--) {
      const n3 = Math.floor(Math.random() * (t2 + 1));
      [e2[t2], e2[n3]] = [e2[n3], e2[t2]];
    }
    return e2;
  }
  function St() {
    return function(t, e2 = {}) {
      return fetch(t, e2).then((t2) => t2.json()).then((t2) => t2);
    }(Rt, { cache: "no-store" });
  }
  function Nt() {
    return et(this, void 0, void 0, function* () {
      let t = { bridgeURL: "", webWalletURL: "", isWebWalletAvailable: false, shouldDisplayNewBadge: false, shouldUseSound: true, silent: false, promoteMobile: false };
      try {
        const e2 = yield St();
        void 0 !== e2.web_wallet && e2.web_wallet_url && (t.isWebWalletAvailable = e2.web_wallet), void 0 !== e2.display_new_badge && (t.shouldDisplayNewBadge = e2.display_new_badge), void 0 !== e2.use_sound && (t.shouldUseSound = e2.use_sound), void 0 !== e2.silent && (t.silent = e2.silent), void 0 !== e2.promote_mobile && (t.promoteMobile = e2.promote_mobile), t = Object.assign(Object.assign({}, t), { bridgeURL: _t(e2.servers || [])[0] || "", webWalletURL: e2.web_wallet_url || "" });
      } catch (t2) {
        console.log(t2);
      }
      return t;
    });
  }
  function Ct(t) {
    return Uint8Array.from(window.atob(t), (t2) => t2.charCodeAt(0));
  }
  function It(t, e2) {
    return { id: Date.now() * Math.pow(10, 3) + Math.floor(Math.random() * Math.pow(10, 3)), jsonrpc: "2.0", method: t, params: e2 };
  }
  function Pt() {
    return "undefined" != typeof navigator;
  }
  function Ot() {
    return Pt() && /Android/i.test(navigator.userAgent);
  }
  function Lt() {
    return Pt() && /iPhone|iPad|iPod/i.test(navigator.userAgent);
  }
  function Mt() {
    return Pt() && /iPhone|iPod|Android/i.test(navigator.userAgent);
  }
  function Ut() {
    if (!Pt()) return null;
    const { userAgent: t } = navigator;
    let e2;
    return e2 = t.match(/DuckDuckGo/i) ? "DuckDuckGo" : t.match(/OPX/i) ? "Opera GX" : navigator.brave ? "Brave" : import_bowser2.default.getParser(navigator.userAgent).getBrowserName(), e2;
  }
  function Dt(t) {
    return { ROOT: `https://${t}`, CONNECT: `https://${t}/connect`, TRANSACTION_SIGN: `https://${t}/transaction/sign` };
  }
  function xt({ method: t, signTxnRequestParams: e2, signer: n3, chainId: r3, webWalletURL: o3, resolve: i2, reject: s2 }) {
    const a2 = Dt(o3);
    !function() {
      et(this, void 0, void 0, function* () {
        try {
          const o4 = yield lt(a2.TRANSACTION_SIGN);
          if (o4) {
            let i3;
            "SIGN_TXN" === t ? i3 = { type: "SIGN_TXN", txn: e2 } : "SIGN_DATA" === t && n3 && r3 && (i3 = { type: "SIGN_DATA", data: e2, signer: n3, chainId: r3 }), i3 && rt.sendMessage({ message: i3, origin: a2.TRANSACTION_SIGN, targetWindow: o4 });
          }
          const l2 = setInterval(() => {
            true === (null == o4 ? void 0 : o4.closed) && (s2(new nt({ type: `${t}_CANCELLED` }, "Transaction signing is cancelled by user.")), clearInterval(l2));
          }, 2e3);
          rt.setupListener({ onReceiveMessage: (e3) => function({ event: t2, newPeraWalletTab: e4, method: n4, resolve: r4, reject: o5 }) {
            switch (t2.data.message.type) {
              case "SIGN_TXN_CALLBACK":
                null == e4 || e4.close(), r4(t2.data.message.signedTxns.map((t3) => Ct(t3.signedTxn)));
                break;
              case "SIGN_DATA_CALLBACK":
                null == e4 || e4.close(), r4(t2.data.message.signedData.map((t3) => Ct(t3.signedData)));
                break;
              case "SIGN_TXN_NETWORK_MISMATCH":
                o5(new nt({ type: `${n4}_NETWORK_MISMATCH`, detail: t2.data.message.error }, t2.data.message.error || "Network mismatch"));
                break;
              case "SIGN_TXN_CALLBACK_ERROR":
                null == e4 || e4.close(), o5(new nt({ type: `${n4}_CANCELLED` }, t2.data.message.error));
                break;
              case "SESSION_DISCONNECTED":
                null == e4 || e4.close(), Tt(), o5(new nt({ type: "SESSION_DISCONNECTED", detail: t2.data.message.error }, t2.data.message.error));
            }
          }({ event: e3, newPeraWalletTab: o4, method: t, resolve: i2, reject: s2 }) });
        } catch (t2) {
          s2(t2);
        }
      });
    }();
  }
  function Yt({ webWalletURL: t, chainId: e2, resolve: n3, reject: r3 }) {
    const o3 = Dt(t);
    return function() {
      return et(this, void 0, void 0, function* () {
        try {
          const t2 = yield lt(o3.CONNECT);
          t2 && rt.sendMessage({ message: { type: "CONNECT", data: Object.assign(Object.assign({}, st()), { chainId: e2 }) }, origin: o3.CONNECT, targetWindow: t2 });
          const s2 = setInterval(() => {
            true === (null == t2 ? void 0 : t2.closed) && (r3(new nt({ type: "CONNECT_CANCELLED" }, "Connect is cancelled by user")), clearInterval(s2), i2());
          }, 2e3);
          rt.setupListener({ onReceiveMessage: (e3) => function({ event: t3, newPeraWalletTab: e4, resolve: n4, reject: r4 }) {
            if (n4 && "CONNECT_CALLBACK" === t3.data.message.type) {
              const r5 = t3.data.message.data.addresses;
              At(r5, "pera-wallet-web"), n4(r5), vt(ut), null == e4 || e4.close();
            } else "CONNECT_NETWORK_MISMATCH" === t3.data.message.type && (r4(new nt({ type: "CONNECT_NETWORK_MISMATCH", detail: t3.data.message.error }, t3.data.message.error || "Your wallet is connected to a different network to this dApp. Update your wallet to the correct network (MainNet or TestNet) to continue.")), vt(ut), null == e4 || e4.close());
          }({ event: e3, newPeraWalletTab: t2, resolve: n3, reject: r3 }) });
        } catch (t2) {
          i2(), r3(t2);
        }
      });
    };
    function i2() {
      vt(ut);
    }
  }
  function kt({ isWebWalletAvailable: t, shouldDisplayNewBadge: e2, shouldUseSound: n3, compactMode: r3, promoteMobile: o3, singleAccount: i2, selectedAccount: s2 }) {
    return { open: (a2 = { isWebWalletAvailable: t, shouldDisplayNewBadge: e2, shouldUseSound: n3, compactMode: r3, promoteMobile: o3, singleAccount: i2, selectedAccount: s2 }, (t2) => {
      if (!document.getElementById(ut)) {
        const e3 = pt(ut), n4 = `${t2}&algorand=true`, { isWebWalletAvailable: r4, shouldDisplayNewBadge: o4, shouldUseSound: i3, compactMode: s3, promoteMobile: l2, singleAccount: u3, selectedAccount: c2 } = a2;
        e3.innerHTML = `<pera-wallet-connect-modal uri="${n4}" is-web-wallet-avaliable="${r4}" should-display-new-badge="${o4}" should-use-sound="${i3}" compact-mode="${s3}" promote-mobile="${l2}" single-account="${u3}" selected-account="${c2 || ""}"></pera-wallet-connect-modal>`;
      }
    }), close: () => vt(ut) };
    var a2;
  }
  var import_bowser2, r2, o2, i, s, a, d, p, D2, X2, nt, rt, ot, it, ut, ct, ht, ft, dt, mt, Rt, Bt, Wt, jt;
  var init_index_87e811df = __esm({
    "node_modules/@perawallet/connect/dist/index-87e811df.js"() {
      init_polyfills();
      init_esm9();
      init_esm10();
      import_bowser2 = __toESM(require_es5(), 1);
      r2 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
      o2 = [];
      i = [];
      s = "undefined" != typeof Uint8Array ? Uint8Array : Array;
      a = false;
      d = {}.toString;
      p = Array.isArray || function(t) {
        return "[object Array]" == d.call(t);
      };
      y2.TYPED_ARRAY_SUPPORT = void 0 === r2.TYPED_ARRAY_SUPPORT || r2.TYPED_ARRAY_SUPPORT, g2(), y2.poolSize = 8192, y2._augment = function(t) {
        return t.__proto__ = y2.prototype, t;
      }, y2.from = function(t, e2, n3) {
        return v2(null, t, e2, n3);
      }, y2.TYPED_ARRAY_SUPPORT && (y2.prototype.__proto__ = Uint8Array.prototype, y2.__proto__ = Uint8Array), y2.alloc = function(t, e2, n3) {
        return function(t2, e3, n4, r3) {
          return m2(e3), e3 <= 0 ? w2(t2, e3) : void 0 !== n4 ? "string" == typeof r3 ? w2(t2, e3).fill(n4, r3) : w2(t2, e3).fill(n4) : w2(t2, e3);
        }(null, t, e2, n3);
      }, y2.allocUnsafe = function(t) {
        return b2(null, t);
      }, y2.allocUnsafeSlow = function(t) {
        return b2(null, t);
      }, y2.isBuffer = function(t) {
        return null != t && (!!t._isBuffer || tt(t) || function(t2) {
          return "function" == typeof t2.readFloatLE && "function" == typeof t2.slice && tt(t2.slice(0, 0));
        }(t));
      }, y2.compare = function(t, e2) {
        if (!T2(t) || !T2(e2)) throw new TypeError("Arguments must be Buffers");
        if (t === e2) return 0;
        for (var n3 = t.length, r3 = e2.length, o3 = 0, i2 = Math.min(n3, r3); o3 < i2; ++o3) if (t[o3] !== e2[o3]) {
          n3 = t[o3], r3 = e2[o3];
          break;
        }
        return n3 < r3 ? -1 : r3 < n3 ? 1 : 0;
      }, y2.isEncoding = function(t) {
        switch (String(t).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      }, y2.concat = function(t, e2) {
        if (!p(t)) throw new TypeError('"list" argument must be an Array of Buffers');
        if (0 === t.length) return y2.alloc(0);
        var n3;
        if (void 0 === e2) for (e2 = 0, n3 = 0; n3 < t.length; ++n3) e2 += t[n3].length;
        var r3 = y2.allocUnsafe(e2), o3 = 0;
        for (n3 = 0; n3 < t.length; ++n3) {
          var i2 = t[n3];
          if (!T2(i2)) throw new TypeError('"list" argument must be an Array of Buffers');
          i2.copy(r3, o3), o3 += i2.length;
        }
        return r3;
      }, y2.byteLength = _2, y2.prototype._isBuffer = true, y2.prototype.swap16 = function() {
        var t = this.length;
        if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (var e2 = 0; e2 < t; e2 += 2) S2(this, e2, e2 + 1);
        return this;
      }, y2.prototype.swap32 = function() {
        var t = this.length;
        if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (var e2 = 0; e2 < t; e2 += 4) S2(this, e2, e2 + 3), S2(this, e2 + 1, e2 + 2);
        return this;
      }, y2.prototype.swap64 = function() {
        var t = this.length;
        if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (var e2 = 0; e2 < t; e2 += 8) S2(this, e2, e2 + 7), S2(this, e2 + 1, e2 + 6), S2(this, e2 + 2, e2 + 5), S2(this, e2 + 3, e2 + 4);
        return this;
      }, y2.prototype.toString = function() {
        var t = 0 | this.length;
        return 0 === t ? "" : 0 === arguments.length ? W2(this, 0, t) : R2.apply(this, arguments);
      }, y2.prototype.equals = function(t) {
        if (!T2(t)) throw new TypeError("Argument must be a Buffer");
        return this === t || 0 === y2.compare(this, t);
      }, y2.prototype.inspect = function() {
        var t = "";
        return this.length > 0 && (t = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (t += " ... ")), "<Buffer " + t + ">";
      }, y2.prototype.compare = function(t, e2, n3, r3, o3) {
        if (!T2(t)) throw new TypeError("Argument must be a Buffer");
        if (void 0 === e2 && (e2 = 0), void 0 === n3 && (n3 = t ? t.length : 0), void 0 === r3 && (r3 = 0), void 0 === o3 && (o3 = this.length), e2 < 0 || n3 > t.length || r3 < 0 || o3 > this.length) throw new RangeError("out of range index");
        if (r3 >= o3 && e2 >= n3) return 0;
        if (r3 >= o3) return -1;
        if (e2 >= n3) return 1;
        if (this === t) return 0;
        for (var i2 = (o3 >>>= 0) - (r3 >>>= 0), s2 = (n3 >>>= 0) - (e2 >>>= 0), a2 = Math.min(i2, s2), l2 = this.slice(r3, o3), u3 = t.slice(e2, n3), c2 = 0; c2 < a2; ++c2) if (l2[c2] !== u3[c2]) {
          i2 = l2[c2], s2 = u3[c2];
          break;
        }
        return i2 < s2 ? -1 : s2 < i2 ? 1 : 0;
      }, y2.prototype.includes = function(t, e2, n3) {
        return -1 !== this.indexOf(t, e2, n3);
      }, y2.prototype.indexOf = function(t, e2, n3) {
        return N2(this, t, e2, n3, true);
      }, y2.prototype.lastIndexOf = function(t, e2, n3) {
        return N2(this, t, e2, n3, false);
      }, y2.prototype.write = function(t, e2, n3, r3) {
        if (void 0 === e2) r3 = "utf8", n3 = this.length, e2 = 0;
        else if (void 0 === n3 && "string" == typeof e2) r3 = e2, n3 = this.length, e2 = 0;
        else {
          if (!isFinite(e2)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          e2 |= 0, isFinite(n3) ? (n3 |= 0, void 0 === r3 && (r3 = "utf8")) : (r3 = n3, n3 = void 0);
        }
        var o3 = this.length - e2;
        if ((void 0 === n3 || n3 > o3) && (n3 = o3), t.length > 0 && (n3 < 0 || e2 < 0) || e2 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
        r3 || (r3 = "utf8");
        for (var i2 = false; ; ) switch (r3) {
          case "hex":
            return I2(this, t, e2, n3);
          case "utf8":
          case "utf-8":
            return P2(this, t, e2, n3);
          case "ascii":
            return O2(this, t, e2, n3);
          case "latin1":
          case "binary":
            return L2(this, t, e2, n3);
          case "base64":
            return M2(this, t, e2, n3);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return U2(this, t, e2, n3);
          default:
            if (i2) throw new TypeError("Unknown encoding: " + r3);
            r3 = ("" + r3).toLowerCase(), i2 = true;
        }
      }, y2.prototype.toJSON = function() {
        return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
      };
      D2 = 4096;
      y2.prototype.slice = function(t, e2) {
        var n3, r3 = this.length;
        if ((t = ~~t) < 0 ? (t += r3) < 0 && (t = 0) : t > r3 && (t = r3), (e2 = void 0 === e2 ? r3 : ~~e2) < 0 ? (e2 += r3) < 0 && (e2 = 0) : e2 > r3 && (e2 = r3), e2 < t && (e2 = t), y2.TYPED_ARRAY_SUPPORT) (n3 = this.subarray(t, e2)).__proto__ = y2.prototype;
        else {
          var o3 = e2 - t;
          n3 = new y2(o3, void 0);
          for (var i2 = 0; i2 < o3; ++i2) n3[i2] = this[i2 + t];
        }
        return n3;
      }, y2.prototype.readUIntLE = function(t, e2, n3) {
        t |= 0, e2 |= 0, n3 || $2(t, e2, this.length);
        for (var r3 = this[t], o3 = 1, i2 = 0; ++i2 < e2 && (o3 *= 256); ) r3 += this[t + i2] * o3;
        return r3;
      }, y2.prototype.readUIntBE = function(t, e2, n3) {
        t |= 0, e2 |= 0, n3 || $2(t, e2, this.length);
        for (var r3 = this[t + --e2], o3 = 1; e2 > 0 && (o3 *= 256); ) r3 += this[t + --e2] * o3;
        return r3;
      }, y2.prototype.readUInt8 = function(t, e2) {
        return e2 || $2(t, 1, this.length), this[t];
      }, y2.prototype.readUInt16LE = function(t, e2) {
        return e2 || $2(t, 2, this.length), this[t] | this[t + 1] << 8;
      }, y2.prototype.readUInt16BE = function(t, e2) {
        return e2 || $2(t, 2, this.length), this[t] << 8 | this[t + 1];
      }, y2.prototype.readUInt32LE = function(t, e2) {
        return e2 || $2(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];
      }, y2.prototype.readUInt32BE = function(t, e2) {
        return e2 || $2(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
      }, y2.prototype.readIntLE = function(t, e2, n3) {
        t |= 0, e2 |= 0, n3 || $2(t, e2, this.length);
        for (var r3 = this[t], o3 = 1, i2 = 0; ++i2 < e2 && (o3 *= 256); ) r3 += this[t + i2] * o3;
        return r3 >= (o3 *= 128) && (r3 -= Math.pow(2, 8 * e2)), r3;
      }, y2.prototype.readIntBE = function(t, e2, n3) {
        t |= 0, e2 |= 0, n3 || $2(t, e2, this.length);
        for (var r3 = e2, o3 = 1, i2 = this[t + --r3]; r3 > 0 && (o3 *= 256); ) i2 += this[t + --r3] * o3;
        return i2 >= (o3 *= 128) && (i2 -= Math.pow(2, 8 * e2)), i2;
      }, y2.prototype.readInt8 = function(t, e2) {
        return e2 || $2(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];
      }, y2.prototype.readInt16LE = function(t, e2) {
        e2 || $2(t, 2, this.length);
        var n3 = this[t] | this[t + 1] << 8;
        return 32768 & n3 ? 4294901760 | n3 : n3;
      }, y2.prototype.readInt16BE = function(t, e2) {
        e2 || $2(t, 2, this.length);
        var n3 = this[t + 1] | this[t] << 8;
        return 32768 & n3 ? 4294901760 | n3 : n3;
      }, y2.prototype.readInt32LE = function(t, e2) {
        return e2 || $2(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
      }, y2.prototype.readInt32BE = function(t, e2) {
        return e2 || $2(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
      }, y2.prototype.readFloatLE = function(t, e2) {
        return e2 || $2(t, 4, this.length), h2(this, t, true, 23, 4);
      }, y2.prototype.readFloatBE = function(t, e2) {
        return e2 || $2(t, 4, this.length), h2(this, t, false, 23, 4);
      }, y2.prototype.readDoubleLE = function(t, e2) {
        return e2 || $2(t, 8, this.length), h2(this, t, true, 52, 8);
      }, y2.prototype.readDoubleBE = function(t, e2) {
        return e2 || $2(t, 8, this.length), h2(this, t, false, 52, 8);
      }, y2.prototype.writeUIntLE = function(t, e2, n3, r3) {
        (t = +t, e2 |= 0, n3 |= 0, r3) || G2(this, t, e2, n3, Math.pow(2, 8 * n3) - 1, 0);
        var o3 = 1, i2 = 0;
        for (this[e2] = 255 & t; ++i2 < n3 && (o3 *= 256); ) this[e2 + i2] = t / o3 & 255;
        return e2 + n3;
      }, y2.prototype.writeUIntBE = function(t, e2, n3, r3) {
        (t = +t, e2 |= 0, n3 |= 0, r3) || G2(this, t, e2, n3, Math.pow(2, 8 * n3) - 1, 0);
        var o3 = n3 - 1, i2 = 1;
        for (this[e2 + o3] = 255 & t; --o3 >= 0 && (i2 *= 256); ) this[e2 + o3] = t / i2 & 255;
        return e2 + n3;
      }, y2.prototype.writeUInt8 = function(t, e2, n3) {
        return t = +t, e2 |= 0, n3 || G2(this, t, e2, 1, 255, 0), y2.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e2] = 255 & t, e2 + 1;
      }, y2.prototype.writeUInt16LE = function(t, e2, n3) {
        return t = +t, e2 |= 0, n3 || G2(this, t, e2, 2, 65535, 0), y2.TYPED_ARRAY_SUPPORT ? (this[e2] = 255 & t, this[e2 + 1] = t >>> 8) : q2(this, t, e2, true), e2 + 2;
      }, y2.prototype.writeUInt16BE = function(t, e2, n3) {
        return t = +t, e2 |= 0, n3 || G2(this, t, e2, 2, 65535, 0), y2.TYPED_ARRAY_SUPPORT ? (this[e2] = t >>> 8, this[e2 + 1] = 255 & t) : q2(this, t, e2, false), e2 + 2;
      }, y2.prototype.writeUInt32LE = function(t, e2, n3) {
        return t = +t, e2 |= 0, n3 || G2(this, t, e2, 4, 4294967295, 0), y2.TYPED_ARRAY_SUPPORT ? (this[e2 + 3] = t >>> 24, this[e2 + 2] = t >>> 16, this[e2 + 1] = t >>> 8, this[e2] = 255 & t) : z2(this, t, e2, true), e2 + 4;
      }, y2.prototype.writeUInt32BE = function(t, e2, n3) {
        return t = +t, e2 |= 0, n3 || G2(this, t, e2, 4, 4294967295, 0), y2.TYPED_ARRAY_SUPPORT ? (this[e2] = t >>> 24, this[e2 + 1] = t >>> 16, this[e2 + 2] = t >>> 8, this[e2 + 3] = 255 & t) : z2(this, t, e2, false), e2 + 4;
      }, y2.prototype.writeIntLE = function(t, e2, n3, r3) {
        if (t = +t, e2 |= 0, !r3) {
          var o3 = Math.pow(2, 8 * n3 - 1);
          G2(this, t, e2, n3, o3 - 1, -o3);
        }
        var i2 = 0, s2 = 1, a2 = 0;
        for (this[e2] = 255 & t; ++i2 < n3 && (s2 *= 256); ) t < 0 && 0 === a2 && 0 !== this[e2 + i2 - 1] && (a2 = 1), this[e2 + i2] = (t / s2 | 0) - a2 & 255;
        return e2 + n3;
      }, y2.prototype.writeIntBE = function(t, e2, n3, r3) {
        if (t = +t, e2 |= 0, !r3) {
          var o3 = Math.pow(2, 8 * n3 - 1);
          G2(this, t, e2, n3, o3 - 1, -o3);
        }
        var i2 = n3 - 1, s2 = 1, a2 = 0;
        for (this[e2 + i2] = 255 & t; --i2 >= 0 && (s2 *= 256); ) t < 0 && 0 === a2 && 0 !== this[e2 + i2 + 1] && (a2 = 1), this[e2 + i2] = (t / s2 | 0) - a2 & 255;
        return e2 + n3;
      }, y2.prototype.writeInt8 = function(t, e2, n3) {
        return t = +t, e2 |= 0, n3 || G2(this, t, e2, 1, 127, -128), y2.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e2] = 255 & t, e2 + 1;
      }, y2.prototype.writeInt16LE = function(t, e2, n3) {
        return t = +t, e2 |= 0, n3 || G2(this, t, e2, 2, 32767, -32768), y2.TYPED_ARRAY_SUPPORT ? (this[e2] = 255 & t, this[e2 + 1] = t >>> 8) : q2(this, t, e2, true), e2 + 2;
      }, y2.prototype.writeInt16BE = function(t, e2, n3) {
        return t = +t, e2 |= 0, n3 || G2(this, t, e2, 2, 32767, -32768), y2.TYPED_ARRAY_SUPPORT ? (this[e2] = t >>> 8, this[e2 + 1] = 255 & t) : q2(this, t, e2, false), e2 + 2;
      }, y2.prototype.writeInt32LE = function(t, e2, n3) {
        return t = +t, e2 |= 0, n3 || G2(this, t, e2, 4, 2147483647, -2147483648), y2.TYPED_ARRAY_SUPPORT ? (this[e2] = 255 & t, this[e2 + 1] = t >>> 8, this[e2 + 2] = t >>> 16, this[e2 + 3] = t >>> 24) : z2(this, t, e2, true), e2 + 4;
      }, y2.prototype.writeInt32BE = function(t, e2, n3) {
        return t = +t, e2 |= 0, n3 || G2(this, t, e2, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), y2.TYPED_ARRAY_SUPPORT ? (this[e2] = t >>> 24, this[e2 + 1] = t >>> 16, this[e2 + 2] = t >>> 8, this[e2 + 3] = 255 & t) : z2(this, t, e2, false), e2 + 4;
      }, y2.prototype.writeFloatLE = function(t, e2, n3) {
        return H2(this, t, e2, true, n3);
      }, y2.prototype.writeFloatBE = function(t, e2, n3) {
        return H2(this, t, e2, false, n3);
      }, y2.prototype.writeDoubleLE = function(t, e2, n3) {
        return K2(this, t, e2, true, n3);
      }, y2.prototype.writeDoubleBE = function(t, e2, n3) {
        return K2(this, t, e2, false, n3);
      }, y2.prototype.copy = function(t, e2, n3, r3) {
        if (n3 || (n3 = 0), r3 || 0 === r3 || (r3 = this.length), e2 >= t.length && (e2 = t.length), e2 || (e2 = 0), r3 > 0 && r3 < n3 && (r3 = n3), r3 === n3) return 0;
        if (0 === t.length || 0 === this.length) return 0;
        if (e2 < 0) throw new RangeError("targetStart out of bounds");
        if (n3 < 0 || n3 >= this.length) throw new RangeError("sourceStart out of bounds");
        if (r3 < 0) throw new RangeError("sourceEnd out of bounds");
        r3 > this.length && (r3 = this.length), t.length - e2 < r3 - n3 && (r3 = t.length - e2 + n3);
        var o3, i2 = r3 - n3;
        if (this === t && n3 < e2 && e2 < r3) for (o3 = i2 - 1; o3 >= 0; --o3) t[o3 + e2] = this[o3 + n3];
        else if (i2 < 1e3 || !y2.TYPED_ARRAY_SUPPORT) for (o3 = 0; o3 < i2; ++o3) t[o3 + e2] = this[o3 + n3];
        else Uint8Array.prototype.set.call(t, this.subarray(n3, n3 + i2), e2);
        return i2;
      }, y2.prototype.fill = function(t, e2, n3, r3) {
        if ("string" == typeof t) {
          if ("string" == typeof e2 ? (r3 = e2, e2 = 0, n3 = this.length) : "string" == typeof n3 && (r3 = n3, n3 = this.length), 1 === t.length) {
            var o3 = t.charCodeAt(0);
            o3 < 256 && (t = o3);
          }
          if (void 0 !== r3 && "string" != typeof r3) throw new TypeError("encoding must be a string");
          if ("string" == typeof r3 && !y2.isEncoding(r3)) throw new TypeError("Unknown encoding: " + r3);
        } else "number" == typeof t && (t &= 255);
        if (e2 < 0 || this.length < e2 || this.length < n3) throw new RangeError("Out of range index");
        if (n3 <= e2) return this;
        var i2;
        if (e2 >>>= 0, n3 = void 0 === n3 ? this.length : n3 >>> 0, t || (t = 0), "number" == typeof t) for (i2 = e2; i2 < n3; ++i2) this[i2] = t;
        else {
          var s2 = T2(t) ? t : V2(new y2(t, r3).toString()), a2 = s2.length;
          for (i2 = 0; i2 < n3 - e2; ++i2) this[i2 + e2] = s2[i2 % a2];
        }
        return this;
      };
      X2 = /[^+\/0-9A-Za-z-_]/g;
      nt = class _nt extends Error {
        constructor(t, e2, ...n3) {
          super(...n3), Error.captureStackTrace && Error.captureStackTrace(this, _nt), this.name = "PeraWalletConnectError", this.data = t, this.message = e2;
        }
      };
      rt = new class {
        constructor(t) {
          this.listener = void 0, this.channel = t.channel;
        }
        setupListener({ onReceiveMessage: t }) {
          this.close(), this.listener = (e2) => {
            if ("object" == typeof e2.data) try {
              e2.data.channel === this.channel && t(e2);
            } catch (t2) {
              console.error(t2);
            }
          }, window.addEventListener("message", this.listener);
        }
        sendMessage({ message: t, targetWindow: e2, origin: n3, timeout: r3 = 1e3 }) {
          setTimeout(() => {
            const r4 = { channel: this.channel, message: t };
            e2.postMessage(r4, { targetOrigin: n3 || "*" });
          }, r3);
        }
        close() {
          this.listener && (window.removeEventListener("message", this.listener), this.listener = void 0);
        }
      }({ channel: "pera-web-wallet" });
      ot = 700;
      it = 50;
      ut = "pera-wallet-connect-modal-wrapper";
      ct = "pera-wallet-redirect-modal-wrapper";
      ht = "pera-wallet-sign-txn-toast-wrapper";
      ft = "pera-wallet-sign-txn-modal-wrapper";
      dt = "pera-wallet-modal";
      mt = { WALLET: "PeraWallet.Wallet", WALLETCONNECT: "walletconnect" };
      Rt = "https://wc.perawallet.app/config.json";
      Bt = "perawallet-wc://";
      Wt = "https://perawallet.app/download/";
      jt = class {
        constructor(t) {
          this.bridge = (null == t ? void 0 : t.bridge) || "", this.connector = null, this.shouldShowSignTxnToast = void 0 === (null == t ? void 0 : t.shouldShowSignTxnToast) || t.shouldShowSignTxnToast, this.chainId = null == t ? void 0 : t.chainId, this.compactMode = (null == t ? void 0 : t.compactMode) || false, this.singleAccount = (null == t ? void 0 : t.singleAccount) || false;
        }
        get platform() {
          return function() {
            const t = Et();
            let e2 = null;
            return "pera-wallet" === (null == t ? void 0 : t.type) ? e2 = "mobile" : "pera-wallet-web" === (null == t ? void 0 : t.type) && (e2 = "web"), e2;
          }();
        }
        get isConnected() {
          var t;
          return "mobile" === this.platform ? !!this.connector : "web" === this.platform && !!(null === (t = Et()) || void 0 === t ? void 0 : t.accounts.length);
        }
        get isPeraDiscoverBrowser() {
          return this.checkIsPeraDiscoverBrowser();
        }
        connect(e2) {
          return new Promise((n3, r3) => et(this, void 0, void 0, function* () {
            var o3;
            try {
              if (null === (o3 = this.connector) || void 0 === o3 ? void 0 : o3.connected) try {
                yield this.connector.killSession();
              } catch (t) {
              }
              const { isWebWalletAvailable: i2, bridgeURL: s2, webWalletURL: a2, shouldDisplayNewBadge: l2, shouldUseSound: u3, promoteMobile: c2 } = yield Nt(), h3 = Yt({ resolve: n3, reject: r3, webWalletURL: a2, chainId: this.chainId, isCompactMode: this.compactMode });
              i2 && (window.onWebWalletConnect = h3), this.connector = new esm_default3({ bridge: this.bridge || s2 || "https://bridge.walletconnect.org", qrcodeModal: kt({ isWebWalletAvailable: i2, shouldDisplayNewBadge: l2, shouldUseSound: u3, compactMode: this.compactMode, promoteMobile: c2, singleAccount: this.singleAccount, selectedAccount: null == e2 ? void 0 : e2.selectedAccount }) }), yield this.connector.createSession({ chainId: this.chainId || 4160 }), function(t, e3) {
                var n4, r4, o4, i3;
                const s3 = document.getElementById(t), a3 = null === (r4 = null === (n4 = null == s3 ? void 0 : s3.querySelector(t.replace("-wrapper", ""))) || void 0 === n4 ? void 0 : n4.shadowRoot) || void 0 === r4 ? void 0 : r4.querySelector(`.${dt}`), l3 = null === (i3 = null === (o4 = null == a3 ? void 0 : a3.querySelector("pera-wallet-modal-header")) || void 0 === o4 ? void 0 : o4.shadowRoot) || void 0 === i3 ? void 0 : i3.getElementById("pera-wallet-modal-header-close-button");
                null == l3 || l3.addEventListener("click", () => {
                  e3(), vt(t);
                });
              }(ut, () => r3(new nt({ type: "CONNECT_MODAL_CLOSED" }, "Connect modal is closed by user"))), this.connector.on("connect", (t, e3) => {
                var o4, i3;
                t && r3(t), n3((null === (o4 = this.connector) || void 0 === o4 ? void 0 : o4.accounts) || []), At((null === (i3 = this.connector) || void 0 === i3 ? void 0 : i3.accounts) || []);
              });
            } catch (t) {
              console.log(t), r3(new nt({ type: "SESSION_CONNECT", detail: t }, t.message || "There was an error while connecting to Pera Wallet"));
            }
          }));
        }
        reconnectSession() {
          return new Promise((e2, n3) => et(this, void 0, void 0, function* () {
            var r3, o3;
            try {
              const i2 = Et();
              if (!i2) return void e2([]);
              if ("pera-wallet-web" === (null == i2 ? void 0 : i2.type)) {
                const { isWebWalletAvailable: t } = yield Nt();
                t ? e2(i2.accounts || []) : n3(new nt({ type: "SESSION_RECONNECT", detail: "Pera Web is not available" }, "Pera Web is not available"));
              }
              this.connector && e2(this.connector.accounts || []), this.bridge = (null === (r3 = function() {
                var t;
                const e3 = null === (t = bt()) || void 0 === t ? void 0 : t.getItem(mt.WALLETCONNECT);
                return e3 ? JSON.parse(e3) : null;
              }()) || void 0 === r3 ? void 0 : r3.bridge) || "", this.bridge && (this.connector = new esm_default3({ bridge: this.bridge }), e2((null === (o3 = this.connector) || void 0 === o3 ? void 0 : o3.accounts) || [])), this.isConnected || e2([]);
            } catch (t) {
              yield this.disconnect(), n3(new nt({ type: "SESSION_RECONNECT", detail: t }, t.message || "There was an error while reconnecting to Pera Wallet"));
            }
          }));
        }
        disconnect() {
          var t;
          return et(this, void 0, void 0, function* () {
            let e2;
            this.isConnected && "mobile" === this.platform && (e2 = null === (t = this.connector) || void 0 === t ? void 0 : t.killSession(), null == e2 || e2.then(() => {
              this.connector = null;
            })), yield Tt();
          });
        }
        signTransactionWithMobile(t) {
          return et(this, void 0, void 0, function* () {
            const e2 = It("algo_signTxn", [t]);
            try {
              try {
                const { silent: t2 } = yield Nt(), n3 = (yield this.connector.sendCustomRequest(e2, { forcePushNotification: !t2 })).filter(Boolean);
                return "string" == typeof n3[0] ? n3.map(Ct) : n3.map((t3) => Uint8Array.from(t3));
              } catch (t2) {
                return yield Promise.reject(new nt({ type: "SIGN_TRANSACTIONS", detail: t2 }, t2.message || "Failed to sign transaction"));
              }
            } finally {
              vt(ct), vt(ht);
            }
          });
        }
        signTransactionWithWeb(t, e2) {
          return new Promise((n3, r3) => xt({ signTxnRequestParams: t, webWalletURL: e2, method: "SIGN_TXN", resolve: n3, reject: r3 }));
        }
        signDataWithMobile({ data: t, signer: e2, chainId: n3 }) {
          return et(this, void 0, void 0, function* () {
            const r3 = It("algo_signData", t.map((t2) => Object.assign(Object.assign({}, t2), { signer: e2, chainId: n3 })));
            try {
              try {
                const { silent: t2 } = yield Nt(), e3 = (yield this.connector.sendCustomRequest(r3, { forcePushNotification: !t2 })).filter(Boolean);
                return "string" == typeof e3[0] ? e3.map(Ct) : e3.map((t3) => Uint8Array.from(t3));
              } catch (t2) {
                return yield Promise.reject(new nt({ type: "SIGN_TRANSACTIONS", detail: t2 }, t2.message || "Failed to sign transaction"));
              }
            } finally {
              vt(ct), vt(ht);
            }
          });
        }
        signDataWithWeb({ data: t, signer: e2, chainId: n3, webWalletURL: r3 }) {
          return new Promise((o3, i2) => xt({ method: "SIGN_DATA", signTxnRequestParams: t, signer: e2, chainId: n3, webWalletURL: r3, resolve: o3, reject: i2 }));
        }
        checkIsPeraDiscoverBrowser() {
          return window.navigator.userAgent.includes("pera");
        }
        signTransaction(t, n3) {
          return et(this, void 0, void 0, function* () {
            if ("mobile" === this.platform && (Mt() ? gt() : !Mt() && this.shouldShowSignTxnToast && wt(), !this.connector)) throw new Error("PeraWalletConnect was not initialized correctly.");
            const r3 = t.flatMap((t2) => t2.map((t3) => function(t4, n4) {
              let r4;
              n4 && !(t4.signers || []).includes(n4) && (r4 = []);
              const o3 = { txn: (i2 = t4.txn, Buffer.from(esm_default4.encodeUnsignedTransaction(i2)).toString("base64")) };
              var i2;
              return Array.isArray(r4) && (o3.signers = r4), t4.authAddr && (o3.authAddr = t4.authAddr), t4.message && (o3.message = t4.message), t4.msig && (o3.msig = t4.msig), o3;
            }(t3, n3)));
            if ("web" === this.platform) {
              const { webWalletURL: t2 } = yield Nt();
              return this.signTransactionWithWeb(r3, t2);
            }
            return this.signTransactionWithMobile(r3);
          });
        }
        signData(t, e2) {
          return et(this, void 0, void 0, function* () {
            const n3 = this.chainId || 4160;
            if ("mobile" === this.platform && (Mt() ? gt() : !Mt() && this.shouldShowSignTxnToast && wt(), !this.connector)) throw new Error("PeraWalletConnect was not initialized correctly.");
            if ("web" === this.platform) {
              const { webWalletURL: r4 } = yield Nt();
              return this.signDataWithWeb({ data: t, signer: e2, chainId: n3, webWalletURL: r4 });
            }
            const r3 = t.map((t2) => Object.assign(Object.assign({}, t2), { data: Buffer.from(t2.data).toString("base64") }));
            return this.signDataWithMobile({ data: r3, signer: e2, chainId: n3 });
          });
        }
      };
      "undefined" != typeof window && (window.global = window, window.Buffer = window.Buffer || y2, Promise.resolve().then(() => (init_App_428f5096(), App_428f5096_exports)));
    }
  });

  // pera-wallet-entry.js
  init_polyfills();

  // node_modules/@perawallet/connect/dist/index.js
  init_polyfills();
  init_index_87e811df();
  init_esm9();
  init_esm10();
  var import_bowser3 = __toESM(require_es5(), 1);

  // pera-wallet-entry.js
  window.PeraWalletConnect = jt;
})();
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

js-sha512/src/sha512.js:
  (*
   * [js-sha512]{@link https://github.com/emn178/js-sha512}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2018
   * @license MIT
   *)

hi-base32/src/base32.js:
  (*
   * [hi-base32]{@link https://github.com/emn178/hi-base32}
   *
   * @version 0.5.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

@evanhahn/lottie-web-light/index.js:
  (*!
   Transformation Matrix v2.0
   (c) Epistemex 2014-2015
   www.epistemex.com
   By Ken Fyrstenberg
   Contributions by leeoniya.
   License: MIT, header required.
   *)
*/
